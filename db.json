{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/sea/source/css/base.css","path":"css/base.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/media.css","path":"css/media.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/sea/source/css/variables.css","path":"css/variables.css","modified":0,"renderable":1},{"_id":"themes/sea/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/sea/source/js/theme_mode.js","path":"js/theme_mode.js","modified":0,"renderable":1},{"_id":"themes/sea/source/js/theme.js","path":"js/theme.js","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/archive.css","path":"css/partial/archive.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/common.css","path":"css/partial/common.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/footer.css","path":"css/partial/footer.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/friends.css","path":"css/partial/friends.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/hero.css","path":"css/partial/hero.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/index.css","path":"css/partial/index.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/layout.css","path":"css/partial/layout.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/menu.css","path":"css/partial/menu.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/nav.css","path":"css/partial/nav.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/page.css","path":"css/partial/page.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/pagination.css","path":"css/partial/pagination.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/post.css","path":"css/partial/post.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/sea_doc.css","path":"css/partial/sea_doc.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/partial/prev_next.css","path":"css/partial/prev_next.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/plugins/docsearch.css","path":"css/plugins/docsearch.css","modified":0,"renderable":1},{"_id":"themes/sea/source/css/plugins/prism.styl","path":"css/plugins/prism.styl","modified":0,"renderable":1},{"_id":"themes/sea/source/css/plugins/waline.css","path":"css/plugins/waline.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1737809549271},{"_id":"themes/sea/example/themes/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1737810118260},{"_id":"themes/sea/.gitignore","hash":"ea0049f4ac0eb1f99fdb8d720f13799f2ade859a","modified":1737810118254},{"_id":"themes/sea/LICENSE","hash":"df9911a27e482d1a3d37addfa4e82e3cd619bfb3","modified":1737810118255},{"_id":"themes/sea/package.json","hash":"befaeeddacac5ea57093c0467f31e047f373fbff","modified":1737810118264},{"_id":"themes/sea/.npmignore","hash":"f7151d659dde1336b7e2aa5d088aa1b814c0fc02","modified":1737810118254},{"_id":"themes/sea/README.md","hash":"de8cff42a53c4d308c1eeaebec3f7ade162a1f83","modified":1737810118255},{"_id":"themes/sea/.vscode/settings.json","hash":"027d15c4945cb0df2d722fc41225836c3e2c290f","modified":1737810118255},{"_id":"themes/sea/_config.yml","hash":"e9c22578ffa601786f02cef952649e0fdf0e5dbe","modified":1737810490696},{"_id":"themes/sea/example/_config.sea.yml","hash":"889bb0400bfd6f652e3d2df75b346c87407d8bde","modified":1737810118255},{"_id":"themes/sea/example/package.json","hash":"271066d691d28c648e0901e24c14d7ad45fd034a","modified":1737810118255},{"_id":"themes/sea/example/_config.yml","hash":"9e651e7d8814de0ae74b7979bb811172a6a613aa","modified":1737810118255},{"_id":"themes/sea/languages/en.yml","hash":"7a4a990823d32ca46e041068d8f4537acadc1814","modified":1737810118260},{"_id":"themes/sea/languages/zh.yml","hash":"a025e8178ce30e47a3e65f2218ae202f36cb383c","modified":1737810118261},{"_id":"themes/sea/scripts/helpers.js","hash":"104daeba100ab0cf6022aecb2b7d671b5edc2cef","modified":1737810118264},{"_id":"themes/sea/scripts/tags.js","hash":"a9f602c92dc3dac5ce8ea4da971753eee4f9d70d","modified":1737810118264},{"_id":"themes/sea/scripts/page.js","hash":"c3cb89a430244d02dffacc640a04692063833983","modified":1737810118264},{"_id":"themes/sea/layout/archive.njk","hash":"8ce79fed59307a3e0ea8e1f38ef38fa157968e03","modified":1737810118262},{"_id":"themes/sea/scripts/filters.js","hash":"dfc0b9a8e53127feba70af3946f9fb29879c984d","modified":1737810118264},{"_id":"themes/sea/layout/category.njk","hash":"81665b52b56cebf6fae00cea983994ca3ef409a1","modified":1737810118262},{"_id":"themes/sea/layout/index.njk","hash":"d4440fabf837fd7c1523c6706a749eac37e1da60","modified":1737810118262},{"_id":"themes/sea/layout/articles.njk","hash":"49a42959cc6a55b4cb732cb88cfa31b68f569d2e","modified":1737810118262},{"_id":"themes/sea/layout/page.njk","hash":"df2af7bdd96665c742370f4f4f400980934e27fb","modified":1737810118263},{"_id":"themes/sea/layout/tag.njk","hash":"54f3b8d807fc0502ee50ee11d15e0c8b0554e3e3","modified":1737810118264},{"_id":"themes/sea/layout/post.njk","hash":"17f56c72c09b443de4f2039d0d55b3ed81f145ab","modified":1737810118263},{"_id":"themes/sea/.github/workflows/release.yml","hash":"85f9854b1504f6df9dbb9387547bf53bc57b3572","modified":1737810118254},{"_id":"themes/sea/example/scaffolds/page.md","hash":"f0af1cb10f27d859caa51c8e3704469d9ed842a6","modified":1737810118255},{"_id":"themes/sea/example/scaffolds/draft.md","hash":"204ab550ddffa92051ea0eb2484a78d84dac3693","modified":1737810118255},{"_id":"themes/sea/layout/layout.njk","hash":"1d3aadc03104c0c1da231d5dced7184317bab088","modified":1737810118263},{"_id":"themes/sea/example/scaffolds/post.md","hash":"e7169dab8ce62d41e3734e30706fa786cc7d46f4","modified":1737810118255},{"_id":"themes/sea/example/source/logo.svg","hash":"6657ba50e702d84afb32fe846bed54fba1a77add","modified":1737810118260},{"_id":"themes/sea/layout/_partial/head.njk","hash":"8c4b903e222a21aec9a3774b2feb440662616bd6","modified":1737810118261},{"_id":"themes/sea/layout/svg/arrow_left.njk","hash":"3dbd82c60d0c6b79042d7bc343eaff0b98acc221","modified":1737810118263},{"_id":"themes/sea/layout/_partial/body_script.njk","hash":"7c3043efea83fc911d73b5f19dcbe34d09328468","modified":1737810118261},{"_id":"themes/sea/layout/svg/arrow_up.njk","hash":"b2dd1743b51fb782d36c3150d6239851429b5f69","modified":1737810118263},{"_id":"themes/sea/layout/svg/bars.njk","hash":"605cf58596c7922eea99e4aadafed9dc56da8075","modified":1737810118263},{"_id":"themes/sea/layout/svg/arrow_right.njk","hash":"3a14a7d93c96bfc7fb0961a53d40f8a73a2163ef","modified":1737810118263},{"_id":"themes/sea/layout/svg/close.njk","hash":"5ace5cb06d27bc1beaac0061f1d47b692e302b7f","modified":1737810118263},{"_id":"themes/sea/layout/svg/folder.njk","hash":"f2db5705fa18167ab8dd56a678cbb21e5b986b1d","modified":1737810118263},{"_id":"themes/sea/layout/svg/email.njk","hash":"acb522ac1deed1896970c16f7dac49d32ae85550","modified":1737810118263},{"_id":"themes/sea/layout/svg/date.njk","hash":"6e9d6b2abc3960ddf73b76cd1694929be765d22b","modified":1737810118263},{"_id":"themes/sea/layout/svg/moon.njk","hash":"e8764ed7cac36ca1cda4e57bfad290073365da07","modified":1737810118264},{"_id":"themes/sea/layout/svg/github.njk","hash":"87376073509d4398d1cca07dacd1f7dd3fa12616","modified":1737810118263},{"_id":"themes/sea/layout/svg/juejin.njk","hash":"fac363afd8a1e853713456cea354be974c2bfd5d","modified":1737810118263},{"_id":"themes/sea/layout/svg/rss.njk","hash":"96218f60bed20e6d98773bb53315ba26861ae795","modified":1737810118264},{"_id":"themes/sea/layout/svg/sun.njk","hash":"32a057015a6000edccf90347f6da5776147f78ad","modified":1737810118264},{"_id":"themes/sea/layout/svg/search.njk","hash":"4f87a5c8a3e035d5f1e56fe3eebb6dbe31d0ee42","modified":1737810118264},{"_id":"themes/sea/layout/svg/tag.njk","hash":"39f5791023fd1d5f61f14cabbd77c48f8a0b7bcf","modified":1737810118264},{"_id":"themes/sea/source/css/media.css","hash":"1851795a8094cdae3a0283877f8b042fddfe059b","modified":1737810118264},{"_id":"themes/sea/source/css/main.styl","hash":"6bc38a3e4b7ffe32f5a5f7c51ae91e738f3e04bc","modified":1737810118264},{"_id":"themes/sea/source/css/base.css","hash":"77b45165b38e07f4a61fadf225b1b23fb1d157e0","modified":1737810118264},{"_id":"themes/sea/source/js/main.js","hash":"dde1df7981f498a1f726414f19c67f1e5021f1cb","modified":1737810118266},{"_id":"themes/sea/source/js/theme_mode.js","hash":"58e9e66b6fd90219d921d11801d8e43832d780b9","modified":1737810118266},{"_id":"themes/sea/source/css/variables.css","hash":"7a8c724f01d83c5d9077c9d492366e89a3abde9a","modified":1737810118266},{"_id":"themes/sea/source/js/theme.js","hash":"612df0a7d087141ff59203d3c1900669c43b4541","modified":1737810118266},{"_id":"themes/sea/example/source/_posts/categories.md","hash":"c023118431e400a213f568fd572d2da1eb42bff4","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/elements.md","hash":"c74ed1974348870b22053f4ef56623be9f548a7e","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/code-highlight.md","hash":"334e0e84be834318e2b00fc0ef665e49d59ec47f","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/excerpts.md","hash":"64dabd6382092c9424de013e1b1e24be2a6d73b8","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/gallery-post.md","hash":"2eb3bdfbc32d64396aa8d958adcb74b6dfca3a26","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/hello-world.md","hash":"9429cd5d2c34ebda1ef04248bf67b18c369c1220","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/images.md","hash":"566d27e870757555ef8bc32781ddddcae9a7b693","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/long-title.md","hash":"0d101b388a23e6609c121ff00b4dfd14df1e9938","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/markdown.md","hash":"3e297f3c739f9b70083b19541955a74c75ba15c4","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/mathjax.md","hash":"b003cf320e6d1f36025cdf4ebdf2965395ad6733","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/tag-plugins.md","hash":"f9f8d7a4361668c410cb5ddd54f4d1f2f167d51e","modified":1737810118256},{"_id":"themes/sea/example/source/_posts/中文測試.md","hash":"dc6e9310fa1c331bd61c63aef7c8a87dfa18b8cd","modified":1737810118257},{"_id":"themes/sea/example/source/_posts/日本語テスト.md","hash":"0941ec02163c0329e38217195aed622de32c2e61","modified":1737810118257},{"_id":"themes/sea/example/source/_posts/tags.md","hash":"22452f7286e135658aabe870143c5550e5648143","modified":1737810118256},{"_id":"themes/sea/layout/_partial/main/footer.njk","hash":"917482e7f8517a7c2cf27312638c22712037d000","modified":1737810118261},{"_id":"themes/sea/example/source/friends/index.md","hash":"6971052af98328af210cf218aa98ae3368e73196","modified":1737810118260},{"_id":"themes/sea/layout/_partial/main/hero.njk","hash":"34720508c8866a6d37fc59a8689c4a55a2b59e8f","modified":1737810118261},{"_id":"themes/sea/layout/_partial/main/menu.njk","hash":"2fd44172a9dcee2b9c5b2ea1727724a36d546aca","modified":1737810118261},{"_id":"themes/sea/layout/_partial/main/pagination.njk","hash":"2c8a3d27854d29fee50c581cbd67efff64bfc76b","modified":1737810118261},{"_id":"themes/sea/layout/_partial/main/navbar.njk","hash":"fc618d279296aff1f55d633919ad4de1be20bc56","modified":1737810118261},{"_id":"themes/sea/layout/_partial/main/prev_next.njk","hash":"24aa5adaa593992292e93807e96219a2b363f768","modified":1737810118261},{"_id":"themes/sea/layout/_partial/page/tags.njk","hash":"0ca3558a458344954beb3a2d26f9b1abdf6b5113","modified":1737810118261},{"_id":"themes/sea/layout/_partial/page/categories.njk","hash":"8e954ea0804f5c36f95151ab09ef4ea596ea6889","modified":1737810118261},{"_id":"themes/sea/layout/_partial/page/default.njk","hash":"af86d797eb375b7190cba50e5c083905b9819534","modified":1737810118261},{"_id":"themes/sea/layout/_partial/post/post_categories.njk","hash":"c2fb0937ff9a7288105fea5dcdddb2c5aacf5fe5","modified":1737810118262},{"_id":"themes/sea/layout/_partial/post/post_list.njk","hash":"2b04e0d9a3c7a3810784ae5c678b08cadf48ed20","modified":1737810118262},{"_id":"themes/sea/layout/_partial/post/post_tags.njk","hash":"0cd17ecf392f2b90a44b2af0b9c064343aafc511","modified":1737810118262},{"_id":"themes/sea/layout/_partial/post/post_date.njk","hash":"5602ad9071768c367a08fbcb02847a5e5459bdc4","modified":1737810118262},{"_id":"themes/sea/layout/_plugins/comments/giscus.njk","hash":"bc52987ebfd554d4ed4dc65fd4769d59ffecd0b6","modified":1737810118262},{"_id":"themes/sea/layout/_plugins/comments/waline.njk","hash":"bf57c88eca1c2b1d2593091548a5356c62114d08","modified":1737810118262},{"_id":"themes/sea/layout/_plugins/search/docsearch.njk","hash":"c9e42c6896dfd5a6670aa6cdbf3469d2ad242341","modified":1737810118262},{"_id":"themes/sea/layout/_plugins/comments/index.njk","hash":"123e19964d587a6cd95151edf12145b52f4975ee","modified":1737810118262},{"_id":"themes/sea/layout/_plugins/search/local.njk","hash":"c966c605f91f39a88de2047e1ff42edbf72d512d","modified":1737810118262},{"_id":"themes/sea/source/css/partial/archive.css","hash":"9f4efdde49f4eef173ab95f21a31511b17be29fd","modified":1737810118265},{"_id":"themes/sea/source/css/partial/common.css","hash":"5d51ded96a49e4687f8412b0e0116db398b9dfdd","modified":1737810118265},{"_id":"themes/sea/source/css/partial/footer.css","hash":"fb38ed32a1efae788fb9da9db2ab37f16a5b300d","modified":1737810118265},{"_id":"themes/sea/source/css/partial/friends.css","hash":"fc4c1386de32b7a4c836fa7465d77d652e53eb5b","modified":1737810118265},{"_id":"themes/sea/source/css/partial/hero.css","hash":"97b851bdc5f8d565f8803def53fd20948f393bba","modified":1737810118265},{"_id":"themes/sea/layout/_plugins/search/index.njk","hash":"a684f8d7e03b3313e4ee60390a6dede8d4afaf43","modified":1737810118262},{"_id":"themes/sea/source/css/partial/index.css","hash":"0f992168abddf7a5b06a95dbb034d7904db0a989","modified":1737810118265},{"_id":"themes/sea/source/css/partial/layout.css","hash":"27f3d61443fd9994bfe7563bbe556bbc51142ff7","modified":1737810118265},{"_id":"themes/sea/source/css/partial/nav.css","hash":"d98825b190522f163fa09d72a58d8c24fbffc311","modified":1737810118265},{"_id":"themes/sea/source/css/partial/menu.css","hash":"167ec058606f02ca6ba37d716f4d3f8b56f31f52","modified":1737810118265},{"_id":"themes/sea/source/css/partial/page.css","hash":"a13ff27338136dbd2aab06b118c2e1f65fdcd0c2","modified":1737810118265},{"_id":"themes/sea/source/css/partial/pagination.css","hash":"4876cf32ad1f0973952c65fa9c9f6e2146f12853","modified":1737810118265},{"_id":"themes/sea/source/css/partial/post.css","hash":"e993f31a46eb33e0e6dfa070358193d0fcaed04f","modified":1737810118265},{"_id":"themes/sea/source/css/partial/prev_next.css","hash":"233f0d196833e63c04063f0bab372d47e04b8c92","modified":1737810118265},{"_id":"themes/sea/source/css/plugins/docsearch.css","hash":"61c9afe7758f17766bf7bcf3cb1231ee201a9faa","modified":1737810118265},{"_id":"themes/sea/source/css/plugins/prism.styl","hash":"42a1981f84f7c90877284383617c2c6a8ddfbf1e","modified":1737810118265},{"_id":"themes/sea/source/css/plugins/waline.css","hash":"b18e502b4d49a5f0300b3cdec6a37c19e0f7a564","modified":1737810118266},{"_id":"themes/sea/source/css/partial/sea_doc.css","hash":"4a032c39ab58828fdcb0d73c91a829f66ca01674","modified":1737810118265},{"_id":"themes/sea/example/source/assets/wallpaper-2572384.jpg","hash":"1df3620ab8c69fe2498a746f8ead057162df0637","modified":1737810118258},{"_id":"themes/sea/example/source/assets/wallpaper-878514.jpg","hash":"9f9705a377c42320b335b3c66b023e62b80e56e3","modified":1737810118260},{"_id":"themes/sea/example/source/assets/wallpaper-2311325.jpg","hash":"ddaaaeb4fa04a05c83053c1f8149720d18c9c8de","modified":1737810118257},{"_id":"public/2025/01/25/hello-world/index.html","hash":"bf9872a9fe7312ddb5dcad44cca02b12e52e28aa","modified":1737810615195},{"_id":"public/archives/index.html","hash":"368db19d20505255fe46c87be7a2ebfa54cde957","modified":1737810993929},{"_id":"public/archives/2025/index.html","hash":"4de90844c8032f9d73fabf8974e59590e2069f28","modified":1737810993929},{"_id":"public/archives/2025/01/index.html","hash":"be2fe6b4697412bbaa8011d8357767b7da806e24","modified":1737810993929},{"_id":"public/index.html","hash":"a93f1b34ab60263fb839e968e8a44e7268791c96","modified":1737810993929},{"_id":"public/tags/index.html","hash":"85584341b213f991f11cce982f6828850bf4cfe4","modified":1737810698988},{"_id":"public/categories/index.html","hash":"97c06ed63d3d6497b46a3eea88a232488d6c5ba5","modified":1737810615195},{"_id":"public/articles/index.html","hash":"ce27bddffe3fe9d263178839a543f465bf1cb512","modified":1737810993929},{"_id":"public/css/main.css","hash":"35bab8ded49d800b47bda4eded49657926f01b3b","modified":1737810204517},{"_id":"public/css/base.css","hash":"db7d2fbfaa093d82e18557b0a4b89f897bc47fe5","modified":1737810204517},{"_id":"public/css/media.css","hash":"d51b836803b09aef1e1c2f2ac2a00f51854d6763","modified":1737810204517},{"_id":"public/js/theme.js","hash":"612df0a7d087141ff59203d3c1900669c43b4541","modified":1737810204517},{"_id":"public/js/theme_mode.js","hash":"455ea87174cbe06f0b7a9f7f16a05b7282b8c37a","modified":1737810204517},{"_id":"public/js/main.js","hash":"0a83cb0a8ccf336ae6f24d1b5f957fe7efea2214","modified":1737810204517},{"_id":"public/css/partial/common.css","hash":"5d51ded96a49e4687f8412b0e0116db398b9dfdd","modified":1737810204517},{"_id":"public/css/variables.css","hash":"e816bf1ad04fcddaab77bf7e9caa8025c365e687","modified":1737810204517},{"_id":"public/css/partial/friends.css","hash":"877a1e5b6e4d884e2c7c4b38bacf35b6f14c401b","modified":1737810204517},{"_id":"public/css/partial/hero.css","hash":"97b851bdc5f8d565f8803def53fd20948f393bba","modified":1737810204517},{"_id":"public/css/partial/index.css","hash":"0f992168abddf7a5b06a95dbb034d7904db0a989","modified":1737810204517},{"_id":"public/css/partial/layout.css","hash":"0819c2195788887927b641ba206a2936b89a2dc2","modified":1737810204517},{"_id":"public/css/partial/footer.css","hash":"c668aa13cc8ee9c1514edfa7d251327cca2ea94a","modified":1737810204517},{"_id":"public/css/partial/archive.css","hash":"9f4efdde49f4eef173ab95f21a31511b17be29fd","modified":1737810204517},{"_id":"public/css/partial/menu.css","hash":"167ec058606f02ca6ba37d716f4d3f8b56f31f52","modified":1737810204517},{"_id":"public/css/partial/nav.css","hash":"d98825b190522f163fa09d72a58d8c24fbffc311","modified":1737810204517},{"_id":"public/css/partial/page.css","hash":"b3e0fdbab7fc1705113a5bdc801f6222d7e5bbd4","modified":1737810204517},{"_id":"public/css/partial/pagination.css","hash":"4876cf32ad1f0973952c65fa9c9f6e2146f12853","modified":1737810204517},{"_id":"public/css/partial/post.css","hash":"e993f31a46eb33e0e6dfa070358193d0fcaed04f","modified":1737810204517},{"_id":"public/css/partial/sea_doc.css","hash":"2b1edf9eabaf38659b0729555824f1aa29ddfdd8","modified":1737810204517},{"_id":"public/css/partial/prev_next.css","hash":"233f0d196833e63c04063f0bab372d47e04b8c92","modified":1737810204517},{"_id":"public/css/plugins/prism.css","hash":"426bf2b87b6fb1ba4c116d64baa6fab59b1c8836","modified":1737810204517},{"_id":"public/css/plugins/docsearch.css","hash":"61c9afe7758f17766bf7bcf3cb1231ee201a9faa","modified":1737810204517},{"_id":"public/css/plugins/waline.css","hash":"97a62b3cdd60f9325f0e8e2a632ee8d02f093f28","modified":1737810204517},{"_id":"source/_posts/mysql/mmysql.md","hash":"b6f058f64b072444d2f3e2752773d8db73237300","modified":1737810604155},{"_id":"public/2025/01/25/mysql/mmysql/index.html","hash":"27422a07cb3fe2a27782df800034d251840954f1","modified":1737810615195},{"_id":"source/_posts/Alist访问.md","hash":"51fe02e54259af5a52d960aa9c1f30d1dc8add26","modified":1735297395342},{"_id":"source/_posts/Docker学习笔记.md","hash":"df28d661e409e0be755e4606a51dc18cf05a6c06","modified":1735297395342},{"_id":"source/_posts/Kafka实践.md","hash":"dc8d9edc85680f9fff3e80d9ef62c129263a37f1","modified":1735972325125},{"_id":"source/_posts/Kafka理论知识.md","hash":"ea8e52ea502a8e4793a0b82a941b6d0482f77211","modified":1736078199329},{"_id":"source/_posts/.DS_Store","hash":"4a7bd8fd6d55b97d3657d3afb748d8875a7e94ae","modified":1737810696990},{"_id":"source/_posts/Sync.md","hash":"be56e54d71f14566772f8d60e61829b0c8acc593","modified":1735297395343},{"_id":"source/.DS_Store","hash":"af6910d7d10ea2eff8009ca951ddbbf5c8d62022","modified":1737810687633},{"_id":"source/_posts/component.md","hash":"f3ae9b8ed6850112a62c6037049982ce742d7690","modified":1735297395343},{"_id":"source/_posts/git学习笔记.md","hash":"587de83665c5922301b311597bfe98c168bb83a6","modified":1735297395343},{"_id":"source/_posts/goroutine.md","hash":"2565a2c03b3144905dc835ac329cffdab0c9f156","modified":1735297395343},{"_id":"source/_posts/more.md","hash":"df68b34fbedff0eb553a654d9048fb468a1619d8","modified":1735297395344},{"_id":"source/_posts/style.md","hash":"b3d856ab3551d94120926afcb8a08878eaa6cdf7","modified":1735297395344},{"_id":"source/_posts/《设计模式之美》阅读笔记.md","hash":"4023490db301b9ebd1a95dc6835e2f3aeaaa76be","modified":1735297395344},{"_id":"source/_posts/他们眼中的简历.md","hash":"0909bf5d230617025a7e5cb696edcbb70f3cec1a","modified":1737810988409},{"_id":"source/_posts/《Go语言精进之路》阅读笔记.md","hash":"89f552fe3bd6ce132d6728c5f0f30f5458ab12b9","modified":1735297395344},{"_id":"source/_posts/优质好文合集.md","hash":"449e2c57eabb757c4cf49990f1d44c72fbffe6e4","modified":1735297395344},{"_id":"source/_posts/使用本地缓存代替Redis.md","hash":"b72cf767b7217ed32aecb97c3e8227508b3ed99d","modified":1735297395344},{"_id":"source/_posts/传输层知识点.md","hash":"909cc6d89d75ddfc3da960b6cbaf8046cf30a1ec","modified":1735297395344},{"_id":"source/_posts/优质开源软件合集.md","hash":"1ca15d4963b3e9b1bbdf88a005d79fd32e176c9b","modified":1735297395344},{"_id":"source/_posts/发帖功能实现.md","hash":"1eceb361519f1b26c72f583cbca2d7b3a7fa2310","modified":1735297395344},{"_id":"source/_posts/分布式理论基础.md","hash":"7ff89b680e130482fcdc00b7e7efdd8d00c748e7","modified":1735297395344},{"_id":"source/_posts/异步框架.md","hash":"a10e00f3de5e4cf2f4c7827a957180fb4a4d9707","modified":1735297395344},{"_id":"source/_posts/换取Mac OS第一步.md","hash":"043f279e824f251a7a29b78585a93a828b29c0e9","modified":1735297395344},{"_id":"source/_posts/定时微服务.md","hash":"33adc2df9b64e6a89d5af0e8499b5aec55538db1","modified":1735297395344},{"_id":"source/_posts/数据链路层知识点.md","hash":"b78be4afcfbe3d0a48a9b0c36f92d1887c455492","modified":1735297395345},{"_id":"source/_posts/短链系统.md","hash":"bf6166d84d1abc061b1a73c828179f59c5190833","modified":1735297395345},{"_id":"source/_posts/理睬.md","hash":"a277f5575b4bf38992f64867415e1207688397d1","modified":1735297395345},{"_id":"source/_posts/用户态和内核态.md","hash":"99ce65930686769cc55e3ef4fd8c2df3b8b20d89","modified":1735297395345},{"_id":"source/_posts/网络代理.md","hash":"09ece3a1b4df62b3acf3b31efffe1a6a386b4c7c","modified":1735297395345},{"_id":"source/_posts/设计模式.md","hash":"d99c110491e55867a06571a49c61b59e42a9439f","modified":1735299107220},{"_id":"source/_posts/网络层知识点.md","hash":"0dc759b2a9fb277acba6bbd48ea43b00d8d82255","modified":1735297395345},{"_id":"source/_posts/草稿.md","hash":"2073e15a91610d95def0a9b9ac30a0e7893f8fef","modified":1735297395345},{"_id":"source/_posts/读书笔记.md","hash":"727f569d53714fff4f7abc2409d66a9ef5728180","modified":1735297395345},{"_id":"source/_posts/Go/Go embed使用.md","hash":"5d5754aaddef5e0ed6d066b6d6739c1b12bef908","modified":1735297395342},{"_id":"source/_posts/Asyncflow/草稿.md","hash":"e351cbc786356a36e89fbf6c3ee056c998b71a27","modified":1737380153875},{"_id":"source/_posts/Go/GC.md","hash":"d8b09b96c79e22d98c172f0fdb5241ab67751516","modified":1735297395342},{"_id":"source/_posts/Excalidraw/Drawing 2024-12-17 15.07.21.excalidraw.md","hash":"64035e224c6d79222bffcaaeaa563adf0ddae654","modified":1736060491935},{"_id":"source/_posts/Go/GMP原理.md","hash":"a4e2e67cd087f49b829e71757fcb961d350a09b6","modified":1735297395342},{"_id":"source/_posts/Go/Golang数据结构.md","hash":"5d1631c9c6592034fdee204b2da16cd321b5f72d","modified":1735297395342},{"_id":"source/_posts/Go/接入日志模块.md","hash":"91190b5b1e56a27e17b9cf65c3c6de99cded96e3","modified":1735297395345},{"_id":"source/_posts/Go/接入配置模块.md","hash":"52a904748bc0971b6f0c885161e9ae614b5cb060","modified":1735297395345},{"_id":"source/_posts/Go/Go电商实战笔记.md","hash":"a28377656921bf374a646870104af58e8875c10a","modified":1735297395342},{"_id":"source/_posts/Go/榜单模型与分布式任务调度.md","hash":"95dea834db445e91c6b1bb77b5ac7676395e3e7a","modified":1735297395345},{"_id":"source/_posts/MySQL/MySQL事务学习.md","hash":"dbd5d8f8ff3315020edc3c56320139269ba8d2ab","modified":1735297395343},{"_id":"source/_posts/MySQL/MySQL索引学习.md","hash":"a842471b8b3748763a1aa8459cbd45c7ef1ffb7d","modified":1735297395343},{"_id":"source/_posts/Go/阅读、点赞、收藏功能.md","hash":"f60a452dd3df1fb753d240f46b792262bab046d5","modified":1735297395345},{"_id":"source/_posts/MySQL/MySQL日志学习.md","hash":"1c4d05f0b09a0d8628e5356fa783c8e43cf34561","modified":1735297395343},{"_id":"source/_posts/MySQL/MySQL实战45讲.md","hash":"fc9db9d66b2099c702eeaafe8414a3de88889ee4","modified":1737641436311},{"_id":"source/_posts/MySQL/MySQL锁学习.md","hash":"480f6dc686d2ec32c33f26af75e8d07bf701ba34","modified":1735297395343},{"_id":"source/_posts/Redis/Redis场景应用.md","hash":"9e8e17758e9a2b978f3befdf154c8133a9b19eef","modified":1735297395343},{"_id":"source/_posts/Redis/Redis对象.md","hash":"877db456091778eb66c408ebe2e6945f7e64658f","modified":1735297395343},{"_id":"source/_posts/MySQL/MySQL连接池优化.md","hash":"284fadcfe3f6f8c59844b22b016b36ab78b88626","modified":1735297395343},{"_id":"source/_posts/Redis/Redis持久化.md","hash":"54e6d4e0464a8ec9e488f522960035a3d6a5c882","modified":1735297395343},{"_id":"source/_posts/Redis/Redis运行原理.md","hash":"b8d8d748aaab8f4fb6d02bda2b5551ddf8db3042","modified":1735297395343},{"_id":"source/_posts/interview experience/其他.md","hash":"568ab5a7d503e635dfe682f788e52cc7179d1f80","modified":1737082143403},{"_id":"source/_posts/interview experience/阿里巴巴.md","hash":"8656d7692ef567c20f457d203255681a33020827","modified":1737383395728},{"_id":"source/_posts/interview experience/字节跳动.md","hash":"695f2072c430ad36463f619395a46e3440b144be","modified":1737270415166},{"_id":"source/_posts/interview experience/.obsidian/core-plugins.json","hash":"688b44c61ce85d9ac421b1a310a72c1348bc9b51","modified":1736861959814},{"_id":"source/_posts/interview experience/.obsidian/app.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1736861960299},{"_id":"source/_posts/interview experience/.obsidian/appearance.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1736861960301},{"_id":"source/_posts/interview experience/.obsidian/workspace.json","hash":"b9277dc189b96d756e771592c6d873022c02c962","modified":1736864286597},{"_id":"public/2025/01/19/他们眼中的简历/index.html","hash":"d49f95ab53a498be6cd805d0106b211700fe0a50","modified":1737810698988},{"_id":"public/2025/01/19/interview experience/阿里巴巴/index.html","hash":"0e6c66de7e5657a5fc629e839d55d0ca1289fe86","modified":1737810993929},{"_id":"public/2025/01/16/interview experience/其他/index.html","hash":"7e13fa5e40a044201cd62bca4d1b642c714d07e8","modified":1737810698988},{"_id":"public/2025/01/13/MySQL/MySQL实战45讲/index.html","hash":"5a658b761c6634f2b4d4221f0a3352f5306b31a5","modified":1737810698988},{"_id":"public/2025/01/12/interview experience/字节跳动/index.html","hash":"f18ec43931b0aae3d7166061461ecbb2a025c053","modified":1737810698988},{"_id":"public/2025/01/04/Kafka理论知识/index.html","hash":"db769c2100a8dfdbbb007649ab1af9341a03e3da","modified":1737810698988},{"_id":"public/2024/12/27/理睬/index.html","hash":"763b7a773c503bc6de1a209425ba2434ccdd98d5","modified":1737810698988},{"_id":"public/2024/12/27/用户态和内核态/index.html","hash":"e8fd96f790b7b1115da462b200c3074210a02b69","modified":1737810698988},{"_id":"public/2024/12/27/短链系统/index.html","hash":"53dbf305c143d9cf9be0a49ffde00009520f38ca","modified":1737810698988},{"_id":"public/2024/12/27/草稿/index.html","hash":"d5474046c5a697788d9291b21d6dd9bdd4d25969","modified":1737810698988},{"_id":"public/2024/12/27/读书笔记/index.html","hash":"da8f85a4ac595fc978304a81a2df415e74290377","modified":1737810698988},{"_id":"public/2024/12/27/Go/阅读、点赞、收藏功能/index.html","hash":"3d5adc78229934a329b4b9a6e8c82159ca0f1328","modified":1737810698988},{"_id":"public/2024/12/27/Go/榜单模型与分布式任务调度/index.html","hash":"1355758c58ad34050037309b1afb0c3fc9c5c93b","modified":1737810698988},{"_id":"public/2024/12/27/more/index.html","hash":"d97a4ed1b14ffebbeed4248efd3a9c8a47fe52a2","modified":1737810698988},{"_id":"public/2024/12/27/style/index.html","hash":"0bf672cdd5e72bed818d94407e4dea0edcafe54d","modified":1737810698988},{"_id":"public/2024/12/27/《Go语言精进之路》阅读笔记/index.html","hash":"92ab759324db1966fac37a89c639510494236db4","modified":1737810698988},{"_id":"public/2024/12/27/《设计模式之美》阅读笔记/index.html","hash":"ecf178d4c364157787355d6bcd88438d16a9d36f","modified":1737810698988},{"_id":"public/2024/12/27/优质开源软件合集/index.html","hash":"d53eda780aa192a012e354883df2179667c3e1c4","modified":1737810698988},{"_id":"public/2024/12/27/使用本地缓存代替Redis/index.html","hash":"75d12d60b4597e0f55498056a5dae5bca1c7e09e","modified":1737810698988},{"_id":"public/2024/12/27/分布式理论基础/index.html","hash":"7b58f8aad92b5bbff952059b55da85f3601069f2","modified":1737810698988},{"_id":"public/2024/12/27/发帖功能实现/index.html","hash":"87b1c9d955d5e4397ca5c05c04371bd0f4e9e3e1","modified":1737810698988},{"_id":"public/2024/12/27/换取Mac OS第一步/index.html","hash":"39ebb5f67b3229a6bc2a533b0d023d735a2d18f6","modified":1737810698988},{"_id":"public/2024/12/27/定时微服务/index.html","hash":"b76b5fdb5e31ad53e73c981bb5cf891db7f0db2e","modified":1737810698988},{"_id":"public/2024/12/27/Sync/index.html","hash":"8c5cbd405d75754c4399df2c0a540448a39281fa","modified":1737810698988},{"_id":"public/2024/12/27/component/index.html","hash":"4b2f925e4d24a2330814a07700054de753e2486d","modified":1737810698988},{"_id":"public/2024/12/27/MySQL/MySQL日志学习/index.html","hash":"b69f0af77e70cb9d701b1a550ba3ec25d93c479f","modified":1737810698988},{"_id":"public/2024/12/27/MySQL/MySQL连接池优化/index.html","hash":"360fd135aaa44664aff2ad095fc8c327d274b16a","modified":1737810698988},{"_id":"public/2024/12/27/Redis/Redis持久化/index.html","hash":"9dda157886820b3a60c10d122e8714197691a1b1","modified":1737810698988},{"_id":"public/2024/12/27/Redis/Redis场景应用/index.html","hash":"1b97de1cc6d49f60675c6008846553ffc4a15cad","modified":1737810698988},{"_id":"public/2024/12/27/Redis/Redis对象/index.html","hash":"003e064c25494c3a3c3d674941259849bdc38026","modified":1737810698988},{"_id":"public/2024/12/27/Redis/Redis运行原理/index.html","hash":"433450d2feb0c31e289c98fb58c479edf104cf9b","modified":1737810698988},{"_id":"public/2024/12/27/Alist访问/index.html","hash":"9bcc4b76e5a524054df904c0b64522b7bbfaac22","modified":1737810698988},{"_id":"public/2024/12/27/Docker学习笔记/index.html","hash":"77504a3b1d5d6f54bf5318a94f58cd0ba1ccc0a3","modified":1737810698988},{"_id":"public/2024/12/27/Kafka实践/index.html","hash":"45c1550287f7b618db8eed28f5522f5c068d2888","modified":1737810698988},{"_id":"public/2024/12/27/Asyncflow/草稿/index.html","hash":"4fb86b5fb87d196f37bb6fad5b26c1a58fbc55e3","modified":1737810698988},{"_id":"public/2024/12/27/Excalidraw/Drawing 2024-12-17 15.07.21.excalidraw/index.html","hash":"678104c885ebf1a4d79926dc63f22d9eda76c2a2","modified":1737810698988},{"_id":"public/2024/12/27/Go/GC/index.html","hash":"d3d16f779a98e5f31d3204ed25aadab7ea3bcba1","modified":1737810698988},{"_id":"public/2024/12/27/Go/Go embed使用/index.html","hash":"4651862faee18b57ac02f0cf8269dba81275bccd","modified":1737810698988},{"_id":"public/2024/12/27/Go/GMP原理/index.html","hash":"30232779edaf8a0a473a142e238ced68d3438c81","modified":1737810698988},{"_id":"public/2024/12/27/Go/Go电商实战笔记/index.html","hash":"21dd8d4255db61835669332f5d6604dd1172d7f2","modified":1737810698988},{"_id":"public/2024/12/15/设计模式/index.html","hash":"92199bb352ee3ff2de8c631d2955ec05910953b0","modified":1737810698988},{"_id":"public/2024/12/13/异步框架/index.html","hash":"6fc996c0b7e855cbb8a7971848681e9ab12a2894","modified":1737810698988},{"_id":"public/2024/12/12/优质好文合集/index.html","hash":"b0075c7c43ab4d54ecc13870e3a430c2a3dd8dfd","modified":1737810698988},{"_id":"public/2024/09/27/goroutine/index.html","hash":"a2644edec29b50b00cb0f01d22b504614f4f1e02","modified":1737810698988},{"_id":"public/2024/12/12/Go/Golang数据结构/index.html","hash":"c8a0987f3d4745db702125b7f52725b02a2e7972","modified":1737810698988},{"_id":"public/2024/09/27/网络代理/index.html","hash":"9b35f6d5abde0a857938a453dcbf1ef00f1fa3ee","modified":1737810698988},{"_id":"public/2024/09/27/MySQL/MySQL锁学习/index.html","hash":"31a0b948d84db91e79b8d746e188557bef8c1bdb","modified":1737810698988},{"_id":"public/2024/09/23/数据链路层知识点/index.html","hash":"18e992aa0457ef4b7aaa837d8d033aaf7ba546f9","modified":1737810698988},{"_id":"public/2024/09/23/MySQL/MySQL事务学习/index.html","hash":"427abc96190eb860053ddaae96154b85f8481f2a","modified":1737810698988},{"_id":"public/2024/09/21/网络层知识点/index.html","hash":"ae46eb38176068620e6774b9738ae0beb203c4d3","modified":1737810698988},{"_id":"public/2024/09/19/MySQL/MySQL索引学习/index.html","hash":"d5ad98a08b2ddd6e407134a13b38c64d62df5d00","modified":1737810698988},{"_id":"public/2024/09/15/git学习笔记/index.html","hash":"de49bf0b42482f1b8cb4ca288705d242465d6930","modified":1737810698988},{"_id":"public/2024/09/14/传输层知识点/index.html","hash":"ff3b0bc03bf4205e77bbbc7b57de7533023a43fb","modified":1737810698988},{"_id":"public/2024/08/20/Go/接入日志模块/index.html","hash":"889f7f45c3fe3ba1be7a3c6c66f36ceee366e2b9","modified":1737810698988},{"_id":"public/2024/08/15/Go/接入配置模块/index.html","hash":"d558ab8049fa46b5af3ac9d0675fef3ab47dd747","modified":1737810698988},{"_id":"public/archives/page/2/index.html","hash":"897888f6c4a799156ca8fbf8a1be9e4ebd826f34","modified":1737810698988},{"_id":"public/archives/page/3/index.html","hash":"a84edef257037e5eea8845a169a0002cc622a67d","modified":1737810698988},{"_id":"public/archives/page/4/index.html","hash":"5bb37ffc278db0821f5b3165aff51ec51ec6b241","modified":1737810698988},{"_id":"public/archives/page/5/index.html","hash":"1df559dc724bb01d60c0adf9407a2742b29deeaf","modified":1737810698988},{"_id":"public/archives/page/6/index.html","hash":"261440e610497dfa09dfc98617e42a48a120001f","modified":1737810698988},{"_id":"public/archives/2024/index.html","hash":"c248a7338cc3bbf6cc46d99eb1ada1380938a337","modified":1737810698988},{"_id":"public/archives/2024/page/2/index.html","hash":"bcfa53ed9e2530c30e3508867b12d2542586ef21","modified":1737810698988},{"_id":"public/archives/2024/page/3/index.html","hash":"75b616d47480e44d15126bec5fc8089e7f901499","modified":1737810698988},{"_id":"public/archives/2024/page/4/index.html","hash":"122d2173db48d5fcd84f799041b11d00899a9905","modified":1737810698988},{"_id":"public/archives/2024/page/5/index.html","hash":"806d6a4f3a60aebf72a2b9aac3fcd4531e807c0e","modified":1737810698988},{"_id":"public/archives/2024/08/index.html","hash":"fe941621bc216143c867a076013fe1805139a3c3","modified":1737810698988},{"_id":"public/archives/2024/09/index.html","hash":"670c557b8f889369c79e975a11dc410f0d17549a","modified":1737810698988},{"_id":"public/archives/2024/12/index.html","hash":"503387b55f97f4222547a6bcd1ba98bd6553105e","modified":1737810698988},{"_id":"public/archives/2024/12/page/2/index.html","hash":"2f5657e0517f808955b7b7afcff71c9e5e2b5346","modified":1737810698988},{"_id":"public/archives/2024/12/page/3/index.html","hash":"6a4b69529218b60ff3065b7bea5871120ac9116c","modified":1737810698988},{"_id":"public/archives/2024/12/page/4/index.html","hash":"4e861554086f39c3257f842b15813b421032c5f6","modified":1737810698988},{"_id":"public/page/2/index.html","hash":"eb9a3eec566c490b31534a2a89c7f5ad448015fc","modified":1737810993929},{"_id":"public/page/3/index.html","hash":"6545c2a85ee5776f2a6e9ae1c80576da12d2dff7","modified":1737810993929},{"_id":"public/page/4/index.html","hash":"0b8d08f813bacd11dd3bed7d21738afd4be308f5","modified":1737810993929},{"_id":"public/page/6/index.html","hash":"ff81ca257c64424d2d8ca3485962a19053e62bc0","modified":1737810993929},{"_id":"public/page/5/index.html","hash":"4c923a39e7b962c22e3b6d71c674a08917ccda14","modified":1737810993929},{"_id":"public/tags/Docker/index.html","hash":"1aaa827b5a657d37881a8ac9a232bab38985c28b","modified":1737810698988},{"_id":"public/tags/Git/index.html","hash":"cca73bbdfffecd601ecb4913365928786c535f52","modified":1737810698988},{"_id":"public/tags/Golang/index.html","hash":"a651259ab8acccf69e6729bfdcf6fefa08ca28c6","modified":1737810698988},{"_id":"public/tags/配置/index.html","hash":"e0f8a92f8014e77397d8094f8a9100b44dd8f089","modified":1737810698988},{"_id":"public/tags/Go/index.html","hash":"f186ac116715e5c8afba55ca0a4b8e73fedb9b6c","modified":1737810698988},{"_id":"public/tags/优质文章/index.html","hash":"320907230befdc4c9537ae16c3a9375122879a34","modified":1737810698988},{"_id":"public/tags/设计模式/index.html","hash":"e0d65104843bee2efdefa9938b40bde3d59eb200","modified":1737810698988},{"_id":"public/tags/计算机网络/index.html","hash":"83b9d946a4f537942731e03226a81f590bc747f3","modified":1737810698988},{"_id":"public/tags/开源工具/index.html","hash":"1583d9c5b504872330dca6eb880d75621c9dabfd","modified":1737810698988},{"_id":"public/tags/资源/index.html","hash":"83d61077a0efbe8e2f2d595cb5b60703c6f308f2","modified":1737810698988},{"_id":"public/tags/项目/index.html","hash":"53d715d70df1953c49eb5e50d95e231d65b78c84","modified":1737810698988},{"_id":"public/tags/学习/index.html","hash":"9945ccd486347a0d2407d4066f43870f6eca6fff","modified":1737810698988},{"_id":"public/tags/excalidraw/index.html","hash":"4445ededba53095ef3a39c222eaeb31791289de4","modified":1737810698988},{"_id":"public/tags/MySQL/index.html","hash":"c9ec44b0f5874a7a2604c676d36faa3ecae1ae5b","modified":1737810698988},{"_id":"public/tags/Redis/index.html","hash":"133510c770b458ef6b12995dd4c1dd16e3071f9d","modified":1737810698988},{"_id":"public/tags/数据结构/index.html","hash":"3bde0c042ca4f919604de3b23a2027f633dd1a4d","modified":1737810698988},{"_id":"public/articles/page/2/index.html","hash":"a733975eb79180ec767b302e28fcd3c081842ad2","modified":1737810698988},{"_id":"public/articles/page/3/index.html","hash":"35095a209201c4d8b2ecaa12a29aa13d3b4f8526","modified":1737810698988},{"_id":"public/articles/page/4/index.html","hash":"192e546d58af1c45dc7b1ea0a292c4d26de4df1e","modified":1737810698988},{"_id":"public/articles/page/5/index.html","hash":"731e92bd543494dbbb1ceddaf018d40d79088459","modified":1737810698988},{"_id":"public/articles/page/6/index.html","hash":"a1a9a19de891ee79761e3999b083bce6d32bee06","modified":1737810698988},{"_id":"public/2025/01/25/他们眼中的简历/index.html","hash":"bb8f29765b8c458046f20f29d1636bb859d8d670","modified":1737810993929}],"Category":[],"Data":[],"Page":[],"Post":[{"publish":true,"_content":"\n\n\n一般地，点击一个视频是不会加载成功的，就像这样子：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191901690.png\" alt=\"image-20241019190139605\" style=\"zoom:50%;\" />\n\n这是因为**Alist挂载的是百度云盘，而百度云盘会在处理请求时会先进行身份校验**。一般身份校验操作都会针对**jwt-token、请求头中的User-Agent字段**进行验证。\n\n上述视频无法加载成功的原因就是**User-Agent字段**设置错误。那么我们只需要将**User-Agent字段设置为`pan.baidu.com`就能在线播放视频啦**~~（Alist官网官方文档告诉我的🤪）~~\n\n具体操作（以edge浏览器为例）：\n\n- 按下键盘`F12`，呼出开发者工具\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191910833.png\" alt=\"image-20241019191014765\" style=\"zoom:50%;\" />\n\n- 点击网络状况（关键是找到这个🛜+⚙️的图标）\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191913926.png\" style=\"zoom:50%;\" />\n\n- 取消勾选`Use browse default`，并将字段值自定义为`pan.baidu.com`。最终结果如下图\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191916203.png\" alt=\"image-20241019191634164\" style=\"zoom: 67%;\" />\n\n- 修改完后刷新（**刷新时不要关闭开发者工具**）即可播放。若后续仍出现不可播放的情况，请检查`User-Agent`是否为`pan.baidu.com`\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191920677.png\" alt=\"image-20241019192045600\" style=\"zoom:50%;\" />\n\n","source":"_posts/Alist访问.md","raw":"---\npublish: true\n---\n\n\n\n一般地，点击一个视频是不会加载成功的，就像这样子：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191901690.png\" alt=\"image-20241019190139605\" style=\"zoom:50%;\" />\n\n这是因为**Alist挂载的是百度云盘，而百度云盘会在处理请求时会先进行身份校验**。一般身份校验操作都会针对**jwt-token、请求头中的User-Agent字段**进行验证。\n\n上述视频无法加载成功的原因就是**User-Agent字段**设置错误。那么我们只需要将**User-Agent字段设置为`pan.baidu.com`就能在线播放视频啦**~~（Alist官网官方文档告诉我的🤪）~~\n\n具体操作（以edge浏览器为例）：\n\n- 按下键盘`F12`，呼出开发者工具\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191910833.png\" alt=\"image-20241019191014765\" style=\"zoom:50%;\" />\n\n- 点击网络状况（关键是找到这个🛜+⚙️的图标）\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191913926.png\" style=\"zoom:50%;\" />\n\n- 取消勾选`Use browse default`，并将字段值自定义为`pan.baidu.com`。最终结果如下图\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191916203.png\" alt=\"image-20241019191634164\" style=\"zoom: 67%;\" />\n\n- 修改完后刷新（**刷新时不要关闭开发者工具**）即可播放。若后续仍出现不可播放的情况，请检查`User-Agent`是否为`pan.baidu.com`\n  - <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191920677.png\" alt=\"image-20241019192045600\" style=\"zoom:50%;\" />\n\n","slug":"Alist访问","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6d0000a5t2cua69y20","content":"<p>一般地，点击一个视频是不会加载成功的，就像这样子：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191901690.png\" alt=\"image-20241019190139605\" style=\"zoom:50%;\" />\n\n<p>这是因为<strong>Alist挂载的是百度云盘，而百度云盘会在处理请求时会先进行身份校验</strong>。一般身份校验操作都会针对<strong>jwt-token、请求头中的User-Agent字段</strong>进行验证。</p>\n<p>上述视频无法加载成功的原因就是<strong>User-Agent字段</strong>设置错误。那么我们只需要将<strong>User-Agent字段设置为<code>pan.baidu.com</code>就能在线播放视频啦</strong><del>（Alist官网官方文档告诉我的🤪）</del></p>\n<p>具体操作（以edge浏览器为例）：</p>\n<ul>\n<li><p>按下键盘<code>F12</code>，呼出开发者工具</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191910833.png\" alt=\"image-20241019191014765\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>点击网络状况（关键是找到这个🛜+⚙️的图标）</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191913926.png\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>取消勾选<code>Use browse default</code>，并将字段值自定义为<code>pan.baidu.com</code>。最终结果如下图</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191916203.png\" alt=\"image-20241019191634164\" style=\"zoom: 67%;\" /></li>\n</ul>\n</li>\n<li><p>修改完后刷新（<strong>刷新时不要关闭开发者工具</strong>）即可播放。若后续仍出现不可播放的情况，请检查<code>User-Agent</code>是否为<code>pan.baidu.com</code></p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191920677.png\" alt=\"image-20241019192045600\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<p>一般地，点击一个视频是不会加载成功的，就像这样子：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191901690.png\" alt=\"image-20241019190139605\" style=\"zoom:50%;\" />\n\n<p>这是因为<strong>Alist挂载的是百度云盘，而百度云盘会在处理请求时会先进行身份校验</strong>。一般身份校验操作都会针对<strong>jwt-token、请求头中的User-Agent字段</strong>进行验证。</p>\n<p>上述视频无法加载成功的原因就是<strong>User-Agent字段</strong>设置错误。那么我们只需要将<strong>User-Agent字段设置为<code>pan.baidu.com</code>就能在线播放视频啦</strong><del>（Alist官网官方文档告诉我的🤪）</del></p>\n<p>具体操作（以edge浏览器为例）：</p>\n<ul>\n<li><p>按下键盘<code>F12</code>，呼出开发者工具</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191910833.png\" alt=\"image-20241019191014765\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>点击网络状况（关键是找到这个🛜+⚙️的图标）</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191913926.png\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>取消勾选<code>Use browse default</code>，并将字段值自定义为<code>pan.baidu.com</code>。最终结果如下图</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191916203.png\" alt=\"image-20241019191634164\" style=\"zoom: 67%;\" /></li>\n</ul>\n</li>\n<li><p>修改完后刷新（<strong>刷新时不要关闭开发者工具</strong>）即可播放。若后续仍出现不可播放的情况，请检查<code>User-Agent</code>是否为<code>pan.baidu.com</code></p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191920677.png\" alt=\"image-20241019192045600\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ul>\n"},{"description":"记录有关Docker的一些知识点","_content":"\n# Docker学习笔记\n\n## Docker和传统虚拟机的区别\n\n![image-20241114183050052](https://raw.githubusercontent.com/lyydsheep/pic/main/202411141831820.png)\n\n**物理服务器**\n\n一台看得见摸的着的机器就是物理机器，即云服务厂商所说的**物理服务器、物理机、独立服务器**\n\n**VPS**\n\n一般来说，一台物理服务器性能比普通电脑要好得多，但是这样一台服务器分配给个人使用就会导致性能过剩、资金浪费。**VPS（Virtual Private Server，虚拟专用服务器）**就是指在物理服务器上运行多台虚拟机，这些虚拟机有独立的资源、操作系统和公网IP地址。云服务厂家就能一VPS为最小单位向用户出租服务器\n\n**ECS**\n\nVPS的配置都是事先由厂家确定好的，但是很多情况下用户有自定义服务器配置的需求。**ECS（Elastic Computer Service）**就是加入了自主升降级功能的VPS，用户可以根据需求随时调整CPU、内存、磁盘等配置\n\n**Docker**\n\nECS归根到底也是一台电脑，那就不可避免会存在**应用在不同操作系统之间兼容性**的问题。~~一个很简单的想法就是将软件连带操作系统一同部署~~Docker容器技术选择将**软件及其所依赖的环境配置**一同打包，挂载在服务器上，再通过**Namespace**让它们看起来是运行在一个独立的操作系统上，以及利用**Cgroup**限制可使用的计算资源\n\n![image-20241114190259158](https://raw.githubusercontent.com/lyydsheep/pic/main/202411141902210.png)\n\n总结一下就是：**物理服务器上跑ecs，ecs跑Docker容器。多个Docker容器共享一个ecs实例操作系统内核**\n\n## 参考\n\n[面试官：Docker和传统虚拟机有什么区别？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247534049&idx=2&sn=1ef2674ddb3217bbafcb5cd6946407ac&chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&token=630123097&lang=zh_CN#rd)","source":"_posts/Docker学习笔记.md","raw":"---\ntags:\n- Docker\ndescription: 记录有关Docker的一些知识点\n---\n\n# Docker学习笔记\n\n## Docker和传统虚拟机的区别\n\n![image-20241114183050052](https://raw.githubusercontent.com/lyydsheep/pic/main/202411141831820.png)\n\n**物理服务器**\n\n一台看得见摸的着的机器就是物理机器，即云服务厂商所说的**物理服务器、物理机、独立服务器**\n\n**VPS**\n\n一般来说，一台物理服务器性能比普通电脑要好得多，但是这样一台服务器分配给个人使用就会导致性能过剩、资金浪费。**VPS（Virtual Private Server，虚拟专用服务器）**就是指在物理服务器上运行多台虚拟机，这些虚拟机有独立的资源、操作系统和公网IP地址。云服务厂家就能一VPS为最小单位向用户出租服务器\n\n**ECS**\n\nVPS的配置都是事先由厂家确定好的，但是很多情况下用户有自定义服务器配置的需求。**ECS（Elastic Computer Service）**就是加入了自主升降级功能的VPS，用户可以根据需求随时调整CPU、内存、磁盘等配置\n\n**Docker**\n\nECS归根到底也是一台电脑，那就不可避免会存在**应用在不同操作系统之间兼容性**的问题。~~一个很简单的想法就是将软件连带操作系统一同部署~~Docker容器技术选择将**软件及其所依赖的环境配置**一同打包，挂载在服务器上，再通过**Namespace**让它们看起来是运行在一个独立的操作系统上，以及利用**Cgroup**限制可使用的计算资源\n\n![image-20241114190259158](https://raw.githubusercontent.com/lyydsheep/pic/main/202411141902210.png)\n\n总结一下就是：**物理服务器上跑ecs，ecs跑Docker容器。多个Docker容器共享一个ecs实例操作系统内核**\n\n## 参考\n\n[面试官：Docker和传统虚拟机有什么区别？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247534049&idx=2&sn=1ef2674ddb3217bbafcb5cd6946407ac&chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&token=630123097&lang=zh_CN#rd)","slug":"Docker学习笔记","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6f0001a5t2d10u8ihd","content":"<h1 id=\"Docker学习笔记\"><a href=\"#Docker学习笔记\" class=\"headerlink\" title=\"Docker学习笔记\"></a>Docker学习笔记</h1><h2 id=\"Docker和传统虚拟机的区别\"><a href=\"#Docker和传统虚拟机的区别\" class=\"headerlink\" title=\"Docker和传统虚拟机的区别\"></a>Docker和传统虚拟机的区别</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411141831820.png\" alt=\"image-20241114183050052\"></p>\n<p><strong>物理服务器</strong></p>\n<p>一台看得见摸的着的机器就是物理机器，即云服务厂商所说的<strong>物理服务器、物理机、独立服务器</strong></p>\n<p><strong>VPS</strong></p>\n<p>一般来说，一台物理服务器性能比普通电脑要好得多，但是这样一台服务器分配给个人使用就会导致性能过剩、资金浪费。<strong>VPS（Virtual Private Server，虚拟专用服务器）</strong>就是指在物理服务器上运行多台虚拟机，这些虚拟机有独立的资源、操作系统和公网IP地址。云服务厂家就能一VPS为最小单位向用户出租服务器</p>\n<p><strong>ECS</strong></p>\n<p>VPS的配置都是事先由厂家确定好的，但是很多情况下用户有自定义服务器配置的需求。<strong>ECS（Elastic Computer Service）</strong>就是加入了自主升降级功能的VPS，用户可以根据需求随时调整CPU、内存、磁盘等配置</p>\n<p><strong>Docker</strong></p>\n<p>ECS归根到底也是一台电脑，那就不可避免会存在<strong>应用在不同操作系统之间兼容性</strong>的问题。<del>一个很简单的想法就是将软件连带操作系统一同部署</del>Docker容器技术选择将<strong>软件及其所依赖的环境配置</strong>一同打包，挂载在服务器上，再通过<strong>Namespace</strong>让它们看起来是运行在一个独立的操作系统上，以及利用<strong>Cgroup</strong>限制可使用的计算资源</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411141902210.png\" alt=\"image-20241114190259158\"></p>\n<p>总结一下就是：<strong>物理服务器上跑ecs，ecs跑Docker容器。多个Docker容器共享一个ecs实例操作系统内核</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247534049&idx=2&sn=1ef2674ddb3217bbafcb5cd6946407ac&chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&token=630123097&lang=zh_CN#rd\">面试官：Docker和传统虚拟机有什么区别？ (qq.com)</a></p>\n","excerpt":"","more":"<h1 id=\"Docker学习笔记\"><a href=\"#Docker学习笔记\" class=\"headerlink\" title=\"Docker学习笔记\"></a>Docker学习笔记</h1><h2 id=\"Docker和传统虚拟机的区别\"><a href=\"#Docker和传统虚拟机的区别\" class=\"headerlink\" title=\"Docker和传统虚拟机的区别\"></a>Docker和传统虚拟机的区别</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411141831820.png\" alt=\"image-20241114183050052\"></p>\n<p><strong>物理服务器</strong></p>\n<p>一台看得见摸的着的机器就是物理机器，即云服务厂商所说的<strong>物理服务器、物理机、独立服务器</strong></p>\n<p><strong>VPS</strong></p>\n<p>一般来说，一台物理服务器性能比普通电脑要好得多，但是这样一台服务器分配给个人使用就会导致性能过剩、资金浪费。<strong>VPS（Virtual Private Server，虚拟专用服务器）</strong>就是指在物理服务器上运行多台虚拟机，这些虚拟机有独立的资源、操作系统和公网IP地址。云服务厂家就能一VPS为最小单位向用户出租服务器</p>\n<p><strong>ECS</strong></p>\n<p>VPS的配置都是事先由厂家确定好的，但是很多情况下用户有自定义服务器配置的需求。<strong>ECS（Elastic Computer Service）</strong>就是加入了自主升降级功能的VPS，用户可以根据需求随时调整CPU、内存、磁盘等配置</p>\n<p><strong>Docker</strong></p>\n<p>ECS归根到底也是一台电脑，那就不可避免会存在<strong>应用在不同操作系统之间兼容性</strong>的问题。<del>一个很简单的想法就是将软件连带操作系统一同部署</del>Docker容器技术选择将<strong>软件及其所依赖的环境配置</strong>一同打包，挂载在服务器上，再通过<strong>Namespace</strong>让它们看起来是运行在一个独立的操作系统上，以及利用<strong>Cgroup</strong>限制可使用的计算资源</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411141902210.png\" alt=\"image-20241114190259158\"></p>\n<p>总结一下就是：<strong>物理服务器上跑ecs，ecs跑Docker容器。多个Docker容器共享一个ecs实例操作系统内核</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247534049&idx=2&sn=1ef2674ddb3217bbafcb5cd6946407ac&chksm=f98d014bcefa885d6b68c0405718abf634a33427264a8ae4d04bc478bc03121dbfdceed7012e&token=630123097&lang=zh_CN#rd\">面试官：Docker和传统虚拟机有什么区别？ (qq.com)</a></p>\n"},{"_content":"# 消息队列\n\n消息队列的基本形态，就是有**N个生产者，N个消费者**\n\n生产者和消费者解耦了\n\n## 应用场景\n### 消息队列解耦\n一个模块A接收到请求后需要调用模块B，接着等待模块B完成后续工作，才进行回包。这种情况下模块A极度依赖于模块B的运行状况，耦合度较高。如果业务允许的话，模块A完全可以将调用模块B的请求信息丢进**消息中转站**中，模块B一旦发现中转站中有消息就进行工作。这个中转站就是消息队列，起着解耦合作用\n解耦的本质就是**A不用关心B的事情，以及不受B执行结果的影响**\n\n### 消息队列削峰\n在请求处理链中，各模块的处理能力通常存在较大差异。根据木桶原理，系统的 QPS（每秒查询量）往往受最弱处理模块的限制，这导致上游模块的剩余处理能力无法充分利用，进而造成性能与资源的浪费。为提升系统整体的 QPS，并最大限度发挥上游模块的高响应性能，**上游可以将处理完成的消息暂存至消息队列**。下游模块则从消息队列中逐步获取消息进行处理，通过延迟处理的方式，实现**削峰填谷**的效果，有效缓解负载不均问题。\n实际场景：1、秒杀场景 2、凌晨录入数据\n\n```sh\ncnt=1\nwhile [ $cnt -le 10 ]\ndo\n\tcurl -w \"\\n cost %{time_total}s\" -H \"Trace-ID:lyydsheep1\" -H \"Content-Type: application/json; charset=utf-8\" -H \"User-ID: 7\" http://localhost:8080/demo/peak_clipping -d '{\"num\":1}'\n\tcnt=$((cnt + 1))\ndone\n```\n\n### 消息队列分发\n一个模块A需要将消息分发至模块B、C、D\n实际场景：1、数据更新 2、数据分析/校验\n在引入消息队列之前，生产者需要了解有多少个消费者，以及消费者对于消息的格式化要求。在引入消息队列后，生产者只需要和消息队列打交道，不必关心消费者，也可以说是实现了消息群发场景下的解耦\n\n## 基本概念\n\n- 生产者 producer\n- 消费者 consumer\n- 消息服务器 broker\n- topic与partition\n- 消费者组与消费者\n\n![image-20241121143736964](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211437013.png)\n\nbroker（中间人），是一个逻辑上的概念。在实践中，可以映射为一个消息队列进程或一台机器\n\n**topic是消息队列上代表不同业务的东西**，简单来说，一个业务就是一个topic，而**一个topic可以有多个分区**\n\n![image-20241121144040306](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211440344.png)\n\n**当发送消息到Kafka上的时候，Kafka会先把消息写入主分区，再同步到从分区**。这是为了保证高可用和数据不丢失\n\n但通常说topic有多少个分区，是指有多少个主分区\n\n![image-20241121144329550](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211443600.png)\n\n正常情况下，同一个topic的分区会尽量均匀分散到所有的broker上。为了保证当某个broker奔溃后，不会造成很大的影响，需要满足下面两个条件：\n\n- **所有主分区不在同一个broker上**\n- **同一个topic的分区不都在一个broker上**\n\n如上文所述，一个topic都会有多个分区，**所以发送者在发送消息的时候，就需要选择一个目标（主）分区**\n\n比较常用的策略：\n\n- 轮询\n- 哈希\n- 随机\n\n![image-20241121150303848](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211503889.png)\n\nKafka消息隔离单位是**区**，**只有一个分区内的消息才能保证是有序的**\n\n**一个消费者组可以看作是关心这个topic的业务方**，对于一个分区，同一个消费者组只能有一个消费者出来消费\n\n- 一个消费者可以消费多个分区的数据\n- 一个分区在同一时刻，只能被一个消费者消费\n\n![image-20241121151119740](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211511775.png)\n\n**消息积压问题**\n\n- **如果一个topic有N个分组，那么同一个消费者组最多有N个消费者，多余的消费者会被忽略**\n- **如果消费者性能低，那么不能通过无限增加消费者数量的方式提高消费速率**\n\n## 命令行工具\n\nsarama提供了许多命令行工具，其中consumer和producer用得比较多\n\n```go\ngo install github.com/IBM/sarama/tools/kafka-console-consumer\n\ngo install github.com/IBM/sarama/tools/kafka-console-producer\n```\n\n这些具体工具的使用方法可以参考sarama中的`ReadMe`文档\n\n## Sarama使用\n\n### 同步发送消息\n\n```go\nfunc TestSyncProducer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\t// 同步生产者必须设置\n\tcfg.Producer.Return.Successes = true\n\tclient, err := sarama.NewClient([]string{\"localhost:9094\"}, cfg)\n\trequire.NoError(t, err)\n\tproducer, err := sarama.NewSyncProducerFromClient(client)\n\trequire.NoError(t, err)\n\terr = producer.SendMessages([]*sarama.ProducerMessage{\n\t\t{\n\t\t\tTopic: \"test_topic\",\n\t\t\tValue: sarama.StringEncoder(\"message A\"),\n\t\t},\n\t\t{\n\t\t\tTopic: \"test_topic\",\n\t\t\tValue: sarama.StringEncoder(\"message B\"),\n\t\t},\n\t})\n\trequire.NoError(t, err)\n}\n\n```\n\n### 指定分区\n\n由上文可知，Kafka只能保证一个分区内的消息是有序的。倘若我们希望**同一个业务的消息一定发送到同一个分区上，保证业务内消息有序性**，可以对`sarama.Config.Producer`结构体中的`Partitioner`字段进行配置，如下图：\n\n![image-20241124201226717](https://raw.githubusercontent.com/lyydsheep/pic/main/202411242012815.png)\n\n常见的：\n\n- Random：随机一个\n- RoundRobin：轮询\n- Hash：根据Message中的key的哈希值来筛选一个\n- Manual：根据Message中的partition字段来选择\n- ConsistentCRC：一致性哈希，用的是CRC16算法\n- Custom：自定义一部分Hash参数\n\n### 异步发送消息\n\n```go\nfunc TestAsyncProducer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\tcfg.Producer.Return.Successes = true\n\tcfg.Producer.Return.Errors = true\n\tclient, err := sarama.NewClient([]string{\"localhost:9094\"}, cfg)\n\trequire.NoError(t, err)\n\tproducer, err := sarama.NewAsyncProducerFromClient(client)\n\trequire.NoError(t, err)\n\tmsgInput := producer.Input()\n\tmsgInput <- &sarama.ProducerMessage{\n\t\tTopic: \"test_topic\",\n\t\tValue: sarama.StringEncoder(\"message Hello\"),\n\t}\n\tsuCh, erCh := producer.Successes(), producer.Errors()\n\t// 实践中一般都是开一个goroutine来处理\n\tselect {\n\tcase msg := <-suCh:\n\t\tval, _ := msg.Value.Encode()\n\t\tfmt.Println(msg.Topic, string(val))\n\tcase err := <-erCh:\n\t\tfmt.Println(err.Error())\n\t}\n}\n```\n\n- 需要把`Success`和`Errors`都设置为`true`，这是为了后面能异步获取到结果\n- 通过一个**channel**异步发送消息\n- 通过`select case`，监听异步发送消息的结果\n\n### 指定acks\n\n生产者在发送数据的时候，有一个关键参数——**acks**,该参数有三个取值：\n\n![image-20241125193828822](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251938899.png)\n\n- 0：客户端发一次，仅收到TCP的ACK报文（没实质作用）\n- 1：客户端发送一次，需要**等待服务端将消息写入主分区**，能确保消息成功送达\n- -1：客户端发送一次，需要**等待服务端将消息同步至所有（可配置）的ISR上**\n\n![image-20241125194219136](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251942196.png)\n\n自上而下，性能逐渐变差，但是数据可靠性上升\n\n### ISR\n\n**ISR（In Sync Replicas），就是和主分区保持数据同步的从分区集合**\n\n![image-20241125194510901](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251945935.png)\n\n### **启动消费者**\n\n```go\nfunc TestConsumer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\t// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\n\t//cfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n\tcg, err := sarama.NewConsumerGroup([]string{\"localhost:9094\"}, \"test_id\", cfg)\n\trequire.NoError(t, err)\n\t// 定时结束\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\terr = cg.Consume(ctx, []string{\"test_topic\"}, &ConsumerHandler{})\n}\n\ntype ConsumerHandler struct {\n}\n\nfunc (c ConsumerHandler) Setup(session sarama.ConsumerGroupSession) error {\n\tfmt.Println(\"this is setup\")\n\t// 重置偏移量\n\t//partitions := session.Claims()[\"test_topic\"]\n\t//for _, v := range partitions {\n\t//\tsession.ResetOffset(\"test_topic\", v, sarama.OffsetOldest, \"\")\n\t//}\n\treturn nil\n}\n\nfunc (c ConsumerHandler) Cleanup(session sarama.ConsumerGroupSession) error {\n\tfmt.Println(\"this is cleanup\")\n\treturn nil\n}\n\nfunc (c ConsumerHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\t// 关键实现\n\tmsgCh := claim.Messages()\n\tfor msg := range msgCh {\n\t\tfmt.Println(string(msg.Value))\n\t\t// 标记消费成功，用于移动offset\n\t\t// 服务端只会提交带有标记的消息，代表该消息被成功消费\n\t\tsession.MarkMessage(msg, \"\")\n\t}\n\treturn nil\n}\n```\n\n- 初始化一个**消费者组**\n- 调用消费者组的**Consume**方法\n- 为**Consume**方法传入一个**ConsumerGroupHandler接口**\n  - 向Consume方法中传入一个带有定时器或Cancel的Context，可以控制消费者退出\n\nConsumerGroupHandler接口需要实现三个方法：\n\n- Setup\n- Cleanup\n- ConsumeClaim\n\n其中消费组对消息进行消费的逻辑在ConsumClaim方法中实现：\n\n![image-20241126130732077](https://raw.githubusercontent.com/lyydsheep/pic/main/202411261307125.png)\n\n由于Consume方法需要的是一个接口，那么我们可以基于类型定义、结构体等方式花式实现ConsumeClaim方法，以达到一些巧妙的作用\n\n### 自定偏移量消费\n\nsarama中提供了两个设置偏移量的方法：\n\n- 设置`cfg.Consumer.Offsets.Initial`字段\n\n  - ```go\n    cfg := sarama.NewConfig()\n    // 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\n    cfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n    ```\n\n- 调用`session.ResetOffset()`方法\n\n  - ```go\n    // 重置偏移量\n    partitions := session.Claims()[\"test_topic\"]\n    for _, v := range partitions {\n    \tsession.ResetOffset(\"test_topic\", v, sarama.OffsetOldest, \"\")\n    }\n    ```\n\nResetOffset方法通常在Setup函数中调用\n\n值得注意的是，只有上述两个方式同时执行，消费者组才会从历史第一条消息进行消费。最好的方式是走离线渠道，操作kafka集群去重置对应的偏移量。\n\n### 异步消费，批量提交\n\n```go\nfunc (h *Handler[T]) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\tmsgCh := claim.Messages()\n\tfor {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*2)\n\t\tdone := false\n\t\tmsgs := make([]*sarama.ConsumerMessage, 0, 10)\n\t\tevts := make([]T, 0, 10)\n\t\tfor i := 0; i < h.batch && !done; i++ {\n\t\t\tselect {\n\t\t\tcase msg, ok := <-msgCh:\n\t\t\t\tif !ok {\n\t\t\t\t\t// msgCh被关闭\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tvar t T\n\t\t\t\terr := json.Unmarshal(msg.Value, &t)\n\t\t\t\tif err != nil {\n\t\t\t\t\th.l.Error(\"fail to unmarshal\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsgs = append(msgs, msg)\n\t\t\t\tevts = append(evts, t)\n\t\t\tcase <-ctx.Done():\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t\terr := h.fn(msgs, evts)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := range msgs {\n\t\t\tsession.MarkMessage(msgs[i], \"\")\n\t\t}\n\t}\n}\n\n```\n\n**异步消费一批，提交一批**。\n\n其中提交一批在实现过程中只需要**将最后一个消息标记**即可\n\n在`select case`中有两个分支，一个分支是ctx.Done，可以防止因长时间凑不齐一个batch的消息，而导致的阻塞现象；另一个分支调用`errgroup.Go()`方法异步处理kafka中的消息\n\n## 改造统计阅读计数\n\n**DDD中的一个重要概念：领域事件**\n\n当我们在发送消息时，需要发送的是一个**事件**，即某个用户阅读了某篇文章的事件。项目结构：\n\n![image-20241127185624318](https://raw.githubusercontent.com/lyydsheep/pic/main/202411271856428.png)\n\n### 封装批量消费\n\n前文提及`cg.consumer()`方法第三个参数是一个`ConsumeGroupHandler`接口参数，我们可以封装一个Handler结构体实现这个接口，这个结构体初始化时接受业务方的消费函数，并在`ConsumeClaim()`方法中调用下游的消费函数对消息进行处理。具体（批量消费）封装下：\n\n```go\ntype Handler[T any] struct {\n\tl     *zap.Logger\n\tfn    func(msgs []*sarama.ConsumerMessage, evts []T) error\n\tbatch int\n}\n\nfunc (h *Handler[T]) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\tmsgCh := claim.Messages()\n\tfor {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tmsgs := make([]*sarama.ConsumerMessage, 0, h.batch)\n\t\tevts := make([]T, 0, h.batch)\n\t\tdone := false\n\t\tfor i := 0; i < h.batch && !done; i++ {\n\t\t\tselect {\n\t\t\tcase msg, ok := <-msgCh:\n\t\t\t\tif !ok {\n\t\t\t\t\t// channel关闭\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tvar t T\n\t\t\t\terr := json.Unmarshal(msg.Value, &t)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// 记录日志\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsgs = append(msgs, msg)\n\t\t\t\tevts = append(evts, t)\n\t\t\tcase <-ctx.Done():\n\t\t\t\t// 超时\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t\terr := h.fn(msgs, evts)\n\t\tif err != nil {\n\t\t\t// 记录日志\n\t\t\t// 记录整个批次\n\t\t\t// 继续消费\n\t\t}\n\t\t// 标记消息\n\t\tfor i := range msgs {\n\t\t\tsession.MarkMessage(msgs[i], \"\")\n\t\t}\n\t}\n}\n```\n\n上述代码实现了对消费者批量消费的封装，可以提高系统处理消息的性能。这是因为批量处理可以将DAO层面10次（假定batch为10）事务处理缩减至在一次事务中处理十次操作。两个注意点：\n\n- 注意超时\n- 调用下游\n\n### 组装消费者\n\n在依赖注入的过程中，消费者类似于Web、GRpc服务器的东西，需要启动。因此引入一个App结构体，对Web和消费者进行组合\n\n```go\n// app.go\ntype App struct {\n    Web *gin.Engine\n    Consumers []events.Consumer\n}\n\n// ioc/kafka.go\n// 由于Go没有动态类型，因此每一个消费者都需要进行注册操作\nfunc NewConsumers(c1 *articles.InteractiveReadEventConsumer) []events.Consumer {\n    return []events.Consumer{c1}\n}\n\n// wire.go\n// 组合结构体所有的字段，*表示所有\nwire.Struct(new(App), \"*\")\n```\n\n### 批量生产\n\nsvc通过channel将消息发送给生产者，当生产者积累足够多的消息后，就将这一批消息发送给Kafka\n\n```go\nfunc NewBasicInteractService(repo repository.InteractRepository, producer events.Producer) *BasicInteractService {\n\tch := make(chan events.ReadEvent, 10)\n    // 凑足一批消息\n\tgo func() {\n\t\tfor {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tevts := make([]events.ReadEvent, 0, 10)\n\t\t\tdone := false\n\t\t\tfor i := 0; i < 10 && !done; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase evt, ok := <-ch:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tevts = append(evts, evt)\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tdone = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tcancel()\n\t\t\terr := producer.ProduceReadEventV1(ctx, evts)\n\t\t\tif err != nil {\n\t\t\t\t// 日志\n\t\t\t}\n\t\t}\n\t}()\n\treturn &BasicInteractService{repo: repo, producer: producer, ch: ch}\n}\n\n\n// 积累消息\nfunc (svc *BasicInteractService) IncReadCnt(ctx context.Context, biz string, bizId, uid int64) error {\n\t_, err := svc.Get(ctx, biz, bizId, uid)\n\tgo func() {\n\t\tif err == nil {\n\t\t\tsvc.ch <- events.ReadEvent{\n\t\t\t\tUid: uid,\n\t\t\t\tAid: bizId,\n\t\t\t}\n\t\t}\n\t}()\n\treturn err\n}\n```\n\n","source":"_posts/Kafka实践.md","raw":"# 消息队列\n\n消息队列的基本形态，就是有**N个生产者，N个消费者**\n\n生产者和消费者解耦了\n\n## 应用场景\n### 消息队列解耦\n一个模块A接收到请求后需要调用模块B，接着等待模块B完成后续工作，才进行回包。这种情况下模块A极度依赖于模块B的运行状况，耦合度较高。如果业务允许的话，模块A完全可以将调用模块B的请求信息丢进**消息中转站**中，模块B一旦发现中转站中有消息就进行工作。这个中转站就是消息队列，起着解耦合作用\n解耦的本质就是**A不用关心B的事情，以及不受B执行结果的影响**\n\n### 消息队列削峰\n在请求处理链中，各模块的处理能力通常存在较大差异。根据木桶原理，系统的 QPS（每秒查询量）往往受最弱处理模块的限制，这导致上游模块的剩余处理能力无法充分利用，进而造成性能与资源的浪费。为提升系统整体的 QPS，并最大限度发挥上游模块的高响应性能，**上游可以将处理完成的消息暂存至消息队列**。下游模块则从消息队列中逐步获取消息进行处理，通过延迟处理的方式，实现**削峰填谷**的效果，有效缓解负载不均问题。\n实际场景：1、秒杀场景 2、凌晨录入数据\n\n```sh\ncnt=1\nwhile [ $cnt -le 10 ]\ndo\n\tcurl -w \"\\n cost %{time_total}s\" -H \"Trace-ID:lyydsheep1\" -H \"Content-Type: application/json; charset=utf-8\" -H \"User-ID: 7\" http://localhost:8080/demo/peak_clipping -d '{\"num\":1}'\n\tcnt=$((cnt + 1))\ndone\n```\n\n### 消息队列分发\n一个模块A需要将消息分发至模块B、C、D\n实际场景：1、数据更新 2、数据分析/校验\n在引入消息队列之前，生产者需要了解有多少个消费者，以及消费者对于消息的格式化要求。在引入消息队列后，生产者只需要和消息队列打交道，不必关心消费者，也可以说是实现了消息群发场景下的解耦\n\n## 基本概念\n\n- 生产者 producer\n- 消费者 consumer\n- 消息服务器 broker\n- topic与partition\n- 消费者组与消费者\n\n![image-20241121143736964](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211437013.png)\n\nbroker（中间人），是一个逻辑上的概念。在实践中，可以映射为一个消息队列进程或一台机器\n\n**topic是消息队列上代表不同业务的东西**，简单来说，一个业务就是一个topic，而**一个topic可以有多个分区**\n\n![image-20241121144040306](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211440344.png)\n\n**当发送消息到Kafka上的时候，Kafka会先把消息写入主分区，再同步到从分区**。这是为了保证高可用和数据不丢失\n\n但通常说topic有多少个分区，是指有多少个主分区\n\n![image-20241121144329550](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211443600.png)\n\n正常情况下，同一个topic的分区会尽量均匀分散到所有的broker上。为了保证当某个broker奔溃后，不会造成很大的影响，需要满足下面两个条件：\n\n- **所有主分区不在同一个broker上**\n- **同一个topic的分区不都在一个broker上**\n\n如上文所述，一个topic都会有多个分区，**所以发送者在发送消息的时候，就需要选择一个目标（主）分区**\n\n比较常用的策略：\n\n- 轮询\n- 哈希\n- 随机\n\n![image-20241121150303848](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211503889.png)\n\nKafka消息隔离单位是**区**，**只有一个分区内的消息才能保证是有序的**\n\n**一个消费者组可以看作是关心这个topic的业务方**，对于一个分区，同一个消费者组只能有一个消费者出来消费\n\n- 一个消费者可以消费多个分区的数据\n- 一个分区在同一时刻，只能被一个消费者消费\n\n![image-20241121151119740](https://raw.githubusercontent.com/lyydsheep/pic/main/202411211511775.png)\n\n**消息积压问题**\n\n- **如果一个topic有N个分组，那么同一个消费者组最多有N个消费者，多余的消费者会被忽略**\n- **如果消费者性能低，那么不能通过无限增加消费者数量的方式提高消费速率**\n\n## 命令行工具\n\nsarama提供了许多命令行工具，其中consumer和producer用得比较多\n\n```go\ngo install github.com/IBM/sarama/tools/kafka-console-consumer\n\ngo install github.com/IBM/sarama/tools/kafka-console-producer\n```\n\n这些具体工具的使用方法可以参考sarama中的`ReadMe`文档\n\n## Sarama使用\n\n### 同步发送消息\n\n```go\nfunc TestSyncProducer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\t// 同步生产者必须设置\n\tcfg.Producer.Return.Successes = true\n\tclient, err := sarama.NewClient([]string{\"localhost:9094\"}, cfg)\n\trequire.NoError(t, err)\n\tproducer, err := sarama.NewSyncProducerFromClient(client)\n\trequire.NoError(t, err)\n\terr = producer.SendMessages([]*sarama.ProducerMessage{\n\t\t{\n\t\t\tTopic: \"test_topic\",\n\t\t\tValue: sarama.StringEncoder(\"message A\"),\n\t\t},\n\t\t{\n\t\t\tTopic: \"test_topic\",\n\t\t\tValue: sarama.StringEncoder(\"message B\"),\n\t\t},\n\t})\n\trequire.NoError(t, err)\n}\n\n```\n\n### 指定分区\n\n由上文可知，Kafka只能保证一个分区内的消息是有序的。倘若我们希望**同一个业务的消息一定发送到同一个分区上，保证业务内消息有序性**，可以对`sarama.Config.Producer`结构体中的`Partitioner`字段进行配置，如下图：\n\n![image-20241124201226717](https://raw.githubusercontent.com/lyydsheep/pic/main/202411242012815.png)\n\n常见的：\n\n- Random：随机一个\n- RoundRobin：轮询\n- Hash：根据Message中的key的哈希值来筛选一个\n- Manual：根据Message中的partition字段来选择\n- ConsistentCRC：一致性哈希，用的是CRC16算法\n- Custom：自定义一部分Hash参数\n\n### 异步发送消息\n\n```go\nfunc TestAsyncProducer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\tcfg.Producer.Return.Successes = true\n\tcfg.Producer.Return.Errors = true\n\tclient, err := sarama.NewClient([]string{\"localhost:9094\"}, cfg)\n\trequire.NoError(t, err)\n\tproducer, err := sarama.NewAsyncProducerFromClient(client)\n\trequire.NoError(t, err)\n\tmsgInput := producer.Input()\n\tmsgInput <- &sarama.ProducerMessage{\n\t\tTopic: \"test_topic\",\n\t\tValue: sarama.StringEncoder(\"message Hello\"),\n\t}\n\tsuCh, erCh := producer.Successes(), producer.Errors()\n\t// 实践中一般都是开一个goroutine来处理\n\tselect {\n\tcase msg := <-suCh:\n\t\tval, _ := msg.Value.Encode()\n\t\tfmt.Println(msg.Topic, string(val))\n\tcase err := <-erCh:\n\t\tfmt.Println(err.Error())\n\t}\n}\n```\n\n- 需要把`Success`和`Errors`都设置为`true`，这是为了后面能异步获取到结果\n- 通过一个**channel**异步发送消息\n- 通过`select case`，监听异步发送消息的结果\n\n### 指定acks\n\n生产者在发送数据的时候，有一个关键参数——**acks**,该参数有三个取值：\n\n![image-20241125193828822](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251938899.png)\n\n- 0：客户端发一次，仅收到TCP的ACK报文（没实质作用）\n- 1：客户端发送一次，需要**等待服务端将消息写入主分区**，能确保消息成功送达\n- -1：客户端发送一次，需要**等待服务端将消息同步至所有（可配置）的ISR上**\n\n![image-20241125194219136](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251942196.png)\n\n自上而下，性能逐渐变差，但是数据可靠性上升\n\n### ISR\n\n**ISR（In Sync Replicas），就是和主分区保持数据同步的从分区集合**\n\n![image-20241125194510901](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251945935.png)\n\n### **启动消费者**\n\n```go\nfunc TestConsumer(t *testing.T) {\n\tcfg := sarama.NewConfig()\n\t// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\n\t//cfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n\tcg, err := sarama.NewConsumerGroup([]string{\"localhost:9094\"}, \"test_id\", cfg)\n\trequire.NoError(t, err)\n\t// 定时结束\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\terr = cg.Consume(ctx, []string{\"test_topic\"}, &ConsumerHandler{})\n}\n\ntype ConsumerHandler struct {\n}\n\nfunc (c ConsumerHandler) Setup(session sarama.ConsumerGroupSession) error {\n\tfmt.Println(\"this is setup\")\n\t// 重置偏移量\n\t//partitions := session.Claims()[\"test_topic\"]\n\t//for _, v := range partitions {\n\t//\tsession.ResetOffset(\"test_topic\", v, sarama.OffsetOldest, \"\")\n\t//}\n\treturn nil\n}\n\nfunc (c ConsumerHandler) Cleanup(session sarama.ConsumerGroupSession) error {\n\tfmt.Println(\"this is cleanup\")\n\treturn nil\n}\n\nfunc (c ConsumerHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\t// 关键实现\n\tmsgCh := claim.Messages()\n\tfor msg := range msgCh {\n\t\tfmt.Println(string(msg.Value))\n\t\t// 标记消费成功，用于移动offset\n\t\t// 服务端只会提交带有标记的消息，代表该消息被成功消费\n\t\tsession.MarkMessage(msg, \"\")\n\t}\n\treturn nil\n}\n```\n\n- 初始化一个**消费者组**\n- 调用消费者组的**Consume**方法\n- 为**Consume**方法传入一个**ConsumerGroupHandler接口**\n  - 向Consume方法中传入一个带有定时器或Cancel的Context，可以控制消费者退出\n\nConsumerGroupHandler接口需要实现三个方法：\n\n- Setup\n- Cleanup\n- ConsumeClaim\n\n其中消费组对消息进行消费的逻辑在ConsumClaim方法中实现：\n\n![image-20241126130732077](https://raw.githubusercontent.com/lyydsheep/pic/main/202411261307125.png)\n\n由于Consume方法需要的是一个接口，那么我们可以基于类型定义、结构体等方式花式实现ConsumeClaim方法，以达到一些巧妙的作用\n\n### 自定偏移量消费\n\nsarama中提供了两个设置偏移量的方法：\n\n- 设置`cfg.Consumer.Offsets.Initial`字段\n\n  - ```go\n    cfg := sarama.NewConfig()\n    // 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\n    cfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n    ```\n\n- 调用`session.ResetOffset()`方法\n\n  - ```go\n    // 重置偏移量\n    partitions := session.Claims()[\"test_topic\"]\n    for _, v := range partitions {\n    \tsession.ResetOffset(\"test_topic\", v, sarama.OffsetOldest, \"\")\n    }\n    ```\n\nResetOffset方法通常在Setup函数中调用\n\n值得注意的是，只有上述两个方式同时执行，消费者组才会从历史第一条消息进行消费。最好的方式是走离线渠道，操作kafka集群去重置对应的偏移量。\n\n### 异步消费，批量提交\n\n```go\nfunc (h *Handler[T]) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\tmsgCh := claim.Messages()\n\tfor {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*2)\n\t\tdone := false\n\t\tmsgs := make([]*sarama.ConsumerMessage, 0, 10)\n\t\tevts := make([]T, 0, 10)\n\t\tfor i := 0; i < h.batch && !done; i++ {\n\t\t\tselect {\n\t\t\tcase msg, ok := <-msgCh:\n\t\t\t\tif !ok {\n\t\t\t\t\t// msgCh被关闭\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tvar t T\n\t\t\t\terr := json.Unmarshal(msg.Value, &t)\n\t\t\t\tif err != nil {\n\t\t\t\t\th.l.Error(\"fail to unmarshal\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsgs = append(msgs, msg)\n\t\t\t\tevts = append(evts, t)\n\t\t\tcase <-ctx.Done():\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t\terr := h.fn(msgs, evts)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := range msgs {\n\t\t\tsession.MarkMessage(msgs[i], \"\")\n\t\t}\n\t}\n}\n\n```\n\n**异步消费一批，提交一批**。\n\n其中提交一批在实现过程中只需要**将最后一个消息标记**即可\n\n在`select case`中有两个分支，一个分支是ctx.Done，可以防止因长时间凑不齐一个batch的消息，而导致的阻塞现象；另一个分支调用`errgroup.Go()`方法异步处理kafka中的消息\n\n## 改造统计阅读计数\n\n**DDD中的一个重要概念：领域事件**\n\n当我们在发送消息时，需要发送的是一个**事件**，即某个用户阅读了某篇文章的事件。项目结构：\n\n![image-20241127185624318](https://raw.githubusercontent.com/lyydsheep/pic/main/202411271856428.png)\n\n### 封装批量消费\n\n前文提及`cg.consumer()`方法第三个参数是一个`ConsumeGroupHandler`接口参数，我们可以封装一个Handler结构体实现这个接口，这个结构体初始化时接受业务方的消费函数，并在`ConsumeClaim()`方法中调用下游的消费函数对消息进行处理。具体（批量消费）封装下：\n\n```go\ntype Handler[T any] struct {\n\tl     *zap.Logger\n\tfn    func(msgs []*sarama.ConsumerMessage, evts []T) error\n\tbatch int\n}\n\nfunc (h *Handler[T]) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\tmsgCh := claim.Messages()\n\tfor {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tmsgs := make([]*sarama.ConsumerMessage, 0, h.batch)\n\t\tevts := make([]T, 0, h.batch)\n\t\tdone := false\n\t\tfor i := 0; i < h.batch && !done; i++ {\n\t\t\tselect {\n\t\t\tcase msg, ok := <-msgCh:\n\t\t\t\tif !ok {\n\t\t\t\t\t// channel关闭\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tvar t T\n\t\t\t\terr := json.Unmarshal(msg.Value, &t)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// 记录日志\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsgs = append(msgs, msg)\n\t\t\t\tevts = append(evts, t)\n\t\t\tcase <-ctx.Done():\n\t\t\t\t// 超时\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t\terr := h.fn(msgs, evts)\n\t\tif err != nil {\n\t\t\t// 记录日志\n\t\t\t// 记录整个批次\n\t\t\t// 继续消费\n\t\t}\n\t\t// 标记消息\n\t\tfor i := range msgs {\n\t\t\tsession.MarkMessage(msgs[i], \"\")\n\t\t}\n\t}\n}\n```\n\n上述代码实现了对消费者批量消费的封装，可以提高系统处理消息的性能。这是因为批量处理可以将DAO层面10次（假定batch为10）事务处理缩减至在一次事务中处理十次操作。两个注意点：\n\n- 注意超时\n- 调用下游\n\n### 组装消费者\n\n在依赖注入的过程中，消费者类似于Web、GRpc服务器的东西，需要启动。因此引入一个App结构体，对Web和消费者进行组合\n\n```go\n// app.go\ntype App struct {\n    Web *gin.Engine\n    Consumers []events.Consumer\n}\n\n// ioc/kafka.go\n// 由于Go没有动态类型，因此每一个消费者都需要进行注册操作\nfunc NewConsumers(c1 *articles.InteractiveReadEventConsumer) []events.Consumer {\n    return []events.Consumer{c1}\n}\n\n// wire.go\n// 组合结构体所有的字段，*表示所有\nwire.Struct(new(App), \"*\")\n```\n\n### 批量生产\n\nsvc通过channel将消息发送给生产者，当生产者积累足够多的消息后，就将这一批消息发送给Kafka\n\n```go\nfunc NewBasicInteractService(repo repository.InteractRepository, producer events.Producer) *BasicInteractService {\n\tch := make(chan events.ReadEvent, 10)\n    // 凑足一批消息\n\tgo func() {\n\t\tfor {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tevts := make([]events.ReadEvent, 0, 10)\n\t\t\tdone := false\n\t\t\tfor i := 0; i < 10 && !done; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase evt, ok := <-ch:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tevts = append(evts, evt)\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tdone = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tcancel()\n\t\t\terr := producer.ProduceReadEventV1(ctx, evts)\n\t\t\tif err != nil {\n\t\t\t\t// 日志\n\t\t\t}\n\t\t}\n\t}()\n\treturn &BasicInteractService{repo: repo, producer: producer, ch: ch}\n}\n\n\n// 积累消息\nfunc (svc *BasicInteractService) IncReadCnt(ctx context.Context, biz string, bizId, uid int64) error {\n\t_, err := svc.Get(ctx, biz, bizId, uid)\n\tgo func() {\n\t\tif err == nil {\n\t\t\tsvc.ch <- events.ReadEvent{\n\t\t\t\tUid: uid,\n\t\t\t\tAid: bizId,\n\t\t\t}\n\t\t}\n\t}()\n\treturn err\n}\n```\n\n","slug":"Kafka实践","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2025-01-04T06:32:05.125Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6f0002a5t2dxvx1v5t","content":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列的基本形态，就是有<strong>N个生产者，N个消费者</strong></p>\n<p>生产者和消费者解耦了</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"消息队列解耦\"><a href=\"#消息队列解耦\" class=\"headerlink\" title=\"消息队列解耦\"></a>消息队列解耦</h3><p>一个模块A接收到请求后需要调用模块B，接着等待模块B完成后续工作，才进行回包。这种情况下模块A极度依赖于模块B的运行状况，耦合度较高。如果业务允许的话，模块A完全可以将调用模块B的请求信息丢进<strong>消息中转站</strong>中，模块B一旦发现中转站中有消息就进行工作。这个中转站就是消息队列，起着解耦合作用<br>解耦的本质就是<strong>A不用关心B的事情，以及不受B执行结果的影响</strong></p>\n<h3 id=\"消息队列削峰\"><a href=\"#消息队列削峰\" class=\"headerlink\" title=\"消息队列削峰\"></a>消息队列削峰</h3><p>在请求处理链中，各模块的处理能力通常存在较大差异。根据木桶原理，系统的 QPS（每秒查询量）往往受最弱处理模块的限制，这导致上游模块的剩余处理能力无法充分利用，进而造成性能与资源的浪费。为提升系统整体的 QPS，并最大限度发挥上游模块的高响应性能，<strong>上游可以将处理完成的消息暂存至消息队列</strong>。下游模块则从消息队列中逐步获取消息进行处理，通过延迟处理的方式，实现<strong>削峰填谷</strong>的效果，有效缓解负载不均问题。<br>实际场景：1、秒杀场景 2、凌晨录入数据</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnt=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$cnt</span> -le 10 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tcurl -w <span class=\"string\">&quot;\\n cost %&#123;time_total&#125;s&quot;</span> -H <span class=\"string\">&quot;Trace-ID:lyydsheep1&quot;</span> -H <span class=\"string\">&quot;Content-Type: application/json; charset=utf-8&quot;</span> -H <span class=\"string\">&quot;User-ID: 7&quot;</span> http://localhost:8080/demo/peak_clipping -d <span class=\"string\">&#x27;&#123;&quot;num&quot;:1&#125;&#x27;</span></span><br><span class=\"line\">\tcnt=$((cnt + <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列分发\"><a href=\"#消息队列分发\" class=\"headerlink\" title=\"消息队列分发\"></a>消息队列分发</h3><p>一个模块A需要将消息分发至模块B、C、D<br>实际场景：1、数据更新 2、数据分析&#x2F;校验<br>在引入消息队列之前，生产者需要了解有多少个消费者，以及消费者对于消息的格式化要求。在引入消息队列后，生产者只需要和消息队列打交道，不必关心消费者，也可以说是实现了消息群发场景下的解耦</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>生产者 producer</li>\n<li>消费者 consumer</li>\n<li>消息服务器 broker</li>\n<li>topic与partition</li>\n<li>消费者组与消费者</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211437013.png\" alt=\"image-20241121143736964\"></p>\n<p>broker（中间人），是一个逻辑上的概念。在实践中，可以映射为一个消息队列进程或一台机器</p>\n<p><strong>topic是消息队列上代表不同业务的东西</strong>，简单来说，一个业务就是一个topic，而<strong>一个topic可以有多个分区</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211440344.png\" alt=\"image-20241121144040306\"></p>\n<p><strong>当发送消息到Kafka上的时候，Kafka会先把消息写入主分区，再同步到从分区</strong>。这是为了保证高可用和数据不丢失</p>\n<p>但通常说topic有多少个分区，是指有多少个主分区</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211443600.png\" alt=\"image-20241121144329550\"></p>\n<p>正常情况下，同一个topic的分区会尽量均匀分散到所有的broker上。为了保证当某个broker奔溃后，不会造成很大的影响，需要满足下面两个条件：</p>\n<ul>\n<li><strong>所有主分区不在同一个broker上</strong></li>\n<li><strong>同一个topic的分区不都在一个broker上</strong></li>\n</ul>\n<p>如上文所述，一个topic都会有多个分区，<strong>所以发送者在发送消息的时候，就需要选择一个目标（主）分区</strong></p>\n<p>比较常用的策略：</p>\n<ul>\n<li>轮询</li>\n<li>哈希</li>\n<li>随机</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211503889.png\" alt=\"image-20241121150303848\"></p>\n<p>Kafka消息隔离单位是<strong>区</strong>，<strong>只有一个分区内的消息才能保证是有序的</strong></p>\n<p><strong>一个消费者组可以看作是关心这个topic的业务方</strong>，对于一个分区，同一个消费者组只能有一个消费者出来消费</p>\n<ul>\n<li>一个消费者可以消费多个分区的数据</li>\n<li>一个分区在同一时刻，只能被一个消费者消费</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211511775.png\" alt=\"image-20241121151119740\"></p>\n<p><strong>消息积压问题</strong></p>\n<ul>\n<li><strong>如果一个topic有N个分组，那么同一个消费者组最多有N个消费者，多余的消费者会被忽略</strong></li>\n<li><strong>如果消费者性能低，那么不能通过无限增加消费者数量的方式提高消费速率</strong></li>\n</ul>\n<h2 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h2><p>sarama提供了许多命令行工具，其中consumer和producer用得比较多</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> install github.com/IBM/sarama/tools/kafka-console-consumer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> install github.com/IBM/sarama/tools/kafka-console-producer</span><br></pre></td></tr></table></figure>\n\n<p>这些具体工具的使用方法可以参考sarama中的<code>ReadMe</code>文档</p>\n<h2 id=\"Sarama使用\"><a href=\"#Sarama使用\" class=\"headerlink\" title=\"Sarama使用\"></a>Sarama使用</h2><h3 id=\"同步发送消息\"><a href=\"#同步发送消息\" class=\"headerlink\" title=\"同步发送消息\"></a>同步发送消息</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSyncProducer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\t<span class=\"comment\">// 同步生产者必须设置</span></span><br><span class=\"line\">\tcfg.Producer.Return.Successes = <span class=\"literal\">true</span></span><br><span class=\"line\">\tclient, err := sarama.NewClient([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tproducer, err := sarama.NewSyncProducerFromClient(client)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\terr = producer.SendMessages([]*sarama.ProducerMessage&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message A&quot;</span>),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message B&quot;</span>),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指定分区\"><a href=\"#指定分区\" class=\"headerlink\" title=\"指定分区\"></a>指定分区</h3><p>由上文可知，Kafka只能保证一个分区内的消息是有序的。倘若我们希望<strong>同一个业务的消息一定发送到同一个分区上，保证业务内消息有序性</strong>，可以对<code>sarama.Config.Producer</code>结构体中的<code>Partitioner</code>字段进行配置，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411242012815.png\" alt=\"image-20241124201226717\"></p>\n<p>常见的：</p>\n<ul>\n<li>Random：随机一个</li>\n<li>RoundRobin：轮询</li>\n<li>Hash：根据Message中的key的哈希值来筛选一个</li>\n<li>Manual：根据Message中的partition字段来选择</li>\n<li>ConsistentCRC：一致性哈希，用的是CRC16算法</li>\n<li>Custom：自定义一部分Hash参数</li>\n</ul>\n<h3 id=\"异步发送消息\"><a href=\"#异步发送消息\" class=\"headerlink\" title=\"异步发送消息\"></a>异步发送消息</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestAsyncProducer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\tcfg.Producer.Return.Successes = <span class=\"literal\">true</span></span><br><span class=\"line\">\tcfg.Producer.Return.Errors = <span class=\"literal\">true</span></span><br><span class=\"line\">\tclient, err := sarama.NewClient([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tproducer, err := sarama.NewAsyncProducerFromClient(client)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tmsgInput := producer.Input()</span><br><span class=\"line\">\tmsgInput &lt;- &amp;sarama.ProducerMessage&#123;</span><br><span class=\"line\">\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message Hello&quot;</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsuCh, erCh := producer.Successes(), producer.Errors()</span><br><span class=\"line\">\t<span class=\"comment\">// 实践中一般都是开一个goroutine来处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> msg := &lt;-suCh:</span><br><span class=\"line\">\t\tval, _ := msg.Value.Encode()</span><br><span class=\"line\">\t\tfmt.Println(msg.Topic, <span class=\"type\">string</span>(val))</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> err := &lt;-erCh:</span><br><span class=\"line\">\t\tfmt.Println(err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>需要把<code>Success</code>和<code>Errors</code>都设置为<code>true</code>，这是为了后面能异步获取到结果</li>\n<li>通过一个<strong>channel</strong>异步发送消息</li>\n<li>通过<code>select case</code>，监听异步发送消息的结果</li>\n</ul>\n<h3 id=\"指定acks\"><a href=\"#指定acks\" class=\"headerlink\" title=\"指定acks\"></a>指定acks</h3><p>生产者在发送数据的时候，有一个关键参数——<strong>acks</strong>,该参数有三个取值：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251938899.png\" alt=\"image-20241125193828822\"></p>\n<ul>\n<li>0：客户端发一次，仅收到TCP的ACK报文（没实质作用）</li>\n<li>1：客户端发送一次，需要<strong>等待服务端将消息写入主分区</strong>，能确保消息成功送达</li>\n<li>-1：客户端发送一次，需要<strong>等待服务端将消息同步至所有（可配置）的ISR上</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251942196.png\" alt=\"image-20241125194219136\"></p>\n<p>自上而下，性能逐渐变差，但是数据可靠性上升</p>\n<h3 id=\"ISR\"><a href=\"#ISR\" class=\"headerlink\" title=\"ISR\"></a>ISR</h3><p><strong>ISR（In Sync Replicas），就是和主分区保持数据同步的从分区集合</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251945935.png\" alt=\"image-20241125194510901\"></p>\n<h3 id=\"启动消费者\"><a href=\"#启动消费者\" class=\"headerlink\" title=\"启动消费者\"></a><strong>启动消费者</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestConsumer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">//cfg.Consumer.Offsets.Initial = sarama.OffsetOldest</span></span><br><span class=\"line\">\tcg, err := sarama.NewConsumerGroup([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, <span class=\"string\">&quot;test_id&quot;</span>, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\t<span class=\"comment\">// 定时结束</span></span><br><span class=\"line\">\tctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\">\terr = cg.Consume(ctx, []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;test_topic&quot;</span>&#125;, &amp;ConsumerHandler&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ConsumerHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> Setup(session sarama.ConsumerGroupSession) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;this is setup&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 重置偏移量</span></span><br><span class=\"line\">\t<span class=\"comment\">//partitions := session.Claims()[&quot;test_topic&quot;]</span></span><br><span class=\"line\">\t<span class=\"comment\">//for _, v := range partitions &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tsession.ResetOffset(&quot;test_topic&quot;, v, sarama.OffsetOldest, &quot;&quot;)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> Cleanup(session sarama.ConsumerGroupSession) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;this is cleanup&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关键实现</span></span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> msg := <span class=\"keyword\">range</span> msgCh &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"type\">string</span>(msg.Value))</span><br><span class=\"line\">\t\t<span class=\"comment\">// 标记消费成功，用于移动offset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 服务端只会提交带有标记的消息，代表该消息被成功消费</span></span><br><span class=\"line\">\t\tsession.MarkMessage(msg, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化一个<strong>消费者组</strong></li>\n<li>调用消费者组的<strong>Consume</strong>方法</li>\n<li>为<strong>Consume</strong>方法传入一个<strong>ConsumerGroupHandler接口</strong><ul>\n<li>向Consume方法中传入一个带有定时器或Cancel的Context，可以控制消费者退出</li>\n</ul>\n</li>\n</ul>\n<p>ConsumerGroupHandler接口需要实现三个方法：</p>\n<ul>\n<li>Setup</li>\n<li>Cleanup</li>\n<li>ConsumeClaim</li>\n</ul>\n<p>其中消费组对消息进行消费的逻辑在ConsumClaim方法中实现：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411261307125.png\" alt=\"image-20241126130732077\"></p>\n<p>由于Consume方法需要的是一个接口，那么我们可以基于类型定义、结构体等方式花式实现ConsumeClaim方法，以达到一些巧妙的作用</p>\n<h3 id=\"自定偏移量消费\"><a href=\"#自定偏移量消费\" class=\"headerlink\" title=\"自定偏移量消费\"></a>自定偏移量消费</h3><p>sarama中提供了两个设置偏移量的方法：</p>\n<ul>\n<li><p>设置<code>cfg.Consumer.Offsets.Initial</code>字段</p>\n<ul>\n<li><pre><code class=\"go\">cfg := sarama.NewConfig()\n// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\ncfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 调用`session.ResetOffset()`方法</span><br><span class=\"line\"></span><br><span class=\"line\">  - ```go</span><br><span class=\"line\">    // 重置偏移量</span><br><span class=\"line\">    partitions := session.Claims()[&quot;test_topic&quot;]</span><br><span class=\"line\">    for _, v := range partitions &#123;</span><br><span class=\"line\">    \tsession.ResetOffset(&quot;test_topic&quot;, v, sarama.OffsetOldest, &quot;&quot;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>ResetOffset方法通常在Setup函数中调用</p>\n<p>值得注意的是，只有上述两个方式同时执行，消费者组才会从历史第一条消息进行消费。最好的方式是走离线渠道，操作kafka集群去重置对应的偏移量。</p>\n<h3 id=\"异步消费，批量提交\"><a href=\"#异步消费，批量提交\" class=\"headerlink\" title=\"异步消费，批量提交\"></a>异步消费，批量提交</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handler[T])</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\tmsgs := <span class=\"built_in\">make</span>([]*sarama.ConsumerMessage, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\tevts := <span class=\"built_in\">make</span>([]T, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; h.batch &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> msg, ok := &lt;-msgCh:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// msgCh被关闭</span></span><br><span class=\"line\">\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> t T</span><br><span class=\"line\">\t\t\t\terr := json.Unmarshal(msg.Value, &amp;t)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\th.l.Error(<span class=\"string\">&quot;fail to unmarshal&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmsgs = <span class=\"built_in\">append</span>(msgs, msg)</span><br><span class=\"line\">\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, t)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\">\t\terr := h.fn(msgs, evts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tsession.MarkMessage(msgs[i], <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>异步消费一批，提交一批</strong>。</p>\n<p>其中提交一批在实现过程中只需要<strong>将最后一个消息标记</strong>即可</p>\n<p>在<code>select case</code>中有两个分支，一个分支是ctx.Done，可以防止因长时间凑不齐一个batch的消息，而导致的阻塞现象；另一个分支调用<code>errgroup.Go()</code>方法异步处理kafka中的消息</p>\n<h2 id=\"改造统计阅读计数\"><a href=\"#改造统计阅读计数\" class=\"headerlink\" title=\"改造统计阅读计数\"></a>改造统计阅读计数</h2><p><strong>DDD中的一个重要概念：领域事件</strong></p>\n<p>当我们在发送消息时，需要发送的是一个<strong>事件</strong>，即某个用户阅读了某篇文章的事件。项目结构：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411271856428.png\" alt=\"image-20241127185624318\"></p>\n<h3 id=\"封装批量消费\"><a href=\"#封装批量消费\" class=\"headerlink\" title=\"封装批量消费\"></a>封装批量消费</h3><p>前文提及<code>cg.consumer()</code>方法第三个参数是一个<code>ConsumeGroupHandler</code>接口参数，我们可以封装一个Handler结构体实现这个接口，这个结构体初始化时接受业务方的消费函数，并在<code>ConsumeClaim()</code>方法中调用下游的消费函数对消息进行处理。具体（批量消费）封装下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler[T any] <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tl     *zap.Logger</span><br><span class=\"line\">\tfn    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(msgs []*sarama.ConsumerMessage, evts []T)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\">\tbatch <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handler[T])</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\t\tmsgs := <span class=\"built_in\">make</span>([]*sarama.ConsumerMessage, <span class=\"number\">0</span>, h.batch)</span><br><span class=\"line\">\t\tevts := <span class=\"built_in\">make</span>([]T, <span class=\"number\">0</span>, h.batch)</span><br><span class=\"line\">\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; h.batch &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> msg, ok := &lt;-msgCh:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// channel关闭</span></span><br><span class=\"line\">\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> t T</span><br><span class=\"line\">\t\t\t\terr := json.Unmarshal(msg.Value, &amp;t)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmsgs = <span class=\"built_in\">append</span>(msgs, msg)</span><br><span class=\"line\">\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, t)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 超时</span></span><br><span class=\"line\">\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\">\t\terr := h.fn(msgs, evts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 记录整个批次</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 继续消费</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 标记消息</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tsession.MarkMessage(msgs[i], <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实现了对消费者批量消费的封装，可以提高系统处理消息的性能。这是因为批量处理可以将DAO层面10次（假定batch为10）事务处理缩减至在一次事务中处理十次操作。两个注意点：</p>\n<ul>\n<li>注意超时</li>\n<li>调用下游</li>\n</ul>\n<h3 id=\"组装消费者\"><a href=\"#组装消费者\" class=\"headerlink\" title=\"组装消费者\"></a>组装消费者</h3><p>在依赖注入的过程中，消费者类似于Web、GRpc服务器的东西，需要启动。因此引入一个App结构体，对Web和消费者进行组合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Web *gin.Engine</span><br><span class=\"line\">    Consumers []events.Consumer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ioc/kafka.go</span></span><br><span class=\"line\"><span class=\"comment\">// 由于Go没有动态类型，因此每一个消费者都需要进行注册操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewConsumers</span><span class=\"params\">(c1 *articles.InteractiveReadEventConsumer)</span></span> []events.Consumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []events.Consumer&#123;c1&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// wire.go</span></span><br><span class=\"line\"><span class=\"comment\">// 组合结构体所有的字段，*表示所有</span></span><br><span class=\"line\">wire.Struct(<span class=\"built_in\">new</span>(App), <span class=\"string\">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量生产\"><a href=\"#批量生产\" class=\"headerlink\" title=\"批量生产\"></a>批量生产</h3><p>svc通过channel将消息发送给生产者，当生产者积累足够多的消息后，就将这一批消息发送给Kafka</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBasicInteractService</span><span class=\"params\">(repo repository.InteractRepository, producer events.Producer)</span></span> *BasicInteractService &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> events.ReadEvent, <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 凑足一批消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\t\t\tevts := <span class=\"built_in\">make</span>([]events.ReadEvent, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> evt, ok := &lt;-ch:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, evt)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcancel()</span><br><span class=\"line\">\t\t\terr := producer.ProduceReadEventV1(ctx, evts)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 日志</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BasicInteractService&#123;repo: repo, producer: producer, ch: ch&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 积累消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(svc *BasicInteractService)</span></span> IncReadCnt(ctx context.Context, biz <span class=\"type\">string</span>, bizId, uid <span class=\"type\">int64</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t_, err := svc.Get(ctx, biz, bizId, uid)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tsvc.ch &lt;- events.ReadEvent&#123;</span><br><span class=\"line\">\t\t\t\tUid: uid,</span><br><span class=\"line\">\t\t\t\tAid: bizId,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列的基本形态，就是有<strong>N个生产者，N个消费者</strong></p>\n<p>生产者和消费者解耦了</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"消息队列解耦\"><a href=\"#消息队列解耦\" class=\"headerlink\" title=\"消息队列解耦\"></a>消息队列解耦</h3><p>一个模块A接收到请求后需要调用模块B，接着等待模块B完成后续工作，才进行回包。这种情况下模块A极度依赖于模块B的运行状况，耦合度较高。如果业务允许的话，模块A完全可以将调用模块B的请求信息丢进<strong>消息中转站</strong>中，模块B一旦发现中转站中有消息就进行工作。这个中转站就是消息队列，起着解耦合作用<br>解耦的本质就是<strong>A不用关心B的事情，以及不受B执行结果的影响</strong></p>\n<h3 id=\"消息队列削峰\"><a href=\"#消息队列削峰\" class=\"headerlink\" title=\"消息队列削峰\"></a>消息队列削峰</h3><p>在请求处理链中，各模块的处理能力通常存在较大差异。根据木桶原理，系统的 QPS（每秒查询量）往往受最弱处理模块的限制，这导致上游模块的剩余处理能力无法充分利用，进而造成性能与资源的浪费。为提升系统整体的 QPS，并最大限度发挥上游模块的高响应性能，<strong>上游可以将处理完成的消息暂存至消息队列</strong>。下游模块则从消息队列中逐步获取消息进行处理，通过延迟处理的方式，实现<strong>削峰填谷</strong>的效果，有效缓解负载不均问题。<br>实际场景：1、秒杀场景 2、凌晨录入数据</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnt=1</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ <span class=\"variable\">$cnt</span> -le 10 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">\tcurl -w <span class=\"string\">&quot;\\n cost %&#123;time_total&#125;s&quot;</span> -H <span class=\"string\">&quot;Trace-ID:lyydsheep1&quot;</span> -H <span class=\"string\">&quot;Content-Type: application/json; charset=utf-8&quot;</span> -H <span class=\"string\">&quot;User-ID: 7&quot;</span> http://localhost:8080/demo/peak_clipping -d <span class=\"string\">&#x27;&#123;&quot;num&quot;:1&#125;&#x27;</span></span><br><span class=\"line\">\tcnt=$((cnt + <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列分发\"><a href=\"#消息队列分发\" class=\"headerlink\" title=\"消息队列分发\"></a>消息队列分发</h3><p>一个模块A需要将消息分发至模块B、C、D<br>实际场景：1、数据更新 2、数据分析&#x2F;校验<br>在引入消息队列之前，生产者需要了解有多少个消费者，以及消费者对于消息的格式化要求。在引入消息队列后，生产者只需要和消息队列打交道，不必关心消费者，也可以说是实现了消息群发场景下的解耦</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>生产者 producer</li>\n<li>消费者 consumer</li>\n<li>消息服务器 broker</li>\n<li>topic与partition</li>\n<li>消费者组与消费者</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211437013.png\" alt=\"image-20241121143736964\"></p>\n<p>broker（中间人），是一个逻辑上的概念。在实践中，可以映射为一个消息队列进程或一台机器</p>\n<p><strong>topic是消息队列上代表不同业务的东西</strong>，简单来说，一个业务就是一个topic，而<strong>一个topic可以有多个分区</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211440344.png\" alt=\"image-20241121144040306\"></p>\n<p><strong>当发送消息到Kafka上的时候，Kafka会先把消息写入主分区，再同步到从分区</strong>。这是为了保证高可用和数据不丢失</p>\n<p>但通常说topic有多少个分区，是指有多少个主分区</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211443600.png\" alt=\"image-20241121144329550\"></p>\n<p>正常情况下，同一个topic的分区会尽量均匀分散到所有的broker上。为了保证当某个broker奔溃后，不会造成很大的影响，需要满足下面两个条件：</p>\n<ul>\n<li><strong>所有主分区不在同一个broker上</strong></li>\n<li><strong>同一个topic的分区不都在一个broker上</strong></li>\n</ul>\n<p>如上文所述，一个topic都会有多个分区，<strong>所以发送者在发送消息的时候，就需要选择一个目标（主）分区</strong></p>\n<p>比较常用的策略：</p>\n<ul>\n<li>轮询</li>\n<li>哈希</li>\n<li>随机</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211503889.png\" alt=\"image-20241121150303848\"></p>\n<p>Kafka消息隔离单位是<strong>区</strong>，<strong>只有一个分区内的消息才能保证是有序的</strong></p>\n<p><strong>一个消费者组可以看作是关心这个topic的业务方</strong>，对于一个分区，同一个消费者组只能有一个消费者出来消费</p>\n<ul>\n<li>一个消费者可以消费多个分区的数据</li>\n<li>一个分区在同一时刻，只能被一个消费者消费</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411211511775.png\" alt=\"image-20241121151119740\"></p>\n<p><strong>消息积压问题</strong></p>\n<ul>\n<li><strong>如果一个topic有N个分组，那么同一个消费者组最多有N个消费者，多余的消费者会被忽略</strong></li>\n<li><strong>如果消费者性能低，那么不能通过无限增加消费者数量的方式提高消费速率</strong></li>\n</ul>\n<h2 id=\"命令行工具\"><a href=\"#命令行工具\" class=\"headerlink\" title=\"命令行工具\"></a>命令行工具</h2><p>sarama提供了许多命令行工具，其中consumer和producer用得比较多</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> install github.com/IBM/sarama/tools/kafka-console-consumer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> install github.com/IBM/sarama/tools/kafka-console-producer</span><br></pre></td></tr></table></figure>\n\n<p>这些具体工具的使用方法可以参考sarama中的<code>ReadMe</code>文档</p>\n<h2 id=\"Sarama使用\"><a href=\"#Sarama使用\" class=\"headerlink\" title=\"Sarama使用\"></a>Sarama使用</h2><h3 id=\"同步发送消息\"><a href=\"#同步发送消息\" class=\"headerlink\" title=\"同步发送消息\"></a>同步发送消息</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSyncProducer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\t<span class=\"comment\">// 同步生产者必须设置</span></span><br><span class=\"line\">\tcfg.Producer.Return.Successes = <span class=\"literal\">true</span></span><br><span class=\"line\">\tclient, err := sarama.NewClient([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tproducer, err := sarama.NewSyncProducerFromClient(client)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\terr = producer.SendMessages([]*sarama.ProducerMessage&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message A&quot;</span>),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message B&quot;</span>),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指定分区\"><a href=\"#指定分区\" class=\"headerlink\" title=\"指定分区\"></a>指定分区</h3><p>由上文可知，Kafka只能保证一个分区内的消息是有序的。倘若我们希望<strong>同一个业务的消息一定发送到同一个分区上，保证业务内消息有序性</strong>，可以对<code>sarama.Config.Producer</code>结构体中的<code>Partitioner</code>字段进行配置，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411242012815.png\" alt=\"image-20241124201226717\"></p>\n<p>常见的：</p>\n<ul>\n<li>Random：随机一个</li>\n<li>RoundRobin：轮询</li>\n<li>Hash：根据Message中的key的哈希值来筛选一个</li>\n<li>Manual：根据Message中的partition字段来选择</li>\n<li>ConsistentCRC：一致性哈希，用的是CRC16算法</li>\n<li>Custom：自定义一部分Hash参数</li>\n</ul>\n<h3 id=\"异步发送消息\"><a href=\"#异步发送消息\" class=\"headerlink\" title=\"异步发送消息\"></a>异步发送消息</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestAsyncProducer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\tcfg.Producer.Return.Successes = <span class=\"literal\">true</span></span><br><span class=\"line\">\tcfg.Producer.Return.Errors = <span class=\"literal\">true</span></span><br><span class=\"line\">\tclient, err := sarama.NewClient([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tproducer, err := sarama.NewAsyncProducerFromClient(client)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\tmsgInput := producer.Input()</span><br><span class=\"line\">\tmsgInput &lt;- &amp;sarama.ProducerMessage&#123;</span><br><span class=\"line\">\t\tTopic: <span class=\"string\">&quot;test_topic&quot;</span>,</span><br><span class=\"line\">\t\tValue: sarama.StringEncoder(<span class=\"string\">&quot;message Hello&quot;</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsuCh, erCh := producer.Successes(), producer.Errors()</span><br><span class=\"line\">\t<span class=\"comment\">// 实践中一般都是开一个goroutine来处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> msg := &lt;-suCh:</span><br><span class=\"line\">\t\tval, _ := msg.Value.Encode()</span><br><span class=\"line\">\t\tfmt.Println(msg.Topic, <span class=\"type\">string</span>(val))</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> err := &lt;-erCh:</span><br><span class=\"line\">\t\tfmt.Println(err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>需要把<code>Success</code>和<code>Errors</code>都设置为<code>true</code>，这是为了后面能异步获取到结果</li>\n<li>通过一个<strong>channel</strong>异步发送消息</li>\n<li>通过<code>select case</code>，监听异步发送消息的结果</li>\n</ul>\n<h3 id=\"指定acks\"><a href=\"#指定acks\" class=\"headerlink\" title=\"指定acks\"></a>指定acks</h3><p>生产者在发送数据的时候，有一个关键参数——<strong>acks</strong>,该参数有三个取值：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251938899.png\" alt=\"image-20241125193828822\"></p>\n<ul>\n<li>0：客户端发一次，仅收到TCP的ACK报文（没实质作用）</li>\n<li>1：客户端发送一次，需要<strong>等待服务端将消息写入主分区</strong>，能确保消息成功送达</li>\n<li>-1：客户端发送一次，需要<strong>等待服务端将消息同步至所有（可配置）的ISR上</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251942196.png\" alt=\"image-20241125194219136\"></p>\n<p>自上而下，性能逐渐变差，但是数据可靠性上升</p>\n<h3 id=\"ISR\"><a href=\"#ISR\" class=\"headerlink\" title=\"ISR\"></a>ISR</h3><p><strong>ISR（In Sync Replicas），就是和主分区保持数据同步的从分区集合</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251945935.png\" alt=\"image-20241125194510901\"></p>\n<h3 id=\"启动消费者\"><a href=\"#启动消费者\" class=\"headerlink\" title=\"启动消费者\"></a><strong>启动消费者</strong></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestConsumer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tcfg := sarama.NewConfig()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">//cfg.Consumer.Offsets.Initial = sarama.OffsetOldest</span></span><br><span class=\"line\">\tcg, err := sarama.NewConsumerGroup([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;localhost:9094&quot;</span>&#125;, <span class=\"string\">&quot;test_id&quot;</span>, cfg)</span><br><span class=\"line\">\trequire.NoError(t, err)</span><br><span class=\"line\">\t<span class=\"comment\">// 定时结束</span></span><br><span class=\"line\">\tctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\">\terr = cg.Consume(ctx, []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;test_topic&quot;</span>&#125;, &amp;ConsumerHandler&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ConsumerHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> Setup(session sarama.ConsumerGroupSession) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;this is setup&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 重置偏移量</span></span><br><span class=\"line\">\t<span class=\"comment\">//partitions := session.Claims()[&quot;test_topic&quot;]</span></span><br><span class=\"line\">\t<span class=\"comment\">//for _, v := range partitions &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tsession.ResetOffset(&quot;test_topic&quot;, v, sarama.OffsetOldest, &quot;&quot;)</span></span><br><span class=\"line\">\t<span class=\"comment\">//&#125;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> Cleanup(session sarama.ConsumerGroupSession) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;this is cleanup&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c ConsumerHandler)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关键实现</span></span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> msg := <span class=\"keyword\">range</span> msgCh &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"type\">string</span>(msg.Value))</span><br><span class=\"line\">\t\t<span class=\"comment\">// 标记消费成功，用于移动offset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 服务端只会提交带有标记的消息，代表该消息被成功消费</span></span><br><span class=\"line\">\t\tsession.MarkMessage(msg, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化一个<strong>消费者组</strong></li>\n<li>调用消费者组的<strong>Consume</strong>方法</li>\n<li>为<strong>Consume</strong>方法传入一个<strong>ConsumerGroupHandler接口</strong><ul>\n<li>向Consume方法中传入一个带有定时器或Cancel的Context，可以控制消费者退出</li>\n</ul>\n</li>\n</ul>\n<p>ConsumerGroupHandler接口需要实现三个方法：</p>\n<ul>\n<li>Setup</li>\n<li>Cleanup</li>\n<li>ConsumeClaim</li>\n</ul>\n<p>其中消费组对消息进行消费的逻辑在ConsumClaim方法中实现：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411261307125.png\" alt=\"image-20241126130732077\"></p>\n<p>由于Consume方法需要的是一个接口，那么我们可以基于类型定义、结构体等方式花式实现ConsumeClaim方法，以达到一些巧妙的作用</p>\n<h3 id=\"自定偏移量消费\"><a href=\"#自定偏移量消费\" class=\"headerlink\" title=\"自定偏移量消费\"></a>自定偏移量消费</h3><p>sarama中提供了两个设置偏移量的方法：</p>\n<ul>\n<li><p>设置<code>cfg.Consumer.Offsets.Initial</code>字段</p>\n<ul>\n<li><pre><code class=\"go\">cfg := sarama.NewConfig()\n// 设置初始消费偏移量，如果没有已提交的offset数据，则默认是下一个消息的位置\ncfg.Consumer.Offsets.Initial = sarama.OffsetOldest\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 调用`session.ResetOffset()`方法</span><br><span class=\"line\"></span><br><span class=\"line\">  - ```go</span><br><span class=\"line\">    // 重置偏移量</span><br><span class=\"line\">    partitions := session.Claims()[&quot;test_topic&quot;]</span><br><span class=\"line\">    for _, v := range partitions &#123;</span><br><span class=\"line\">    \tsession.ResetOffset(&quot;test_topic&quot;, v, sarama.OffsetOldest, &quot;&quot;)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>ResetOffset方法通常在Setup函数中调用</p>\n<p>值得注意的是，只有上述两个方式同时执行，消费者组才会从历史第一条消息进行消费。最好的方式是走离线渠道，操作kafka集群去重置对应的偏移量。</p>\n<h3 id=\"异步消费，批量提交\"><a href=\"#异步消费，批量提交\" class=\"headerlink\" title=\"异步消费，批量提交\"></a>异步消费，批量提交</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handler[T])</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\tmsgs := <span class=\"built_in\">make</span>([]*sarama.ConsumerMessage, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\tevts := <span class=\"built_in\">make</span>([]T, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; h.batch &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> msg, ok := &lt;-msgCh:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// msgCh被关闭</span></span><br><span class=\"line\">\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> t T</span><br><span class=\"line\">\t\t\t\terr := json.Unmarshal(msg.Value, &amp;t)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\th.l.Error(<span class=\"string\">&quot;fail to unmarshal&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmsgs = <span class=\"built_in\">append</span>(msgs, msg)</span><br><span class=\"line\">\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, t)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\">\t\terr := h.fn(msgs, evts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tsession.MarkMessage(msgs[i], <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>异步消费一批，提交一批</strong>。</p>\n<p>其中提交一批在实现过程中只需要<strong>将最后一个消息标记</strong>即可</p>\n<p>在<code>select case</code>中有两个分支，一个分支是ctx.Done，可以防止因长时间凑不齐一个batch的消息，而导致的阻塞现象；另一个分支调用<code>errgroup.Go()</code>方法异步处理kafka中的消息</p>\n<h2 id=\"改造统计阅读计数\"><a href=\"#改造统计阅读计数\" class=\"headerlink\" title=\"改造统计阅读计数\"></a>改造统计阅读计数</h2><p><strong>DDD中的一个重要概念：领域事件</strong></p>\n<p>当我们在发送消息时，需要发送的是一个<strong>事件</strong>，即某个用户阅读了某篇文章的事件。项目结构：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411271856428.png\" alt=\"image-20241127185624318\"></p>\n<h3 id=\"封装批量消费\"><a href=\"#封装批量消费\" class=\"headerlink\" title=\"封装批量消费\"></a>封装批量消费</h3><p>前文提及<code>cg.consumer()</code>方法第三个参数是一个<code>ConsumeGroupHandler</code>接口参数，我们可以封装一个Handler结构体实现这个接口，这个结构体初始化时接受业务方的消费函数，并在<code>ConsumeClaim()</code>方法中调用下游的消费函数对消息进行处理。具体（批量消费）封装下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler[T any] <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tl     *zap.Logger</span><br><span class=\"line\">\tfn    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(msgs []*sarama.ConsumerMessage, evts []T)</span></span> <span class=\"type\">error</span></span><br><span class=\"line\">\tbatch <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handler[T])</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tmsgCh := claim.Messages()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\t\tmsgs := <span class=\"built_in\">make</span>([]*sarama.ConsumerMessage, <span class=\"number\">0</span>, h.batch)</span><br><span class=\"line\">\t\tevts := <span class=\"built_in\">make</span>([]T, <span class=\"number\">0</span>, h.batch)</span><br><span class=\"line\">\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; h.batch &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> msg, ok := &lt;-msgCh:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// channel关闭</span></span><br><span class=\"line\">\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> t T</span><br><span class=\"line\">\t\t\t\terr := json.Unmarshal(msg.Value, &amp;t)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmsgs = <span class=\"built_in\">append</span>(msgs, msg)</span><br><span class=\"line\">\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, t)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 超时</span></span><br><span class=\"line\">\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\">\t\terr := h.fn(msgs, evts)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 记录整个批次</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 继续消费</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 标记消息</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> msgs &#123;</span><br><span class=\"line\">\t\t\tsession.MarkMessage(msgs[i], <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实现了对消费者批量消费的封装，可以提高系统处理消息的性能。这是因为批量处理可以将DAO层面10次（假定batch为10）事务处理缩减至在一次事务中处理十次操作。两个注意点：</p>\n<ul>\n<li>注意超时</li>\n<li>调用下游</li>\n</ul>\n<h3 id=\"组装消费者\"><a href=\"#组装消费者\" class=\"headerlink\" title=\"组装消费者\"></a>组装消费者</h3><p>在依赖注入的过程中，消费者类似于Web、GRpc服务器的东西，需要启动。因此引入一个App结构体，对Web和消费者进行组合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Web *gin.Engine</span><br><span class=\"line\">    Consumers []events.Consumer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ioc/kafka.go</span></span><br><span class=\"line\"><span class=\"comment\">// 由于Go没有动态类型，因此每一个消费者都需要进行注册操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewConsumers</span><span class=\"params\">(c1 *articles.InteractiveReadEventConsumer)</span></span> []events.Consumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []events.Consumer&#123;c1&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// wire.go</span></span><br><span class=\"line\"><span class=\"comment\">// 组合结构体所有的字段，*表示所有</span></span><br><span class=\"line\">wire.Struct(<span class=\"built_in\">new</span>(App), <span class=\"string\">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"批量生产\"><a href=\"#批量生产\" class=\"headerlink\" title=\"批量生产\"></a>批量生产</h3><p>svc通过channel将消息发送给生产者，当生产者积累足够多的消息后，就将这一批消息发送给Kafka</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBasicInteractService</span><span class=\"params\">(repo repository.InteractRepository, producer events.Producer)</span></span> *BasicInteractService &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> events.ReadEvent, <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 凑足一批消息</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\t\t\tevts := <span class=\"built_in\">make</span>([]events.ReadEvent, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\tdone := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> &amp;&amp; !done; i++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> evt, ok := &lt;-ch:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\tcancel()</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tevts = <span class=\"built_in\">append</span>(evts, evt)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcancel()</span><br><span class=\"line\">\t\t\terr := producer.ProduceReadEventV1(ctx, evts)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 日志</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BasicInteractService&#123;repo: repo, producer: producer, ch: ch&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 积累消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(svc *BasicInteractService)</span></span> IncReadCnt(ctx context.Context, biz <span class=\"type\">string</span>, bizId, uid <span class=\"type\">int64</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t_, err := svc.Get(ctx, biz, bizId, uid)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tsvc.ch &lt;- events.ReadEvent&#123;</span><br><span class=\"line\">\t\t\t\tUid: uid,</span><br><span class=\"line\">\t\t\t\tAid: bizId,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"publish":false,"_content":"\n\n\n# sync、context\n\n## Sync\n\n### sync.WaitGroup\n\n在Go语言中可以使用`sync.WaitGroup`实现并发任务的同步以及协程等待\n\n`sync.WaitGroup`是一个结构体，内置了一个计数器，有三个方法\n\n- Add(delta int)，计数器增加`delta`\n- Done()，计数器`-1`\n- Wait()，**阻塞当前协程的运行，直至计数器为0**\n\n🌰：\n\n```go\nvar wg sync.WaitGroup\n\nfunc main() {\n\twg.Add(10)\n\tfor range 10 {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Println(\"hello world\")\n\t\t}()\n\t}\n\twg.Wait()\n\tfmt.Println(\"end!\")\n}\n```\n\n⚠️：`sync.WaitGroup`对象的计数器不能为负数，当调用Done()方法后，必须确保计数器值大于等于零，否则会`panic`\n\n### sync.Once\n\n程序中有一些逻辑只需要执行一次，最典型的就是项目中的配置文件，通常的做法有两种，一是在项目启动时就将代码执行并将结果保存在内存中，二是需要使用时再执行相应的逻辑代码，而`sync.Once`就属于后者\n\n`sync.Once`可以在代码的任意位置初始化和调用，并且线程安全。`sync.Once`最大的用处就是**延迟初始化（调用）并只初始化一次**，避免过早执行代码逻辑导致内存空间的浪费\n\n🌰：\n\n```go\nvar once sync.Once\nvar instance *Config\nvar i = 0\n\ntype Config struct{}\n\nfunc Init() {\n\tonce.Do(func() {\n\t\tinstance = &Config{}\n\t\tfmt.Println(i)\n\t\ti++\n\t})\n}\n\nfunc main() {\n\tfor range 10 {\n\t\tInit()\n\t}\n}\n```\n\n由例子可知，被`once.Do()`包裹的函数只会执行一次，即使调用多次`Init()`函数\n\n#### 与init()的区别\n\n`init()`方法和`sync.Once`都可以用来进行一些初始化操作，**二者的区别主要在于被调用（初始化）的时机**\n\n`init()`方法是在其所在的package被首次加载时执行的，可以确保在`main`函数之前执行，适用于程序启动时的初始化操作\n\n`sync.Once`可以在代码的任意位置调用，适用于在**并发环境下确保某个逻辑只执行一次**\n\n### sync.Map\n\nGo内置的Map不是并发安全的，在多个goroutine操作情况下，会出现意想不到的结果。想要并发安全地使用Map结构，要么是进行加锁操作，要么就是使用`sync.Map`结构\n\n`sync.Map`有如下常用方法\n\n- `Load()`：写入一个键值对\n- `Store()`：读取一个键值对\n- `Range()`：遍历map，类似于JS中的`for each`\n- `Delete()`：删除操作\n- `LoadOrStore()`：读取或存储数据\n\n🌰：\n\n```go\nfunc main() {\n\tvar m sync.Map\n\tm.Store(\"name\", \"zhao\")\n\tm.Store(\"hello\", \"world\")\n\n\tv, ok := m.Load(\"hello\")\n\tif ok {\n\t\tfmt.Println(v)\n\t}\n\n\tm.Range(func(key, value any) bool {\n\t\tfmt.Printf(\"key is %v\tval is %v\\n\", key, value)\n\t\treturn true\n\t})\n\n\tv, ok = m.LoadOrStore(\"name\", \"yun\")\n\tif ok {\n\t\tfmt.Printf(\"name`s new val is %v\\n\", v)\n\t}\n\n\tm.Delete(\"name\")\n\tv, ok = m.Load(\"name\")\n\tif ok {\n\t\tfmt.Printf(\"name`s val is %v\\n\", v)\n\t}\n}\n\n```\n\n## Context\n\n用于并发控制\n\n上下文的信息传递\n","source":"_posts/Sync.md","raw":"---\npublish: false\n---\n\n\n\n# sync、context\n\n## Sync\n\n### sync.WaitGroup\n\n在Go语言中可以使用`sync.WaitGroup`实现并发任务的同步以及协程等待\n\n`sync.WaitGroup`是一个结构体，内置了一个计数器，有三个方法\n\n- Add(delta int)，计数器增加`delta`\n- Done()，计数器`-1`\n- Wait()，**阻塞当前协程的运行，直至计数器为0**\n\n🌰：\n\n```go\nvar wg sync.WaitGroup\n\nfunc main() {\n\twg.Add(10)\n\tfor range 10 {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Println(\"hello world\")\n\t\t}()\n\t}\n\twg.Wait()\n\tfmt.Println(\"end!\")\n}\n```\n\n⚠️：`sync.WaitGroup`对象的计数器不能为负数，当调用Done()方法后，必须确保计数器值大于等于零，否则会`panic`\n\n### sync.Once\n\n程序中有一些逻辑只需要执行一次，最典型的就是项目中的配置文件，通常的做法有两种，一是在项目启动时就将代码执行并将结果保存在内存中，二是需要使用时再执行相应的逻辑代码，而`sync.Once`就属于后者\n\n`sync.Once`可以在代码的任意位置初始化和调用，并且线程安全。`sync.Once`最大的用处就是**延迟初始化（调用）并只初始化一次**，避免过早执行代码逻辑导致内存空间的浪费\n\n🌰：\n\n```go\nvar once sync.Once\nvar instance *Config\nvar i = 0\n\ntype Config struct{}\n\nfunc Init() {\n\tonce.Do(func() {\n\t\tinstance = &Config{}\n\t\tfmt.Println(i)\n\t\ti++\n\t})\n}\n\nfunc main() {\n\tfor range 10 {\n\t\tInit()\n\t}\n}\n```\n\n由例子可知，被`once.Do()`包裹的函数只会执行一次，即使调用多次`Init()`函数\n\n#### 与init()的区别\n\n`init()`方法和`sync.Once`都可以用来进行一些初始化操作，**二者的区别主要在于被调用（初始化）的时机**\n\n`init()`方法是在其所在的package被首次加载时执行的，可以确保在`main`函数之前执行，适用于程序启动时的初始化操作\n\n`sync.Once`可以在代码的任意位置调用，适用于在**并发环境下确保某个逻辑只执行一次**\n\n### sync.Map\n\nGo内置的Map不是并发安全的，在多个goroutine操作情况下，会出现意想不到的结果。想要并发安全地使用Map结构，要么是进行加锁操作，要么就是使用`sync.Map`结构\n\n`sync.Map`有如下常用方法\n\n- `Load()`：写入一个键值对\n- `Store()`：读取一个键值对\n- `Range()`：遍历map，类似于JS中的`for each`\n- `Delete()`：删除操作\n- `LoadOrStore()`：读取或存储数据\n\n🌰：\n\n```go\nfunc main() {\n\tvar m sync.Map\n\tm.Store(\"name\", \"zhao\")\n\tm.Store(\"hello\", \"world\")\n\n\tv, ok := m.Load(\"hello\")\n\tif ok {\n\t\tfmt.Println(v)\n\t}\n\n\tm.Range(func(key, value any) bool {\n\t\tfmt.Printf(\"key is %v\tval is %v\\n\", key, value)\n\t\treturn true\n\t})\n\n\tv, ok = m.LoadOrStore(\"name\", \"yun\")\n\tif ok {\n\t\tfmt.Printf(\"name`s new val is %v\\n\", v)\n\t}\n\n\tm.Delete(\"name\")\n\tv, ok = m.Load(\"name\")\n\tif ok {\n\t\tfmt.Printf(\"name`s val is %v\\n\", v)\n\t}\n}\n\n```\n\n## Context\n\n用于并发控制\n\n上下文的信息传递\n","slug":"Sync","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6g0004a5t21kkh6c8z","content":"<h1 id=\"sync、context\"><a href=\"#sync、context\" class=\"headerlink\" title=\"sync、context\"></a>sync、context</h1><h2 id=\"Sync\"><a href=\"#Sync\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><h3 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h3><p>在Go语言中可以使用<code>sync.WaitGroup</code>实现并发任务的同步以及协程等待</p>\n<p><code>sync.WaitGroup</code>是一个结构体，内置了一个计数器，有三个方法</p>\n<ul>\n<li>Add(delta int)，计数器增加<code>delta</code></li>\n<li>Done()，计数器<code>-1</code></li>\n<li>Wait()，<strong>阻塞当前协程的运行，直至计数器为0</strong></li>\n</ul>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> <span class=\"number\">10</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;hello world&quot;</span>)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;end!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：<code>sync.WaitGroup</code>对象的计数器不能为负数，当调用Done()方法后，必须确保计数器值大于等于零，否则会<code>panic</code></p>\n<h3 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h3><p>程序中有一些逻辑只需要执行一次，最典型的就是项目中的配置文件，通常的做法有两种，一是在项目启动时就将代码执行并将结果保存在内存中，二是需要使用时再执行相应的逻辑代码，而<code>sync.Once</code>就属于后者</p>\n<p><code>sync.Once</code>可以在代码的任意位置初始化和调用，并且线程安全。<code>sync.Once</code>最大的用处就是<strong>延迟初始化（调用）并只初始化一次</strong>，避免过早执行代码逻辑导致内存空间的浪费</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance *Config</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tonce.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tinstance = &amp;Config&#123;&#125;</span><br><span class=\"line\">\t\tfmt.Println(i)</span><br><span class=\"line\">\t\ti++</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> <span class=\"number\">10</span> &#123;</span><br><span class=\"line\">\t\tInit()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由例子可知，被<code>once.Do()</code>包裹的函数只会执行一次，即使调用多次<code>Init()</code>函数</p>\n<h4 id=\"与init-的区别\"><a href=\"#与init-的区别\" class=\"headerlink\" title=\"与init()的区别\"></a>与init()的区别</h4><p><code>init()</code>方法和<code>sync.Once</code>都可以用来进行一些初始化操作，<strong>二者的区别主要在于被调用（初始化）的时机</strong></p>\n<p><code>init()</code>方法是在其所在的package被首次加载时执行的，可以确保在<code>main</code>函数之前执行，适用于程序启动时的初始化操作</p>\n<p><code>sync.Once</code>可以在代码的任意位置调用，适用于在<strong>并发环境下确保某个逻辑只执行一次</strong></p>\n<h3 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h3><p>Go内置的Map不是并发安全的，在多个goroutine操作情况下，会出现意想不到的结果。想要并发安全地使用Map结构，要么是进行加锁操作，要么就是使用<code>sync.Map</code>结构</p>\n<p><code>sync.Map</code>有如下常用方法</p>\n<ul>\n<li><code>Load()</code>：写入一个键值对</li>\n<li><code>Store()</code>：读取一个键值对</li>\n<li><code>Range()</code>：遍历map，类似于JS中的<code>for each</code></li>\n<li><code>Delete()</code>：删除操作</li>\n<li><code>LoadOrStore()</code>：读取或存储数据</li>\n</ul>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m sync.Map</span><br><span class=\"line\">\tm.Store(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;zhao&quot;</span>)</span><br><span class=\"line\">\tm.Store(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok := m.Load(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tm.Range(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key, value any)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;key is %v\tval is %v\\n&quot;</span>, key, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok = m.LoadOrStore(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;yun&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;name`s new val is %v\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tm.Delete(<span class=\"string\">&quot;name&quot;</span>)</span><br><span class=\"line\">\tv, ok = m.Load(<span class=\"string\">&quot;name&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;name`s val is %v\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h2><p>用于并发控制</p>\n<p>上下文的信息传递</p>\n","excerpt":"","more":"<h1 id=\"sync、context\"><a href=\"#sync、context\" class=\"headerlink\" title=\"sync、context\"></a>sync、context</h1><h2 id=\"Sync\"><a href=\"#Sync\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><h3 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h3><p>在Go语言中可以使用<code>sync.WaitGroup</code>实现并发任务的同步以及协程等待</p>\n<p><code>sync.WaitGroup</code>是一个结构体，内置了一个计数器，有三个方法</p>\n<ul>\n<li>Add(delta int)，计数器增加<code>delta</code></li>\n<li>Done()，计数器<code>-1</code></li>\n<li>Wait()，<strong>阻塞当前协程的运行，直至计数器为0</strong></li>\n</ul>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> <span class=\"number\">10</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;hello world&quot;</span>)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;end!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：<code>sync.WaitGroup</code>对象的计数器不能为负数，当调用Done()方法后，必须确保计数器值大于等于零，否则会<code>panic</code></p>\n<h3 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h3><p>程序中有一些逻辑只需要执行一次，最典型的就是项目中的配置文件，通常的做法有两种，一是在项目启动时就将代码执行并将结果保存在内存中，二是需要使用时再执行相应的逻辑代码，而<code>sync.Once</code>就属于后者</p>\n<p><code>sync.Once</code>可以在代码的任意位置初始化和调用，并且线程安全。<code>sync.Once</code>最大的用处就是<strong>延迟初始化（调用）并只初始化一次</strong>，避免过早执行代码逻辑导致内存空间的浪费</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance *Config</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tonce.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tinstance = &amp;Config&#123;&#125;</span><br><span class=\"line\">\t\tfmt.Println(i)</span><br><span class=\"line\">\t\ti++</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> <span class=\"number\">10</span> &#123;</span><br><span class=\"line\">\t\tInit()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由例子可知，被<code>once.Do()</code>包裹的函数只会执行一次，即使调用多次<code>Init()</code>函数</p>\n<h4 id=\"与init-的区别\"><a href=\"#与init-的区别\" class=\"headerlink\" title=\"与init()的区别\"></a>与init()的区别</h4><p><code>init()</code>方法和<code>sync.Once</code>都可以用来进行一些初始化操作，<strong>二者的区别主要在于被调用（初始化）的时机</strong></p>\n<p><code>init()</code>方法是在其所在的package被首次加载时执行的，可以确保在<code>main</code>函数之前执行，适用于程序启动时的初始化操作</p>\n<p><code>sync.Once</code>可以在代码的任意位置调用，适用于在<strong>并发环境下确保某个逻辑只执行一次</strong></p>\n<h3 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h3><p>Go内置的Map不是并发安全的，在多个goroutine操作情况下，会出现意想不到的结果。想要并发安全地使用Map结构，要么是进行加锁操作，要么就是使用<code>sync.Map</code>结构</p>\n<p><code>sync.Map</code>有如下常用方法</p>\n<ul>\n<li><code>Load()</code>：写入一个键值对</li>\n<li><code>Store()</code>：读取一个键值对</li>\n<li><code>Range()</code>：遍历map，类似于JS中的<code>for each</code></li>\n<li><code>Delete()</code>：删除操作</li>\n<li><code>LoadOrStore()</code>：读取或存储数据</li>\n</ul>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m sync.Map</span><br><span class=\"line\">\tm.Store(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;zhao&quot;</span>)</span><br><span class=\"line\">\tm.Store(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok := m.Load(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Println(v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tm.Range(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key, value any)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;key is %v\tval is %v\\n&quot;</span>, key, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok = m.LoadOrStore(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;yun&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;name`s new val is %v\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tm.Delete(<span class=\"string\">&quot;name&quot;</span>)</span><br><span class=\"line\">\tv, ok = m.Load(<span class=\"string\">&quot;name&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;name`s val is %v\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h2><p>用于并发控制</p>\n<p>上下文的信息传递</p>\n"},{"_content":"## 整体架构\n宏观上可以将Kafka分成三个部分：生产者、中间服务层、消费者\n中间服务层相当于一个“消息中转站”，但不同之处在于，中间服务层会将消息持久化存储\n\n中间服务层由多个部件构成：\n- broker：可以理解为是一个节点，即运行Kafka程序的服务器\n- topic：对消息进行逻辑分类的粗粒度单位，可用于实现负载均衡、消息并行处理。消费者订阅某一个主题进行消费。生产者向指定的主题写入消息\n- partition：消息上物理上存储的空间，一个partition对应着一个topic，一个topic可以有多个partition。partition对于生产者和消费者是透明的、无法感知的。\n\t- 每个partition存储着有序、不可变的消息序列\n\t- partition可被独立读写\n\nbroker、topic、partition三者之间的关系如下：\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250104150207.png)\n## Topic\n在Kafka中，Topic就是一个主题，属于逻辑上的概念，并不存在任何一台物理设备上。作为使用者，我们可以将同业务的消息放入同一个topic，例如秒杀业务、售票业务等，通过这个逻辑上的概念，可以粗粒度地将数据消息进行分片，分门别类地处理消息。\n\n## Partition\n对数据进行逻辑Topic分区后，一个业务的数据量可能仍然庞大，为了对数据进一步分而治之，设计Kafka的大佬决定将Topic的数据实际物理存储在一个个Partition中。Partition就相当于对粗粒度划分的数据再进行一次细粒度区分。由于Topic是一个逻辑上的概念，并不存在于某一个具体的broker上，因此在集群模式下，同一个Topic下的多个Partition是独立的，完全可以在不同的broker上。\n\n分片的好处：\n- 提高写入性能，不同的partition分布在不同的broker上，可以实现并行写入，提高了系统吞吐量\n- 提高消费者并发度，因为有了不同的分片，不同的消费者可以对不同的分片同时消费\n- 提高了Kafka水平扩展能力\n- 提高了系统的容错能力，引入partition后，同一个 Topic下不同partition中的数据解耦合，即使一个partition崩溃了，也不影响其他partition运作\n\n一个Partition就相当于一个队列，最新的数据被写在队列的末尾，即同一个Partition下的数据是有序的，但综合来看，同一个Topic下的所有Partition中的数据是无序的\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250104192916.png)\n\n由于Partition对于生产者是透明的，那么生产者向一个Topic写入数据，数据最终会流向何处呢？\n如果生产者向Topic发送消息时没有指定Key，那么Kafka服务就会默认采取**轮询Partition**的方式将数据写入到Partition中。\n如果生产者指定了发送的Key，那么消息就会被写入到将Key进行哈希过后对应的Partition中\n\n## Broker\nBroker实际就是一个运行Kafka程序的服务器节点，Broker需要提供如下功能：\n1. 接受来自客户端的连接\n2. 支持客户端查询Kafka集群的信息，比如查询其他Broker信息\n3. 响应来自客户端的命令请求\n4. 存储消息，即将消息持久化存储在本地服务器上\n\n在集群部署模式下，每一个Broker都有唯一的ID标识自己身份。Partition是存放在Broker节点上的，一个Partition对应一个Broker，一个Broker可能存放着多个Partition\n针对于一个Topic下的多个Partition，需要先随机选取一个Broker（比如是Broker10）存放Partition_0，接着按照Broker的ID顺序依次存放Partition，即Broker11存放Partition_1、Broker12存放Partition_2，以此类推。\n\n前文提及了，消费者在发送消息时可以指定Key，相当于将消息发送到指定的Partition上。那么客户端是如何在Kafka集群中快速找到目标Partition所在的Broker节点呢？\n通常客户端连接集群有三种方式：\n1. 引入代理，代理和众多Broker打交道\n2. 重定向，客户端发送命令到某一个节点上，如果该节点不是目标节点，那么该节点会告知客户端木笔哦节点具体地址（Redis）\n3. 查询路由表，客户端先查询路由表，直接向目标节点发送请求命令（Kafka）\n\nKafka选择第三种方式的一个契机是，在Kafka集群中，每一个Broker都支持客户端查询Kafka集群的信息，即每一个Broker都知晓其他Broker的信息。这些信息都被维护在每一个Broker的路由表中，了解了这一点，客户端发送读写命令的过程就呼之欲出了：\n1. 任意访问一台Broker\n2. 从这台Broker中获取路由表\n3. 根据规则找到目标Partition，在路由表中找到哪个Broker上存有目标Partition，最后发送读写命令\n\t1. 找Partition的规则就是上文讲的**轮询或哈希Key**规则\n\n## 生产者Producer\n\n生产者发送一条消息需要历经三个步骤：\n- 构建消息：将需要发送的信息打包成Kafka消息结构\n- 序列化消息：将消息序列化成二进制数据，以便在网络中传输\n- 寻找Broker：根据规则找到目标分区，接着依据路由表将消息发送到Partition对应的Broker\n\n**构建消息**\n生产者需要将发送的信息打包成Kafka消息结构，接下来就详细看看消息结构的具体组成：\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105102410.png)\n\n- Key：根据Key的哈希值（取模）确定发送到Topic下的哪一个Partition上，一般是字符串类型，最终会被序列化为二进制数据\n- Value：实际发送的数据\n- Compression Type：指定压缩算法，该字段表明采用什么压缩算法对数据进行压缩，枚举值：None、gzip、lz4等\n- Header：生产者额外想传输的数据就放在Header中，比如TraceID\n- Partition+Offset：该字段在生产出来的时候是空的，消息发送到Kafka服务端后才会将具体的分区、偏移量写入该字段。Topic + Partition + Offset唯一确定一条消息\n\n**序列化**\n序列化就是将消息从常规类型转换至二进制类型，以在网络中传输\n\n**发送模式**\n在Go、Java的SDK中提供了三种消息发送模式：\n1. 同步发送，生产者发送消息后，执行阻塞操作，等待Kafka服务端返回发送消息成功或异常结果。适用于生产者需要确保成功发送消息才能执行后续操作的场景。\n2. 发了就忘，生产者发完消息就继续执行后续操作，不理会消息是否发送成功，也不采取措施应对发送异常\n3. 异步发送，生产者发送消息的同时注册回调函数，不执行阻塞操作，而是继续执行后续的操作。当Kafka服务端返回发送消息的结果后，执行对应回调函数的内容\n\n三种发送模式实际上就是**高性能和可靠性**之间的权衡。同步发送模式可靠性强，但是效率不高，适用于保持数据一致性的场景；发了就忘性能高，可是不保证可靠性，因此适合在要求高性能的场景下使用；异步发送就是在二者之间的折中办法，使用于在需要时处理消息发送失败的情况\n\n## 消费者Consumer\n和生产者一样，消费者也需要集成Kafka客户端库，通过接口向Broker获取消息进行消费\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105141657.png)\n通过上图可得出一下结论：\n1. 不同的消费者可以在同一时刻对同一Topic进行消费\n2. 一个消费者可以在同一时刻对一个Topic下的不同Partition进行消费\n3. 一个消费者同时消费多个Partition是无法保证消息有序性的\n4. 一个消费者只消费一个Partition，消费顺序即生产顺序，是有序的\n\n**拉还是推**？\n消费者消费消息是通过**拉模式**进行的，也就是说，消费者先向Broker发送拉取消息的信号，接着Broker再将消息发送给消费者，而不是Broker主动向消费者推送消息。\n选择这种拉模式的主要原因在于，消费者可以根据自身的资源利用率（CPU、内存等）适时地向Broker拉取消息，调节消费速度，避免因消费速度不合适导致资源浪费或超载\n\n**消费者Offset**\n在Partition中，位于Offset之前的消息都已经被消费过了，而之后的消息则没有被消费。消费者组每消费完一个消息后，就向Broker提供该消息的Offset，表示该消息已经消费过了。消费者下一次拉取的消息就是Partition中Offset的下一位。消费者完成消费后，就将该消息的“Partition + Offset”字段信息发送给Broker，由Broker负责更新对应Partition的Offset\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105144221.png)\n\n**主动提交和被动提交**\n消费者组提交Offset分为两种方式：\n - 被动提交\n - 主动提交\n被动提交就是定时周期性地向Broker提交最新已处理的消息。但是这种提交方式存在一致性问题，例如消费者正在处理offset为5的消息，此时发生了被动提交，需要告知Broker将Offset更新为5，但实际上offset为5的消息还没有完全处理完。如果此时发生了崩溃重启，那么该消息就会被丢失。\n\n手动提交则是一种更为稳妥的方式，当某条消息彻底处理好后，再主动向Broker提交消息，避免出现不一致的情况。\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105150142.png)\n\n**消费者组ConsumerGroup**\n消费者组实质就是由多个消费者组成的集合，一个消费者组由一个GroupID唯一标识。\n多个消费者组成消费者组，那么这些消费者必须有一些约束：\n- 在同一个消费者组中，一个Partition只能分配一个消费者\n- 同一个消费者组中，可以分派多个消费者\n- 不同消费者组可以同时消费同一个Topic\n消费者组在消费者方面进行了水平扩容，提高了消费能力。\n\n消费者组咋眼一看没多大用处，实际上，消费者组带来的最大便利在于对分区的封装性，一个消费者组可以自动完成**Re balance**操作，使得Partition对于消费者是透明的。反之，消费者每次拉取消息都要指定Partition，这就导致Partition和消费者耦合在一块，Partition数量发生变动，消费者方面的代码就要随之变动\n\n**消费者组分区分配策略**\n partition.assignment.strategy字段可以配置消费者组中多个消费者对于分区分配的规则：\n - Range Assignor：基于范围的分配策略\n - Round Robin Assignor：基于轮询的分配策略\n - Sticky Assignor：优先保持当前的分配状态，尽量减少Rebalance过程中分区的移动\n - CooperativeSticky Assignor：基本和Sticky Assignor策略一致，但是区别在于该协议将原来一次行对一大片分区进行Rebalance改为多次小规模的Rebalance操作，即渐进式Rebalance\n\n## Rebalance机制\n Rebalance机制用于确保数据在消费者组中尽可能地负载均衡\n 触发Rebalance的三个时机：\n - 加入新的消费者\n - 消费者减少，不论是正常关闭还是崩溃\n - Topic下的Partition数量发生变化\n\n**再平衡的步骤**\n再平衡操作需要经历五个阶段：\n1. 暂停消费，消费者需要暂停正在进行的消费，防止重新分配过程中出现数据丢失或重复问题\n2. 触发再分配，由消费者组协调器Group Coordinator（通常是一个Broker）触发再平衡\n3. 分配分区，消费者配合协调器根据当前消费者和分区数量，重新分配主题的分区\n4. 获取分配信息，重新分配完成后，消费者会从协调器拿到新的分区分配情况\n5. 恢复消费，消费者收到新的分配后，恢复消费，开始处理新分区\n\n上文提到有四种消费组分区分配策略，这四种分配策略可以依据是否产生STW问题分为Eager和Incremental两种再平衡策略。其中前三种方案都是Eager策略，因为这三种分配策略在暂停消费者阶段会停止所有的消费行为，而Cooperative Sticky方式则只会暂停部分消费者，未被暂停的消费者仍能继续消费行为，但代价是Rebalance的时间被延长\n\n**Group Coordinator是什么**？\n","source":"_posts/Kafka理论知识.md","raw":"## 整体架构\n宏观上可以将Kafka分成三个部分：生产者、中间服务层、消费者\n中间服务层相当于一个“消息中转站”，但不同之处在于，中间服务层会将消息持久化存储\n\n中间服务层由多个部件构成：\n- broker：可以理解为是一个节点，即运行Kafka程序的服务器\n- topic：对消息进行逻辑分类的粗粒度单位，可用于实现负载均衡、消息并行处理。消费者订阅某一个主题进行消费。生产者向指定的主题写入消息\n- partition：消息上物理上存储的空间，一个partition对应着一个topic，一个topic可以有多个partition。partition对于生产者和消费者是透明的、无法感知的。\n\t- 每个partition存储着有序、不可变的消息序列\n\t- partition可被独立读写\n\nbroker、topic、partition三者之间的关系如下：\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250104150207.png)\n## Topic\n在Kafka中，Topic就是一个主题，属于逻辑上的概念，并不存在任何一台物理设备上。作为使用者，我们可以将同业务的消息放入同一个topic，例如秒杀业务、售票业务等，通过这个逻辑上的概念，可以粗粒度地将数据消息进行分片，分门别类地处理消息。\n\n## Partition\n对数据进行逻辑Topic分区后，一个业务的数据量可能仍然庞大，为了对数据进一步分而治之，设计Kafka的大佬决定将Topic的数据实际物理存储在一个个Partition中。Partition就相当于对粗粒度划分的数据再进行一次细粒度区分。由于Topic是一个逻辑上的概念，并不存在于某一个具体的broker上，因此在集群模式下，同一个Topic下的多个Partition是独立的，完全可以在不同的broker上。\n\n分片的好处：\n- 提高写入性能，不同的partition分布在不同的broker上，可以实现并行写入，提高了系统吞吐量\n- 提高消费者并发度，因为有了不同的分片，不同的消费者可以对不同的分片同时消费\n- 提高了Kafka水平扩展能力\n- 提高了系统的容错能力，引入partition后，同一个 Topic下不同partition中的数据解耦合，即使一个partition崩溃了，也不影响其他partition运作\n\n一个Partition就相当于一个队列，最新的数据被写在队列的末尾，即同一个Partition下的数据是有序的，但综合来看，同一个Topic下的所有Partition中的数据是无序的\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250104192916.png)\n\n由于Partition对于生产者是透明的，那么生产者向一个Topic写入数据，数据最终会流向何处呢？\n如果生产者向Topic发送消息时没有指定Key，那么Kafka服务就会默认采取**轮询Partition**的方式将数据写入到Partition中。\n如果生产者指定了发送的Key，那么消息就会被写入到将Key进行哈希过后对应的Partition中\n\n## Broker\nBroker实际就是一个运行Kafka程序的服务器节点，Broker需要提供如下功能：\n1. 接受来自客户端的连接\n2. 支持客户端查询Kafka集群的信息，比如查询其他Broker信息\n3. 响应来自客户端的命令请求\n4. 存储消息，即将消息持久化存储在本地服务器上\n\n在集群部署模式下，每一个Broker都有唯一的ID标识自己身份。Partition是存放在Broker节点上的，一个Partition对应一个Broker，一个Broker可能存放着多个Partition\n针对于一个Topic下的多个Partition，需要先随机选取一个Broker（比如是Broker10）存放Partition_0，接着按照Broker的ID顺序依次存放Partition，即Broker11存放Partition_1、Broker12存放Partition_2，以此类推。\n\n前文提及了，消费者在发送消息时可以指定Key，相当于将消息发送到指定的Partition上。那么客户端是如何在Kafka集群中快速找到目标Partition所在的Broker节点呢？\n通常客户端连接集群有三种方式：\n1. 引入代理，代理和众多Broker打交道\n2. 重定向，客户端发送命令到某一个节点上，如果该节点不是目标节点，那么该节点会告知客户端木笔哦节点具体地址（Redis）\n3. 查询路由表，客户端先查询路由表，直接向目标节点发送请求命令（Kafka）\n\nKafka选择第三种方式的一个契机是，在Kafka集群中，每一个Broker都支持客户端查询Kafka集群的信息，即每一个Broker都知晓其他Broker的信息。这些信息都被维护在每一个Broker的路由表中，了解了这一点，客户端发送读写命令的过程就呼之欲出了：\n1. 任意访问一台Broker\n2. 从这台Broker中获取路由表\n3. 根据规则找到目标Partition，在路由表中找到哪个Broker上存有目标Partition，最后发送读写命令\n\t1. 找Partition的规则就是上文讲的**轮询或哈希Key**规则\n\n## 生产者Producer\n\n生产者发送一条消息需要历经三个步骤：\n- 构建消息：将需要发送的信息打包成Kafka消息结构\n- 序列化消息：将消息序列化成二进制数据，以便在网络中传输\n- 寻找Broker：根据规则找到目标分区，接着依据路由表将消息发送到Partition对应的Broker\n\n**构建消息**\n生产者需要将发送的信息打包成Kafka消息结构，接下来就详细看看消息结构的具体组成：\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105102410.png)\n\n- Key：根据Key的哈希值（取模）确定发送到Topic下的哪一个Partition上，一般是字符串类型，最终会被序列化为二进制数据\n- Value：实际发送的数据\n- Compression Type：指定压缩算法，该字段表明采用什么压缩算法对数据进行压缩，枚举值：None、gzip、lz4等\n- Header：生产者额外想传输的数据就放在Header中，比如TraceID\n- Partition+Offset：该字段在生产出来的时候是空的，消息发送到Kafka服务端后才会将具体的分区、偏移量写入该字段。Topic + Partition + Offset唯一确定一条消息\n\n**序列化**\n序列化就是将消息从常规类型转换至二进制类型，以在网络中传输\n\n**发送模式**\n在Go、Java的SDK中提供了三种消息发送模式：\n1. 同步发送，生产者发送消息后，执行阻塞操作，等待Kafka服务端返回发送消息成功或异常结果。适用于生产者需要确保成功发送消息才能执行后续操作的场景。\n2. 发了就忘，生产者发完消息就继续执行后续操作，不理会消息是否发送成功，也不采取措施应对发送异常\n3. 异步发送，生产者发送消息的同时注册回调函数，不执行阻塞操作，而是继续执行后续的操作。当Kafka服务端返回发送消息的结果后，执行对应回调函数的内容\n\n三种发送模式实际上就是**高性能和可靠性**之间的权衡。同步发送模式可靠性强，但是效率不高，适用于保持数据一致性的场景；发了就忘性能高，可是不保证可靠性，因此适合在要求高性能的场景下使用；异步发送就是在二者之间的折中办法，使用于在需要时处理消息发送失败的情况\n\n## 消费者Consumer\n和生产者一样，消费者也需要集成Kafka客户端库，通过接口向Broker获取消息进行消费\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105141657.png)\n通过上图可得出一下结论：\n1. 不同的消费者可以在同一时刻对同一Topic进行消费\n2. 一个消费者可以在同一时刻对一个Topic下的不同Partition进行消费\n3. 一个消费者同时消费多个Partition是无法保证消息有序性的\n4. 一个消费者只消费一个Partition，消费顺序即生产顺序，是有序的\n\n**拉还是推**？\n消费者消费消息是通过**拉模式**进行的，也就是说，消费者先向Broker发送拉取消息的信号，接着Broker再将消息发送给消费者，而不是Broker主动向消费者推送消息。\n选择这种拉模式的主要原因在于，消费者可以根据自身的资源利用率（CPU、内存等）适时地向Broker拉取消息，调节消费速度，避免因消费速度不合适导致资源浪费或超载\n\n**消费者Offset**\n在Partition中，位于Offset之前的消息都已经被消费过了，而之后的消息则没有被消费。消费者组每消费完一个消息后，就向Broker提供该消息的Offset，表示该消息已经消费过了。消费者下一次拉取的消息就是Partition中Offset的下一位。消费者完成消费后，就将该消息的“Partition + Offset”字段信息发送给Broker，由Broker负责更新对应Partition的Offset\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105144221.png)\n\n**主动提交和被动提交**\n消费者组提交Offset分为两种方式：\n - 被动提交\n - 主动提交\n被动提交就是定时周期性地向Broker提交最新已处理的消息。但是这种提交方式存在一致性问题，例如消费者正在处理offset为5的消息，此时发生了被动提交，需要告知Broker将Offset更新为5，但实际上offset为5的消息还没有完全处理完。如果此时发生了崩溃重启，那么该消息就会被丢失。\n\n手动提交则是一种更为稳妥的方式，当某条消息彻底处理好后，再主动向Broker提交消息，避免出现不一致的情况。\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250105150142.png)\n\n**消费者组ConsumerGroup**\n消费者组实质就是由多个消费者组成的集合，一个消费者组由一个GroupID唯一标识。\n多个消费者组成消费者组，那么这些消费者必须有一些约束：\n- 在同一个消费者组中，一个Partition只能分配一个消费者\n- 同一个消费者组中，可以分派多个消费者\n- 不同消费者组可以同时消费同一个Topic\n消费者组在消费者方面进行了水平扩容，提高了消费能力。\n\n消费者组咋眼一看没多大用处，实际上，消费者组带来的最大便利在于对分区的封装性，一个消费者组可以自动完成**Re balance**操作，使得Partition对于消费者是透明的。反之，消费者每次拉取消息都要指定Partition，这就导致Partition和消费者耦合在一块，Partition数量发生变动，消费者方面的代码就要随之变动\n\n**消费者组分区分配策略**\n partition.assignment.strategy字段可以配置消费者组中多个消费者对于分区分配的规则：\n - Range Assignor：基于范围的分配策略\n - Round Robin Assignor：基于轮询的分配策略\n - Sticky Assignor：优先保持当前的分配状态，尽量减少Rebalance过程中分区的移动\n - CooperativeSticky Assignor：基本和Sticky Assignor策略一致，但是区别在于该协议将原来一次行对一大片分区进行Rebalance改为多次小规模的Rebalance操作，即渐进式Rebalance\n\n## Rebalance机制\n Rebalance机制用于确保数据在消费者组中尽可能地负载均衡\n 触发Rebalance的三个时机：\n - 加入新的消费者\n - 消费者减少，不论是正常关闭还是崩溃\n - Topic下的Partition数量发生变化\n\n**再平衡的步骤**\n再平衡操作需要经历五个阶段：\n1. 暂停消费，消费者需要暂停正在进行的消费，防止重新分配过程中出现数据丢失或重复问题\n2. 触发再分配，由消费者组协调器Group Coordinator（通常是一个Broker）触发再平衡\n3. 分配分区，消费者配合协调器根据当前消费者和分区数量，重新分配主题的分区\n4. 获取分配信息，重新分配完成后，消费者会从协调器拿到新的分区分配情况\n5. 恢复消费，消费者收到新的分配后，恢复消费，开始处理新分区\n\n上文提到有四种消费组分区分配策略，这四种分配策略可以依据是否产生STW问题分为Eager和Incremental两种再平衡策略。其中前三种方案都是Eager策略，因为这三种分配策略在暂停消费者阶段会停止所有的消费行为，而Cooperative Sticky方式则只会暂停部分消费者，未被暂停的消费者仍能继续消费行为，但代价是Rebalance的时间被延长\n\n**Group Coordinator是什么**？\n","slug":"Kafka理论知识","published":1,"date":"2025-01-04T06:32:27.252Z","updated":"2025-01-05T11:56:39.329Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6g0005a5t2c2cn5dff","content":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>宏观上可以将Kafka分成三个部分：生产者、中间服务层、消费者<br>中间服务层相当于一个“消息中转站”，但不同之处在于，中间服务层会将消息持久化存储</p>\n<p>中间服务层由多个部件构成：</p>\n<ul>\n<li>broker：可以理解为是一个节点，即运行Kafka程序的服务器</li>\n<li>topic：对消息进行逻辑分类的粗粒度单位，可用于实现负载均衡、消息并行处理。消费者订阅某一个主题进行消费。生产者向指定的主题写入消息</li>\n<li>partition：消息上物理上存储的空间，一个partition对应着一个topic，一个topic可以有多个partition。partition对于生产者和消费者是透明的、无法感知的。<ul>\n<li>每个partition存储着有序、不可变的消息序列</li>\n<li>partition可被独立读写</li>\n</ul>\n</li>\n</ul>\n<p>broker、topic、partition三者之间的关系如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250104150207.png\" alt=\"image.png\"></p>\n<h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><p>在Kafka中，Topic就是一个主题，属于逻辑上的概念，并不存在任何一台物理设备上。作为使用者，我们可以将同业务的消息放入同一个topic，例如秒杀业务、售票业务等，通过这个逻辑上的概念，可以粗粒度地将数据消息进行分片，分门别类地处理消息。</p>\n<h2 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h2><p>对数据进行逻辑Topic分区后，一个业务的数据量可能仍然庞大，为了对数据进一步分而治之，设计Kafka的大佬决定将Topic的数据实际物理存储在一个个Partition中。Partition就相当于对粗粒度划分的数据再进行一次细粒度区分。由于Topic是一个逻辑上的概念，并不存在于某一个具体的broker上，因此在集群模式下，同一个Topic下的多个Partition是独立的，完全可以在不同的broker上。</p>\n<p>分片的好处：</p>\n<ul>\n<li>提高写入性能，不同的partition分布在不同的broker上，可以实现并行写入，提高了系统吞吐量</li>\n<li>提高消费者并发度，因为有了不同的分片，不同的消费者可以对不同的分片同时消费</li>\n<li>提高了Kafka水平扩展能力</li>\n<li>提高了系统的容错能力，引入partition后，同一个 Topic下不同partition中的数据解耦合，即使一个partition崩溃了，也不影响其他partition运作</li>\n</ul>\n<p>一个Partition就相当于一个队列，最新的数据被写在队列的末尾，即同一个Partition下的数据是有序的，但综合来看，同一个Topic下的所有Partition中的数据是无序的<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250104192916.png\" alt=\"image.png\"></p>\n<p>由于Partition对于生产者是透明的，那么生产者向一个Topic写入数据，数据最终会流向何处呢？<br>如果生产者向Topic发送消息时没有指定Key，那么Kafka服务就会默认采取<strong>轮询Partition</strong>的方式将数据写入到Partition中。<br>如果生产者指定了发送的Key，那么消息就会被写入到将Key进行哈希过后对应的Partition中</p>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p>Broker实际就是一个运行Kafka程序的服务器节点，Broker需要提供如下功能：</p>\n<ol>\n<li>接受来自客户端的连接</li>\n<li>支持客户端查询Kafka集群的信息，比如查询其他Broker信息</li>\n<li>响应来自客户端的命令请求</li>\n<li>存储消息，即将消息持久化存储在本地服务器上</li>\n</ol>\n<p>在集群部署模式下，每一个Broker都有唯一的ID标识自己身份。Partition是存放在Broker节点上的，一个Partition对应一个Broker，一个Broker可能存放着多个Partition<br>针对于一个Topic下的多个Partition，需要先随机选取一个Broker（比如是Broker10）存放Partition_0，接着按照Broker的ID顺序依次存放Partition，即Broker11存放Partition_1、Broker12存放Partition_2，以此类推。</p>\n<p>前文提及了，消费者在发送消息时可以指定Key，相当于将消息发送到指定的Partition上。那么客户端是如何在Kafka集群中快速找到目标Partition所在的Broker节点呢？<br>通常客户端连接集群有三种方式：</p>\n<ol>\n<li>引入代理，代理和众多Broker打交道</li>\n<li>重定向，客户端发送命令到某一个节点上，如果该节点不是目标节点，那么该节点会告知客户端木笔哦节点具体地址（Redis）</li>\n<li>查询路由表，客户端先查询路由表，直接向目标节点发送请求命令（Kafka）</li>\n</ol>\n<p>Kafka选择第三种方式的一个契机是，在Kafka集群中，每一个Broker都支持客户端查询Kafka集群的信息，即每一个Broker都知晓其他Broker的信息。这些信息都被维护在每一个Broker的路由表中，了解了这一点，客户端发送读写命令的过程就呼之欲出了：</p>\n<ol>\n<li>任意访问一台Broker</li>\n<li>从这台Broker中获取路由表</li>\n<li>根据规则找到目标Partition，在路由表中找到哪个Broker上存有目标Partition，最后发送读写命令<ol>\n<li>找Partition的规则就是上文讲的<strong>轮询或哈希Key</strong>规则</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"生产者Producer\"><a href=\"#生产者Producer\" class=\"headerlink\" title=\"生产者Producer\"></a>生产者Producer</h2><p>生产者发送一条消息需要历经三个步骤：</p>\n<ul>\n<li>构建消息：将需要发送的信息打包成Kafka消息结构</li>\n<li>序列化消息：将消息序列化成二进制数据，以便在网络中传输</li>\n<li>寻找Broker：根据规则找到目标分区，接着依据路由表将消息发送到Partition对应的Broker</li>\n</ul>\n<p><strong>构建消息</strong><br>生产者需要将发送的信息打包成Kafka消息结构，接下来就详细看看消息结构的具体组成：<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105102410.png\" alt=\"image.png\"></p>\n<ul>\n<li>Key：根据Key的哈希值（取模）确定发送到Topic下的哪一个Partition上，一般是字符串类型，最终会被序列化为二进制数据</li>\n<li>Value：实际发送的数据</li>\n<li>Compression Type：指定压缩算法，该字段表明采用什么压缩算法对数据进行压缩，枚举值：None、gzip、lz4等</li>\n<li>Header：生产者额外想传输的数据就放在Header中，比如TraceID</li>\n<li>Partition+Offset：该字段在生产出来的时候是空的，消息发送到Kafka服务端后才会将具体的分区、偏移量写入该字段。Topic + Partition + Offset唯一确定一条消息</li>\n</ul>\n<p><strong>序列化</strong><br>序列化就是将消息从常规类型转换至二进制类型，以在网络中传输</p>\n<p><strong>发送模式</strong><br>在Go、Java的SDK中提供了三种消息发送模式：</p>\n<ol>\n<li>同步发送，生产者发送消息后，执行阻塞操作，等待Kafka服务端返回发送消息成功或异常结果。适用于生产者需要确保成功发送消息才能执行后续操作的场景。</li>\n<li>发了就忘，生产者发完消息就继续执行后续操作，不理会消息是否发送成功，也不采取措施应对发送异常</li>\n<li>异步发送，生产者发送消息的同时注册回调函数，不执行阻塞操作，而是继续执行后续的操作。当Kafka服务端返回发送消息的结果后，执行对应回调函数的内容</li>\n</ol>\n<p>三种发送模式实际上就是<strong>高性能和可靠性</strong>之间的权衡。同步发送模式可靠性强，但是效率不高，适用于保持数据一致性的场景；发了就忘性能高，可是不保证可靠性，因此适合在要求高性能的场景下使用；异步发送就是在二者之间的折中办法，使用于在需要时处理消息发送失败的情况</p>\n<h2 id=\"消费者Consumer\"><a href=\"#消费者Consumer\" class=\"headerlink\" title=\"消费者Consumer\"></a>消费者Consumer</h2><p>和生产者一样，消费者也需要集成Kafka客户端库，通过接口向Broker获取消息进行消费<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105141657.png\" alt=\"image.png\"><br>通过上图可得出一下结论：</p>\n<ol>\n<li>不同的消费者可以在同一时刻对同一Topic进行消费</li>\n<li>一个消费者可以在同一时刻对一个Topic下的不同Partition进行消费</li>\n<li>一个消费者同时消费多个Partition是无法保证消息有序性的</li>\n<li>一个消费者只消费一个Partition，消费顺序即生产顺序，是有序的</li>\n</ol>\n<p><strong>拉还是推</strong>？<br>消费者消费消息是通过<strong>拉模式</strong>进行的，也就是说，消费者先向Broker发送拉取消息的信号，接着Broker再将消息发送给消费者，而不是Broker主动向消费者推送消息。<br>选择这种拉模式的主要原因在于，消费者可以根据自身的资源利用率（CPU、内存等）适时地向Broker拉取消息，调节消费速度，避免因消费速度不合适导致资源浪费或超载</p>\n<p><strong>消费者Offset</strong><br>在Partition中，位于Offset之前的消息都已经被消费过了，而之后的消息则没有被消费。消费者组每消费完一个消息后，就向Broker提供该消息的Offset，表示该消息已经消费过了。消费者下一次拉取的消息就是Partition中Offset的下一位。消费者完成消费后，就将该消息的“Partition + Offset”字段信息发送给Broker，由Broker负责更新对应Partition的Offset<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105144221.png\" alt=\"image.png\"></p>\n<p><strong>主动提交和被动提交</strong><br>消费者组提交Offset分为两种方式：</p>\n<ul>\n<li>被动提交</li>\n<li>主动提交<br>被动提交就是定时周期性地向Broker提交最新已处理的消息。但是这种提交方式存在一致性问题，例如消费者正在处理offset为5的消息，此时发生了被动提交，需要告知Broker将Offset更新为5，但实际上offset为5的消息还没有完全处理完。如果此时发生了崩溃重启，那么该消息就会被丢失。</li>\n</ul>\n<p>手动提交则是一种更为稳妥的方式，当某条消息彻底处理好后，再主动向Broker提交消息，避免出现不一致的情况。<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105150142.png\" alt=\"image.png\"></p>\n<p><strong>消费者组ConsumerGroup</strong><br>消费者组实质就是由多个消费者组成的集合，一个消费者组由一个GroupID唯一标识。<br>多个消费者组成消费者组，那么这些消费者必须有一些约束：</p>\n<ul>\n<li>在同一个消费者组中，一个Partition只能分配一个消费者</li>\n<li>同一个消费者组中，可以分派多个消费者</li>\n<li>不同消费者组可以同时消费同一个Topic<br>消费者组在消费者方面进行了水平扩容，提高了消费能力。</li>\n</ul>\n<p>消费者组咋眼一看没多大用处，实际上，消费者组带来的最大便利在于对分区的封装性，一个消费者组可以自动完成<strong>Re balance</strong>操作，使得Partition对于消费者是透明的。反之，消费者每次拉取消息都要指定Partition，这就导致Partition和消费者耦合在一块，Partition数量发生变动，消费者方面的代码就要随之变动</p>\n<p><strong>消费者组分区分配策略</strong><br> partition.assignment.strategy字段可以配置消费者组中多个消费者对于分区分配的规则：</p>\n<ul>\n<li>Range Assignor：基于范围的分配策略</li>\n<li>Round Robin Assignor：基于轮询的分配策略</li>\n<li>Sticky Assignor：优先保持当前的分配状态，尽量减少Rebalance过程中分区的移动</li>\n<li>CooperativeSticky Assignor：基本和Sticky Assignor策略一致，但是区别在于该协议将原来一次行对一大片分区进行Rebalance改为多次小规模的Rebalance操作，即渐进式Rebalance</li>\n</ul>\n<h2 id=\"Rebalance机制\"><a href=\"#Rebalance机制\" class=\"headerlink\" title=\"Rebalance机制\"></a>Rebalance机制</h2><p> Rebalance机制用于确保数据在消费者组中尽可能地负载均衡<br> 触发Rebalance的三个时机：</p>\n<ul>\n<li>加入新的消费者</li>\n<li>消费者减少，不论是正常关闭还是崩溃</li>\n<li>Topic下的Partition数量发生变化</li>\n</ul>\n<p><strong>再平衡的步骤</strong><br>再平衡操作需要经历五个阶段：</p>\n<ol>\n<li>暂停消费，消费者需要暂停正在进行的消费，防止重新分配过程中出现数据丢失或重复问题</li>\n<li>触发再分配，由消费者组协调器Group Coordinator（通常是一个Broker）触发再平衡</li>\n<li>分配分区，消费者配合协调器根据当前消费者和分区数量，重新分配主题的分区</li>\n<li>获取分配信息，重新分配完成后，消费者会从协调器拿到新的分区分配情况</li>\n<li>恢复消费，消费者收到新的分配后，恢复消费，开始处理新分区</li>\n</ol>\n<p>上文提到有四种消费组分区分配策略，这四种分配策略可以依据是否产生STW问题分为Eager和Incremental两种再平衡策略。其中前三种方案都是Eager策略，因为这三种分配策略在暂停消费者阶段会停止所有的消费行为，而Cooperative Sticky方式则只会暂停部分消费者，未被暂停的消费者仍能继续消费行为，但代价是Rebalance的时间被延长</p>\n<p><strong>Group Coordinator是什么</strong>？</p>\n","excerpt":"","more":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>宏观上可以将Kafka分成三个部分：生产者、中间服务层、消费者<br>中间服务层相当于一个“消息中转站”，但不同之处在于，中间服务层会将消息持久化存储</p>\n<p>中间服务层由多个部件构成：</p>\n<ul>\n<li>broker：可以理解为是一个节点，即运行Kafka程序的服务器</li>\n<li>topic：对消息进行逻辑分类的粗粒度单位，可用于实现负载均衡、消息并行处理。消费者订阅某一个主题进行消费。生产者向指定的主题写入消息</li>\n<li>partition：消息上物理上存储的空间，一个partition对应着一个topic，一个topic可以有多个partition。partition对于生产者和消费者是透明的、无法感知的。<ul>\n<li>每个partition存储着有序、不可变的消息序列</li>\n<li>partition可被独立读写</li>\n</ul>\n</li>\n</ul>\n<p>broker、topic、partition三者之间的关系如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250104150207.png\" alt=\"image.png\"></p>\n<h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><p>在Kafka中，Topic就是一个主题，属于逻辑上的概念，并不存在任何一台物理设备上。作为使用者，我们可以将同业务的消息放入同一个topic，例如秒杀业务、售票业务等，通过这个逻辑上的概念，可以粗粒度地将数据消息进行分片，分门别类地处理消息。</p>\n<h2 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h2><p>对数据进行逻辑Topic分区后，一个业务的数据量可能仍然庞大，为了对数据进一步分而治之，设计Kafka的大佬决定将Topic的数据实际物理存储在一个个Partition中。Partition就相当于对粗粒度划分的数据再进行一次细粒度区分。由于Topic是一个逻辑上的概念，并不存在于某一个具体的broker上，因此在集群模式下，同一个Topic下的多个Partition是独立的，完全可以在不同的broker上。</p>\n<p>分片的好处：</p>\n<ul>\n<li>提高写入性能，不同的partition分布在不同的broker上，可以实现并行写入，提高了系统吞吐量</li>\n<li>提高消费者并发度，因为有了不同的分片，不同的消费者可以对不同的分片同时消费</li>\n<li>提高了Kafka水平扩展能力</li>\n<li>提高了系统的容错能力，引入partition后，同一个 Topic下不同partition中的数据解耦合，即使一个partition崩溃了，也不影响其他partition运作</li>\n</ul>\n<p>一个Partition就相当于一个队列，最新的数据被写在队列的末尾，即同一个Partition下的数据是有序的，但综合来看，同一个Topic下的所有Partition中的数据是无序的<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250104192916.png\" alt=\"image.png\"></p>\n<p>由于Partition对于生产者是透明的，那么生产者向一个Topic写入数据，数据最终会流向何处呢？<br>如果生产者向Topic发送消息时没有指定Key，那么Kafka服务就会默认采取<strong>轮询Partition</strong>的方式将数据写入到Partition中。<br>如果生产者指定了发送的Key，那么消息就会被写入到将Key进行哈希过后对应的Partition中</p>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p>Broker实际就是一个运行Kafka程序的服务器节点，Broker需要提供如下功能：</p>\n<ol>\n<li>接受来自客户端的连接</li>\n<li>支持客户端查询Kafka集群的信息，比如查询其他Broker信息</li>\n<li>响应来自客户端的命令请求</li>\n<li>存储消息，即将消息持久化存储在本地服务器上</li>\n</ol>\n<p>在集群部署模式下，每一个Broker都有唯一的ID标识自己身份。Partition是存放在Broker节点上的，一个Partition对应一个Broker，一个Broker可能存放着多个Partition<br>针对于一个Topic下的多个Partition，需要先随机选取一个Broker（比如是Broker10）存放Partition_0，接着按照Broker的ID顺序依次存放Partition，即Broker11存放Partition_1、Broker12存放Partition_2，以此类推。</p>\n<p>前文提及了，消费者在发送消息时可以指定Key，相当于将消息发送到指定的Partition上。那么客户端是如何在Kafka集群中快速找到目标Partition所在的Broker节点呢？<br>通常客户端连接集群有三种方式：</p>\n<ol>\n<li>引入代理，代理和众多Broker打交道</li>\n<li>重定向，客户端发送命令到某一个节点上，如果该节点不是目标节点，那么该节点会告知客户端木笔哦节点具体地址（Redis）</li>\n<li>查询路由表，客户端先查询路由表，直接向目标节点发送请求命令（Kafka）</li>\n</ol>\n<p>Kafka选择第三种方式的一个契机是，在Kafka集群中，每一个Broker都支持客户端查询Kafka集群的信息，即每一个Broker都知晓其他Broker的信息。这些信息都被维护在每一个Broker的路由表中，了解了这一点，客户端发送读写命令的过程就呼之欲出了：</p>\n<ol>\n<li>任意访问一台Broker</li>\n<li>从这台Broker中获取路由表</li>\n<li>根据规则找到目标Partition，在路由表中找到哪个Broker上存有目标Partition，最后发送读写命令<ol>\n<li>找Partition的规则就是上文讲的<strong>轮询或哈希Key</strong>规则</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"生产者Producer\"><a href=\"#生产者Producer\" class=\"headerlink\" title=\"生产者Producer\"></a>生产者Producer</h2><p>生产者发送一条消息需要历经三个步骤：</p>\n<ul>\n<li>构建消息：将需要发送的信息打包成Kafka消息结构</li>\n<li>序列化消息：将消息序列化成二进制数据，以便在网络中传输</li>\n<li>寻找Broker：根据规则找到目标分区，接着依据路由表将消息发送到Partition对应的Broker</li>\n</ul>\n<p><strong>构建消息</strong><br>生产者需要将发送的信息打包成Kafka消息结构，接下来就详细看看消息结构的具体组成：<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105102410.png\" alt=\"image.png\"></p>\n<ul>\n<li>Key：根据Key的哈希值（取模）确定发送到Topic下的哪一个Partition上，一般是字符串类型，最终会被序列化为二进制数据</li>\n<li>Value：实际发送的数据</li>\n<li>Compression Type：指定压缩算法，该字段表明采用什么压缩算法对数据进行压缩，枚举值：None、gzip、lz4等</li>\n<li>Header：生产者额外想传输的数据就放在Header中，比如TraceID</li>\n<li>Partition+Offset：该字段在生产出来的时候是空的，消息发送到Kafka服务端后才会将具体的分区、偏移量写入该字段。Topic + Partition + Offset唯一确定一条消息</li>\n</ul>\n<p><strong>序列化</strong><br>序列化就是将消息从常规类型转换至二进制类型，以在网络中传输</p>\n<p><strong>发送模式</strong><br>在Go、Java的SDK中提供了三种消息发送模式：</p>\n<ol>\n<li>同步发送，生产者发送消息后，执行阻塞操作，等待Kafka服务端返回发送消息成功或异常结果。适用于生产者需要确保成功发送消息才能执行后续操作的场景。</li>\n<li>发了就忘，生产者发完消息就继续执行后续操作，不理会消息是否发送成功，也不采取措施应对发送异常</li>\n<li>异步发送，生产者发送消息的同时注册回调函数，不执行阻塞操作，而是继续执行后续的操作。当Kafka服务端返回发送消息的结果后，执行对应回调函数的内容</li>\n</ol>\n<p>三种发送模式实际上就是<strong>高性能和可靠性</strong>之间的权衡。同步发送模式可靠性强，但是效率不高，适用于保持数据一致性的场景；发了就忘性能高，可是不保证可靠性，因此适合在要求高性能的场景下使用；异步发送就是在二者之间的折中办法，使用于在需要时处理消息发送失败的情况</p>\n<h2 id=\"消费者Consumer\"><a href=\"#消费者Consumer\" class=\"headerlink\" title=\"消费者Consumer\"></a>消费者Consumer</h2><p>和生产者一样，消费者也需要集成Kafka客户端库，通过接口向Broker获取消息进行消费<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105141657.png\" alt=\"image.png\"><br>通过上图可得出一下结论：</p>\n<ol>\n<li>不同的消费者可以在同一时刻对同一Topic进行消费</li>\n<li>一个消费者可以在同一时刻对一个Topic下的不同Partition进行消费</li>\n<li>一个消费者同时消费多个Partition是无法保证消息有序性的</li>\n<li>一个消费者只消费一个Partition，消费顺序即生产顺序，是有序的</li>\n</ol>\n<p><strong>拉还是推</strong>？<br>消费者消费消息是通过<strong>拉模式</strong>进行的，也就是说，消费者先向Broker发送拉取消息的信号，接着Broker再将消息发送给消费者，而不是Broker主动向消费者推送消息。<br>选择这种拉模式的主要原因在于，消费者可以根据自身的资源利用率（CPU、内存等）适时地向Broker拉取消息，调节消费速度，避免因消费速度不合适导致资源浪费或超载</p>\n<p><strong>消费者Offset</strong><br>在Partition中，位于Offset之前的消息都已经被消费过了，而之后的消息则没有被消费。消费者组每消费完一个消息后，就向Broker提供该消息的Offset，表示该消息已经消费过了。消费者下一次拉取的消息就是Partition中Offset的下一位。消费者完成消费后，就将该消息的“Partition + Offset”字段信息发送给Broker，由Broker负责更新对应Partition的Offset<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105144221.png\" alt=\"image.png\"></p>\n<p><strong>主动提交和被动提交</strong><br>消费者组提交Offset分为两种方式：</p>\n<ul>\n<li>被动提交</li>\n<li>主动提交<br>被动提交就是定时周期性地向Broker提交最新已处理的消息。但是这种提交方式存在一致性问题，例如消费者正在处理offset为5的消息，此时发生了被动提交，需要告知Broker将Offset更新为5，但实际上offset为5的消息还没有完全处理完。如果此时发生了崩溃重启，那么该消息就会被丢失。</li>\n</ul>\n<p>手动提交则是一种更为稳妥的方式，当某条消息彻底处理好后，再主动向Broker提交消息，避免出现不一致的情况。<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250105150142.png\" alt=\"image.png\"></p>\n<p><strong>消费者组ConsumerGroup</strong><br>消费者组实质就是由多个消费者组成的集合，一个消费者组由一个GroupID唯一标识。<br>多个消费者组成消费者组，那么这些消费者必须有一些约束：</p>\n<ul>\n<li>在同一个消费者组中，一个Partition只能分配一个消费者</li>\n<li>同一个消费者组中，可以分派多个消费者</li>\n<li>不同消费者组可以同时消费同一个Topic<br>消费者组在消费者方面进行了水平扩容，提高了消费能力。</li>\n</ul>\n<p>消费者组咋眼一看没多大用处，实际上，消费者组带来的最大便利在于对分区的封装性，一个消费者组可以自动完成<strong>Re balance</strong>操作，使得Partition对于消费者是透明的。反之，消费者每次拉取消息都要指定Partition，这就导致Partition和消费者耦合在一块，Partition数量发生变动，消费者方面的代码就要随之变动</p>\n<p><strong>消费者组分区分配策略</strong><br> partition.assignment.strategy字段可以配置消费者组中多个消费者对于分区分配的规则：</p>\n<ul>\n<li>Range Assignor：基于范围的分配策略</li>\n<li>Round Robin Assignor：基于轮询的分配策略</li>\n<li>Sticky Assignor：优先保持当前的分配状态，尽量减少Rebalance过程中分区的移动</li>\n<li>CooperativeSticky Assignor：基本和Sticky Assignor策略一致，但是区别在于该协议将原来一次行对一大片分区进行Rebalance改为多次小规模的Rebalance操作，即渐进式Rebalance</li>\n</ul>\n<h2 id=\"Rebalance机制\"><a href=\"#Rebalance机制\" class=\"headerlink\" title=\"Rebalance机制\"></a>Rebalance机制</h2><p> Rebalance机制用于确保数据在消费者组中尽可能地负载均衡<br> 触发Rebalance的三个时机：</p>\n<ul>\n<li>加入新的消费者</li>\n<li>消费者减少，不论是正常关闭还是崩溃</li>\n<li>Topic下的Partition数量发生变化</li>\n</ul>\n<p><strong>再平衡的步骤</strong><br>再平衡操作需要经历五个阶段：</p>\n<ol>\n<li>暂停消费，消费者需要暂停正在进行的消费，防止重新分配过程中出现数据丢失或重复问题</li>\n<li>触发再分配，由消费者组协调器Group Coordinator（通常是一个Broker）触发再平衡</li>\n<li>分配分区，消费者配合协调器根据当前消费者和分区数量，重新分配主题的分区</li>\n<li>获取分配信息，重新分配完成后，消费者会从协调器拿到新的分区分配情况</li>\n<li>恢复消费，消费者收到新的分配后，恢复消费，开始处理新分区</li>\n</ol>\n<p>上文提到有四种消费组分区分配策略，这四种分配策略可以依据是否产生STW问题分为Eager和Incremental两种再平衡策略。其中前三种方案都是Eager策略，因为这三种分配策略在暂停消费者阶段会停止所有的消费行为，而Cooperative Sticky方式则只会暂停部分消费者，未被暂停的消费者仍能继续消费行为，但代价是Rebalance的时间被延长</p>\n<p><strong>Group Coordinator是什么</strong>？</p>\n"},{"description":"默认支持流程图，tabs面板，待办列表，作品页面","publish":false,"_content":"\n# 内置第三方插件能力\n\n部分内置组件（插件），来源 [vitepress.yiov.top](https://vitepress.yiov.top/plugin.html) 推荐\n\n## oml2d - 看板娘集成\n* Type：[oml2dOptions](https://oml2d.com/options/Options.html)\n\n为网站提供一个 Live2D 看板组件。\n\n:::tip 一点说明\n通过内置 [oh-my-live2d](https://oml2d.com) 实现, 可以通过 `oml2d` 选项配置。\n\n通过这个能力可以快速加入并定制属于自己的看板娘, 开启只需要为其传递一个 [配置选项](https://oml2d.com/options/Options.html) 即可\n:::\n\n以下是一个简单的使用示例，当模型加载成功时它将出现在您网站的左下角。\n\n```ts\nconst blogTheme = getThemeConfig({\n  oml2d: {\n    mobileDisplay: true,\n    models: [\n      {\n        path: 'https://registry.npmmirror.com/oml2d-models/latest/files/models/Senko_Normals/senko.model3.json'\n      }\n    ]\n  }\n})\n```\n效果图如下\n\n![](https://loclink-1259720482.cos.ap-beijing.myqcloud.com/image/%E5%BD%95%E5%B1%8F2024-03-11%2023.51.51.gif)\n\n之后您还可以前往[配置选项](https://oml2d.com/options/Options.html)查阅更多自定义内容\n\n:::tip 版本说明\n由于时间原因，主题内置的版本不一定都是最新的，可以通过 `resolutions` 配置指定要使用的版本。\n\n下面是使用示例，配置在 `package.json` 中，其它依赖覆盖版本也是这样操作。\n```json\n{\n  \"resolutions\": {\n    \"oh-my-live2d\": \"^0.17.0\"\n  }\n}\n```\n:::\n\n## task-checkbox\n* Type: `boolean | TaskCheckbox`\n\n支持渲染 markdown 任务列表，内置 [markdown-it-task-checkbox](https://github.com/linsir/markdown-it-task-checkbox) 插件提供支持\n\n* [ ] 🥔 TODO\n* [ ] 真不戳\n* [x] 内置任务列表\n\n语法如下\n```md\n* [ ] 🥔 TODO\n* [ ] 真不戳\n* [x] 内置任务列表\n```\n\n默认开启，你可以进一步配置\n\n:::code-group\n```ts [① 关闭]\nconst blogTheme = getThemeConfig({\n  taskCheckbox: false\n})\n```\n```ts [② 进一步配置]\nconst blogTheme = getThemeConfig({\n  taskCheckbox: {\n    // refer https://github.com/linsir/markdown-it-task-checkbox for options\n  }\n})\n```\n```ts [③ type]\ninterface TaskCheckbox {\n  disabled?: boolean\n  divWrap?: boolean\n  divClass?: string\n  idPrefix?: string\n  ulClass?: string\n  liClass?: string\n}\n```\n:::\n\n## timeline\n* Type: `boolean`\n* default: `true`\n\n提供 markdown 时间线语法，在 vitepress 中使用 markdown 渲染时间线（时间轴）样式。\n\n:::tip 一点说明\n内置 [vitepress-markdown-timeline](https://github.com/HanochMa/vitepress-markdown-timeline) 实现\n:::\n\n效果如下\n\n::: timeline 2023-05-24\n- **do some thing1**\n- do some thing2\n:::\n\n::: timeline 2023-05-23\ndo some thing3\ndo some thing4\n:::\n\n语法如下\n```md\n::: timeline 2023-05-24\n- **do some thing1**\n- do some thing2\n:::\n\n::: timeline 2023-05-23\ndo some thing3\ndo some thing4\n:::\n```\n\n:::code-group\n```ts [关闭]\nconst blogTheme = getThemeConfig({\n  timeline: false\n})\n```\n:::\n## tabs\n* Type: `boolean`\n\n支持局部的`tabs`面板，**默认开启**\n\n:::details 我之前手动安装配置了怎么办？\n① package.json 中移除 vitepress-plugin-tabs 依赖\n\n② .vitepress/theme/index.ts 中移除注册的组件`enhanceAppWithTabs`\n\n③ （可选）`getThemeConfig` 中移除配置项`tabs`\n:::\n:::tip 一点说明\n基于 [vitepress-plugin-tabs@0.2.0](https://www.npmjs.com/package/vitepress-plugin-tabs) 内置实现\n:::\n\n效果如下\n\n:::=tabs\n::tab1\n一些内容\n\n一些内容\n\n一些内容\n\n::tab2\n一些内容 。。。\n:::\n\n简单的使用方式如下（效果如上面的示例）\n\n```md\n:::=tabs\n::tab1\n一些内容\n\n一些内容\n\n一些内容\n\n::tab2\n一些内容 。。。\n:::\n```\n\n共享状态的使用方式如下\n\n```md\n:::=tabs=ab\n::a\na content\n\n::b\nb content\n:::\n\n:::=tabs=ab\n::a\na content 2\n\n::b\nb content 2\n:::\n```\n\n\n:::=tabs=ab\n::a\na content\n\n::b\nb content\n:::\n\n:::=tabs=ab\n::a\na content 2\n\n::b\nb content 2\n:::\n\n不需要也可以关闭\n\n```ts\n// .vitepress/blog-theme.ts\nconst blogTheme = getThemeConfig({\n  tabs: false\n})\n```\n\n## Mermaid - 图表\n* Type: `boolean`|`object`\n\n>通过解析类 Markdown 的文本语法来实现图表的创建和动态修改。\n\n:::tip 一点说明\n基于 [vitepress-plugin-mermaid](https://github.com/emersonbottero/vitepress-plugin-mermaid) 实现\n:::\n\n简单语法如下，详细流程图语法见 [Mermaid 中文文档](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n\n<pre>\n```mermaid\nflowchart TD\n  Start --> Stop\n```\n</pre>\n\n\n效果如下\n\n```mermaid\nflowchart TD\n  Start --> Stop\n```\n\n**默认关闭**，可以通过设置 `mermaid: true` 开启，或进行进一步配置。\n\n:::code-group\n```ts [① 开启]\nconst blogTheme = getThemeConfig({\n  mermaid: true\n})\n```\n```ts [② 进一步配置]\nconst blogTheme = getThemeConfig({\n  mermaid: {\n    // refer https://mermaid.js.org/config/setup/modules/mermaidAPI.html#mermaidapi-configuration-defaults for options\n  }\n})\n```\n:::\n\n下面看一下官方其它案例\n\n**时序图**\n```mermaid\nsequenceDiagram\nAlice->>John: Hello John, how are you?\nloop Healthcheck\n    John->>John: Fight against hypochondria\nend\nNote right of John: Rational thoughts!\nJohn-->>Alice: Great!\nJohn->>Bob: How about you?\nBob-->>John: Jolly good!\n```\n\n**甘特图**\n```mermaid\ngantt\n    section Section\n    Completed :done,    des1, 2014-01-06,2014-01-08\n    Active        :active,  des2, 2014-01-07, 3d\n    Parallel 1   :         des3, after des1, 1d\n    Parallel 2   :         des4, after des1, 1d\n    Parallel 3   :         des5, after des3, 1d\n    Parallel 4   :         des6, after des4, 1d\n```\n\n\n## UserWorksPage\n* Type: `UserWorks`\n\n用于作品列表展示\n\n效果如下，详见 [个人作品展示](https://theme.sugarat.top/work.html)\n\n![](https://img.cdn.sugarat.top/mdImg/MTY4NzA4ODczMzkwNg==687088733906)\n\n新建一个`works.md`文件，放入以下内容\n\n```md\n---\nlayout: page\ntitle: 个人作品展示\nsidebar: false\noutline: [2,3]\nsticky: 1\n---\n<UserWorksPage />\n```\n\n内容配置方式如下\n\n::: code-group\n\n```ts [default]\nconst blogTheme = getThemeConfig({\n  works: {\n    title: '个人项目/线上作品',\n    description: '记录开发的点点滴滴',\n    topTitle: '举些🌰',\n    list: [\n      {\n        title: '博客主题 @sugarat/theme',\n        description: '基于 vitepress 实现的博客主题',\n        time: {\n          start: '2023/01/29'\n        },\n        github: {\n          owner: 'ATQQ',\n          repo: 'sugar-blog',\n          branch: 'master',\n          path: 'packages/theme'\n        },\n        status: {\n          text: '自定义badge'\n        },\n        url: 'https://theme.sugarat.top',\n        cover:\n          'https://img.cdn.sugarat.top/mdImg/MTY3MzE3MDUxOTMwMw==673170519303',\n        tags: ['Vitepress', 'Vue'],\n        links: [\n          {\n            title: '一个简约风的VitePress博客主题',\n            url: 'https://juejin.cn/post/7196517835380293693'\n          }\n        ]\n      }\n    ]\n  }\n})\n```\n\n```ts [type]\ninterface UserWorks {\n  title: string\n  description?: string\n  topTitle?: string\n  list: UserWork[]\n}\ninterface UserWork {\n  title: string\n  description: string\n  time:\n  | string\n  | {\n    start: string\n    end?: string\n    lastupdate?: string\n  }\n  status?: {\n    text: string\n    type?: 'tip' | 'warning' | 'danger'\n  }\n  url?: string\n  github?:\n  | string\n  | {\n    owner: string\n    repo: string\n    branch?: string\n    path?: string\n  }\n  cover?:\n  | string\n  | string[]\n  | {\n    urls: string[]\n    layout?: 'swiper' | 'list'\n  }\n  links?: {\n    title: string\n    url: string\n  }[]\n  tags?: string[]\n  top?: number\n}\n```\n\n:::\n","source":"_posts/component.md","raw":"---\ndescription: 默认支持流程图，tabs面板，待办列表，作品页面\npublish: false\n---\n\n# 内置第三方插件能力\n\n部分内置组件（插件），来源 [vitepress.yiov.top](https://vitepress.yiov.top/plugin.html) 推荐\n\n## oml2d - 看板娘集成\n* Type：[oml2dOptions](https://oml2d.com/options/Options.html)\n\n为网站提供一个 Live2D 看板组件。\n\n:::tip 一点说明\n通过内置 [oh-my-live2d](https://oml2d.com) 实现, 可以通过 `oml2d` 选项配置。\n\n通过这个能力可以快速加入并定制属于自己的看板娘, 开启只需要为其传递一个 [配置选项](https://oml2d.com/options/Options.html) 即可\n:::\n\n以下是一个简单的使用示例，当模型加载成功时它将出现在您网站的左下角。\n\n```ts\nconst blogTheme = getThemeConfig({\n  oml2d: {\n    mobileDisplay: true,\n    models: [\n      {\n        path: 'https://registry.npmmirror.com/oml2d-models/latest/files/models/Senko_Normals/senko.model3.json'\n      }\n    ]\n  }\n})\n```\n效果图如下\n\n![](https://loclink-1259720482.cos.ap-beijing.myqcloud.com/image/%E5%BD%95%E5%B1%8F2024-03-11%2023.51.51.gif)\n\n之后您还可以前往[配置选项](https://oml2d.com/options/Options.html)查阅更多自定义内容\n\n:::tip 版本说明\n由于时间原因，主题内置的版本不一定都是最新的，可以通过 `resolutions` 配置指定要使用的版本。\n\n下面是使用示例，配置在 `package.json` 中，其它依赖覆盖版本也是这样操作。\n```json\n{\n  \"resolutions\": {\n    \"oh-my-live2d\": \"^0.17.0\"\n  }\n}\n```\n:::\n\n## task-checkbox\n* Type: `boolean | TaskCheckbox`\n\n支持渲染 markdown 任务列表，内置 [markdown-it-task-checkbox](https://github.com/linsir/markdown-it-task-checkbox) 插件提供支持\n\n* [ ] 🥔 TODO\n* [ ] 真不戳\n* [x] 内置任务列表\n\n语法如下\n```md\n* [ ] 🥔 TODO\n* [ ] 真不戳\n* [x] 内置任务列表\n```\n\n默认开启，你可以进一步配置\n\n:::code-group\n```ts [① 关闭]\nconst blogTheme = getThemeConfig({\n  taskCheckbox: false\n})\n```\n```ts [② 进一步配置]\nconst blogTheme = getThemeConfig({\n  taskCheckbox: {\n    // refer https://github.com/linsir/markdown-it-task-checkbox for options\n  }\n})\n```\n```ts [③ type]\ninterface TaskCheckbox {\n  disabled?: boolean\n  divWrap?: boolean\n  divClass?: string\n  idPrefix?: string\n  ulClass?: string\n  liClass?: string\n}\n```\n:::\n\n## timeline\n* Type: `boolean`\n* default: `true`\n\n提供 markdown 时间线语法，在 vitepress 中使用 markdown 渲染时间线（时间轴）样式。\n\n:::tip 一点说明\n内置 [vitepress-markdown-timeline](https://github.com/HanochMa/vitepress-markdown-timeline) 实现\n:::\n\n效果如下\n\n::: timeline 2023-05-24\n- **do some thing1**\n- do some thing2\n:::\n\n::: timeline 2023-05-23\ndo some thing3\ndo some thing4\n:::\n\n语法如下\n```md\n::: timeline 2023-05-24\n- **do some thing1**\n- do some thing2\n:::\n\n::: timeline 2023-05-23\ndo some thing3\ndo some thing4\n:::\n```\n\n:::code-group\n```ts [关闭]\nconst blogTheme = getThemeConfig({\n  timeline: false\n})\n```\n:::\n## tabs\n* Type: `boolean`\n\n支持局部的`tabs`面板，**默认开启**\n\n:::details 我之前手动安装配置了怎么办？\n① package.json 中移除 vitepress-plugin-tabs 依赖\n\n② .vitepress/theme/index.ts 中移除注册的组件`enhanceAppWithTabs`\n\n③ （可选）`getThemeConfig` 中移除配置项`tabs`\n:::\n:::tip 一点说明\n基于 [vitepress-plugin-tabs@0.2.0](https://www.npmjs.com/package/vitepress-plugin-tabs) 内置实现\n:::\n\n效果如下\n\n:::=tabs\n::tab1\n一些内容\n\n一些内容\n\n一些内容\n\n::tab2\n一些内容 。。。\n:::\n\n简单的使用方式如下（效果如上面的示例）\n\n```md\n:::=tabs\n::tab1\n一些内容\n\n一些内容\n\n一些内容\n\n::tab2\n一些内容 。。。\n:::\n```\n\n共享状态的使用方式如下\n\n```md\n:::=tabs=ab\n::a\na content\n\n::b\nb content\n:::\n\n:::=tabs=ab\n::a\na content 2\n\n::b\nb content 2\n:::\n```\n\n\n:::=tabs=ab\n::a\na content\n\n::b\nb content\n:::\n\n:::=tabs=ab\n::a\na content 2\n\n::b\nb content 2\n:::\n\n不需要也可以关闭\n\n```ts\n// .vitepress/blog-theme.ts\nconst blogTheme = getThemeConfig({\n  tabs: false\n})\n```\n\n## Mermaid - 图表\n* Type: `boolean`|`object`\n\n>通过解析类 Markdown 的文本语法来实现图表的创建和动态修改。\n\n:::tip 一点说明\n基于 [vitepress-plugin-mermaid](https://github.com/emersonbottero/vitepress-plugin-mermaid) 实现\n:::\n\n简单语法如下，详细流程图语法见 [Mermaid 中文文档](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n\n<pre>\n```mermaid\nflowchart TD\n  Start --> Stop\n```\n</pre>\n\n\n效果如下\n\n```mermaid\nflowchart TD\n  Start --> Stop\n```\n\n**默认关闭**，可以通过设置 `mermaid: true` 开启，或进行进一步配置。\n\n:::code-group\n```ts [① 开启]\nconst blogTheme = getThemeConfig({\n  mermaid: true\n})\n```\n```ts [② 进一步配置]\nconst blogTheme = getThemeConfig({\n  mermaid: {\n    // refer https://mermaid.js.org/config/setup/modules/mermaidAPI.html#mermaidapi-configuration-defaults for options\n  }\n})\n```\n:::\n\n下面看一下官方其它案例\n\n**时序图**\n```mermaid\nsequenceDiagram\nAlice->>John: Hello John, how are you?\nloop Healthcheck\n    John->>John: Fight against hypochondria\nend\nNote right of John: Rational thoughts!\nJohn-->>Alice: Great!\nJohn->>Bob: How about you?\nBob-->>John: Jolly good!\n```\n\n**甘特图**\n```mermaid\ngantt\n    section Section\n    Completed :done,    des1, 2014-01-06,2014-01-08\n    Active        :active,  des2, 2014-01-07, 3d\n    Parallel 1   :         des3, after des1, 1d\n    Parallel 2   :         des4, after des1, 1d\n    Parallel 3   :         des5, after des3, 1d\n    Parallel 4   :         des6, after des4, 1d\n```\n\n\n## UserWorksPage\n* Type: `UserWorks`\n\n用于作品列表展示\n\n效果如下，详见 [个人作品展示](https://theme.sugarat.top/work.html)\n\n![](https://img.cdn.sugarat.top/mdImg/MTY4NzA4ODczMzkwNg==687088733906)\n\n新建一个`works.md`文件，放入以下内容\n\n```md\n---\nlayout: page\ntitle: 个人作品展示\nsidebar: false\noutline: [2,3]\nsticky: 1\n---\n<UserWorksPage />\n```\n\n内容配置方式如下\n\n::: code-group\n\n```ts [default]\nconst blogTheme = getThemeConfig({\n  works: {\n    title: '个人项目/线上作品',\n    description: '记录开发的点点滴滴',\n    topTitle: '举些🌰',\n    list: [\n      {\n        title: '博客主题 @sugarat/theme',\n        description: '基于 vitepress 实现的博客主题',\n        time: {\n          start: '2023/01/29'\n        },\n        github: {\n          owner: 'ATQQ',\n          repo: 'sugar-blog',\n          branch: 'master',\n          path: 'packages/theme'\n        },\n        status: {\n          text: '自定义badge'\n        },\n        url: 'https://theme.sugarat.top',\n        cover:\n          'https://img.cdn.sugarat.top/mdImg/MTY3MzE3MDUxOTMwMw==673170519303',\n        tags: ['Vitepress', 'Vue'],\n        links: [\n          {\n            title: '一个简约风的VitePress博客主题',\n            url: 'https://juejin.cn/post/7196517835380293693'\n          }\n        ]\n      }\n    ]\n  }\n})\n```\n\n```ts [type]\ninterface UserWorks {\n  title: string\n  description?: string\n  topTitle?: string\n  list: UserWork[]\n}\ninterface UserWork {\n  title: string\n  description: string\n  time:\n  | string\n  | {\n    start: string\n    end?: string\n    lastupdate?: string\n  }\n  status?: {\n    text: string\n    type?: 'tip' | 'warning' | 'danger'\n  }\n  url?: string\n  github?:\n  | string\n  | {\n    owner: string\n    repo: string\n    branch?: string\n    path?: string\n  }\n  cover?:\n  | string\n  | string[]\n  | {\n    urls: string[]\n    layout?: 'swiper' | 'list'\n  }\n  links?: {\n    title: string\n    url: string\n  }[]\n  tags?: string[]\n  top?: number\n}\n```\n\n:::\n","slug":"component","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6g0006a5t2f9co6cx2","content":"<h1 id=\"内置第三方插件能力\"><a href=\"#内置第三方插件能力\" class=\"headerlink\" title=\"内置第三方插件能力\"></a>内置第三方插件能力</h1><p>部分内置组件（插件），来源 <a href=\"https://vitepress.yiov.top/plugin.html\">vitepress.yiov.top</a> 推荐</p>\n<h2 id=\"oml2d-看板娘集成\"><a href=\"#oml2d-看板娘集成\" class=\"headerlink\" title=\"oml2d - 看板娘集成\"></a>oml2d - 看板娘集成</h2><ul>\n<li>Type：<a href=\"https://oml2d.com/options/Options.html\">oml2dOptions</a></li>\n</ul>\n<p>为网站提供一个 Live2D 看板组件。</p>\n<p>:::tip 一点说明<br>通过内置 <a href=\"https://oml2d.com/\">oh-my-live2d</a> 实现, 可以通过 <code>oml2d</code> 选项配置。</p>\n<p>通过这个能力可以快速加入并定制属于自己的看板娘, 开启只需要为其传递一个 <a href=\"https://oml2d.com/options/Options.html\">配置选项</a> 即可<br>:::</p>\n<p>以下是一个简单的使用示例，当模型加载成功时它将出现在您网站的左下角。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">oml2d</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">mobileDisplay</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">models</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;https://registry.npmmirror.com/oml2d-models/latest/files/models/Senko_Normals/senko.model3.json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>效果图如下</p>\n<p><img src=\"https://loclink-1259720482.cos.ap-beijing.myqcloud.com/image/%E5%BD%95%E5%B1%8F2024-03-11%2023.51.51.gif\"></p>\n<p>之后您还可以前往<a href=\"https://oml2d.com/options/Options.html\">配置选项</a>查阅更多自定义内容</p>\n<p>:::tip 版本说明<br>由于时间原因，主题内置的版本不一定都是最新的，可以通过 <code>resolutions</code> 配置指定要使用的版本。</p>\n<p>下面是使用示例，配置在 <code>package.json</code> 中，其它依赖覆盖版本也是这样操作。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;resolutions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;oh-my-live2d&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^0.17.0&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"task-checkbox\"><a href=\"#task-checkbox\" class=\"headerlink\" title=\"task-checkbox\"></a>task-checkbox</h2><ul>\n<li>Type: <code>boolean | TaskCheckbox</code></li>\n</ul>\n<p>支持渲染 markdown 任务列表，内置 <a href=\"https://github.com/linsir/markdown-it-task-checkbox\">markdown-it-task-checkbox</a> 插件提供支持</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 🥔 TODO</li>\n<li><input disabled=\"\" type=\"checkbox\"> 真不戳</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 内置任务列表</li>\n</ul>\n<p>语法如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">*</span> [ ] 🥔 TODO</span><br><span class=\"line\"><span class=\"bullet\">*</span> [ ] 真不戳</span><br><span class=\"line\"><span class=\"bullet\">*</span> [x] 内置任务列表</span><br></pre></td></tr></table></figure>\n\n<p>默认开启，你可以进一步配置</p>\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[① 关闭]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">taskCheckbox</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[② 进一步配置]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">taskCheckbox</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// refer https://github.com/linsir/markdown-it-task-checkbox for options</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[③ type]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">TaskCheckbox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">disabled</span>?: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">  <span class=\"attr\">divWrap</span>?: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">  <span class=\"attr\">divClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">idPrefix</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">ulClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">liClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"timeline\"><a href=\"#timeline\" class=\"headerlink\" title=\"timeline\"></a>timeline</h2><ul>\n<li>Type: <code>boolean</code></li>\n<li>default: <code>true</code></li>\n</ul>\n<p>提供 markdown 时间线语法，在 vitepress 中使用 markdown 渲染时间线（时间轴）样式。</p>\n<p>:::tip 一点说明<br>内置 <a href=\"https://github.com/HanochMa/vitepress-markdown-timeline\">vitepress-markdown-timeline</a> 实现<br>:::</p>\n<p>效果如下</p>\n<p>::: timeline 2023-05-24</p>\n<ul>\n<li><strong>do some thing1</strong></li>\n<li>do some thing2<br>:::</li>\n</ul>\n<p>::: timeline 2023-05-23<br>do some thing3<br>do some thing4<br>:::</p>\n<p>语法如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::: timeline 2023-05-24</span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"strong\">**do some thing1**</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> do some thing2</span><br><span class=\"line\">:::</span><br><span class=\"line\"></span><br><span class=\"line\">::: timeline 2023-05-23</span><br><span class=\"line\">do some thing3</span><br><span class=\"line\">do some thing4</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[关闭]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">timeline</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"tabs\"><a href=\"#tabs\" class=\"headerlink\" title=\"tabs\"></a>tabs</h2><ul>\n<li>Type: <code>boolean</code></li>\n</ul>\n<p>支持局部的<code>tabs</code>面板，<strong>默认开启</strong></p>\n<p>:::details 我之前手动安装配置了怎么办？<br>① package.json 中移除 vitepress-plugin-tabs 依赖</p>\n<p>② .vitepress&#x2F;theme&#x2F;index.ts 中移除注册的组件<code>enhanceAppWithTabs</code></p>\n<p>③ （可选）<code>getThemeConfig</code> 中移除配置项<code>tabs</code><br>:::<br>:::tip 一点说明<br>基于 <a href=\"https://www.npmjs.com/package/vitepress-plugin-tabs\">vitepress-plugin-tabs@0.2.0</a> 内置实现<br>:::</p>\n<p>效果如下</p>\n<p>:::&#x3D;tabs<br>::tab1<br>一些内容</p>\n<p>一些内容</p>\n<p>一些内容</p>\n<p>::tab2<br>一些内容 。。。<br>:::</p>\n<p>简单的使用方式如下（效果如上面的示例）</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:::=tabs</span><br><span class=\"line\">::tab1</span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">::tab2</span><br><span class=\"line\">一些内容 。。。</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n<p>共享状态的使用方式如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:::=tabs=ab</span><br><span class=\"line\">::a</span><br><span class=\"line\">a content</span><br><span class=\"line\"></span><br><span class=\"line\">::b</span><br><span class=\"line\">b content</span><br><span class=\"line\">:::</span><br><span class=\"line\"></span><br><span class=\"line\">:::=tabs=ab</span><br><span class=\"line\">::a</span><br><span class=\"line\">a content 2</span><br><span class=\"line\"></span><br><span class=\"line\">::b</span><br><span class=\"line\">b content 2</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n\n<p>:::&#x3D;tabs&#x3D;ab<br>::a<br>a content</p>\n<p>::b<br>b content<br>:::</p>\n<p>:::&#x3D;tabs&#x3D;ab<br>::a<br>a content 2</p>\n<p>::b<br>b content 2<br>:::</p>\n<p>不需要也可以关闭</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .vitepress/blog-theme.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">tabs</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mermaid-图表\"><a href=\"#Mermaid-图表\" class=\"headerlink\" title=\"Mermaid - 图表\"></a>Mermaid - 图表</h2><ul>\n<li>Type: <code>boolean</code>|<code>object</code></li>\n</ul>\n<blockquote>\n<p>通过解析类 Markdown 的文本语法来实现图表的创建和动态修改。</p>\n</blockquote>\n<p>:::tip 一点说明<br>基于 <a href=\"https://github.com/emersonbottero/vitepress-plugin-mermaid\">vitepress-plugin-mermaid</a> 实现<br>:::</p>\n<p>简单语法如下，详细流程图语法见 <a href=\"https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md\">Mermaid 中文文档</a></p>\n<pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart TD</span><br><span class=\"line\">  Start --&gt; Stop</span><br></pre></td></tr></table></figure>\n</pre>\n\n\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart TD</span><br><span class=\"line\">  Start --&gt; Stop</span><br></pre></td></tr></table></figure>\n\n<p><strong>默认关闭</strong>，可以通过设置 <code>mermaid: true</code> 开启，或进行进一步配置。</p>\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[① 开启]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">mermaid</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[② 进一步配置]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">mermaid</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// refer https://mermaid.js.org/config/setup/modules/mermaidAPI.html#mermaidapi-configuration-defaults for options</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<p>下面看一下官方其它案例</p>\n<p><strong>时序图</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class=\"line\">loop Healthcheck</span><br><span class=\"line\">    John-&gt;&gt;John: Fight against hypochondria</span><br><span class=\"line\">end</span><br><span class=\"line\">Note right of John: Rational thoughts!</span><br><span class=\"line\">John--&gt;&gt;Alice: Great!</span><br><span class=\"line\">John-&gt;&gt;Bob: How about you?</span><br><span class=\"line\">Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>\n\n<p><strong>甘特图</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">    section Section</span><br><span class=\"line\">    Completed :done,    des1, 2014-01-06,2014-01-08</span><br><span class=\"line\">    Active        :active,  des2, 2014-01-07, 3d</span><br><span class=\"line\">    Parallel 1   :         des3, after des1, 1d</span><br><span class=\"line\">    Parallel 2   :         des4, after des1, 1d</span><br><span class=\"line\">    Parallel 3   :         des5, after des3, 1d</span><br><span class=\"line\">    Parallel 4   :         des6, after des4, 1d</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"UserWorksPage\"><a href=\"#UserWorksPage\" class=\"headerlink\" title=\"UserWorksPage\"></a>UserWorksPage</h2><ul>\n<li>Type: <code>UserWorks</code></li>\n</ul>\n<p>用于作品列表展示</p>\n<p>效果如下，详见 <a href=\"https://theme.sugarat.top/work.html\">个人作品展示</a></p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY4NzA4ODczMzkwNg==687088733906\"></p>\n<p>新建一个<code>works.md</code>文件，放入以下内容</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: page</span><br><span class=\"line\">title: 个人作品展示</span><br><span class=\"line\">sidebar: false</span><br><span class=\"line\">outline: [2,3]</span><br><span class=\"line\"><span class=\"section\">sticky: 1</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserWorksPage</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>内容配置方式如下</p>\n<p>::: code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[default]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">works</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;个人项目/线上作品&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">description</span>: <span class=\"string\">&#x27;记录开发的点点滴滴&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">topTitle</span>: <span class=\"string\">&#x27;举些🌰&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">&#x27;博客主题 @sugarat/theme&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">description</span>: <span class=\"string\">&#x27;基于 vitepress 实现的博客主题&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">time</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">start</span>: <span class=\"string\">&#x27;2023/01/29&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">github</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">owner</span>: <span class=\"string\">&#x27;ATQQ&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">repo</span>: <span class=\"string\">&#x27;sugar-blog&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">branch</span>: <span class=\"string\">&#x27;master&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">&#x27;packages/theme&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">status</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">text</span>: <span class=\"string\">&#x27;自定义badge&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://theme.sugarat.top&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">cover</span>:</span><br><span class=\"line\">          <span class=\"string\">&#x27;https://img.cdn.sugarat.top/mdImg/MTY3MzE3MDUxOTMwMw==673170519303&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">tags</span>: [<span class=\"string\">&#x27;Vitepress&#x27;</span>, <span class=\"string\">&#x27;Vue&#x27;</span>],</span><br><span class=\"line\">        <span class=\"attr\">links</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;一个简约风的VitePress博客主题&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://juejin.cn/post/7196517835380293693&#x27;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight ts\"><figcaption><span>[type]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">UserWorks</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">topTitle</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">list</span>: <span class=\"title class_\">UserWork</span>[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">UserWork</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">time</span>:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">start</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">end</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">lastupdate</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">status</span>?: &#123;</span><br><span class=\"line\">    <span class=\"attr\">text</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>?: <span class=\"string\">&#x27;tip&#x27;</span> | <span class=\"string\">&#x27;warning&#x27;</span> | <span class=\"string\">&#x27;danger&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">url</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">github</span>?:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">owner</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">repo</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">branch</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">cover</span>?:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">urls</span>: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">    <span class=\"attr\">layout</span>?: <span class=\"string\">&#x27;swiper&#x27;</span> | <span class=\"string\">&#x27;list&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">links</span>?: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;[]</span><br><span class=\"line\">  <span class=\"attr\">tags</span>?: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  <span class=\"attr\">top</span>?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>:::</p>\n","excerpt":"","more":"<h1 id=\"内置第三方插件能力\"><a href=\"#内置第三方插件能力\" class=\"headerlink\" title=\"内置第三方插件能力\"></a>内置第三方插件能力</h1><p>部分内置组件（插件），来源 <a href=\"https://vitepress.yiov.top/plugin.html\">vitepress.yiov.top</a> 推荐</p>\n<h2 id=\"oml2d-看板娘集成\"><a href=\"#oml2d-看板娘集成\" class=\"headerlink\" title=\"oml2d - 看板娘集成\"></a>oml2d - 看板娘集成</h2><ul>\n<li>Type：<a href=\"https://oml2d.com/options/Options.html\">oml2dOptions</a></li>\n</ul>\n<p>为网站提供一个 Live2D 看板组件。</p>\n<p>:::tip 一点说明<br>通过内置 <a href=\"https://oml2d.com/\">oh-my-live2d</a> 实现, 可以通过 <code>oml2d</code> 选项配置。</p>\n<p>通过这个能力可以快速加入并定制属于自己的看板娘, 开启只需要为其传递一个 <a href=\"https://oml2d.com/options/Options.html\">配置选项</a> 即可<br>:::</p>\n<p>以下是一个简单的使用示例，当模型加载成功时它将出现在您网站的左下角。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">oml2d</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">mobileDisplay</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">models</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;https://registry.npmmirror.com/oml2d-models/latest/files/models/Senko_Normals/senko.model3.json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>效果图如下</p>\n<p><img src=\"https://loclink-1259720482.cos.ap-beijing.myqcloud.com/image/%E5%BD%95%E5%B1%8F2024-03-11%2023.51.51.gif\"></p>\n<p>之后您还可以前往<a href=\"https://oml2d.com/options/Options.html\">配置选项</a>查阅更多自定义内容</p>\n<p>:::tip 版本说明<br>由于时间原因，主题内置的版本不一定都是最新的，可以通过 <code>resolutions</code> 配置指定要使用的版本。</p>\n<p>下面是使用示例，配置在 <code>package.json</code> 中，其它依赖覆盖版本也是这样操作。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;resolutions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;oh-my-live2d&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^0.17.0&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"task-checkbox\"><a href=\"#task-checkbox\" class=\"headerlink\" title=\"task-checkbox\"></a>task-checkbox</h2><ul>\n<li>Type: <code>boolean | TaskCheckbox</code></li>\n</ul>\n<p>支持渲染 markdown 任务列表，内置 <a href=\"https://github.com/linsir/markdown-it-task-checkbox\">markdown-it-task-checkbox</a> 插件提供支持</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 🥔 TODO</li>\n<li><input disabled=\"\" type=\"checkbox\"> 真不戳</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 内置任务列表</li>\n</ul>\n<p>语法如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">*</span> [ ] 🥔 TODO</span><br><span class=\"line\"><span class=\"bullet\">*</span> [ ] 真不戳</span><br><span class=\"line\"><span class=\"bullet\">*</span> [x] 内置任务列表</span><br></pre></td></tr></table></figure>\n\n<p>默认开启，你可以进一步配置</p>\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[① 关闭]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">taskCheckbox</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[② 进一步配置]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">taskCheckbox</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// refer https://github.com/linsir/markdown-it-task-checkbox for options</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[③ type]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">TaskCheckbox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">disabled</span>?: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">  <span class=\"attr\">divWrap</span>?: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">  <span class=\"attr\">divClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">idPrefix</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">ulClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">liClass</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"timeline\"><a href=\"#timeline\" class=\"headerlink\" title=\"timeline\"></a>timeline</h2><ul>\n<li>Type: <code>boolean</code></li>\n<li>default: <code>true</code></li>\n</ul>\n<p>提供 markdown 时间线语法，在 vitepress 中使用 markdown 渲染时间线（时间轴）样式。</p>\n<p>:::tip 一点说明<br>内置 <a href=\"https://github.com/HanochMa/vitepress-markdown-timeline\">vitepress-markdown-timeline</a> 实现<br>:::</p>\n<p>效果如下</p>\n<p>::: timeline 2023-05-24</p>\n<ul>\n<li><strong>do some thing1</strong></li>\n<li>do some thing2<br>:::</li>\n</ul>\n<p>::: timeline 2023-05-23<br>do some thing3<br>do some thing4<br>:::</p>\n<p>语法如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::: timeline 2023-05-24</span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"strong\">**do some thing1**</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> do some thing2</span><br><span class=\"line\">:::</span><br><span class=\"line\"></span><br><span class=\"line\">::: timeline 2023-05-23</span><br><span class=\"line\">do some thing3</span><br><span class=\"line\">do some thing4</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[关闭]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">timeline</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<h2 id=\"tabs\"><a href=\"#tabs\" class=\"headerlink\" title=\"tabs\"></a>tabs</h2><ul>\n<li>Type: <code>boolean</code></li>\n</ul>\n<p>支持局部的<code>tabs</code>面板，<strong>默认开启</strong></p>\n<p>:::details 我之前手动安装配置了怎么办？<br>① package.json 中移除 vitepress-plugin-tabs 依赖</p>\n<p>② .vitepress&#x2F;theme&#x2F;index.ts 中移除注册的组件<code>enhanceAppWithTabs</code></p>\n<p>③ （可选）<code>getThemeConfig</code> 中移除配置项<code>tabs</code><br>:::<br>:::tip 一点说明<br>基于 <a href=\"https://www.npmjs.com/package/vitepress-plugin-tabs\">vitepress-plugin-tabs@0.2.0</a> 内置实现<br>:::</p>\n<p>效果如下</p>\n<p>:::&#x3D;tabs<br>::tab1<br>一些内容</p>\n<p>一些内容</p>\n<p>一些内容</p>\n<p>::tab2<br>一些内容 。。。<br>:::</p>\n<p>简单的使用方式如下（效果如上面的示例）</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:::=tabs</span><br><span class=\"line\">::tab1</span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">一些内容</span><br><span class=\"line\"></span><br><span class=\"line\">::tab2</span><br><span class=\"line\">一些内容 。。。</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n<p>共享状态的使用方式如下</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:::=tabs=ab</span><br><span class=\"line\">::a</span><br><span class=\"line\">a content</span><br><span class=\"line\"></span><br><span class=\"line\">::b</span><br><span class=\"line\">b content</span><br><span class=\"line\">:::</span><br><span class=\"line\"></span><br><span class=\"line\">:::=tabs=ab</span><br><span class=\"line\">::a</span><br><span class=\"line\">a content 2</span><br><span class=\"line\"></span><br><span class=\"line\">::b</span><br><span class=\"line\">b content 2</span><br><span class=\"line\">:::</span><br></pre></td></tr></table></figure>\n\n\n<p>:::&#x3D;tabs&#x3D;ab<br>::a<br>a content</p>\n<p>::b<br>b content<br>:::</p>\n<p>:::&#x3D;tabs&#x3D;ab<br>::a<br>a content 2</p>\n<p>::b<br>b content 2<br>:::</p>\n<p>不需要也可以关闭</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .vitepress/blog-theme.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">tabs</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mermaid-图表\"><a href=\"#Mermaid-图表\" class=\"headerlink\" title=\"Mermaid - 图表\"></a>Mermaid - 图表</h2><ul>\n<li>Type: <code>boolean</code>|<code>object</code></li>\n</ul>\n<blockquote>\n<p>通过解析类 Markdown 的文本语法来实现图表的创建和动态修改。</p>\n</blockquote>\n<p>:::tip 一点说明<br>基于 <a href=\"https://github.com/emersonbottero/vitepress-plugin-mermaid\">vitepress-plugin-mermaid</a> 实现<br>:::</p>\n<p>简单语法如下，详细流程图语法见 <a href=\"https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md\">Mermaid 中文文档</a></p>\n<pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart TD</span><br><span class=\"line\">  Start --&gt; Stop</span><br></pre></td></tr></table></figure>\n</pre>\n\n\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart TD</span><br><span class=\"line\">  Start --&gt; Stop</span><br></pre></td></tr></table></figure>\n\n<p><strong>默认关闭</strong>，可以通过设置 <code>mermaid: true</code> 开启，或进行进一步配置。</p>\n<p>:::code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[① 开启]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">mermaid</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ts\"><figcaption><span>[② 进一步配置]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">mermaid</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// refer https://mermaid.js.org/config/setup/modules/mermaidAPI.html#mermaidapi-configuration-defaults for options</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>:::</p>\n<p>下面看一下官方其它案例</p>\n<p><strong>时序图</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class=\"line\">loop Healthcheck</span><br><span class=\"line\">    John-&gt;&gt;John: Fight against hypochondria</span><br><span class=\"line\">end</span><br><span class=\"line\">Note right of John: Rational thoughts!</span><br><span class=\"line\">John--&gt;&gt;Alice: Great!</span><br><span class=\"line\">John-&gt;&gt;Bob: How about you?</span><br><span class=\"line\">Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>\n\n<p><strong>甘特图</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">    section Section</span><br><span class=\"line\">    Completed :done,    des1, 2014-01-06,2014-01-08</span><br><span class=\"line\">    Active        :active,  des2, 2014-01-07, 3d</span><br><span class=\"line\">    Parallel 1   :         des3, after des1, 1d</span><br><span class=\"line\">    Parallel 2   :         des4, after des1, 1d</span><br><span class=\"line\">    Parallel 3   :         des5, after des3, 1d</span><br><span class=\"line\">    Parallel 4   :         des6, after des4, 1d</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"UserWorksPage\"><a href=\"#UserWorksPage\" class=\"headerlink\" title=\"UserWorksPage\"></a>UserWorksPage</h2><ul>\n<li>Type: <code>UserWorks</code></li>\n</ul>\n<p>用于作品列表展示</p>\n<p>效果如下，详见 <a href=\"https://theme.sugarat.top/work.html\">个人作品展示</a></p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY4NzA4ODczMzkwNg==687088733906\"></p>\n<p>新建一个<code>works.md</code>文件，放入以下内容</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">layout: page</span><br><span class=\"line\">title: 个人作品展示</span><br><span class=\"line\">sidebar: false</span><br><span class=\"line\">outline: [2,3]</span><br><span class=\"line\"><span class=\"section\">sticky: 1</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserWorksPage</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>内容配置方式如下</p>\n<p>::: code-group</p>\n<figure class=\"highlight ts\"><figcaption><span>[default]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blogTheme = <span class=\"title function_\">getThemeConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">works</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;个人项目/线上作品&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">description</span>: <span class=\"string\">&#x27;记录开发的点点滴滴&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">topTitle</span>: <span class=\"string\">&#x27;举些🌰&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">&#x27;博客主题 @sugarat/theme&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">description</span>: <span class=\"string\">&#x27;基于 vitepress 实现的博客主题&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">time</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">start</span>: <span class=\"string\">&#x27;2023/01/29&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">github</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">owner</span>: <span class=\"string\">&#x27;ATQQ&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">repo</span>: <span class=\"string\">&#x27;sugar-blog&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">branch</span>: <span class=\"string\">&#x27;master&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">&#x27;packages/theme&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">status</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">text</span>: <span class=\"string\">&#x27;自定义badge&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://theme.sugarat.top&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">cover</span>:</span><br><span class=\"line\">          <span class=\"string\">&#x27;https://img.cdn.sugarat.top/mdImg/MTY3MzE3MDUxOTMwMw==673170519303&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">tags</span>: [<span class=\"string\">&#x27;Vitepress&#x27;</span>, <span class=\"string\">&#x27;Vue&#x27;</span>],</span><br><span class=\"line\">        <span class=\"attr\">links</span>: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;一个简约风的VitePress博客主题&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://juejin.cn/post/7196517835380293693&#x27;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight ts\"><figcaption><span>[type]</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">UserWorks</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">topTitle</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">list</span>: <span class=\"title class_\">UserWork</span>[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">UserWork</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">time</span>:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">start</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">end</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">lastupdate</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">status</span>?: &#123;</span><br><span class=\"line\">    <span class=\"attr\">text</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>?: <span class=\"string\">&#x27;tip&#x27;</span> | <span class=\"string\">&#x27;warning&#x27;</span> | <span class=\"string\">&#x27;danger&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">url</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">github</span>?:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">owner</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">repo</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">branch</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">path</span>?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">cover</span>?:</span><br><span class=\"line\">  | <span class=\"built_in\">string</span></span><br><span class=\"line\">  | <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  | &#123;</span><br><span class=\"line\">    <span class=\"attr\">urls</span>: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">    <span class=\"attr\">layout</span>?: <span class=\"string\">&#x27;swiper&#x27;</span> | <span class=\"string\">&#x27;list&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"attr\">links</span>?: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  &#125;[]</span><br><span class=\"line\">  <span class=\"attr\">tags</span>?: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  <span class=\"attr\">top</span>?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>:::</p>\n"},{"title":"Git学习笔记","publish":true,"description":"浅学Git笔记","date":"2024-09-15T02:48:00.000Z","sticky":2,"_content":"\n# Git基础\n\n> 推荐两个学习Git的网站\n>\n> [Git在线练习](https://learngitbranching.js.org/?locale=zh_CN)\n>\n> [Git科普视频](https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.337.search-card.all.click&vd_source=a15269894d9b8114cb5f9bb663d22be9)\n>\n> “惟手熟尔”\n\n## 最小配置\n\n- 配置user信息\n\n  - 配置user.name:`git config --global user.name 'lyydsheep'`\n\n  - 配置user.email:`git config --global user.email '2230561977@qq.com'`\n\n  - ```Go\n    //显示不同级别的配置信息\n    git config --list --local\n    git config --list --global\n    git config --list --system\n    ```\n\n## 新建仓库\n\n在git中有两种新建仓库的方式\n\n- `git init`：在本地新建一个仓库\n- `git clone url`：从远程服务器上克隆一个仓库\n\n## 工作区和缓存区\n\n![image-20240915102716820](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151027874.png)\n\n## 添加和提交文件\n\n- `git status`：查看仓库状态\n- `git add`：添加到暂存区\n    - 可以使用通配符：`git add *.txt`\n    - 也可以使用目录：`git add .`\n- `git commit`：只提交**暂存区**中的内容，不会提交**工作区**的内容\n- `git log`：查看仓库历史提交记录\n    - `git log --oneline`：简洁地呈现日志\n\n## git reset回退版本\n\n使用`git reset`命令可以回退到指定的提交版本，`git reset`有三种模式\n\n- `git reset --soft xxx`：回退到xxx版本，且保存xxx版本之后的工作区和暂存区的修改\n- `git reset --hard xxx`：回退到xxx版本，并删除xxx版本之后工作区和暂存区的修改\n- `git reset --mixed xxx`：回退到xxx版本，只保留xxx版本之后工作区的修改\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025720.png)\n\n## 使用git diff查看差异\n\n- `git diff`命令可以对两个东西进行比较，用于查看差异\n  - 可以是工作区、暂存区、本地仓库之间的差异\n  - 可以是不同版本之间的差异\n  - 也可以是不同分支之间的差异\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024958.png)\n\n- `git diff`：默认查**看工作区**和**暂存区**之间的差异\n- `git diff HEAD`：查看**工作区、暂存区**和**本地仓库**的差异\n- `git diff cached`：查看**暂存区**和**本地仓库**之间的差异\n- `git diff <commit_hash> <commit_hash>`或者`git diff HEAD~ HEAD`：查看**不同提交**之间的差异\n- `git diff <branch_name> <branch_name>`：比较**不同分支**之间的差异\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025464.png)\n\n## 使用git rm删除文件\n\n- `git rm <file_name>`：**一次性将文件从工作区和暂存区中删除**\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025557.png)\n\n## .gitignore忽略文件\n\n在.gitignore文件中写入匹配符，git会忽略对被匹配上的文件的管理\n\n## SSH配置和克隆仓库\n\n[如何在同一电脑上生成配置多个ssh key 公钥 私钥（保姆级教程）](https://juejin.cn/post/7085718883079815176)\n\n- 在`.ssh`文件夹下，使用`ssh-keygen -t rsa -b 4096`生成私钥文件和公钥文件\n  - 将公钥文件的信息配置到GitHub上\n  - 保存好私钥文件中的信息\n- `git clone repo-address`：克隆一个远程仓库\n- `git push <remote> <branch>`：推送更新内容\n- `git pull <remote>`：拉取更新内容\n\n## 关联本地仓库和远程仓库\n\n- 添加远程仓库\n  - `git remote add 远程仓库名 远程仓库地址`\n  - `git push -u 远程仓库名 远程仓库分支`\n- 查看远程仓库\n  - `git remote -v`\n- 拉取远程仓库内容\n  - `git pull 远程仓库名 远程仓库分支:本地仓库分支`\n\n## 分支基本操作\n\n- 查看分支列表：`git branch`\n- 创建分支：`git branch <name>`\n- 切换分支：`git switch <name>`\n- 合并分支：`git merge <name>`，将`<name>`分支合并到当前的分支\n- 删除分支：\n  - `git branch -d <name>`：删除已合并的分支\n  - `git branch -D <name>`：强制删除分支\n\n\n\n## rebase和merge\n\n- `git rebase`：\n  - 优点：不会新增额外的提交记录，形成线性历史，比较直观和干净\n  - 缺点：会改变提交历史，改变了当前分支branch out节点，避免在共享分支使用\n  - 例如当前在main分支下：\n    - `git rebase dev`：将main分支的修改嫁接到dev分支后面\n    - ![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025165.png)\n- `git merge`：\n  - 优点：不会破坏原分支的提交记录，方便回溯和查看\n  - 缺点：会产生额外的提交节点，分支图比较复杂\n  - 例如当前在main分支下：\n    - `gie merge dev`：合并dev分支的修改\n\n# Git和GitHub操作指南\n\n## 初始化仓库并简单配置\n\n> 对仓库进行初始化\n\n- 使用`git init`完成对仓库的初始化操作\n\n> 对仓库进行简单配置\n\n- 使用`git config --global user.name \"lyydsheep\"`设置仓库的用户名\n- 同样地，可以为仓库配置邮箱`git config --global user.email \"2230561977@qq.com\"`\n  - 通过命令`git config --global --list `就可以**查看**我们为该仓库进行的配置\n\n关于`system`、 `global`、`local`\n\n- system-系统级: 在git安装以后，git的默认配置项都在这里\n- global-全局级：登录用户全局级别的git配置\n- local -仓库级: 对不同的仓库进行自定义配置\n\n三个关键字所能配置的**属性集合是一样的，**不同在于**优先级**\n\n```\nlocal > global > system\n```\n\n> 为仓库创建一个分支\n\n- 使用`git branch -M main`就能为仓库创建一个main分支\n\n## 最简单的Git工作流程：工作区、暂存区、仓库\n\n**相关命令**\n\n- Git status：用于查看当前仓库的状态\n- Git add filename:将filename文件添加至暂存区\n  - 单个添加太慢了，不如使用`Git add .`将**所有**修改过的文件添加至暂存区\n- Git commit -m \"comment\":将暂存区的文件提交至仓库中\n  - -m \"comment\":是为这次提交进行注释\n- Git log:查看历史提交记录\n\n> 命令与文件状态变化过程\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024558.png)\n\n## 将本地仓库同步到远程GitHub仓库\n\n为什么选择`SSH`协议而不是`HTTPS`协议？\n\n- 使用`HTTPS`协议可能在日后使用过程中需要**多次**输入用户名和密码，较麻烦\n- `SSH`协议**仅需第一次**配置好公私钥，今后就无需再输入用户名和密码\n\n具体步骤：\n\n1. 为本地仓库创建一个远程的GitHub仓库 \n   - 在GitHub网页上new一个仓库\n   - 通过`git remote add origin ``git@github.com``:lyydsheep/learn_gogogogo.git`命令可以将本地仓库和远程仓库进行关联\n   -  使用`git remote`可以查看远程仓库的名称\n2. 配置公私钥，获取`push`远程仓库的权限\n   -  使用`ssh-keygen -t rsa -C \"2230561977@qq.com\"`命令生成公私钥 \n   - 将公钥的具体内容复制到`ssh and GPG keys`模块中\n     - `Settings` -> `ssh and GPG keys` -> `New SSH key`\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024035.png)\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024012.png)\n\n1. 使用`git push -u origin main`命令将本地文件推送至远程仓库\n     - 前提是**本地仓库要有**`main`**分支**\n\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024373.png)\n\n[在Goland中使用Git进行协作开发的流程 | 青训营笔记 - 掘金](https://juejin.cn/post/7196266492269199419)\n\n**go** mod init 应用名称 就是在应用名称的根目录下，生成一个**go**.mod文件。\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024647.png)","source":"_posts/git学习笔记.md","raw":"---\ntitle: Git学习笔记\npublish: true\ndescription: 浅学Git笔记\ndate: 2024-09-15 10:48:00\ntag: Git\nsticky: 2\n---\n\n# Git基础\n\n> 推荐两个学习Git的网站\n>\n> [Git在线练习](https://learngitbranching.js.org/?locale=zh_CN)\n>\n> [Git科普视频](https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.337.search-card.all.click&vd_source=a15269894d9b8114cb5f9bb663d22be9)\n>\n> “惟手熟尔”\n\n## 最小配置\n\n- 配置user信息\n\n  - 配置user.name:`git config --global user.name 'lyydsheep'`\n\n  - 配置user.email:`git config --global user.email '2230561977@qq.com'`\n\n  - ```Go\n    //显示不同级别的配置信息\n    git config --list --local\n    git config --list --global\n    git config --list --system\n    ```\n\n## 新建仓库\n\n在git中有两种新建仓库的方式\n\n- `git init`：在本地新建一个仓库\n- `git clone url`：从远程服务器上克隆一个仓库\n\n## 工作区和缓存区\n\n![image-20240915102716820](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151027874.png)\n\n## 添加和提交文件\n\n- `git status`：查看仓库状态\n- `git add`：添加到暂存区\n    - 可以使用通配符：`git add *.txt`\n    - 也可以使用目录：`git add .`\n- `git commit`：只提交**暂存区**中的内容，不会提交**工作区**的内容\n- `git log`：查看仓库历史提交记录\n    - `git log --oneline`：简洁地呈现日志\n\n## git reset回退版本\n\n使用`git reset`命令可以回退到指定的提交版本，`git reset`有三种模式\n\n- `git reset --soft xxx`：回退到xxx版本，且保存xxx版本之后的工作区和暂存区的修改\n- `git reset --hard xxx`：回退到xxx版本，并删除xxx版本之后工作区和暂存区的修改\n- `git reset --mixed xxx`：回退到xxx版本，只保留xxx版本之后工作区的修改\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025720.png)\n\n## 使用git diff查看差异\n\n- `git diff`命令可以对两个东西进行比较，用于查看差异\n  - 可以是工作区、暂存区、本地仓库之间的差异\n  - 可以是不同版本之间的差异\n  - 也可以是不同分支之间的差异\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024958.png)\n\n- `git diff`：默认查**看工作区**和**暂存区**之间的差异\n- `git diff HEAD`：查看**工作区、暂存区**和**本地仓库**的差异\n- `git diff cached`：查看**暂存区**和**本地仓库**之间的差异\n- `git diff <commit_hash> <commit_hash>`或者`git diff HEAD~ HEAD`：查看**不同提交**之间的差异\n- `git diff <branch_name> <branch_name>`：比较**不同分支**之间的差异\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025464.png)\n\n## 使用git rm删除文件\n\n- `git rm <file_name>`：**一次性将文件从工作区和暂存区中删除**\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025557.png)\n\n## .gitignore忽略文件\n\n在.gitignore文件中写入匹配符，git会忽略对被匹配上的文件的管理\n\n## SSH配置和克隆仓库\n\n[如何在同一电脑上生成配置多个ssh key 公钥 私钥（保姆级教程）](https://juejin.cn/post/7085718883079815176)\n\n- 在`.ssh`文件夹下，使用`ssh-keygen -t rsa -b 4096`生成私钥文件和公钥文件\n  - 将公钥文件的信息配置到GitHub上\n  - 保存好私钥文件中的信息\n- `git clone repo-address`：克隆一个远程仓库\n- `git push <remote> <branch>`：推送更新内容\n- `git pull <remote>`：拉取更新内容\n\n## 关联本地仓库和远程仓库\n\n- 添加远程仓库\n  - `git remote add 远程仓库名 远程仓库地址`\n  - `git push -u 远程仓库名 远程仓库分支`\n- 查看远程仓库\n  - `git remote -v`\n- 拉取远程仓库内容\n  - `git pull 远程仓库名 远程仓库分支:本地仓库分支`\n\n## 分支基本操作\n\n- 查看分支列表：`git branch`\n- 创建分支：`git branch <name>`\n- 切换分支：`git switch <name>`\n- 合并分支：`git merge <name>`，将`<name>`分支合并到当前的分支\n- 删除分支：\n  - `git branch -d <name>`：删除已合并的分支\n  - `git branch -D <name>`：强制删除分支\n\n\n\n## rebase和merge\n\n- `git rebase`：\n  - 优点：不会新增额外的提交记录，形成线性历史，比较直观和干净\n  - 缺点：会改变提交历史，改变了当前分支branch out节点，避免在共享分支使用\n  - 例如当前在main分支下：\n    - `git rebase dev`：将main分支的修改嫁接到dev分支后面\n    - ![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025165.png)\n- `git merge`：\n  - 优点：不会破坏原分支的提交记录，方便回溯和查看\n  - 缺点：会产生额外的提交节点，分支图比较复杂\n  - 例如当前在main分支下：\n    - `gie merge dev`：合并dev分支的修改\n\n# Git和GitHub操作指南\n\n## 初始化仓库并简单配置\n\n> 对仓库进行初始化\n\n- 使用`git init`完成对仓库的初始化操作\n\n> 对仓库进行简单配置\n\n- 使用`git config --global user.name \"lyydsheep\"`设置仓库的用户名\n- 同样地，可以为仓库配置邮箱`git config --global user.email \"2230561977@qq.com\"`\n  - 通过命令`git config --global --list `就可以**查看**我们为该仓库进行的配置\n\n关于`system`、 `global`、`local`\n\n- system-系统级: 在git安装以后，git的默认配置项都在这里\n- global-全局级：登录用户全局级别的git配置\n- local -仓库级: 对不同的仓库进行自定义配置\n\n三个关键字所能配置的**属性集合是一样的，**不同在于**优先级**\n\n```\nlocal > global > system\n```\n\n> 为仓库创建一个分支\n\n- 使用`git branch -M main`就能为仓库创建一个main分支\n\n## 最简单的Git工作流程：工作区、暂存区、仓库\n\n**相关命令**\n\n- Git status：用于查看当前仓库的状态\n- Git add filename:将filename文件添加至暂存区\n  - 单个添加太慢了，不如使用`Git add .`将**所有**修改过的文件添加至暂存区\n- Git commit -m \"comment\":将暂存区的文件提交至仓库中\n  - -m \"comment\":是为这次提交进行注释\n- Git log:查看历史提交记录\n\n> 命令与文件状态变化过程\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024558.png)\n\n## 将本地仓库同步到远程GitHub仓库\n\n为什么选择`SSH`协议而不是`HTTPS`协议？\n\n- 使用`HTTPS`协议可能在日后使用过程中需要**多次**输入用户名和密码，较麻烦\n- `SSH`协议**仅需第一次**配置好公私钥，今后就无需再输入用户名和密码\n\n具体步骤：\n\n1. 为本地仓库创建一个远程的GitHub仓库 \n   - 在GitHub网页上new一个仓库\n   - 通过`git remote add origin ``git@github.com``:lyydsheep/learn_gogogogo.git`命令可以将本地仓库和远程仓库进行关联\n   -  使用`git remote`可以查看远程仓库的名称\n2. 配置公私钥，获取`push`远程仓库的权限\n   -  使用`ssh-keygen -t rsa -C \"2230561977@qq.com\"`命令生成公私钥 \n   - 将公钥的具体内容复制到`ssh and GPG keys`模块中\n     - `Settings` -> `ssh and GPG keys` -> `New SSH key`\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024035.png)\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024012.png)\n\n1. 使用`git push -u origin main`命令将本地文件推送至远程仓库\n     - 前提是**本地仓库要有**`main`**分支**\n\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024373.png)\n\n[在Goland中使用Git进行协作开发的流程 | 青训营笔记 - 掘金](https://juejin.cn/post/7196266492269199419)\n\n**go** mod init 应用名称 就是在应用名称的根目录下，生成一个**go**.mod文件。\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024647.png)","slug":"git学习笔记","published":1,"updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6h0008a5t29qz25cih","content":"<h1 id=\"Git基础\"><a href=\"#Git基础\" class=\"headerlink\" title=\"Git基础\"></a>Git基础</h1><blockquote>\n<p>推荐两个学习Git的网站</p>\n<p><a href=\"https://learngitbranching.js.org/?locale=zh_CN\">Git在线练习</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.337.search-card.all.click&vd_source=a15269894d9b8114cb5f9bb663d22be9\">Git科普视频</a></p>\n<p>“惟手熟尔”</p>\n</blockquote>\n<h2 id=\"最小配置\"><a href=\"#最小配置\" class=\"headerlink\" title=\"最小配置\"></a>最小配置</h2><ul>\n<li><p>配置user信息</p>\n<ul>\n<li><p>配置user.name:<code>git config --global user.name &#39;lyydsheep&#39;</code></p>\n</li>\n<li><p>配置user.email:<code>git config --global user.email &#39;2230561977@qq.com&#39;</code></p>\n</li>\n<li><pre><code class=\"Go\">//显示不同级别的配置信息\ngit config --list --local\ngit config --list --global\ngit config --list --system\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 新建仓库</span><br><span class=\"line\"></span><br><span class=\"line\">在git中有两种新建仓库的方式</span><br><span class=\"line\"></span><br><span class=\"line\">- `git init`：在本地新建一个仓库</span><br><span class=\"line\">- `git clone url`：从远程服务器上克隆一个仓库</span><br><span class=\"line\"></span><br><span class=\"line\">## 工作区和缓存区</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240915102716820](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151027874.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 添加和提交文件</span><br><span class=\"line\"></span><br><span class=\"line\">- `git status`：查看仓库状态</span><br><span class=\"line\">- `git add`：添加到暂存区</span><br><span class=\"line\">    - 可以使用通配符：`git add *.txt`</span><br><span class=\"line\">    - 也可以使用目录：`git add .`</span><br><span class=\"line\">- `git commit`：只提交**暂存区**中的内容，不会提交**工作区**的内容</span><br><span class=\"line\">- `git log`：查看仓库历史提交记录</span><br><span class=\"line\">    - `git log --oneline`：简洁地呈现日志</span><br><span class=\"line\"></span><br><span class=\"line\">## git reset回退版本</span><br><span class=\"line\"></span><br><span class=\"line\">使用`git reset`命令可以回退到指定的提交版本，`git reset`有三种模式</span><br><span class=\"line\"></span><br><span class=\"line\">- `git reset --soft xxx`：回退到xxx版本，且保存xxx版本之后的工作区和暂存区的修改</span><br><span class=\"line\">- `git reset --hard xxx`：回退到xxx版本，并删除xxx版本之后工作区和暂存区的修改</span><br><span class=\"line\">- `git reset --mixed xxx`：回退到xxx版本，只保留xxx版本之后工作区的修改</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025720.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用git diff查看差异</span><br><span class=\"line\"></span><br><span class=\"line\">- `git diff`命令可以对两个东西进行比较，用于查看差异</span><br><span class=\"line\">  - 可以是工作区、暂存区、本地仓库之间的差异</span><br><span class=\"line\">  - 可以是不同版本之间的差异</span><br><span class=\"line\">  - 也可以是不同分支之间的差异</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024958.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- `git diff`：默认查**看工作区**和**暂存区**之间的差异</span><br><span class=\"line\">- `git diff HEAD`：查看**工作区、暂存区**和**本地仓库**的差异</span><br><span class=\"line\">- `git diff cached`：查看**暂存区**和**本地仓库**之间的差异</span><br><span class=\"line\">- `git diff &lt;commit_hash&gt; &lt;commit_hash&gt;`或者`git diff HEAD~ HEAD`：查看**不同提交**之间的差异</span><br><span class=\"line\">- `git diff &lt;branch_name&gt; &lt;branch_name&gt;`：比较**不同分支**之间的差异</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025464.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用git rm删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">- `git rm &lt;file_name&gt;`：**一次性将文件从工作区和暂存区中删除**</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025557.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## .gitignore忽略文件</span><br><span class=\"line\"></span><br><span class=\"line\">在.gitignore文件中写入匹配符，git会忽略对被匹配上的文件的管理</span><br><span class=\"line\"></span><br><span class=\"line\">## SSH配置和克隆仓库</span><br><span class=\"line\"></span><br><span class=\"line\">[如何在同一电脑上生成配置多个ssh key 公钥 私钥（保姆级教程）](https://juejin.cn/post/7085718883079815176)</span><br><span class=\"line\"></span><br><span class=\"line\">- 在`.ssh`文件夹下，使用`ssh-keygen -t rsa -b 4096`生成私钥文件和公钥文件</span><br><span class=\"line\">  - 将公钥文件的信息配置到GitHub上</span><br><span class=\"line\">  - 保存好私钥文件中的信息</span><br><span class=\"line\">- `git clone repo-address`：克隆一个远程仓库</span><br><span class=\"line\">- `git push &lt;remote&gt; &lt;branch&gt;`：推送更新内容</span><br><span class=\"line\">- `git pull &lt;remote&gt;`：拉取更新内容</span><br><span class=\"line\"></span><br><span class=\"line\">## 关联本地仓库和远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">- 添加远程仓库</span><br><span class=\"line\">  - `git remote add 远程仓库名 远程仓库地址`</span><br><span class=\"line\">  - `git push -u 远程仓库名 远程仓库分支`</span><br><span class=\"line\">- 查看远程仓库</span><br><span class=\"line\">  - `git remote -v`</span><br><span class=\"line\">- 拉取远程仓库内容</span><br><span class=\"line\">  - `git pull 远程仓库名 远程仓库分支:本地仓库分支`</span><br><span class=\"line\"></span><br><span class=\"line\">## 分支基本操作</span><br><span class=\"line\"></span><br><span class=\"line\">- 查看分支列表：`git branch`</span><br><span class=\"line\">- 创建分支：`git branch &lt;name&gt;`</span><br><span class=\"line\">- 切换分支：`git switch &lt;name&gt;`</span><br><span class=\"line\">- 合并分支：`git merge &lt;name&gt;`，将`&lt;name&gt;`分支合并到当前的分支</span><br><span class=\"line\">- 删除分支：</span><br><span class=\"line\">  - `git branch -d &lt;name&gt;`：删除已合并的分支</span><br><span class=\"line\">  - `git branch -D &lt;name&gt;`：强制删除分支</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## rebase和merge</span><br><span class=\"line\"></span><br><span class=\"line\">- `git rebase`：</span><br><span class=\"line\">  - 优点：不会新增额外的提交记录，形成线性历史，比较直观和干净</span><br><span class=\"line\">  - 缺点：会改变提交历史，改变了当前分支branch out节点，避免在共享分支使用</span><br><span class=\"line\">  - 例如当前在main分支下：</span><br><span class=\"line\">    - `git rebase dev`：将main分支的修改嫁接到dev分支后面</span><br><span class=\"line\">    - ![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025165.png)</span><br><span class=\"line\">- `git merge`：</span><br><span class=\"line\">  - 优点：不会破坏原分支的提交记录，方便回溯和查看</span><br><span class=\"line\">  - 缺点：会产生额外的提交节点，分支图比较复杂</span><br><span class=\"line\">  - 例如当前在main分支下：</span><br><span class=\"line\">    - `gie merge dev`：合并dev分支的修改</span><br><span class=\"line\"></span><br><span class=\"line\"># Git和GitHub操作指南</span><br><span class=\"line\"></span><br><span class=\"line\">## 初始化仓库并简单配置</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 对仓库进行初始化</span><br><span class=\"line\"></span><br><span class=\"line\">- 使用`git init`完成对仓库的初始化操作</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 对仓库进行简单配置</span><br><span class=\"line\"></span><br><span class=\"line\">- 使用`git config --global user.name &quot;lyydsheep&quot;`设置仓库的用户名</span><br><span class=\"line\">- 同样地，可以为仓库配置邮箱`git config --global user.email &quot;2230561977@qq.com&quot;`</span><br><span class=\"line\">  - 通过命令`git config --global --list `就可以**查看**我们为该仓库进行的配置</span><br><span class=\"line\"></span><br><span class=\"line\">关于`system`、 `global`、`local`</span><br><span class=\"line\"></span><br><span class=\"line\">- system-系统级: 在git安装以后，git的默认配置项都在这里</span><br><span class=\"line\">- global-全局级：登录用户全局级别的git配置</span><br><span class=\"line\">- local -仓库级: 对不同的仓库进行自定义配置</span><br><span class=\"line\"></span><br><span class=\"line\">三个关键字所能配置的**属性集合是一样的，**不同在于**优先级**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>local &gt; global &gt; system</p>\n<pre><code>\n&gt; 为仓库创建一个分支\n\n- 使用`git branch -M main`就能为仓库创建一个main分支\n\n## 最简单的Git工作流程：工作区、暂存区、仓库\n\n**相关命令**\n\n- Git status：用于查看当前仓库的状态\n- Git add filename:将filename文件添加至暂存区\n  - 单个添加太慢了，不如使用`Git add .`将**所有**修改过的文件添加至暂存区\n- Git commit -m &quot;comment&quot;:将暂存区的文件提交至仓库中\n  - -m &quot;comment&quot;:是为这次提交进行注释\n- Git log:查看历史提交记录\n\n&gt; 命令与文件状态变化过程\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024558.png)\n\n## 将本地仓库同步到远程GitHub仓库\n\n为什么选择`SSH`协议而不是`HTTPS`协议？\n\n- 使用`HTTPS`协议可能在日后使用过程中需要**多次**输入用户名和密码，较麻烦\n- `SSH`协议**仅需第一次**配置好公私钥，今后就无需再输入用户名和密码\n\n具体步骤：\n\n1. 为本地仓库创建一个远程的GitHub仓库 \n   - 在GitHub网页上new一个仓库\n   - 通过`git remote add origin ``git@github.com``:lyydsheep/learn_gogogogo.git`命令可以将本地仓库和远程仓库进行关联\n   -  使用`git remote`可以查看远程仓库的名称\n2. 配置公私钥，获取`push`远程仓库的权限\n   -  使用`ssh-keygen -t rsa -C &quot;2230561977@qq.com&quot;`命令生成公私钥 \n   - 将公钥的具体内容复制到`ssh and GPG keys`模块中\n     - `Settings` -&gt; `ssh and GPG keys` -&gt; `New SSH key`\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024035.png)\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024012.png)\n\n1. 使用`git push -u origin main`命令将本地文件推送至远程仓库\n     - 前提是**本地仓库要有**`main`**分支**\n\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024373.png)\n\n[在Goland中使用Git进行协作开发的流程 | 青训营笔记 - 掘金](https://juejin.cn/post/7196266492269199419)\n\n**go** mod init 应用名称 就是在应用名称的根目录下，生成一个**go**.mod文件。\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024647.png)\n</code></pre>\n","excerpt":"","more":"<h1 id=\"Git基础\"><a href=\"#Git基础\" class=\"headerlink\" title=\"Git基础\"></a>Git基础</h1><blockquote>\n<p>推荐两个学习Git的网站</p>\n<p><a href=\"https://learngitbranching.js.org/?locale=zh_CN\">Git在线练习</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1HM411377j/?spm_id_from=333.337.search-card.all.click&vd_source=a15269894d9b8114cb5f9bb663d22be9\">Git科普视频</a></p>\n<p>“惟手熟尔”</p>\n</blockquote>\n<h2 id=\"最小配置\"><a href=\"#最小配置\" class=\"headerlink\" title=\"最小配置\"></a>最小配置</h2><ul>\n<li><p>配置user信息</p>\n<ul>\n<li><p>配置user.name:<code>git config --global user.name &#39;lyydsheep&#39;</code></p>\n</li>\n<li><p>配置user.email:<code>git config --global user.email &#39;2230561977@qq.com&#39;</code></p>\n</li>\n<li><pre><code class=\"Go\">//显示不同级别的配置信息\ngit config --list --local\ngit config --list --global\ngit config --list --system\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 新建仓库</span><br><span class=\"line\"></span><br><span class=\"line\">在git中有两种新建仓库的方式</span><br><span class=\"line\"></span><br><span class=\"line\">- `git init`：在本地新建一个仓库</span><br><span class=\"line\">- `git clone url`：从远程服务器上克隆一个仓库</span><br><span class=\"line\"></span><br><span class=\"line\">## 工作区和缓存区</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240915102716820](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151027874.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 添加和提交文件</span><br><span class=\"line\"></span><br><span class=\"line\">- `git status`：查看仓库状态</span><br><span class=\"line\">- `git add`：添加到暂存区</span><br><span class=\"line\">    - 可以使用通配符：`git add *.txt`</span><br><span class=\"line\">    - 也可以使用目录：`git add .`</span><br><span class=\"line\">- `git commit`：只提交**暂存区**中的内容，不会提交**工作区**的内容</span><br><span class=\"line\">- `git log`：查看仓库历史提交记录</span><br><span class=\"line\">    - `git log --oneline`：简洁地呈现日志</span><br><span class=\"line\"></span><br><span class=\"line\">## git reset回退版本</span><br><span class=\"line\"></span><br><span class=\"line\">使用`git reset`命令可以回退到指定的提交版本，`git reset`有三种模式</span><br><span class=\"line\"></span><br><span class=\"line\">- `git reset --soft xxx`：回退到xxx版本，且保存xxx版本之后的工作区和暂存区的修改</span><br><span class=\"line\">- `git reset --hard xxx`：回退到xxx版本，并删除xxx版本之后工作区和暂存区的修改</span><br><span class=\"line\">- `git reset --mixed xxx`：回退到xxx版本，只保留xxx版本之后工作区的修改</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025720.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用git diff查看差异</span><br><span class=\"line\"></span><br><span class=\"line\">- `git diff`命令可以对两个东西进行比较，用于查看差异</span><br><span class=\"line\">  - 可以是工作区、暂存区、本地仓库之间的差异</span><br><span class=\"line\">  - 可以是不同版本之间的差异</span><br><span class=\"line\">  - 也可以是不同分支之间的差异</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024958.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- `git diff`：默认查**看工作区**和**暂存区**之间的差异</span><br><span class=\"line\">- `git diff HEAD`：查看**工作区、暂存区**和**本地仓库**的差异</span><br><span class=\"line\">- `git diff cached`：查看**暂存区**和**本地仓库**之间的差异</span><br><span class=\"line\">- `git diff &lt;commit_hash&gt; &lt;commit_hash&gt;`或者`git diff HEAD~ HEAD`：查看**不同提交**之间的差异</span><br><span class=\"line\">- `git diff &lt;branch_name&gt; &lt;branch_name&gt;`：比较**不同分支**之间的差异</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025464.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用git rm删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">- `git rm &lt;file_name&gt;`：**一次性将文件从工作区和暂存区中删除**</span><br><span class=\"line\"></span><br><span class=\"line\">![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025557.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## .gitignore忽略文件</span><br><span class=\"line\"></span><br><span class=\"line\">在.gitignore文件中写入匹配符，git会忽略对被匹配上的文件的管理</span><br><span class=\"line\"></span><br><span class=\"line\">## SSH配置和克隆仓库</span><br><span class=\"line\"></span><br><span class=\"line\">[如何在同一电脑上生成配置多个ssh key 公钥 私钥（保姆级教程）](https://juejin.cn/post/7085718883079815176)</span><br><span class=\"line\"></span><br><span class=\"line\">- 在`.ssh`文件夹下，使用`ssh-keygen -t rsa -b 4096`生成私钥文件和公钥文件</span><br><span class=\"line\">  - 将公钥文件的信息配置到GitHub上</span><br><span class=\"line\">  - 保存好私钥文件中的信息</span><br><span class=\"line\">- `git clone repo-address`：克隆一个远程仓库</span><br><span class=\"line\">- `git push &lt;remote&gt; &lt;branch&gt;`：推送更新内容</span><br><span class=\"line\">- `git pull &lt;remote&gt;`：拉取更新内容</span><br><span class=\"line\"></span><br><span class=\"line\">## 关联本地仓库和远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">- 添加远程仓库</span><br><span class=\"line\">  - `git remote add 远程仓库名 远程仓库地址`</span><br><span class=\"line\">  - `git push -u 远程仓库名 远程仓库分支`</span><br><span class=\"line\">- 查看远程仓库</span><br><span class=\"line\">  - `git remote -v`</span><br><span class=\"line\">- 拉取远程仓库内容</span><br><span class=\"line\">  - `git pull 远程仓库名 远程仓库分支:本地仓库分支`</span><br><span class=\"line\"></span><br><span class=\"line\">## 分支基本操作</span><br><span class=\"line\"></span><br><span class=\"line\">- 查看分支列表：`git branch`</span><br><span class=\"line\">- 创建分支：`git branch &lt;name&gt;`</span><br><span class=\"line\">- 切换分支：`git switch &lt;name&gt;`</span><br><span class=\"line\">- 合并分支：`git merge &lt;name&gt;`，将`&lt;name&gt;`分支合并到当前的分支</span><br><span class=\"line\">- 删除分支：</span><br><span class=\"line\">  - `git branch -d &lt;name&gt;`：删除已合并的分支</span><br><span class=\"line\">  - `git branch -D &lt;name&gt;`：强制删除分支</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## rebase和merge</span><br><span class=\"line\"></span><br><span class=\"line\">- `git rebase`：</span><br><span class=\"line\">  - 优点：不会新增额外的提交记录，形成线性历史，比较直观和干净</span><br><span class=\"line\">  - 缺点：会改变提交历史，改变了当前分支branch out节点，避免在共享分支使用</span><br><span class=\"line\">  - 例如当前在main分支下：</span><br><span class=\"line\">    - `git rebase dev`：将main分支的修改嫁接到dev分支后面</span><br><span class=\"line\">    - ![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151025165.png)</span><br><span class=\"line\">- `git merge`：</span><br><span class=\"line\">  - 优点：不会破坏原分支的提交记录，方便回溯和查看</span><br><span class=\"line\">  - 缺点：会产生额外的提交节点，分支图比较复杂</span><br><span class=\"line\">  - 例如当前在main分支下：</span><br><span class=\"line\">    - `gie merge dev`：合并dev分支的修改</span><br><span class=\"line\"></span><br><span class=\"line\"># Git和GitHub操作指南</span><br><span class=\"line\"></span><br><span class=\"line\">## 初始化仓库并简单配置</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 对仓库进行初始化</span><br><span class=\"line\"></span><br><span class=\"line\">- 使用`git init`完成对仓库的初始化操作</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 对仓库进行简单配置</span><br><span class=\"line\"></span><br><span class=\"line\">- 使用`git config --global user.name &quot;lyydsheep&quot;`设置仓库的用户名</span><br><span class=\"line\">- 同样地，可以为仓库配置邮箱`git config --global user.email &quot;2230561977@qq.com&quot;`</span><br><span class=\"line\">  - 通过命令`git config --global --list `就可以**查看**我们为该仓库进行的配置</span><br><span class=\"line\"></span><br><span class=\"line\">关于`system`、 `global`、`local`</span><br><span class=\"line\"></span><br><span class=\"line\">- system-系统级: 在git安装以后，git的默认配置项都在这里</span><br><span class=\"line\">- global-全局级：登录用户全局级别的git配置</span><br><span class=\"line\">- local -仓库级: 对不同的仓库进行自定义配置</span><br><span class=\"line\"></span><br><span class=\"line\">三个关键字所能配置的**属性集合是一样的，**不同在于**优先级**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>local &gt; global &gt; system</p>\n<pre><code>\n&gt; 为仓库创建一个分支\n\n- 使用`git branch -M main`就能为仓库创建一个main分支\n\n## 最简单的Git工作流程：工作区、暂存区、仓库\n\n**相关命令**\n\n- Git status：用于查看当前仓库的状态\n- Git add filename:将filename文件添加至暂存区\n  - 单个添加太慢了，不如使用`Git add .`将**所有**修改过的文件添加至暂存区\n- Git commit -m &quot;comment&quot;:将暂存区的文件提交至仓库中\n  - -m &quot;comment&quot;:是为这次提交进行注释\n- Git log:查看历史提交记录\n\n&gt; 命令与文件状态变化过程\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024558.png)\n\n## 将本地仓库同步到远程GitHub仓库\n\n为什么选择`SSH`协议而不是`HTTPS`协议？\n\n- 使用`HTTPS`协议可能在日后使用过程中需要**多次**输入用户名和密码，较麻烦\n- `SSH`协议**仅需第一次**配置好公私钥，今后就无需再输入用户名和密码\n\n具体步骤：\n\n1. 为本地仓库创建一个远程的GitHub仓库 \n   - 在GitHub网页上new一个仓库\n   - 通过`git remote add origin ``git@github.com``:lyydsheep/learn_gogogogo.git`命令可以将本地仓库和远程仓库进行关联\n   -  使用`git remote`可以查看远程仓库的名称\n2. 配置公私钥，获取`push`远程仓库的权限\n   -  使用`ssh-keygen -t rsa -C &quot;2230561977@qq.com&quot;`命令生成公私钥 \n   - 将公钥的具体内容复制到`ssh and GPG keys`模块中\n     - `Settings` -&gt; `ssh and GPG keys` -&gt; `New SSH key`\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024035.png)\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024012.png)\n\n1. 使用`git push -u origin main`命令将本地文件推送至远程仓库\n     - 前提是**本地仓库要有**`main`**分支**\n\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024373.png)\n\n[在Goland中使用Git进行协作开发的流程 | 青训营笔记 - 掘金](https://juejin.cn/post/7196266492269199419)\n\n**go** mod init 应用名称 就是在应用名称的根目录下，生成一个**go**.mod文件。\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202409151024647.png)\n</code></pre>\n"},{"title":"goroutine、channel","publish":true,"description":"记录一些有关goroutine的知识点","date":"2024-09-26T16:00:00.000Z","sticky":2,"_content":"\n# goroutine\n\ngoroutine是Go语言中的轻量级线程的实现，由**Go运行时管理**，是Go程序中最小的并发执行单位。并且传统意义上的协程是不支持并发的，而**goroutine支持并发**，同时goroutine可以运行在一个或多个线程上\n\n**goroutine大小为2kb，可以动态增大**\n\n## 简述\n\n### goroutine的运行机制\n\n在Go程序中，`main`函数是程序的入口，当程序开始执行`main`函数时，就会创建一个**主goroutine**，这个主goroutine是**全局唯一的**并且代表着整个Go程序的生命周期\n\n在代码中，可以使用`go`关键字轻松创建出一个goroutine\n\n🌰：\n\n```go\nfunc sum(a, b int) {\n    println(a+b)\n}\n\nfunc main() {\n    go sum(1, 2)\n}\n```\n\n在上述代码中，**`go`关键字+函数调用**表示创建一个goroutine并在这个goroutine中运行`sum`函数。但上述代码的运行结果并不会符合我们的预期，这是因为**goroutine的运行机制是：在主Goroutine结束之后，其他所有的goroutine都会直接退出**，上述代码中的主goroutine结束的比子goroutine更快，所以控制台会没有任何输出😂\n\n### goroutine的特点\n\n- 是一种轻量级“线程”，类似于协程\n- **非抢占式（即不会被中断）多任务处理，有协程主动交出运行权力**\n- 编译器/解释器/虚拟机层面的多任务（不懂🙃）\n- 多个协程可以在一个或多个线程上运行\n\n由于goroutine是非抢占式的，一个goroutine可能会在一下时机主动交出运行权力\n\n- I/O，select\n- channel\n- 等待锁\n- 函数调用\n- runtime.Gosched()\n\n### WaitGroup：多个goroutine并发执行\n\n前文阐述了当主goroutine结束之后，其他的goroutine都会被强制结束。但是很多情况下，主goroutine需要在其他goroutine结束之后再结束，一种很简单的方法就是让主goroutine睡几秒\n\n```go\ntime.Sleep(time.Second)\n```\n\n另一种更优雅的方法就是使用`sync.WaitGroup`结构体，实现多个goroutine的同步\n\n`sync.WaitGroup`结构体有三个方法\n\n- `Add(delta)`：向内部计数器中添加增量`delta`，其中`delta`可正可负\n  - 一般在启动goroutine之前调用\n- `Done()`：使内部计数器`-1`，相当于`Add(-1)`\n  - 一般在goroutine即将结束时执行，可配合`defer`关键字共同使用\n- `Wait()`：阻塞当前goroutine直至内部计数器减少至0\n\n⚠️：调用`Wait()` 函数可能导致死锁，造成程序崩溃\n\n## Go并发的实现原理\n\n> DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING. \n\n在Go中有两种并发形式：传统共享内存的方式和CSP（`communicating sequential processes`）并发模型\n\n### 共享内存\n\n在多个线程共享内存以共享数据的模式下，通过**加锁**实现并发安全\n\n在Go中有两种锁：**互斥锁（Mutex）**、**读写锁（RWMutex）**\n\n两种锁的使用方式如下：\n\n```go\n// Mutex\n\tvar mux sync.Mutex\n\tmux.Lock()\n\t// do something\n\tmux.Unlock()\n\n// RWMutx\n\tvar mux sync.RWMutex\n\tmux.RLock()\n\t// 允许多个读者\n\tmux.RUnlock()\n\tmux.Lock()\n\t// 只有一个写者\n\tmux.Unlock()\n```\n\n区别：只有一个goroutine能拿到**互斥锁**，其他goroutine则会被阻塞；允许有多个goroutine拿到**读锁**，而只有一个goroutine能拿到**写锁**\n\n⚠️：如果将带有锁结构的变量赋值给其他变量，**锁的状态会被复制**\n\n```go\nfunc main() {\n\tvar mux sync.Mutex\n\tvar wg sync.WaitGroup\n\tdefer mux.Unlock()\n\tmux.Lock()\n\twg.Add(1)\n\tgo func(mux sync.Mutex) {\n\t\tdefer func() {\n\t\t\tmux.Unlock()\n\t\t\twg.Done()\n\t\t}()\n\t\tmux.Lock() // deadlock\n\t}(mux)\n\twg.Wait()\n}\n```\n\n\n\n### channel\n\n简单地说，channel就是**收发数据的通道**\n\n声明一个channel要使用`make`函数进行**初始化**，否则声明出来的channel为`nil`\n\n```go\nvar ch chan int\nvar ch [size]chan int\n\nch = make(chan int, size)\n```\n\n#### 常见的使用方法\n\n🕐：\n\n```go\nch <- 1 // 写入一个数据\nv := <-ch // 读取一个数据\n```\n\n⚠️：如果channel没有缓冲区，那么写数据和读数据必定是成对出现的\n\n```go\nclose(ch) // 关闭通道\n```\n\n当关闭通道之后，**不能再向通道中写数据，但是能从通道中读数据，如果通道中还有值则读出对应的值，否则读出零值**\n\n这就导致一个问题：当我读出零值时，无法判断出这是因为**通道关闭还是写入的值确确实实就是零值**\n\n🕑：故需要使用通道的**判定读法**：\n\n```go\nval, ok := <-ch\nif ok {\n    fmt.Printf(\"get val %d\\n\", val)\n} else {\n    fmt.Println(\"closed\")\n}\n```\n\n当管道关闭且读取完毕后，ok为`false`\n\n🕒：有的时候某一个goroutine需要一直监听着管道中的数据，只要管道中有数据就立马读取出来，直至管道关闭\n\n在Go中可以使用`fro range`做到持续监听管道中的数据\n\n```go\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tfor v := range ch {\n\t\t\tfmt.Println(v)\n\t\t}\n\t}()\n\ttime.Sleep(time.Second)\n\tch <- 1\n\ttime.Sleep(time.Second)\n\tch <- 2\n\tclose(ch)\n\ttime.Sleep(time.Second)\n}\n```\n\n### 双向channel和单向channel\n\nchannel可以根据其功能划分为**双向channel和单向channel**，其中双向channel既可以读又可以写，而单向channel要么只读，要么只写\n\n可以通过**类型别名**的方式定义单向channel\n\n🌰：\n\n```go\ntype RChannel = <-chan int\ntype WChannel = chan<- int\n\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tvar w WChannel\n\t\tw = ch\n\t\tw <- 1\n\t}()\n\tgo func() {\n\t\tvar r RChannel\n\t\tr = ch\n\t\tfmt.Println(<-r)\n\t}()\n\ttime.Sleep(time.Second)\n}\n```\n\n### 有缓冲channel和无缓冲channel\n\n无缓冲channel可以理解为是**同步模式**，即一个写，另一个立马读，如果没有读者，写者也会被阻塞\n\n有缓冲channel则可以作为**异步模式**，在缓冲区未满的情况下，即使没有读者，写者也能向通道中写入数据\n\n但当缓冲区满了后，写者想要继续写入数据则会被阻塞，退化成**同步模式**\n\n### 总结\n\n- 关闭一个未初始化的channel会产生panic\n- channel只能关闭一次，对同一channel多次关闭会发生panic\n- 向一个已经关闭的channel写入数据，会发生panic\n- 从一个已经关闭的channel读取数据，会读出缓冲区中的值，当缓冲区没有数据（或没有缓冲区）时，则会读出对应类型的零值\n- channel的读端和写端都可以由多个goroutine操作，当写端被一个goroutine关闭时，读端的多个goroutine都会收到管道关闭的消息\n- channel是并发安全的\n","source":"_posts/goroutine.md","raw":"---\ntitle: goroutine、channel\npublish: true\ndescription: 记录一些有关goroutine的知识点\ndate: 2024-09-27\ntag: Golang\nsticky: 2\n---\n\n# goroutine\n\ngoroutine是Go语言中的轻量级线程的实现，由**Go运行时管理**，是Go程序中最小的并发执行单位。并且传统意义上的协程是不支持并发的，而**goroutine支持并发**，同时goroutine可以运行在一个或多个线程上\n\n**goroutine大小为2kb，可以动态增大**\n\n## 简述\n\n### goroutine的运行机制\n\n在Go程序中，`main`函数是程序的入口，当程序开始执行`main`函数时，就会创建一个**主goroutine**，这个主goroutine是**全局唯一的**并且代表着整个Go程序的生命周期\n\n在代码中，可以使用`go`关键字轻松创建出一个goroutine\n\n🌰：\n\n```go\nfunc sum(a, b int) {\n    println(a+b)\n}\n\nfunc main() {\n    go sum(1, 2)\n}\n```\n\n在上述代码中，**`go`关键字+函数调用**表示创建一个goroutine并在这个goroutine中运行`sum`函数。但上述代码的运行结果并不会符合我们的预期，这是因为**goroutine的运行机制是：在主Goroutine结束之后，其他所有的goroutine都会直接退出**，上述代码中的主goroutine结束的比子goroutine更快，所以控制台会没有任何输出😂\n\n### goroutine的特点\n\n- 是一种轻量级“线程”，类似于协程\n- **非抢占式（即不会被中断）多任务处理，有协程主动交出运行权力**\n- 编译器/解释器/虚拟机层面的多任务（不懂🙃）\n- 多个协程可以在一个或多个线程上运行\n\n由于goroutine是非抢占式的，一个goroutine可能会在一下时机主动交出运行权力\n\n- I/O，select\n- channel\n- 等待锁\n- 函数调用\n- runtime.Gosched()\n\n### WaitGroup：多个goroutine并发执行\n\n前文阐述了当主goroutine结束之后，其他的goroutine都会被强制结束。但是很多情况下，主goroutine需要在其他goroutine结束之后再结束，一种很简单的方法就是让主goroutine睡几秒\n\n```go\ntime.Sleep(time.Second)\n```\n\n另一种更优雅的方法就是使用`sync.WaitGroup`结构体，实现多个goroutine的同步\n\n`sync.WaitGroup`结构体有三个方法\n\n- `Add(delta)`：向内部计数器中添加增量`delta`，其中`delta`可正可负\n  - 一般在启动goroutine之前调用\n- `Done()`：使内部计数器`-1`，相当于`Add(-1)`\n  - 一般在goroutine即将结束时执行，可配合`defer`关键字共同使用\n- `Wait()`：阻塞当前goroutine直至内部计数器减少至0\n\n⚠️：调用`Wait()` 函数可能导致死锁，造成程序崩溃\n\n## Go并发的实现原理\n\n> DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING. \n\n在Go中有两种并发形式：传统共享内存的方式和CSP（`communicating sequential processes`）并发模型\n\n### 共享内存\n\n在多个线程共享内存以共享数据的模式下，通过**加锁**实现并发安全\n\n在Go中有两种锁：**互斥锁（Mutex）**、**读写锁（RWMutex）**\n\n两种锁的使用方式如下：\n\n```go\n// Mutex\n\tvar mux sync.Mutex\n\tmux.Lock()\n\t// do something\n\tmux.Unlock()\n\n// RWMutx\n\tvar mux sync.RWMutex\n\tmux.RLock()\n\t// 允许多个读者\n\tmux.RUnlock()\n\tmux.Lock()\n\t// 只有一个写者\n\tmux.Unlock()\n```\n\n区别：只有一个goroutine能拿到**互斥锁**，其他goroutine则会被阻塞；允许有多个goroutine拿到**读锁**，而只有一个goroutine能拿到**写锁**\n\n⚠️：如果将带有锁结构的变量赋值给其他变量，**锁的状态会被复制**\n\n```go\nfunc main() {\n\tvar mux sync.Mutex\n\tvar wg sync.WaitGroup\n\tdefer mux.Unlock()\n\tmux.Lock()\n\twg.Add(1)\n\tgo func(mux sync.Mutex) {\n\t\tdefer func() {\n\t\t\tmux.Unlock()\n\t\t\twg.Done()\n\t\t}()\n\t\tmux.Lock() // deadlock\n\t}(mux)\n\twg.Wait()\n}\n```\n\n\n\n### channel\n\n简单地说，channel就是**收发数据的通道**\n\n声明一个channel要使用`make`函数进行**初始化**，否则声明出来的channel为`nil`\n\n```go\nvar ch chan int\nvar ch [size]chan int\n\nch = make(chan int, size)\n```\n\n#### 常见的使用方法\n\n🕐：\n\n```go\nch <- 1 // 写入一个数据\nv := <-ch // 读取一个数据\n```\n\n⚠️：如果channel没有缓冲区，那么写数据和读数据必定是成对出现的\n\n```go\nclose(ch) // 关闭通道\n```\n\n当关闭通道之后，**不能再向通道中写数据，但是能从通道中读数据，如果通道中还有值则读出对应的值，否则读出零值**\n\n这就导致一个问题：当我读出零值时，无法判断出这是因为**通道关闭还是写入的值确确实实就是零值**\n\n🕑：故需要使用通道的**判定读法**：\n\n```go\nval, ok := <-ch\nif ok {\n    fmt.Printf(\"get val %d\\n\", val)\n} else {\n    fmt.Println(\"closed\")\n}\n```\n\n当管道关闭且读取完毕后，ok为`false`\n\n🕒：有的时候某一个goroutine需要一直监听着管道中的数据，只要管道中有数据就立马读取出来，直至管道关闭\n\n在Go中可以使用`fro range`做到持续监听管道中的数据\n\n```go\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tfor v := range ch {\n\t\t\tfmt.Println(v)\n\t\t}\n\t}()\n\ttime.Sleep(time.Second)\n\tch <- 1\n\ttime.Sleep(time.Second)\n\tch <- 2\n\tclose(ch)\n\ttime.Sleep(time.Second)\n}\n```\n\n### 双向channel和单向channel\n\nchannel可以根据其功能划分为**双向channel和单向channel**，其中双向channel既可以读又可以写，而单向channel要么只读，要么只写\n\n可以通过**类型别名**的方式定义单向channel\n\n🌰：\n\n```go\ntype RChannel = <-chan int\ntype WChannel = chan<- int\n\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tvar w WChannel\n\t\tw = ch\n\t\tw <- 1\n\t}()\n\tgo func() {\n\t\tvar r RChannel\n\t\tr = ch\n\t\tfmt.Println(<-r)\n\t}()\n\ttime.Sleep(time.Second)\n}\n```\n\n### 有缓冲channel和无缓冲channel\n\n无缓冲channel可以理解为是**同步模式**，即一个写，另一个立马读，如果没有读者，写者也会被阻塞\n\n有缓冲channel则可以作为**异步模式**，在缓冲区未满的情况下，即使没有读者，写者也能向通道中写入数据\n\n但当缓冲区满了后，写者想要继续写入数据则会被阻塞，退化成**同步模式**\n\n### 总结\n\n- 关闭一个未初始化的channel会产生panic\n- channel只能关闭一次，对同一channel多次关闭会发生panic\n- 向一个已经关闭的channel写入数据，会发生panic\n- 从一个已经关闭的channel读取数据，会读出缓冲区中的值，当缓冲区没有数据（或没有缓冲区）时，则会读出对应类型的零值\n- channel的读端和写端都可以由多个goroutine操作，当写端被一个goroutine关闭时，读端的多个goroutine都会收到管道关闭的消息\n- channel是并发安全的\n","slug":"goroutine","published":1,"updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6h0009a5t29ppedzne","content":"<h1 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h1><p>goroutine是Go语言中的轻量级线程的实现，由<strong>Go运行时管理</strong>，是Go程序中最小的并发执行单位。并且传统意义上的协程是不支持并发的，而<strong>goroutine支持并发</strong>，同时goroutine可以运行在一个或多个线程上</p>\n<p><strong>goroutine大小为2kb，可以动态增大</strong></p>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><h3 id=\"goroutine的运行机制\"><a href=\"#goroutine的运行机制\" class=\"headerlink\" title=\"goroutine的运行机制\"></a>goroutine的运行机制</h3><p>在Go程序中，<code>main</code>函数是程序的入口，当程序开始执行<code>main</code>函数时，就会创建一个<strong>主goroutine</strong>，这个主goroutine是<strong>全局唯一的</strong>并且代表着整个Go程序的生命周期</p>\n<p>在代码中，可以使用<code>go</code>关键字轻松创建出一个goroutine</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(a+b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，**<code>go</code>关键字+函数调用<strong>表示创建一个goroutine并在这个goroutine中运行<code>sum</code>函数。但上述代码的运行结果并不会符合我们的预期，这是因为</strong>goroutine的运行机制是：在主Goroutine结束之后，其他所有的goroutine都会直接退出**，上述代码中的主goroutine结束的比子goroutine更快，所以控制台会没有任何输出😂</p>\n<h3 id=\"goroutine的特点\"><a href=\"#goroutine的特点\" class=\"headerlink\" title=\"goroutine的特点\"></a>goroutine的特点</h3><ul>\n<li>是一种轻量级“线程”，类似于协程</li>\n<li><strong>非抢占式（即不会被中断）多任务处理，有协程主动交出运行权力</strong></li>\n<li>编译器&#x2F;解释器&#x2F;虚拟机层面的多任务（不懂🙃）</li>\n<li>多个协程可以在一个或多个线程上运行</li>\n</ul>\n<p>由于goroutine是非抢占式的，一个goroutine可能会在一下时机主动交出运行权力</p>\n<ul>\n<li>I&#x2F;O，select</li>\n<li>channel</li>\n<li>等待锁</li>\n<li>函数调用</li>\n<li>runtime.Gosched()</li>\n</ul>\n<h3 id=\"WaitGroup：多个goroutine并发执行\"><a href=\"#WaitGroup：多个goroutine并发执行\" class=\"headerlink\" title=\"WaitGroup：多个goroutine并发执行\"></a>WaitGroup：多个goroutine并发执行</h3><p>前文阐述了当主goroutine结束之后，其他的goroutine都会被强制结束。但是很多情况下，主goroutine需要在其他goroutine结束之后再结束，一种很简单的方法就是让主goroutine睡几秒</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure>\n\n<p>另一种更优雅的方法就是使用<code>sync.WaitGroup</code>结构体，实现多个goroutine的同步</p>\n<p><code>sync.WaitGroup</code>结构体有三个方法</p>\n<ul>\n<li><code>Add(delta)</code>：向内部计数器中添加增量<code>delta</code>，其中<code>delta</code>可正可负<ul>\n<li>一般在启动goroutine之前调用</li>\n</ul>\n</li>\n<li><code>Done()</code>：使内部计数器<code>-1</code>，相当于<code>Add(-1)</code><ul>\n<li>一般在goroutine即将结束时执行，可配合<code>defer</code>关键字共同使用</li>\n</ul>\n</li>\n<li><code>Wait()</code>：阻塞当前goroutine直至内部计数器减少至0</li>\n</ul>\n<p>⚠️：调用<code>Wait()</code> 函数可能导致死锁，造成程序崩溃</p>\n<h2 id=\"Go并发的实现原理\"><a href=\"#Go并发的实现原理\" class=\"headerlink\" title=\"Go并发的实现原理\"></a>Go并发的实现原理</h2><blockquote>\n<p>DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING. </p>\n</blockquote>\n<p>在Go中有两种并发形式：传统共享内存的方式和CSP（<code>communicating sequential processes</code>）并发模型</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>在多个线程共享内存以共享数据的模式下，通过<strong>加锁</strong>实现并发安全</p>\n<p>在Go中有两种锁：<strong>互斥锁（Mutex）</strong>、<strong>读写锁（RWMutex）</strong></p>\n<p>两种锁的使用方式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Mutex</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.Mutex</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">\tmux.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RWMutx</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.RWMutex</span><br><span class=\"line\">\tmux.RLock()</span><br><span class=\"line\">\t<span class=\"comment\">// 允许多个读者</span></span><br><span class=\"line\">\tmux.RUnlock()</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// 只有一个写者</span></span><br><span class=\"line\">\tmux.Unlock()</span><br></pre></td></tr></table></figure>\n\n<p>区别：只有一个goroutine能拿到<strong>互斥锁</strong>，其他goroutine则会被阻塞；允许有多个goroutine拿到<strong>读锁</strong>，而只有一个goroutine能拿到<strong>写锁</strong></p>\n<p>⚠️：如果将带有锁结构的变量赋值给其他变量，<strong>锁的状态会被复制</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.Mutex</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mux.Unlock()</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(mux sync.Mutex)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tmux.Unlock()</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tmux.Lock() <span class=\"comment\">// deadlock</span></span><br><span class=\"line\">\t&#125;(mux)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h3><p>简单地说，channel就是<strong>收发数据的通道</strong></p>\n<p>声明一个channel要使用<code>make</code>函数进行<strong>初始化</strong>，否则声明出来的channel为<code>nil</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ch [size]<span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, size)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见的使用方法\"><a href=\"#常见的使用方法\" class=\"headerlink\" title=\"常见的使用方法\"></a>常见的使用方法</h4><p>🕐：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- <span class=\"number\">1</span> <span class=\"comment\">// 写入一个数据</span></span><br><span class=\"line\">v := &lt;-ch <span class=\"comment\">// 读取一个数据</span></span><br></pre></td></tr></table></figure>\n\n<p>⚠️：如果channel没有缓冲区，那么写数据和读数据必定是成对出现的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 关闭通道</span></span><br></pre></td></tr></table></figure>\n\n<p>当关闭通道之后，<strong>不能再向通道中写数据，但是能从通道中读数据，如果通道中还有值则读出对应的值，否则读出零值</strong></p>\n<p>这就导致一个问题：当我读出零值时，无法判断出这是因为<strong>通道关闭还是写入的值确确实实就是零值</strong></p>\n<p>🕑：故需要使用通道的<strong>判定读法</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val, ok := &lt;-ch</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;get val %d\\n&quot;</span>, val)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;closed&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当管道关闭且读取完毕后，ok为<code>false</code></p>\n<p>🕒：有的时候某一个goroutine需要一直监听着管道中的数据，只要管道中有数据就立马读取出来，直至管道关闭</p>\n<p>在Go中可以使用<code>fro range</code>做到持续监听管道中的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双向channel和单向channel\"><a href=\"#双向channel和单向channel\" class=\"headerlink\" title=\"双向channel和单向channel\"></a>双向channel和单向channel</h3><p>channel可以根据其功能划分为<strong>双向channel和单向channel</strong>，其中双向channel既可以读又可以写，而单向channel要么只读，要么只写</p>\n<p>可以通过<strong>类型别名</strong>的方式定义单向channel</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RChannel = &lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> WChannel = <span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w WChannel</span><br><span class=\"line\">\t\tw = ch</span><br><span class=\"line\">\t\tw &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> r RChannel</span><br><span class=\"line\">\t\tr = ch</span><br><span class=\"line\">\t\tfmt.Println(&lt;-r)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有缓冲channel和无缓冲channel\"><a href=\"#有缓冲channel和无缓冲channel\" class=\"headerlink\" title=\"有缓冲channel和无缓冲channel\"></a>有缓冲channel和无缓冲channel</h3><p>无缓冲channel可以理解为是<strong>同步模式</strong>，即一个写，另一个立马读，如果没有读者，写者也会被阻塞</p>\n<p>有缓冲channel则可以作为<strong>异步模式</strong>，在缓冲区未满的情况下，即使没有读者，写者也能向通道中写入数据</p>\n<p>但当缓冲区满了后，写者想要继续写入数据则会被阻塞，退化成<strong>同步模式</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>关闭一个未初始化的channel会产生panic</li>\n<li>channel只能关闭一次，对同一channel多次关闭会发生panic</li>\n<li>向一个已经关闭的channel写入数据，会发生panic</li>\n<li>从一个已经关闭的channel读取数据，会读出缓冲区中的值，当缓冲区没有数据（或没有缓冲区）时，则会读出对应类型的零值</li>\n<li>channel的读端和写端都可以由多个goroutine操作，当写端被一个goroutine关闭时，读端的多个goroutine都会收到管道关闭的消息</li>\n<li>channel是并发安全的</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h1><p>goroutine是Go语言中的轻量级线程的实现，由<strong>Go运行时管理</strong>，是Go程序中最小的并发执行单位。并且传统意义上的协程是不支持并发的，而<strong>goroutine支持并发</strong>，同时goroutine可以运行在一个或多个线程上</p>\n<p><strong>goroutine大小为2kb，可以动态增大</strong></p>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><h3 id=\"goroutine的运行机制\"><a href=\"#goroutine的运行机制\" class=\"headerlink\" title=\"goroutine的运行机制\"></a>goroutine的运行机制</h3><p>在Go程序中，<code>main</code>函数是程序的入口，当程序开始执行<code>main</code>函数时，就会创建一个<strong>主goroutine</strong>，这个主goroutine是<strong>全局唯一的</strong>并且代表着整个Go程序的生命周期</p>\n<p>在代码中，可以使用<code>go</code>关键字轻松创建出一个goroutine</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(a+b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，**<code>go</code>关键字+函数调用<strong>表示创建一个goroutine并在这个goroutine中运行<code>sum</code>函数。但上述代码的运行结果并不会符合我们的预期，这是因为</strong>goroutine的运行机制是：在主Goroutine结束之后，其他所有的goroutine都会直接退出**，上述代码中的主goroutine结束的比子goroutine更快，所以控制台会没有任何输出😂</p>\n<h3 id=\"goroutine的特点\"><a href=\"#goroutine的特点\" class=\"headerlink\" title=\"goroutine的特点\"></a>goroutine的特点</h3><ul>\n<li>是一种轻量级“线程”，类似于协程</li>\n<li><strong>非抢占式（即不会被中断）多任务处理，有协程主动交出运行权力</strong></li>\n<li>编译器&#x2F;解释器&#x2F;虚拟机层面的多任务（不懂🙃）</li>\n<li>多个协程可以在一个或多个线程上运行</li>\n</ul>\n<p>由于goroutine是非抢占式的，一个goroutine可能会在一下时机主动交出运行权力</p>\n<ul>\n<li>I&#x2F;O，select</li>\n<li>channel</li>\n<li>等待锁</li>\n<li>函数调用</li>\n<li>runtime.Gosched()</li>\n</ul>\n<h3 id=\"WaitGroup：多个goroutine并发执行\"><a href=\"#WaitGroup：多个goroutine并发执行\" class=\"headerlink\" title=\"WaitGroup：多个goroutine并发执行\"></a>WaitGroup：多个goroutine并发执行</h3><p>前文阐述了当主goroutine结束之后，其他的goroutine都会被强制结束。但是很多情况下，主goroutine需要在其他goroutine结束之后再结束，一种很简单的方法就是让主goroutine睡几秒</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure>\n\n<p>另一种更优雅的方法就是使用<code>sync.WaitGroup</code>结构体，实现多个goroutine的同步</p>\n<p><code>sync.WaitGroup</code>结构体有三个方法</p>\n<ul>\n<li><code>Add(delta)</code>：向内部计数器中添加增量<code>delta</code>，其中<code>delta</code>可正可负<ul>\n<li>一般在启动goroutine之前调用</li>\n</ul>\n</li>\n<li><code>Done()</code>：使内部计数器<code>-1</code>，相当于<code>Add(-1)</code><ul>\n<li>一般在goroutine即将结束时执行，可配合<code>defer</code>关键字共同使用</li>\n</ul>\n</li>\n<li><code>Wait()</code>：阻塞当前goroutine直至内部计数器减少至0</li>\n</ul>\n<p>⚠️：调用<code>Wait()</code> 函数可能导致死锁，造成程序崩溃</p>\n<h2 id=\"Go并发的实现原理\"><a href=\"#Go并发的实现原理\" class=\"headerlink\" title=\"Go并发的实现原理\"></a>Go并发的实现原理</h2><blockquote>\n<p>DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING. </p>\n</blockquote>\n<p>在Go中有两种并发形式：传统共享内存的方式和CSP（<code>communicating sequential processes</code>）并发模型</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>在多个线程共享内存以共享数据的模式下，通过<strong>加锁</strong>实现并发安全</p>\n<p>在Go中有两种锁：<strong>互斥锁（Mutex）</strong>、<strong>读写锁（RWMutex）</strong></p>\n<p>两种锁的使用方式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Mutex</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.Mutex</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">\tmux.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RWMutx</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.RWMutex</span><br><span class=\"line\">\tmux.RLock()</span><br><span class=\"line\">\t<span class=\"comment\">// 允许多个读者</span></span><br><span class=\"line\">\tmux.RUnlock()</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// 只有一个写者</span></span><br><span class=\"line\">\tmux.Unlock()</span><br></pre></td></tr></table></figure>\n\n<p>区别：只有一个goroutine能拿到<strong>互斥锁</strong>，其他goroutine则会被阻塞；允许有多个goroutine拿到<strong>读锁</strong>，而只有一个goroutine能拿到<strong>写锁</strong></p>\n<p>⚠️：如果将带有锁结构的变量赋值给其他变量，<strong>锁的状态会被复制</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mux sync.Mutex</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mux.Unlock()</span><br><span class=\"line\">\tmux.Lock()</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(mux sync.Mutex)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tmux.Unlock()</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\tmux.Lock() <span class=\"comment\">// deadlock</span></span><br><span class=\"line\">\t&#125;(mux)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h3><p>简单地说，channel就是<strong>收发数据的通道</strong></p>\n<p>声明一个channel要使用<code>make</code>函数进行<strong>初始化</strong>，否则声明出来的channel为<code>nil</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ch [size]<span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, size)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见的使用方法\"><a href=\"#常见的使用方法\" class=\"headerlink\" title=\"常见的使用方法\"></a>常见的使用方法</h4><p>🕐：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- <span class=\"number\">1</span> <span class=\"comment\">// 写入一个数据</span></span><br><span class=\"line\">v := &lt;-ch <span class=\"comment\">// 读取一个数据</span></span><br></pre></td></tr></table></figure>\n\n<p>⚠️：如果channel没有缓冲区，那么写数据和读数据必定是成对出现的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 关闭通道</span></span><br></pre></td></tr></table></figure>\n\n<p>当关闭通道之后，<strong>不能再向通道中写数据，但是能从通道中读数据，如果通道中还有值则读出对应的值，否则读出零值</strong></p>\n<p>这就导致一个问题：当我读出零值时，无法判断出这是因为<strong>通道关闭还是写入的值确确实实就是零值</strong></p>\n<p>🕑：故需要使用通道的<strong>判定读法</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val, ok := &lt;-ch</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;get val %d\\n&quot;</span>, val)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;closed&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当管道关闭且读取完毕后，ok为<code>false</code></p>\n<p>🕒：有的时候某一个goroutine需要一直监听着管道中的数据，只要管道中有数据就立马读取出来，直至管道关闭</p>\n<p>在Go中可以使用<code>fro range</code>做到持续监听管道中的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双向channel和单向channel\"><a href=\"#双向channel和单向channel\" class=\"headerlink\" title=\"双向channel和单向channel\"></a>双向channel和单向channel</h3><p>channel可以根据其功能划分为<strong>双向channel和单向channel</strong>，其中双向channel既可以读又可以写，而单向channel要么只读，要么只写</p>\n<p>可以通过<strong>类型别名</strong>的方式定义单向channel</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RChannel = &lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> WChannel = <span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w WChannel</span><br><span class=\"line\">\t\tw = ch</span><br><span class=\"line\">\t\tw &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> r RChannel</span><br><span class=\"line\">\t\tr = ch</span><br><span class=\"line\">\t\tfmt.Println(&lt;-r)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有缓冲channel和无缓冲channel\"><a href=\"#有缓冲channel和无缓冲channel\" class=\"headerlink\" title=\"有缓冲channel和无缓冲channel\"></a>有缓冲channel和无缓冲channel</h3><p>无缓冲channel可以理解为是<strong>同步模式</strong>，即一个写，另一个立马读，如果没有读者，写者也会被阻塞</p>\n<p>有缓冲channel则可以作为<strong>异步模式</strong>，在缓冲区未满的情况下，即使没有读者，写者也能向通道中写入数据</p>\n<p>但当缓冲区满了后，写者想要继续写入数据则会被阻塞，退化成<strong>同步模式</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>关闭一个未初始化的channel会产生panic</li>\n<li>channel只能关闭一次，对同一channel多次关闭会发生panic</li>\n<li>向一个已经关闭的channel写入数据，会发生panic</li>\n<li>从一个已经关闭的channel读取数据，会读出缓冲区中的值，当缓冲区没有数据（或没有缓冲区）时，则会读出对应类型的零值</li>\n<li>channel的读端和写端都可以由多个goroutine操作，当写端被一个goroutine关闭时，读端的多个goroutine都会收到管道关闭的消息</li>\n<li>channel是并发安全的</li>\n</ul>\n"},{"top":3,"publish":false,"_content":"# 更多能力\n\n主题还提供了许多开箱即用的能力，详见文档 https://theme.sugarat.top\n\n* [主题配置：首页&文章](https://theme.sugarat.top/config/frontmatter.html) - 主题提供的一些 `frontmatter`\n* [主题配置：全局](https://theme.sugarat.top/config/global.html) - 主题提供的额外能力\n* [主题配置：样式](https://theme.sugarat.top/config/style.html) - 自定义博客样式介绍\n* [主题配置：组件能力](https://theme.sugarat.top/config/component.html) - 自定义博客样式介绍","source":"_posts/more.md","raw":"---\ntop: 3\npublish: false\n---\n# 更多能力\n\n主题还提供了许多开箱即用的能力，详见文档 https://theme.sugarat.top\n\n* [主题配置：首页&文章](https://theme.sugarat.top/config/frontmatter.html) - 主题提供的一些 `frontmatter`\n* [主题配置：全局](https://theme.sugarat.top/config/global.html) - 主题提供的额外能力\n* [主题配置：样式](https://theme.sugarat.top/config/style.html) - 自定义博客样式介绍\n* [主题配置：组件能力](https://theme.sugarat.top/config/component.html) - 自定义博客样式介绍","slug":"more","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6h000ba5t298167woj","content":"<h1 id=\"更多能力\"><a href=\"#更多能力\" class=\"headerlink\" title=\"更多能力\"></a>更多能力</h1><p>主题还提供了许多开箱即用的能力，详见文档 <a href=\"https://theme.sugarat.top/\">https://theme.sugarat.top</a></p>\n<ul>\n<li><a href=\"https://theme.sugarat.top/config/frontmatter.html\">主题配置：首页&amp;文章</a> - 主题提供的一些 <code>frontmatter</code></li>\n<li><a href=\"https://theme.sugarat.top/config/global.html\">主题配置：全局</a> - 主题提供的额外能力</li>\n<li><a href=\"https://theme.sugarat.top/config/style.html\">主题配置：样式</a> - 自定义博客样式介绍</li>\n<li><a href=\"https://theme.sugarat.top/config/component.html\">主题配置：组件能力</a> - 自定义博客样式介绍</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"更多能力\"><a href=\"#更多能力\" class=\"headerlink\" title=\"更多能力\"></a>更多能力</h1><p>主题还提供了许多开箱即用的能力，详见文档 <a href=\"https://theme.sugarat.top/\">https://theme.sugarat.top</a></p>\n<ul>\n<li><a href=\"https://theme.sugarat.top/config/frontmatter.html\">主题配置：首页&amp;文章</a> - 主题提供的一些 <code>frontmatter</code></li>\n<li><a href=\"https://theme.sugarat.top/config/global.html\">主题配置：全局</a> - 主题提供的额外能力</li>\n<li><a href=\"https://theme.sugarat.top/config/style.html\">主题配置：样式</a> - 自定义博客样式介绍</li>\n<li><a href=\"https://theme.sugarat.top/config/component.html\">主题配置：组件能力</a> - 自定义博客样式介绍</li>\n</ul>\n"},{"description":"介绍一下自定义主题的部分样式","title":"🔧 主题样式定制","readingTime":false,"recommend":3,"publish":false,"_content":"\n# 样式配置\n样式自定义，参考[官方文档思路](https://vitepress.dev/guide/extending-default-theme#customizing-css)\n\n在 `.vitepress/theme/index.ts` 中引入自定义的样式文件，覆盖默认主题样式即可\n\n例如:\n\n博客模板里，提供了一个如下例子\n\n```ts\n// .vitepress/theme/index.ts\nimport BlogTheme from '@sugarat/theme'\n\n// 自定义样式重载 // [!code focus]\nimport './style.scss' // [!code focus]\n\nexport default BlogTheme\n```\n\n里面有如下内容\n```scss\n.VPHome {\n  // 自定义首页背景图\n  &::before {\n    // 图片来源：https://zhuanlan.zhihu.com/p/54060187\n    background-image: url(./assets/bg.webp);\n    background-size: cover;\n  }\n  // 定义遮罩样式\n  background: radial-gradient(\n    ellipse,\n    rgba(var(--bg-gradient-home), 1) 0%,\n    rgba(var(--bg-gradient-home), 0) 150%\n  );\n}\n```\n解除文件`index.ts` 中`import './style.scss'` 注释后，就能看到模板首页背景图发生了变化\n\n![](https://img.cdn.sugarat.top/mdImg/MTY3Njk5MTAzODkzOQ==676991038939)\n\n## 首页背景\n```scss\n.VPHome {// [!code focus]\n  &::before {// [!code focus]\n    background-image: url(./assets/bg.webp); // [!code focus]\n    background-size: cover; // [!code focus]\n  } // [!code focus]\n} // [!code focus]\n\n.VPHome {\n  // 定义遮罩样式，控制图片展示的程度\n  background: radial-gradient(\n    ellipse,\n    rgba(var(--bg-gradient-home), 1) 0%,\n    rgba(var(--bg-gradient-home), 0) 150%\n  );\n}\n```\n\n## 置顶样式\n可以自行修改置顶icon的样式\n```scss\n.blog-item .pin.pin::before {\n  // 修改颜色\n  background-image: linear-gradient(red, red);\n}\n```\n![](https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTExMjgxMA==677079112810)\n\n```scss\n// 隐藏置顶的icon\n.blog-item .pin.pin::before {\n  display: none;\n}\n```\n![](https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTIwODAzNg==677079208036)\n\n\n## 主题色\nvitepress 最新的默认主题色偏紫色，看着感觉有点不习惯\n\n![](https://img.cdn.sugarat.top/mdImg/MTY5MTkyODQ0ODUzOQ==691928448539)\n\n主题包内置了一些主题色，可以自行选择，详见[全局配置:themeColor](https://theme.sugarat.top/config/global.html#themecolor)\n\n如果内置的不满足要求，也可以进行自定义，自定义的方式是通过覆盖变量的方式\n\n例如可以创建`user-theme.css`文件，内容如下\n```css\n/* 所有变量：https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css */\n/* 自定义主题色示例，如下 */\n\n/* 浅色模式使用的变量 */\nhtml[theme] {\n  --vp-c-user-1:red;\n  --vp-c-user-2:blue;\n  --vp-c-user-3:green;\n  --vp-c-user-soft:rgba(255,0,0,.5);\n}\n\n/* 深色模式使用的变量 */\nhtml[theme].dark {\n  --vp-c-user-1:yellow;\n  --vp-c-user-2:purple;\n  --vp-c-user-3:orange;\n  --vp-c-user-soft:rgba(255,255,0,.5);\n}\n\n/* 覆盖默认变量 */\nhtml[theme],html[theme].dark {\n  --vp-c-brand-1: var(--vp-c-user-1);\n  --vp-c-brand-2: var(--vp-c-user-2);\n  --vp-c-brand-3: var(--vp-c-user-3);\n  --vp-c-brand-soft: var(--vp-c-user-soft);\n}\n```\n将其引入到`.vitepress/theme/index.ts`中即可\n\n```ts\nimport BlogTheme from '@sugarat/theme'\n\n// 导入自定义主题色 // [!code focus]\nimport './user-theme.css' // [!code focus]\n\nexport default BlogTheme\n```\n\n## More\n... wait a moment","source":"_posts/style.md","raw":"---\ndescription: 介绍一下自定义主题的部分样式\ntitle: 🔧 主题样式定制\nreadingTime: false\ntag:\n - 配置\nrecommend: 3\npublish: false\n---\n\n# 样式配置\n样式自定义，参考[官方文档思路](https://vitepress.dev/guide/extending-default-theme#customizing-css)\n\n在 `.vitepress/theme/index.ts` 中引入自定义的样式文件，覆盖默认主题样式即可\n\n例如:\n\n博客模板里，提供了一个如下例子\n\n```ts\n// .vitepress/theme/index.ts\nimport BlogTheme from '@sugarat/theme'\n\n// 自定义样式重载 // [!code focus]\nimport './style.scss' // [!code focus]\n\nexport default BlogTheme\n```\n\n里面有如下内容\n```scss\n.VPHome {\n  // 自定义首页背景图\n  &::before {\n    // 图片来源：https://zhuanlan.zhihu.com/p/54060187\n    background-image: url(./assets/bg.webp);\n    background-size: cover;\n  }\n  // 定义遮罩样式\n  background: radial-gradient(\n    ellipse,\n    rgba(var(--bg-gradient-home), 1) 0%,\n    rgba(var(--bg-gradient-home), 0) 150%\n  );\n}\n```\n解除文件`index.ts` 中`import './style.scss'` 注释后，就能看到模板首页背景图发生了变化\n\n![](https://img.cdn.sugarat.top/mdImg/MTY3Njk5MTAzODkzOQ==676991038939)\n\n## 首页背景\n```scss\n.VPHome {// [!code focus]\n  &::before {// [!code focus]\n    background-image: url(./assets/bg.webp); // [!code focus]\n    background-size: cover; // [!code focus]\n  } // [!code focus]\n} // [!code focus]\n\n.VPHome {\n  // 定义遮罩样式，控制图片展示的程度\n  background: radial-gradient(\n    ellipse,\n    rgba(var(--bg-gradient-home), 1) 0%,\n    rgba(var(--bg-gradient-home), 0) 150%\n  );\n}\n```\n\n## 置顶样式\n可以自行修改置顶icon的样式\n```scss\n.blog-item .pin.pin::before {\n  // 修改颜色\n  background-image: linear-gradient(red, red);\n}\n```\n![](https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTExMjgxMA==677079112810)\n\n```scss\n// 隐藏置顶的icon\n.blog-item .pin.pin::before {\n  display: none;\n}\n```\n![](https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTIwODAzNg==677079208036)\n\n\n## 主题色\nvitepress 最新的默认主题色偏紫色，看着感觉有点不习惯\n\n![](https://img.cdn.sugarat.top/mdImg/MTY5MTkyODQ0ODUzOQ==691928448539)\n\n主题包内置了一些主题色，可以自行选择，详见[全局配置:themeColor](https://theme.sugarat.top/config/global.html#themecolor)\n\n如果内置的不满足要求，也可以进行自定义，自定义的方式是通过覆盖变量的方式\n\n例如可以创建`user-theme.css`文件，内容如下\n```css\n/* 所有变量：https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css */\n/* 自定义主题色示例，如下 */\n\n/* 浅色模式使用的变量 */\nhtml[theme] {\n  --vp-c-user-1:red;\n  --vp-c-user-2:blue;\n  --vp-c-user-3:green;\n  --vp-c-user-soft:rgba(255,0,0,.5);\n}\n\n/* 深色模式使用的变量 */\nhtml[theme].dark {\n  --vp-c-user-1:yellow;\n  --vp-c-user-2:purple;\n  --vp-c-user-3:orange;\n  --vp-c-user-soft:rgba(255,255,0,.5);\n}\n\n/* 覆盖默认变量 */\nhtml[theme],html[theme].dark {\n  --vp-c-brand-1: var(--vp-c-user-1);\n  --vp-c-brand-2: var(--vp-c-user-2);\n  --vp-c-brand-3: var(--vp-c-user-3);\n  --vp-c-brand-soft: var(--vp-c-user-soft);\n}\n```\n将其引入到`.vitepress/theme/index.ts`中即可\n\n```ts\nimport BlogTheme from '@sugarat/theme'\n\n// 导入自定义主题色 // [!code focus]\nimport './user-theme.css' // [!code focus]\n\nexport default BlogTheme\n```\n\n## More\n... wait a moment","slug":"style","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6h000ca5t2a1jdepaq","content":"<h1 id=\"样式配置\"><a href=\"#样式配置\" class=\"headerlink\" title=\"样式配置\"></a>样式配置</h1><p>样式自定义，参考<a href=\"https://vitepress.dev/guide/extending-default-theme#customizing-css\">官方文档思路</a></p>\n<p>在 <code>.vitepress/theme/index.ts</code> 中引入自定义的样式文件，覆盖默认主题样式即可</p>\n<p>例如:</p>\n<p>博客模板里，提供了一个如下例子</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .vitepress/theme/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">BlogTheme</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@sugarat/theme&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义样式重载 // [!code focus]</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./style.scss&#x27;</span> <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">BlogTheme</span></span><br></pre></td></tr></table></figure>\n\n<p>里面有如下内容</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 自定义首页背景图</span></span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 图片来源：https://zhuanlan.zhihu.com/p/54060187</span></span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(./assets/bg.webp);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 定义遮罩样式</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">radial-gradient</span>(</span><br><span class=\"line\">    ellipse,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">1</span>) <span class=\"number\">0%</span>,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">0</span>) <span class=\"number\">150%</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解除文件<code>index.ts</code> 中<code>import &#39;./style.scss&#39;</code> 注释后，就能看到模板首页背景图发生了变化</p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3Njk5MTAzODkzOQ==676991038939\"></p>\n<h2 id=\"首页背景\"><a href=\"#首页背景\" class=\"headerlink\" title=\"首页背景\"></a>首页背景</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;<span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">::before</span> &#123;<span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(./assets/bg.webp); <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">  &#125; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义遮罩样式，控制图片展示的程度</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">radial-gradient</span>(</span><br><span class=\"line\">    ellipse,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">1</span>) <span class=\"number\">0%</span>,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">0</span>) <span class=\"number\">150%</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"置顶样式\"><a href=\"#置顶样式\" class=\"headerlink\" title=\"置顶样式\"></a>置顶样式</h2><p>可以自行修改置顶icon的样式</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.blog-item</span> <span class=\"selector-class\">.pin</span><span class=\"selector-class\">.pin</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 修改颜色</span></span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">linear-gradient</span>(red, red);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTExMjgxMA==677079112810\"></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隐藏置顶的icon</span></span><br><span class=\"line\"><span class=\"selector-class\">.blog-item</span> <span class=\"selector-class\">.pin</span><span class=\"selector-class\">.pin</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTIwODAzNg==677079208036\"></p>\n<h2 id=\"主题色\"><a href=\"#主题色\" class=\"headerlink\" title=\"主题色\"></a>主题色</h2><p>vitepress 最新的默认主题色偏紫色，看着感觉有点不习惯</p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY5MTkyODQ0ODUzOQ==691928448539\"></p>\n<p>主题包内置了一些主题色，可以自行选择，详见<a href=\"https://theme.sugarat.top/config/global.html#themecolor\">全局配置:themeColor</a></p>\n<p>如果内置的不满足要求，也可以进行自定义，自定义的方式是通过覆盖变量的方式</p>\n<p>例如可以创建<code>user-theme.css</code>文件，内容如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 所有变量：https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css */</span></span><br><span class=\"line\"><span class=\"comment\">/* 自定义主题色示例，如下 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 浅色模式使用的变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-1</span>:red;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-2</span>:blue;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-3</span>:green;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-soft</span>:<span class=\"built_in\">rgba</span>(<span class=\"number\">255</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 深色模式使用的变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span><span class=\"selector-class\">.dark</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-1</span>:yellow;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-2</span>:purple;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-3</span>:orange;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-soft</span>:<span class=\"built_in\">rgba</span>(<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>,.<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 覆盖默认变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span>,<span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span><span class=\"selector-class\">.dark</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-1</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-2</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-3</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-soft</span>: <span class=\"built_in\">var</span>(--vp-c-user-soft);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将其引入到<code>.vitepress/theme/index.ts</code>中即可</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">BlogTheme</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@sugarat/theme&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入自定义主题色 // [!code focus]</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./user-theme.css&#x27;</span> <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">BlogTheme</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><p>… wait a moment</p>\n","excerpt":"","more":"<h1 id=\"样式配置\"><a href=\"#样式配置\" class=\"headerlink\" title=\"样式配置\"></a>样式配置</h1><p>样式自定义，参考<a href=\"https://vitepress.dev/guide/extending-default-theme#customizing-css\">官方文档思路</a></p>\n<p>在 <code>.vitepress/theme/index.ts</code> 中引入自定义的样式文件，覆盖默认主题样式即可</p>\n<p>例如:</p>\n<p>博客模板里，提供了一个如下例子</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .vitepress/theme/index.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">BlogTheme</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@sugarat/theme&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义样式重载 // [!code focus]</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./style.scss&#x27;</span> <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">BlogTheme</span></span><br></pre></td></tr></table></figure>\n\n<p>里面有如下内容</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 自定义首页背景图</span></span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 图片来源：https://zhuanlan.zhihu.com/p/54060187</span></span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(./assets/bg.webp);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 定义遮罩样式</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">radial-gradient</span>(</span><br><span class=\"line\">    ellipse,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">1</span>) <span class=\"number\">0%</span>,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">0</span>) <span class=\"number\">150%</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解除文件<code>index.ts</code> 中<code>import &#39;./style.scss&#39;</code> 注释后，就能看到模板首页背景图发生了变化</p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3Njk5MTAzODkzOQ==676991038939\"></p>\n<h2 id=\"首页背景\"><a href=\"#首页背景\" class=\"headerlink\" title=\"首页背景\"></a>首页背景</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;<span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">::before</span> &#123;<span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(./assets/bg.webp); <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">  &#125; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.VPHome</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义遮罩样式，控制图片展示的程度</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">radial-gradient</span>(</span><br><span class=\"line\">    ellipse,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">1</span>) <span class=\"number\">0%</span>,</span><br><span class=\"line\">    <span class=\"built_in\">rgba</span>(<span class=\"built_in\">var</span>(--bg-gradient-home), <span class=\"number\">0</span>) <span class=\"number\">150%</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"置顶样式\"><a href=\"#置顶样式\" class=\"headerlink\" title=\"置顶样式\"></a>置顶样式</h2><p>可以自行修改置顶icon的样式</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.blog-item</span> <span class=\"selector-class\">.pin</span><span class=\"selector-class\">.pin</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 修改颜色</span></span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">linear-gradient</span>(red, red);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTExMjgxMA==677079112810\"></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隐藏置顶的icon</span></span><br><span class=\"line\"><span class=\"selector-class\">.blog-item</span> <span class=\"selector-class\">.pin</span><span class=\"selector-class\">.pin</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY3NzA3OTIwODAzNg==677079208036\"></p>\n<h2 id=\"主题色\"><a href=\"#主题色\" class=\"headerlink\" title=\"主题色\"></a>主题色</h2><p>vitepress 最新的默认主题色偏紫色，看着感觉有点不习惯</p>\n<p><img src=\"https://img.cdn.sugarat.top/mdImg/MTY5MTkyODQ0ODUzOQ==691928448539\"></p>\n<p>主题包内置了一些主题色，可以自行选择，详见<a href=\"https://theme.sugarat.top/config/global.html#themecolor\">全局配置:themeColor</a></p>\n<p>如果内置的不满足要求，也可以进行自定义，自定义的方式是通过覆盖变量的方式</p>\n<p>例如可以创建<code>user-theme.css</code>文件，内容如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 所有变量：https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css */</span></span><br><span class=\"line\"><span class=\"comment\">/* 自定义主题色示例，如下 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 浅色模式使用的变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-1</span>:red;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-2</span>:blue;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-3</span>:green;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-soft</span>:<span class=\"built_in\">rgba</span>(<span class=\"number\">255</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 深色模式使用的变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span><span class=\"selector-class\">.dark</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-1</span>:yellow;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-2</span>:purple;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-3</span>:orange;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-user-soft</span>:<span class=\"built_in\">rgba</span>(<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>,.<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 覆盖默认变量 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span>,<span class=\"selector-tag\">html</span><span class=\"selector-attr\">[theme]</span><span class=\"selector-class\">.dark</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-1</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-2</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-3</span>: <span class=\"built_in\">var</span>(--vp-c-user-<span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"attr\">--vp-c-brand-soft</span>: <span class=\"built_in\">var</span>(--vp-c-user-soft);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将其引入到<code>.vitepress/theme/index.ts</code>中即可</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">BlogTheme</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@sugarat/theme&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入自定义主题色 // [!code focus]</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;./user-theme.css&#x27;</span> <span class=\"comment\">// [!code focus]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">BlogTheme</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><p>… wait a moment</p>\n"},{"title":"《Go语言精进之路》阅读笔记","description":"记录《Go语言精进之路》一些有意思的知识点","_content":"\n# 《Go语言精进之路》阅读笔记\n\n## 第10条：使用iota实现枚举常量\n\n- Go的**const**语法提供了“隐式重复前一个非空表达式”的机制\n\n  - ```go\n    const (\n    \tApple, Banana = 11, 22\n    \tStrawberry, Grape\n    \tPear, Watermelon\n    )\n    \n    // 等价于\n    \n    const (\n    \tApple, Banana = 11, 22\n    \tStrawberry, Grape = 11, 22\n    \tPear, Watermelon = 11, 22\n    )\n    ```\n\n- iota表示const声明块中每个常量所处位置在块中的偏移量\n\n  - 配合**隐式重复非空表达式**机制，可以实现一些很神奇的效果\n\n  - ```go\n    const (\n    \ta = 1 << iota\t// 1\n    \tb\t\t\t\t// 2\n    \tc\t\t\t\t// 4\n    \td = iota\t\t// 3\n    \te = 1 << iota\t// 16\n    )\n    \n    // 可以效仿标准库中的代码，略过一些iota值\n    // $GOROOT/src/syscall/net_js.go go 1.12.7\n    const (\n        _ = iota\n        IPV6_V6ONLY\n        SOMAXCONN\n        SO_ERROR\n    )\n    ```\n\nGo引入iota有以下好处：\n\n1. iota使得维护枚举常量列表更容易\n2. 更为灵活的形式为枚举常量赋初值\n\n## 第12条：使用复合字面值作为处置构造器\n\n- 通过**`filed:value`格式**的复合字面值进行**结构体类型**变量初值构造。未显示指明的结构体字段将采用其对应类型的零值\n\n```go\nerr = &net.DNSConfigError{err}\n\t替换为\nerr = &net.DNSConfigError{Error: err}\n```\n\n- 通过`index:value`格式为数组/切片中非连续的元素赋予初始值\n\n```go\nvar data = []int{0:-10, 1:-5, 2:0, 3:1, 7:7}\n```\n\n- 使用`key:value`形式的复合字面值为map类型变量赋初值\n\n```go\nm := map[string]int{\"k\":1, \"kk\":2}\n```\n\n## 第13条：了解切片实现原理并高效使用\n\n- **切片是数组的“描述符”**\n\n```go\n//$GOROOT/src/runtime/slice.go\n\ntype slice struct {\n    array unsafe.Pointer\n    len int\n    cap int\n}\n```\n\n字段`len`取决于切片“窗口”（包含元素个数）的大小\n\n字段`cap`取决于底层数组的大小\n\n使用`cap`参数创建切片可以提升append的平均操作性能，减少或因动态扩容带来的性能损耗\n\n## 第14条：了解map实现原理并高效使用\n\nmap表示一组无序的键值对，其中value的类型没有限制，但是key的类型必须能够进行**==**和**!=**操作。因此，函数、map、切片类型不能作为map的key\n\nmap**不支持**“零值可用”，未显示赋值时，map类型的变量的值为nil。对处于零值状态的map变量进行操作会导致运行时panic\n\n和切片一样，map也是引用类型。当函数参数类型是map时，参数传递损耗很小，并且函数内部对map进行的修改是在外部可见的\n\n**总是使用“comma ok”惯用法读取map中的元素**\n\n遍历map时，Go运行时会随机初始化迭代器的起始位置。因此，多次遍历map得到的键值对次序可能不一致。要想保证遍历键值对的次序固定，可以先用一个切片保存好所有的key，然后再通过遍历切片达到有序遍历map的目的\n\n**map的内部实现**\n\nruntime.hmap类型是语法层面map类型的运行时对应类型，hmap可以理解为是map类型的**描述符**，包含了map类型操作所需的所有信息\n\n![image-20241112195112007](https://raw.githubusercontent.com/lyydsheep/pic/main/202411121951048.png)\n\n- count：当前map中的元素个数\n- flags：当前map所处的状态\n  - iterator\n  - oldIterator\n  - hashWriting\n  - sameSizeGrow\n- noverflow：overflow bucket的大约数量\n- hash0：哈希函数种子\n- buckets：指向bucket数组的指针\n- oldbuckets：在map扩容阶段指向前一个bucket数组的指针\n- nevacuate：在map扩容阶段充当扩容进度计数器\n- extra：可选字段\n\nGo运行时会将map的key通过哈希函数得出一个哈希值，接着利用哈希值的**低位（默认是低8位）**找到对应的bucket，然后再拿着哈希值剩下的数值在bucket中的找到目标或空闲槽位（slot）。hashcode中的高位区就存储在bucket中的**tophash区域**\n\nGo运行时会为map类型生成runtime.maptype实例，这个实例包含了map类型的所有元信息。根据这些元信息，Go运行时可以确定key的类型和大小以及构建value区域\n\n```go\ntype maptype struct {\n    typ _type\n    key *_type\n    elem *_type\n    bucket *_type\t// 表示hash bucket的内部类型\n    keysize uint8\t// key的大小\n    elemsize uint8\t// elem的大小\n    bucketsize uint16\t//bucket的大小\n    flags uint32\n}\n```\n\nGo运行时采用了将key和value分开存储而不是选择key和value紧密相接的存储方式。虽然这带来了算法实现上的复杂性，但却减少了**内存对齐**带来的内存空间损耗\n\n![image-20241112204508526](https://raw.githubusercontent.com/lyydsheep/pic/main/202411122045610.png)\n\nmap描述符runtime.hmap自身是有状态的，并且没有对状态进行并发保护，所以map不是并发安全的数据结构。当多个goroutine同时对一个map进行读写操作时，会诱发panic，导致程序崩溃。\n\n考虑到map会自动扩容，bucket地址会不断变化，因此Go不允许获取map中value的地址，并且这个约束是在编译期间就会生效的\n\n## 第15条：理解string实现原理比高效使用\n\n- string类型的数据是不可变的\n- 零值可用\n- 获取长度时间复杂度为$$O(1)$$\n- 支持通过`+ / += `运算符拼接字符串\n- 支持各种比较运算符\n- 对非ASCII码原生支持\n- 原生支持多行字符串\n","source":"_posts/《Go语言精进之路》阅读笔记.md","raw":"---\ntitle: 《Go语言精进之路》阅读笔记\ndescription: 记录《Go语言精进之路》一些有意思的知识点\ntag: Go\n---\n\n# 《Go语言精进之路》阅读笔记\n\n## 第10条：使用iota实现枚举常量\n\n- Go的**const**语法提供了“隐式重复前一个非空表达式”的机制\n\n  - ```go\n    const (\n    \tApple, Banana = 11, 22\n    \tStrawberry, Grape\n    \tPear, Watermelon\n    )\n    \n    // 等价于\n    \n    const (\n    \tApple, Banana = 11, 22\n    \tStrawberry, Grape = 11, 22\n    \tPear, Watermelon = 11, 22\n    )\n    ```\n\n- iota表示const声明块中每个常量所处位置在块中的偏移量\n\n  - 配合**隐式重复非空表达式**机制，可以实现一些很神奇的效果\n\n  - ```go\n    const (\n    \ta = 1 << iota\t// 1\n    \tb\t\t\t\t// 2\n    \tc\t\t\t\t// 4\n    \td = iota\t\t// 3\n    \te = 1 << iota\t// 16\n    )\n    \n    // 可以效仿标准库中的代码，略过一些iota值\n    // $GOROOT/src/syscall/net_js.go go 1.12.7\n    const (\n        _ = iota\n        IPV6_V6ONLY\n        SOMAXCONN\n        SO_ERROR\n    )\n    ```\n\nGo引入iota有以下好处：\n\n1. iota使得维护枚举常量列表更容易\n2. 更为灵活的形式为枚举常量赋初值\n\n## 第12条：使用复合字面值作为处置构造器\n\n- 通过**`filed:value`格式**的复合字面值进行**结构体类型**变量初值构造。未显示指明的结构体字段将采用其对应类型的零值\n\n```go\nerr = &net.DNSConfigError{err}\n\t替换为\nerr = &net.DNSConfigError{Error: err}\n```\n\n- 通过`index:value`格式为数组/切片中非连续的元素赋予初始值\n\n```go\nvar data = []int{0:-10, 1:-5, 2:0, 3:1, 7:7}\n```\n\n- 使用`key:value`形式的复合字面值为map类型变量赋初值\n\n```go\nm := map[string]int{\"k\":1, \"kk\":2}\n```\n\n## 第13条：了解切片实现原理并高效使用\n\n- **切片是数组的“描述符”**\n\n```go\n//$GOROOT/src/runtime/slice.go\n\ntype slice struct {\n    array unsafe.Pointer\n    len int\n    cap int\n}\n```\n\n字段`len`取决于切片“窗口”（包含元素个数）的大小\n\n字段`cap`取决于底层数组的大小\n\n使用`cap`参数创建切片可以提升append的平均操作性能，减少或因动态扩容带来的性能损耗\n\n## 第14条：了解map实现原理并高效使用\n\nmap表示一组无序的键值对，其中value的类型没有限制，但是key的类型必须能够进行**==**和**!=**操作。因此，函数、map、切片类型不能作为map的key\n\nmap**不支持**“零值可用”，未显示赋值时，map类型的变量的值为nil。对处于零值状态的map变量进行操作会导致运行时panic\n\n和切片一样，map也是引用类型。当函数参数类型是map时，参数传递损耗很小，并且函数内部对map进行的修改是在外部可见的\n\n**总是使用“comma ok”惯用法读取map中的元素**\n\n遍历map时，Go运行时会随机初始化迭代器的起始位置。因此，多次遍历map得到的键值对次序可能不一致。要想保证遍历键值对的次序固定，可以先用一个切片保存好所有的key，然后再通过遍历切片达到有序遍历map的目的\n\n**map的内部实现**\n\nruntime.hmap类型是语法层面map类型的运行时对应类型，hmap可以理解为是map类型的**描述符**，包含了map类型操作所需的所有信息\n\n![image-20241112195112007](https://raw.githubusercontent.com/lyydsheep/pic/main/202411121951048.png)\n\n- count：当前map中的元素个数\n- flags：当前map所处的状态\n  - iterator\n  - oldIterator\n  - hashWriting\n  - sameSizeGrow\n- noverflow：overflow bucket的大约数量\n- hash0：哈希函数种子\n- buckets：指向bucket数组的指针\n- oldbuckets：在map扩容阶段指向前一个bucket数组的指针\n- nevacuate：在map扩容阶段充当扩容进度计数器\n- extra：可选字段\n\nGo运行时会将map的key通过哈希函数得出一个哈希值，接着利用哈希值的**低位（默认是低8位）**找到对应的bucket，然后再拿着哈希值剩下的数值在bucket中的找到目标或空闲槽位（slot）。hashcode中的高位区就存储在bucket中的**tophash区域**\n\nGo运行时会为map类型生成runtime.maptype实例，这个实例包含了map类型的所有元信息。根据这些元信息，Go运行时可以确定key的类型和大小以及构建value区域\n\n```go\ntype maptype struct {\n    typ _type\n    key *_type\n    elem *_type\n    bucket *_type\t// 表示hash bucket的内部类型\n    keysize uint8\t// key的大小\n    elemsize uint8\t// elem的大小\n    bucketsize uint16\t//bucket的大小\n    flags uint32\n}\n```\n\nGo运行时采用了将key和value分开存储而不是选择key和value紧密相接的存储方式。虽然这带来了算法实现上的复杂性，但却减少了**内存对齐**带来的内存空间损耗\n\n![image-20241112204508526](https://raw.githubusercontent.com/lyydsheep/pic/main/202411122045610.png)\n\nmap描述符runtime.hmap自身是有状态的，并且没有对状态进行并发保护，所以map不是并发安全的数据结构。当多个goroutine同时对一个map进行读写操作时，会诱发panic，导致程序崩溃。\n\n考虑到map会自动扩容，bucket地址会不断变化，因此Go不允许获取map中value的地址，并且这个约束是在编译期间就会生效的\n\n## 第15条：理解string实现原理比高效使用\n\n- string类型的数据是不可变的\n- 零值可用\n- 获取长度时间复杂度为$$O(1)$$\n- 支持通过`+ / += `运算符拼接字符串\n- 支持各种比较运算符\n- 对非ASCII码原生支持\n- 原生支持多行字符串\n","slug":"《Go语言精进之路》阅读笔记","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6h000da5t2cs692rgb","content":"<h1 id=\"《Go语言精进之路》阅读笔记\"><a href=\"#《Go语言精进之路》阅读笔记\" class=\"headerlink\" title=\"《Go语言精进之路》阅读笔记\"></a>《Go语言精进之路》阅读笔记</h1><h2 id=\"第10条：使用iota实现枚举常量\"><a href=\"#第10条：使用iota实现枚举常量\" class=\"headerlink\" title=\"第10条：使用iota实现枚举常量\"></a>第10条：使用iota实现枚举常量</h2><ul>\n<li><p>Go的<strong>const</strong>语法提供了“隐式重复前一个非空表达式”的机制</p>\n<ul>\n<li><pre><code class=\"go\">const (\n    Apple, Banana = 11, 22\n    Strawberry, Grape\n    Pear, Watermelon\n)\n\n// 等价于\n\nconst (\n    Apple, Banana = 11, 22\n    Strawberry, Grape = 11, 22\n    Pear, Watermelon = 11, 22\n)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- iota表示const声明块中每个常量所处位置在块中的偏移量</span><br><span class=\"line\"></span><br><span class=\"line\">  - 配合**隐式重复非空表达式**机制，可以实现一些很神奇的效果</span><br><span class=\"line\"></span><br><span class=\"line\">  - ```go</span><br><span class=\"line\">    const (</span><br><span class=\"line\">    \ta = 1 &lt;&lt; iota\t// 1</span><br><span class=\"line\">    \tb\t\t\t\t// 2</span><br><span class=\"line\">    \tc\t\t\t\t// 4</span><br><span class=\"line\">    \td = iota\t\t// 3</span><br><span class=\"line\">    \te = 1 &lt;&lt; iota\t// 16</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 可以效仿标准库中的代码，略过一些iota值</span><br><span class=\"line\">    // $GOROOT/src/syscall/net_js.go go 1.12.7</span><br><span class=\"line\">    const (</span><br><span class=\"line\">        _ = iota</span><br><span class=\"line\">        IPV6_V6ONLY</span><br><span class=\"line\">        SOMAXCONN</span><br><span class=\"line\">        SO_ERROR</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>Go引入iota有以下好处：</p>\n<ol>\n<li>iota使得维护枚举常量列表更容易</li>\n<li>更为灵活的形式为枚举常量赋初值</li>\n</ol>\n<h2 id=\"第12条：使用复合字面值作为处置构造器\"><a href=\"#第12条：使用复合字面值作为处置构造器\" class=\"headerlink\" title=\"第12条：使用复合字面值作为处置构造器\"></a>第12条：使用复合字面值作为处置构造器</h2><ul>\n<li>通过**<code>filed:value</code>格式<strong>的复合字面值进行</strong>结构体类型**变量初值构造。未显示指明的结构体字段将采用其对应类型的零值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = &amp;net.DNSConfigError&#123;err&#125;</span><br><span class=\"line\">\t替换为</span><br><span class=\"line\">err = &amp;net.DNSConfigError&#123;Error: err&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过<code>index:value</code>格式为数组&#x2F;切片中非连续的元素赋予初始值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>:<span class=\"number\">-10</span>, <span class=\"number\">1</span>:<span class=\"number\">-5</span>, <span class=\"number\">2</span>:<span class=\"number\">0</span>, <span class=\"number\">3</span>:<span class=\"number\">1</span>, <span class=\"number\">7</span>:<span class=\"number\">7</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>key:value</code>形式的复合字面值为map类型变量赋初值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&quot;k&quot;</span>:<span class=\"number\">1</span>, <span class=\"string\">&quot;kk&quot;</span>:<span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第13条：了解切片实现原理并高效使用\"><a href=\"#第13条：了解切片实现原理并高效使用\" class=\"headerlink\" title=\"第13条：了解切片实现原理并高效使用\"></a>第13条：了解切片实现原理并高效使用</h2><ul>\n<li><strong>切片是数组的“描述符”</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOROOT/src/runtime/slice.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> slice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    array unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字段<code>len</code>取决于切片“窗口”（包含元素个数）的大小</p>\n<p>字段<code>cap</code>取决于底层数组的大小</p>\n<p>使用<code>cap</code>参数创建切片可以提升append的平均操作性能，减少或因动态扩容带来的性能损耗</p>\n<h2 id=\"第14条：了解map实现原理并高效使用\"><a href=\"#第14条：了解map实现原理并高效使用\" class=\"headerlink\" title=\"第14条：了解map实现原理并高效使用\"></a>第14条：了解map实现原理并高效使用</h2><p>map表示一组无序的键值对，其中value的类型没有限制，但是key的类型必须能够进行**&#x3D;&#x3D;<strong>和</strong>!&#x3D;**操作。因此，函数、map、切片类型不能作为map的key</p>\n<p>map<strong>不支持</strong>“零值可用”，未显示赋值时，map类型的变量的值为nil。对处于零值状态的map变量进行操作会导致运行时panic</p>\n<p>和切片一样，map也是引用类型。当函数参数类型是map时，参数传递损耗很小，并且函数内部对map进行的修改是在外部可见的</p>\n<p><strong>总是使用“comma ok”惯用法读取map中的元素</strong></p>\n<p>遍历map时，Go运行时会随机初始化迭代器的起始位置。因此，多次遍历map得到的键值对次序可能不一致。要想保证遍历键值对的次序固定，可以先用一个切片保存好所有的key，然后再通过遍历切片达到有序遍历map的目的</p>\n<p><strong>map的内部实现</strong></p>\n<p>runtime.hmap类型是语法层面map类型的运行时对应类型，hmap可以理解为是map类型的<strong>描述符</strong>，包含了map类型操作所需的所有信息</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411121951048.png\" alt=\"image-20241112195112007\"></p>\n<ul>\n<li>count：当前map中的元素个数</li>\n<li>flags：当前map所处的状态<ul>\n<li>iterator</li>\n<li>oldIterator</li>\n<li>hashWriting</li>\n<li>sameSizeGrow</li>\n</ul>\n</li>\n<li>noverflow：overflow bucket的大约数量</li>\n<li>hash0：哈希函数种子</li>\n<li>buckets：指向bucket数组的指针</li>\n<li>oldbuckets：在map扩容阶段指向前一个bucket数组的指针</li>\n<li>nevacuate：在map扩容阶段充当扩容进度计数器</li>\n<li>extra：可选字段</li>\n</ul>\n<p>Go运行时会将map的key通过哈希函数得出一个哈希值，接着利用哈希值的<strong>低位（默认是低8位）</strong>找到对应的bucket，然后再拿着哈希值剩下的数值在bucket中的找到目标或空闲槽位（slot）。hashcode中的高位区就存储在bucket中的<strong>tophash区域</strong></p>\n<p>Go运行时会为map类型生成runtime.maptype实例，这个实例包含了map类型的所有元信息。根据这些元信息，Go运行时可以确定key的类型和大小以及构建value区域</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> maptype <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    typ _type</span><br><span class=\"line\">    key *_type</span><br><span class=\"line\">    elem *_type</span><br><span class=\"line\">    bucket *_type\t<span class=\"comment\">// 表示hash bucket的内部类型</span></span><br><span class=\"line\">    keysize <span class=\"type\">uint8</span>\t<span class=\"comment\">// key的大小</span></span><br><span class=\"line\">    elemsize <span class=\"type\">uint8</span>\t<span class=\"comment\">// elem的大小</span></span><br><span class=\"line\">    bucketsize <span class=\"type\">uint16</span>\t<span class=\"comment\">//bucket的大小</span></span><br><span class=\"line\">    flags <span class=\"type\">uint32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go运行时采用了将key和value分开存储而不是选择key和value紧密相接的存储方式。虽然这带来了算法实现上的复杂性，但却减少了<strong>内存对齐</strong>带来的内存空间损耗</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411122045610.png\" alt=\"image-20241112204508526\"></p>\n<p>map描述符runtime.hmap自身是有状态的，并且没有对状态进行并发保护，所以map不是并发安全的数据结构。当多个goroutine同时对一个map进行读写操作时，会诱发panic，导致程序崩溃。</p>\n<p>考虑到map会自动扩容，bucket地址会不断变化，因此Go不允许获取map中value的地址，并且这个约束是在编译期间就会生效的</p>\n<h2 id=\"第15条：理解string实现原理比高效使用\"><a href=\"#第15条：理解string实现原理比高效使用\" class=\"headerlink\" title=\"第15条：理解string实现原理比高效使用\"></a>第15条：理解string实现原理比高效使用</h2><ul>\n<li>string类型的数据是不可变的</li>\n<li>零值可用</li>\n<li>获取长度时间复杂度为$$O(1)$$</li>\n<li>支持通过<code>+ / += </code>运算符拼接字符串</li>\n<li>支持各种比较运算符</li>\n<li>对非ASCII码原生支持</li>\n<li>原生支持多行字符串</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"《Go语言精进之路》阅读笔记\"><a href=\"#《Go语言精进之路》阅读笔记\" class=\"headerlink\" title=\"《Go语言精进之路》阅读笔记\"></a>《Go语言精进之路》阅读笔记</h1><h2 id=\"第10条：使用iota实现枚举常量\"><a href=\"#第10条：使用iota实现枚举常量\" class=\"headerlink\" title=\"第10条：使用iota实现枚举常量\"></a>第10条：使用iota实现枚举常量</h2><ul>\n<li><p>Go的<strong>const</strong>语法提供了“隐式重复前一个非空表达式”的机制</p>\n<ul>\n<li><pre><code class=\"go\">const (\n    Apple, Banana = 11, 22\n    Strawberry, Grape\n    Pear, Watermelon\n)\n\n// 等价于\n\nconst (\n    Apple, Banana = 11, 22\n    Strawberry, Grape = 11, 22\n    Pear, Watermelon = 11, 22\n)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- iota表示const声明块中每个常量所处位置在块中的偏移量</span><br><span class=\"line\"></span><br><span class=\"line\">  - 配合**隐式重复非空表达式**机制，可以实现一些很神奇的效果</span><br><span class=\"line\"></span><br><span class=\"line\">  - ```go</span><br><span class=\"line\">    const (</span><br><span class=\"line\">    \ta = 1 &lt;&lt; iota\t// 1</span><br><span class=\"line\">    \tb\t\t\t\t// 2</span><br><span class=\"line\">    \tc\t\t\t\t// 4</span><br><span class=\"line\">    \td = iota\t\t// 3</span><br><span class=\"line\">    \te = 1 &lt;&lt; iota\t// 16</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 可以效仿标准库中的代码，略过一些iota值</span><br><span class=\"line\">    // $GOROOT/src/syscall/net_js.go go 1.12.7</span><br><span class=\"line\">    const (</span><br><span class=\"line\">        _ = iota</span><br><span class=\"line\">        IPV6_V6ONLY</span><br><span class=\"line\">        SOMAXCONN</span><br><span class=\"line\">        SO_ERROR</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>Go引入iota有以下好处：</p>\n<ol>\n<li>iota使得维护枚举常量列表更容易</li>\n<li>更为灵活的形式为枚举常量赋初值</li>\n</ol>\n<h2 id=\"第12条：使用复合字面值作为处置构造器\"><a href=\"#第12条：使用复合字面值作为处置构造器\" class=\"headerlink\" title=\"第12条：使用复合字面值作为处置构造器\"></a>第12条：使用复合字面值作为处置构造器</h2><ul>\n<li>通过**<code>filed:value</code>格式<strong>的复合字面值进行</strong>结构体类型**变量初值构造。未显示指明的结构体字段将采用其对应类型的零值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = &amp;net.DNSConfigError&#123;err&#125;</span><br><span class=\"line\">\t替换为</span><br><span class=\"line\">err = &amp;net.DNSConfigError&#123;Error: err&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过<code>index:value</code>格式为数组&#x2F;切片中非连续的元素赋予初始值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = []<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>:<span class=\"number\">-10</span>, <span class=\"number\">1</span>:<span class=\"number\">-5</span>, <span class=\"number\">2</span>:<span class=\"number\">0</span>, <span class=\"number\">3</span>:<span class=\"number\">1</span>, <span class=\"number\">7</span>:<span class=\"number\">7</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>key:value</code>形式的复合字面值为map类型变量赋初值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&quot;k&quot;</span>:<span class=\"number\">1</span>, <span class=\"string\">&quot;kk&quot;</span>:<span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第13条：了解切片实现原理并高效使用\"><a href=\"#第13条：了解切片实现原理并高效使用\" class=\"headerlink\" title=\"第13条：了解切片实现原理并高效使用\"></a>第13条：了解切片实现原理并高效使用</h2><ul>\n<li><strong>切片是数组的“描述符”</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOROOT/src/runtime/slice.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> slice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    array unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字段<code>len</code>取决于切片“窗口”（包含元素个数）的大小</p>\n<p>字段<code>cap</code>取决于底层数组的大小</p>\n<p>使用<code>cap</code>参数创建切片可以提升append的平均操作性能，减少或因动态扩容带来的性能损耗</p>\n<h2 id=\"第14条：了解map实现原理并高效使用\"><a href=\"#第14条：了解map实现原理并高效使用\" class=\"headerlink\" title=\"第14条：了解map实现原理并高效使用\"></a>第14条：了解map实现原理并高效使用</h2><p>map表示一组无序的键值对，其中value的类型没有限制，但是key的类型必须能够进行**&#x3D;&#x3D;<strong>和</strong>!&#x3D;**操作。因此，函数、map、切片类型不能作为map的key</p>\n<p>map<strong>不支持</strong>“零值可用”，未显示赋值时，map类型的变量的值为nil。对处于零值状态的map变量进行操作会导致运行时panic</p>\n<p>和切片一样，map也是引用类型。当函数参数类型是map时，参数传递损耗很小，并且函数内部对map进行的修改是在外部可见的</p>\n<p><strong>总是使用“comma ok”惯用法读取map中的元素</strong></p>\n<p>遍历map时，Go运行时会随机初始化迭代器的起始位置。因此，多次遍历map得到的键值对次序可能不一致。要想保证遍历键值对的次序固定，可以先用一个切片保存好所有的key，然后再通过遍历切片达到有序遍历map的目的</p>\n<p><strong>map的内部实现</strong></p>\n<p>runtime.hmap类型是语法层面map类型的运行时对应类型，hmap可以理解为是map类型的<strong>描述符</strong>，包含了map类型操作所需的所有信息</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411121951048.png\" alt=\"image-20241112195112007\"></p>\n<ul>\n<li>count：当前map中的元素个数</li>\n<li>flags：当前map所处的状态<ul>\n<li>iterator</li>\n<li>oldIterator</li>\n<li>hashWriting</li>\n<li>sameSizeGrow</li>\n</ul>\n</li>\n<li>noverflow：overflow bucket的大约数量</li>\n<li>hash0：哈希函数种子</li>\n<li>buckets：指向bucket数组的指针</li>\n<li>oldbuckets：在map扩容阶段指向前一个bucket数组的指针</li>\n<li>nevacuate：在map扩容阶段充当扩容进度计数器</li>\n<li>extra：可选字段</li>\n</ul>\n<p>Go运行时会将map的key通过哈希函数得出一个哈希值，接着利用哈希值的<strong>低位（默认是低8位）</strong>找到对应的bucket，然后再拿着哈希值剩下的数值在bucket中的找到目标或空闲槽位（slot）。hashcode中的高位区就存储在bucket中的<strong>tophash区域</strong></p>\n<p>Go运行时会为map类型生成runtime.maptype实例，这个实例包含了map类型的所有元信息。根据这些元信息，Go运行时可以确定key的类型和大小以及构建value区域</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> maptype <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    typ _type</span><br><span class=\"line\">    key *_type</span><br><span class=\"line\">    elem *_type</span><br><span class=\"line\">    bucket *_type\t<span class=\"comment\">// 表示hash bucket的内部类型</span></span><br><span class=\"line\">    keysize <span class=\"type\">uint8</span>\t<span class=\"comment\">// key的大小</span></span><br><span class=\"line\">    elemsize <span class=\"type\">uint8</span>\t<span class=\"comment\">// elem的大小</span></span><br><span class=\"line\">    bucketsize <span class=\"type\">uint16</span>\t<span class=\"comment\">//bucket的大小</span></span><br><span class=\"line\">    flags <span class=\"type\">uint32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go运行时采用了将key和value分开存储而不是选择key和value紧密相接的存储方式。虽然这带来了算法实现上的复杂性，但却减少了<strong>内存对齐</strong>带来的内存空间损耗</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411122045610.png\" alt=\"image-20241112204508526\"></p>\n<p>map描述符runtime.hmap自身是有状态的，并且没有对状态进行并发保护，所以map不是并发安全的数据结构。当多个goroutine同时对一个map进行读写操作时，会诱发panic，导致程序崩溃。</p>\n<p>考虑到map会自动扩容，bucket地址会不断变化，因此Go不允许获取map中value的地址，并且这个约束是在编译期间就会生效的</p>\n<h2 id=\"第15条：理解string实现原理比高效使用\"><a href=\"#第15条：理解string实现原理比高效使用\" class=\"headerlink\" title=\"第15条：理解string实现原理比高效使用\"></a>第15条：理解string实现原理比高效使用</h2><ul>\n<li>string类型的数据是不可变的</li>\n<li>零值可用</li>\n<li>获取长度时间复杂度为$$O(1)$$</li>\n<li>支持通过<code>+ / += </code>运算符拼接字符串</li>\n<li>支持各种比较运算符</li>\n<li>对非ASCII码原生支持</li>\n<li>原生支持多行字符串</li>\n</ul>\n"},{"title":"他们眼中的简历","_content":"- 注意投递岗位，切忌“一份简历投天下”\n","source":"_posts/他们眼中的简历.md","raw":"---\ntitle: 他们眼中的简历\n---\n- 注意投递岗位，切忌“一份简历投天下”\n","slug":"他们眼中的简历","published":1,"date":"2025-01-25T13:16:28.409Z","updated":"2025-01-25T13:16:28.409Z","_id":"cm6c7md6i000ga5t2gja4dtqr","comments":1,"layout":"post","photos":[],"content":"<ul>\n<li>注意投递岗位，切忌“一份简历投天下”</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>注意投递岗位，切忌“一份简历投天下”</li>\n</ul>\n"},{"title":"优质好文合集","publish":true,"description":"收藏一些优质好文","date":"2024-12-11T16:00:00.000Z","_content":"\n# 优质好文合集 \n\n* [ ] [万字长文详细分享Redis的常见业务场景](https://mp.weixin.qq.com/s/srkd73bS2n3mjIADLVg72A)\n\n* [ ] [“意义”与马拉松](https://mp.weixin.qq.com/s/cc5Thv-umTnApcC8aaQJNw)\n\n* [ ] [消息队列选型](https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw)\n\n* [x] [淘宝数据库，主键如何设计的?](https://cloud.tencent.com/developer/article/2163702)\n\n* [ ] [如何尽可能快地上后一个业务or项目](https://mp.weixin.qq.com/s/I-876sJiI-XFRdDkvJV_mg)\n\t阅读要点记录：\n\t- 尽可能全面地搜集项目资料\n\t\t- 新人空间资料\n\t\t- 系统详细资料，即使不是自己负责的模块\n\t- 梳理领域数据模型\n\t\t- 搞清楚每一个数据模型的设计：属性及其含义、本身代表了什么、数据模型之间的关系\n\t\t- 画[ER图](https://zq99299.github.io/mysql-tutorial/ali-new-retail/03/02.html)或其他图辅助理清思路\n\t- 理解项目结构及业务逻辑\n\t\t- MVC、DDD，搞清楚入口层、核心逻辑层、数据交互层在哪里\n\t\t- 逐个了解数据模型在系统内对于的业务逻辑实现\n\t\t\t- 可以作作业务流程图来梳理（可以看小报童）\n\n* [ ] [38件程序员应该知道的事儿](https://mp.weixin.qq.com/s/tz6V7AIBcxQcuwvp_pRgCQ)\n\t阅读记录\n\t- 对技术债“零容忍”，有些事只有零次和无数次\n\t- 分析需求背后的意义\n\t\t- 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？\n\t\t- 如果不能，那就考虑Say no吧\n\t\t- \n\n* [ ] [Redis也可以是成本优化利器](https://mp.weixin.qq.com/s/bBqeGkKxCp0xEQjmaG1JPQ)\n","source":"_posts/优质好文合集.md","raw":"---\ntitle: 优质好文合集\npublish: true\ndescription: 收藏一些优质好文\ndate: 2024-12-12\ntags:\n  - 优质文章\n---\n\n# 优质好文合集 \n\n* [ ] [万字长文详细分享Redis的常见业务场景](https://mp.weixin.qq.com/s/srkd73bS2n3mjIADLVg72A)\n\n* [ ] [“意义”与马拉松](https://mp.weixin.qq.com/s/cc5Thv-umTnApcC8aaQJNw)\n\n* [ ] [消息队列选型](https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw)\n\n* [x] [淘宝数据库，主键如何设计的?](https://cloud.tencent.com/developer/article/2163702)\n\n* [ ] [如何尽可能快地上后一个业务or项目](https://mp.weixin.qq.com/s/I-876sJiI-XFRdDkvJV_mg)\n\t阅读要点记录：\n\t- 尽可能全面地搜集项目资料\n\t\t- 新人空间资料\n\t\t- 系统详细资料，即使不是自己负责的模块\n\t- 梳理领域数据模型\n\t\t- 搞清楚每一个数据模型的设计：属性及其含义、本身代表了什么、数据模型之间的关系\n\t\t- 画[ER图](https://zq99299.github.io/mysql-tutorial/ali-new-retail/03/02.html)或其他图辅助理清思路\n\t- 理解项目结构及业务逻辑\n\t\t- MVC、DDD，搞清楚入口层、核心逻辑层、数据交互层在哪里\n\t\t- 逐个了解数据模型在系统内对于的业务逻辑实现\n\t\t\t- 可以作作业务流程图来梳理（可以看小报童）\n\n* [ ] [38件程序员应该知道的事儿](https://mp.weixin.qq.com/s/tz6V7AIBcxQcuwvp_pRgCQ)\n\t阅读记录\n\t- 对技术债“零容忍”，有些事只有零次和无数次\n\t- 分析需求背后的意义\n\t\t- 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？\n\t\t- 如果不能，那就考虑Say no吧\n\t\t- \n\n* [ ] [Redis也可以是成本优化利器](https://mp.weixin.qq.com/s/bBqeGkKxCp0xEQjmaG1JPQ)\n","slug":"优质好文合集","published":1,"updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000ha5t27jvj6lzt","content":"<h1 id=\"优质好文合集\"><a href=\"#优质好文合集\" class=\"headerlink\" title=\"优质好文合集\"></a>优质好文合集</h1><ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/srkd73bS2n3mjIADLVg72A\">万字长文详细分享Redis的常见业务场景</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/cc5Thv-umTnApcC8aaQJNw\">“意义”与马拉松</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\">消息队列选型</a></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<a href=\"https://cloud.tencent.com/developer/article/2163702\">淘宝数据库，主键如何设计的?</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/I-876sJiI-XFRdDkvJV_mg\">如何尽可能快地上后一个业务or项目</a><br>  阅读要点记录：</p>\n<ul>\n<li>尽可能全面地搜集项目资料<ul>\n<li>新人空间资料</li>\n<li>系统详细资料，即使不是自己负责的模块</li>\n</ul>\n</li>\n<li>梳理领域数据模型<ul>\n<li>搞清楚每一个数据模型的设计：属性及其含义、本身代表了什么、数据模型之间的关系</li>\n<li>画<a href=\"https://zq99299.github.io/mysql-tutorial/ali-new-retail/03/02.html\">ER图</a>或其他图辅助理清思路</li>\n</ul>\n</li>\n<li>理解项目结构及业务逻辑<ul>\n<li>MVC、DDD，搞清楚入口层、核心逻辑层、数据交互层在哪里</li>\n<li>逐个了解数据模型在系统内对于的业务逻辑实现<ul>\n<li>可以作作业务流程图来梳理（可以看小报童）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/tz6V7AIBcxQcuwvp_pRgCQ\">38件程序员应该知道的事儿</a><br>  阅读记录</p>\n<ul>\n<li>对技术债“零容忍”，有些事只有零次和无数次</li>\n<li><h2 id=\"分析需求背后的意义-根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？-如果不能，那就考虑Say-no吧\"><a href=\"#分析需求背后的意义-根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？-如果不能，那就考虑Say-no吧\" class=\"headerlink\" title=\"分析需求背后的意义  - 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？  - 如果不能，那就考虑Say no吧\"></a>分析需求背后的意义<br>  - 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？<br>  - 如果不能，那就考虑Say no吧</h2></li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/bBqeGkKxCp0xEQjmaG1JPQ\">Redis也可以是成本优化利器</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"优质好文合集\"><a href=\"#优质好文合集\" class=\"headerlink\" title=\"优质好文合集\"></a>优质好文合集</h1><ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/srkd73bS2n3mjIADLVg72A\">万字长文详细分享Redis的常见业务场景</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/cc5Thv-umTnApcC8aaQJNw\">“意义”与马拉松</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\">消息队列选型</a></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<a href=\"https://cloud.tencent.com/developer/article/2163702\">淘宝数据库，主键如何设计的?</a></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/I-876sJiI-XFRdDkvJV_mg\">如何尽可能快地上后一个业务or项目</a><br>  阅读要点记录：</p>\n<ul>\n<li>尽可能全面地搜集项目资料<ul>\n<li>新人空间资料</li>\n<li>系统详细资料，即使不是自己负责的模块</li>\n</ul>\n</li>\n<li>梳理领域数据模型<ul>\n<li>搞清楚每一个数据模型的设计：属性及其含义、本身代表了什么、数据模型之间的关系</li>\n<li>画<a href=\"https://zq99299.github.io/mysql-tutorial/ali-new-retail/03/02.html\">ER图</a>或其他图辅助理清思路</li>\n</ul>\n</li>\n<li>理解项目结构及业务逻辑<ul>\n<li>MVC、DDD，搞清楚入口层、核心逻辑层、数据交互层在哪里</li>\n<li>逐个了解数据模型在系统内对于的业务逻辑实现<ul>\n<li>可以作作业务流程图来梳理（可以看小报童）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/tz6V7AIBcxQcuwvp_pRgCQ\">38件程序员应该知道的事儿</a><br>  阅读记录</p>\n<ul>\n<li>对技术债“零容忍”，有些事只有零次和无数次</li>\n<li><h2 id=\"分析需求背后的意义-根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？-如果不能，那就考虑Say-no吧\"><a href=\"#分析需求背后的意义-根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？-如果不能，那就考虑Say-no吧\" class=\"headerlink\" title=\"分析需求背后的意义  - 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？  - 如果不能，那就考虑Say no吧\"></a>分析需求背后的意义<br>  - 根据“第一性原理”，我们应该从本质出发进行思考。用户的需求必然是想达到某种目的（即罗马），但是用户选择的路未必是最好的，条条大路通罗马，那么我们作为开发者知道了罗马在哪儿，是不是可以找出一条更好的路呢？<br>  - 如果不能，那就考虑Say no吧</h2></li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://mp.weixin.qq.com/s/bBqeGkKxCp0xEQjmaG1JPQ\">Redis也可以是成本优化利器</a></p>\n</li>\n</ul>\n"},{"description":"一些《设计模式之美》的阅读笔记/摘抄","_content":"# 《设计模式之美》阅读笔记\n\n![image-20241108191510420](https://raw.githubusercontent.com/lyydsheep/pic/main/202411081915460.png)\n\n## 面向对象\n\n### 理论二：封装、抽象、继承、多态\n\n#### 封装（Encapsulation）\n\n封装也叫做信息隐藏或数据访问保护。类通过暴露有限的可访问接口，授权外部仅能通过类提供的方法来访问内部的数据。\n\n🌰：\n\n```go\ntype Wallet struct {\n\tid           string\n\tcreateTime   int64\n\tbalance      int64\n\tmodifiedTime int64\n}\n\nfunc (w *Wallet) increaseBalance(increaseAmount int64) error {\n\tif increaseAmount < 0 {\n\t\treturn errors.New(\"...\")\n\t}\n\tw.balance += increaseAmount\n\tw.modifiedTime = time.Now().UnixMilli()\n\treturn nil\n}\n```\n\n封装的作用主要体现在两方面：\n\n- 增加数据的访问权限，防止使用者直接对内部数据进行无检查修改\n- 提高类的易用性，只将关键方法暴露给使用者，降低使用者的操作负担\n\n#### 抽象（Abstraction）\n\n抽象讲究如何隐藏**方法具体实现细节**，让调用者只需要关心如何使用方法，并不需要方法内部是如何实现的\n\n#### 继承（Inheritance）\n\n> 继承这个特性也是一个非常有争议的特性\n\n**少用继承，多用组合**\n\n#### 多态（Polymorphism）\n\n抽象地理解，同一个方法呈现出不同的行为就是多态。在Go语言中的接口可以完全支持鸭子类型，可以被用于多态的具体实现。\n\n多态特性可以提高代码的可扩展下和复用性\n\n### 理论三、四：面向对象和面向过程\n\n面向对象：以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多台四个特性作为代码设计和实现的基石\n\n面向过程：以过程（函数、方法）作为组织代码的基本单元，以数据与方法相分离为最主要的特点\n\n**面向对象编程**是以类为思考对象。在进行面向对象编程的时候，并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，**而是采用曲线救国的方式，先去思考如何给业务建模、如何将需求翻译为类、如何建立类与类之间的交互关系**。当我们有类的设计之后，就能像搭积木一样，按照处理流程，将类组装成整个程序\n\n**OOP风格的代码更易维护、易复用、易扩展**（封装、继承、抽象、多态）\n","source":"_posts/《设计模式之美》阅读笔记.md","raw":"---\ndescription: 一些《设计模式之美》的阅读笔记/摘抄\ntag: 设计模式\n---\n# 《设计模式之美》阅读笔记\n\n![image-20241108191510420](https://raw.githubusercontent.com/lyydsheep/pic/main/202411081915460.png)\n\n## 面向对象\n\n### 理论二：封装、抽象、继承、多态\n\n#### 封装（Encapsulation）\n\n封装也叫做信息隐藏或数据访问保护。类通过暴露有限的可访问接口，授权外部仅能通过类提供的方法来访问内部的数据。\n\n🌰：\n\n```go\ntype Wallet struct {\n\tid           string\n\tcreateTime   int64\n\tbalance      int64\n\tmodifiedTime int64\n}\n\nfunc (w *Wallet) increaseBalance(increaseAmount int64) error {\n\tif increaseAmount < 0 {\n\t\treturn errors.New(\"...\")\n\t}\n\tw.balance += increaseAmount\n\tw.modifiedTime = time.Now().UnixMilli()\n\treturn nil\n}\n```\n\n封装的作用主要体现在两方面：\n\n- 增加数据的访问权限，防止使用者直接对内部数据进行无检查修改\n- 提高类的易用性，只将关键方法暴露给使用者，降低使用者的操作负担\n\n#### 抽象（Abstraction）\n\n抽象讲究如何隐藏**方法具体实现细节**，让调用者只需要关心如何使用方法，并不需要方法内部是如何实现的\n\n#### 继承（Inheritance）\n\n> 继承这个特性也是一个非常有争议的特性\n\n**少用继承，多用组合**\n\n#### 多态（Polymorphism）\n\n抽象地理解，同一个方法呈现出不同的行为就是多态。在Go语言中的接口可以完全支持鸭子类型，可以被用于多态的具体实现。\n\n多态特性可以提高代码的可扩展下和复用性\n\n### 理论三、四：面向对象和面向过程\n\n面向对象：以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多台四个特性作为代码设计和实现的基石\n\n面向过程：以过程（函数、方法）作为组织代码的基本单元，以数据与方法相分离为最主要的特点\n\n**面向对象编程**是以类为思考对象。在进行面向对象编程的时候，并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，**而是采用曲线救国的方式，先去思考如何给业务建模、如何将需求翻译为类、如何建立类与类之间的交互关系**。当我们有类的设计之后，就能像搭积木一样，按照处理流程，将类组装成整个程序\n\n**OOP风格的代码更易维护、易复用、易扩展**（封装、继承、抽象、多态）\n","slug":"《设计模式之美》阅读笔记","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000ja5t21uba1ks8","content":"<h1 id=\"《设计模式之美》阅读笔记\"><a href=\"#《设计模式之美》阅读笔记\" class=\"headerlink\" title=\"《设计模式之美》阅读笔记\"></a>《设计模式之美》阅读笔记</h1><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411081915460.png\" alt=\"image-20241108191510420\"></p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"理论二：封装、抽象、继承、多态\"><a href=\"#理论二：封装、抽象、继承、多态\" class=\"headerlink\" title=\"理论二：封装、抽象、继承、多态\"></a>理论二：封装、抽象、继承、多态</h3><h4 id=\"封装（Encapsulation）\"><a href=\"#封装（Encapsulation）\" class=\"headerlink\" title=\"封装（Encapsulation）\"></a>封装（Encapsulation）</h4><p>封装也叫做信息隐藏或数据访问保护。类通过暴露有限的可访问接口，授权外部仅能通过类提供的方法来访问内部的数据。</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Wallet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tid           <span class=\"type\">string</span></span><br><span class=\"line\">\tcreateTime   <span class=\"type\">int64</span></span><br><span class=\"line\">\tbalance      <span class=\"type\">int64</span></span><br><span class=\"line\">\tmodifiedTime <span class=\"type\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(w *Wallet)</span></span> increaseBalance(increaseAmount <span class=\"type\">int64</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> increaseAmount &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;...&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tw.balance += increaseAmount</span><br><span class=\"line\">\tw.modifiedTime = time.Now().UnixMilli()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>封装的作用主要体现在两方面：</p>\n<ul>\n<li>增加数据的访问权限，防止使用者直接对内部数据进行无检查修改</li>\n<li>提高类的易用性，只将关键方法暴露给使用者，降低使用者的操作负担</li>\n</ul>\n<h4 id=\"抽象（Abstraction）\"><a href=\"#抽象（Abstraction）\" class=\"headerlink\" title=\"抽象（Abstraction）\"></a>抽象（Abstraction）</h4><p>抽象讲究如何隐藏<strong>方法具体实现细节</strong>，让调用者只需要关心如何使用方法，并不需要方法内部是如何实现的</p>\n<h4 id=\"继承（Inheritance）\"><a href=\"#继承（Inheritance）\" class=\"headerlink\" title=\"继承（Inheritance）\"></a>继承（Inheritance）</h4><blockquote>\n<p>继承这个特性也是一个非常有争议的特性</p>\n</blockquote>\n<p><strong>少用继承，多用组合</strong></p>\n<h4 id=\"多态（Polymorphism）\"><a href=\"#多态（Polymorphism）\" class=\"headerlink\" title=\"多态（Polymorphism）\"></a>多态（Polymorphism）</h4><p>抽象地理解，同一个方法呈现出不同的行为就是多态。在Go语言中的接口可以完全支持鸭子类型，可以被用于多态的具体实现。</p>\n<p>多态特性可以提高代码的可扩展下和复用性</p>\n<h3 id=\"理论三、四：面向对象和面向过程\"><a href=\"#理论三、四：面向对象和面向过程\" class=\"headerlink\" title=\"理论三、四：面向对象和面向过程\"></a>理论三、四：面向对象和面向过程</h3><p>面向对象：以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多台四个特性作为代码设计和实现的基石</p>\n<p>面向过程：以过程（函数、方法）作为组织代码的基本单元，以数据与方法相分离为最主要的特点</p>\n<p><strong>面向对象编程</strong>是以类为思考对象。在进行面向对象编程的时候，并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，<strong>而是采用曲线救国的方式，先去思考如何给业务建模、如何将需求翻译为类、如何建立类与类之间的交互关系</strong>。当我们有类的设计之后，就能像搭积木一样，按照处理流程，将类组装成整个程序</p>\n<p><strong>OOP风格的代码更易维护、易复用、易扩展</strong>（封装、继承、抽象、多态）</p>\n","excerpt":"","more":"<h1 id=\"《设计模式之美》阅读笔记\"><a href=\"#《设计模式之美》阅读笔记\" class=\"headerlink\" title=\"《设计模式之美》阅读笔记\"></a>《设计模式之美》阅读笔记</h1><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411081915460.png\" alt=\"image-20241108191510420\"></p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"理论二：封装、抽象、继承、多态\"><a href=\"#理论二：封装、抽象、继承、多态\" class=\"headerlink\" title=\"理论二：封装、抽象、继承、多态\"></a>理论二：封装、抽象、继承、多态</h3><h4 id=\"封装（Encapsulation）\"><a href=\"#封装（Encapsulation）\" class=\"headerlink\" title=\"封装（Encapsulation）\"></a>封装（Encapsulation）</h4><p>封装也叫做信息隐藏或数据访问保护。类通过暴露有限的可访问接口，授权外部仅能通过类提供的方法来访问内部的数据。</p>\n<p>🌰：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Wallet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tid           <span class=\"type\">string</span></span><br><span class=\"line\">\tcreateTime   <span class=\"type\">int64</span></span><br><span class=\"line\">\tbalance      <span class=\"type\">int64</span></span><br><span class=\"line\">\tmodifiedTime <span class=\"type\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(w *Wallet)</span></span> increaseBalance(increaseAmount <span class=\"type\">int64</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> increaseAmount &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;...&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tw.balance += increaseAmount</span><br><span class=\"line\">\tw.modifiedTime = time.Now().UnixMilli()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>封装的作用主要体现在两方面：</p>\n<ul>\n<li>增加数据的访问权限，防止使用者直接对内部数据进行无检查修改</li>\n<li>提高类的易用性，只将关键方法暴露给使用者，降低使用者的操作负担</li>\n</ul>\n<h4 id=\"抽象（Abstraction）\"><a href=\"#抽象（Abstraction）\" class=\"headerlink\" title=\"抽象（Abstraction）\"></a>抽象（Abstraction）</h4><p>抽象讲究如何隐藏<strong>方法具体实现细节</strong>，让调用者只需要关心如何使用方法，并不需要方法内部是如何实现的</p>\n<h4 id=\"继承（Inheritance）\"><a href=\"#继承（Inheritance）\" class=\"headerlink\" title=\"继承（Inheritance）\"></a>继承（Inheritance）</h4><blockquote>\n<p>继承这个特性也是一个非常有争议的特性</p>\n</blockquote>\n<p><strong>少用继承，多用组合</strong></p>\n<h4 id=\"多态（Polymorphism）\"><a href=\"#多态（Polymorphism）\" class=\"headerlink\" title=\"多态（Polymorphism）\"></a>多态（Polymorphism）</h4><p>抽象地理解，同一个方法呈现出不同的行为就是多态。在Go语言中的接口可以完全支持鸭子类型，可以被用于多态的具体实现。</p>\n<p>多态特性可以提高代码的可扩展下和复用性</p>\n<h3 id=\"理论三、四：面向对象和面向过程\"><a href=\"#理论三、四：面向对象和面向过程\" class=\"headerlink\" title=\"理论三、四：面向对象和面向过程\"></a>理论三、四：面向对象和面向过程</h3><p>面向对象：以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多台四个特性作为代码设计和实现的基石</p>\n<p>面向过程：以过程（函数、方法）作为组织代码的基本单元，以数据与方法相分离为最主要的特点</p>\n<p><strong>面向对象编程</strong>是以类为思考对象。在进行面向对象编程的时候，并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，<strong>而是采用曲线救国的方式，先去思考如何给业务建模、如何将需求翻译为类、如何建立类与类之间的交互关系</strong>。当我们有类的设计之后，就能像搭积木一样，按照处理流程，将类组装成整个程序</p>\n<p><strong>OOP风格的代码更易维护、易复用、易扩展</strong>（封装、继承、抽象、多态）</p>\n"},{"title":"TCP、UDP知识点","publish":true,"description":"记录了一些TCP、UDP知识点","date":"2024-09-14T10:29:00.000Z","sticky":2,"_content":"\n# TCP、UDP\n\n## TCP粘包拆包\n\n> 为什么会有TCP粘包？应用层是如何解决TCP粘包的问题？\n\n### 什么是TCP粘包\n\nTCP粘包就是指发送方发送的若干个数据包到达接收方时粘成了一包，从接受缓冲区看，若干个数据包首位相连，好像是粘在了一块儿。TCP粘包的原因可能是来自发送方，也可能来自接收方。\n\n### TCP粘包的原因\n\n1. 发送方的原因\n\nTCP默认使用**Nagle**算法（用于减轻网络负担，提高数据传输的效率），而Nagle算法主要工作有这么两个：\n\n- 只有上一个分组得到确认，才会发送下一个分组的数据包\n- 收集多个小分组，累计数据量，在一个确认到来后一块发送\n\n发送方由于使用了**Nagle**算法，才会导致TCP粘包的现象\n\n2. 接收方的原因\n\n一般情况下，接收方收到数据包时，并不会立马交付给应用层进行处理，而是放在**缓冲窗口**中，然后应用程序再从缓冲窗口中读取收到的分组。如果应用程序的读取速度远小于数据的缓存速度，那么就会有多个包被缓存在窗口中，此时应用程序就可能会读取到首位粘在一起的数据包\n\n### 如何解决TCP粘包\n\n对于发送方，可以通过关闭Nagle算法来解决\n\n对于接收方，只能依靠应用层来解决\n\n对于应用程序，一般有两种方法来区别一大坨的数据分别由哪个分组构成：\n\n- **格式化数据**：每条数据都有固定的格式，例如大名鼎鼎的Redis在数据交互时就用`\\n`来区分每一个数据分组\n- **发送长度**：发送每条数据时，将数据的长度一并发送，例如HTTP协议中的`Content-Length`字段\n\n### UDP有木有粘包问题\n\nTCP采用了**基于流的传输**，基于流的传输不认为消息是一条一条的，是无保护消息边界的\n\n而UDP则是**面向消息传输**的，是有保护消息边界的，接收方只能一次只能接受一条独立的消息，所以**不存在粘包问题**\n\n## TPC异常\n\n如果**客户端进程崩溃**，客户端的进程在发生奔溃时，内核会发送FIN报文，与服务端进行四次挥手\n\n如果**客户端主机宕机**，客户端不会发送FIN报文，后续情况需要根据服务端的行为来判断\n\n- 如果服务端**会发送数据**，由于客户端已经宕机，服务端收不到响应报文，于是会进行超时重传，当重传总间隔时长超过一定阈值后，会断开TCP连接\n- 如果服务端不会发送数据，则需要看看服务端**是否开启了TCP keepalive机制**\n  - 如果开启了TCP keepalive机制，服务端通过发送探测报文发现客户端已经消亡，则会断开自身的TCP连接\n  - 如果没有开启，服务端的TCP连接会一直存在，并且保持着ESTABLISHED状态\n\n## HTTP Keep-Alive和TCP Keepalive\n\n### HTTP Keep-Alive\n\nHTTP协议基于TCP传输协议实现，采用**请求、应答**模式进行信息交互。也就是说，每一次的数据传输都要经历这四个过程：建立TCP连接  -->  请求数据资源  -->  响应数据资源  -->  断开TCP连接（即HTTP短连接）\n\n但现如今，一个HTML页面就可能包含了上百个数据资源，也就是说至少得建立几百个TCP连接才能把一个网页加载出来。如此浮躁的时代，如此夸张的网络延迟，用户体验肯定异常糟糕\n\n一个很直接的想法就是所有的请求应答资源都共用一个TCP连接，这样就省去了很多建立、断开TCP连接的时间。而在实际应用中，就是使用**HTTP Keep-Alive**实现这个功能的，可以使用同一个TCP连接来发送和接收多个HTTP请求/应答，避免连接建立和释放的开销，即**HTTP长连接**\n\nHTTP长连接的一个特点就是：**只要一端没有明确断开连接，就保持TCP连接状态**\n\n### TCP Keepalive\n\nTCP Keepalive机制就是**TCP连接的保活机制**，当连接的双方很长一段时间没有通信（进行数据的交互），达到触发TCP保活机制的条件，那么**内核**中的TCP协议栈就会发送探测报文\n\n- 如果对端程序正常运行，接收到探测报文后会正常响应，TCP保活时间将被重置\n- 如果对端主机宕机（注意**不是进程崩溃**，因为当操作系统回收崩溃的进程时，会发送FIN报文来断开TCP连接。而主机宕机则是对端不可知的，需要通过保活机制来探测是否是真的宕机），或其他原因导致探测报文无法正常得到响应，重复几次，**达到重发阈值后，就报告TCP连接死亡，需要断开该TCP连接**\n\n## UDP vs TCP\n\n> 弄清楚UDP和TCP的区别和应用场景，至少要记忆3个区别\n\n- 连接\n  - TCP要求在发送方和接收方通信之前建立一个TCP连接，是面向连接的协议\n  - UDP是无连接协议\n- 保证数据传输的顺序\n  - 在TCP中，由于事先建立了一条良好的连接，接收方将顺序地接收数据包\n  - 而在UDP中，接收方以无序的方式接收数据包\n- 可靠性\n  - 每当接收方通过TCP连接接收到数据包后，都会向发送方发送一个响应包，明确不需要重传这个数据包\n  - UDP是尽力而为的，只能依赖于高层协议实现可靠传输，例如[QUIC](https://en.wikipedia.org/wiki/QUIC)协议\n- 错误检查\n  - TCP中有广泛的错误检查规则，\n  - 而UDP中只有基本的校验和错误检查技术\n- 传输方法\n  - 在TCP中，数据以字节流的形式传输\n  - 而在UDP中，数据是以一个一个数据包的形式发送的\n- 广播\n  - TCP不支持广播，因为TCP协议要求发送方和接收方建立一条连接，在发送后断开连接\n  - UDP支持广播\n- TCP和UDP常见使用场景\n  - TCP：HTTPS、HTTP、SMTP、FTP\n  - UDP：DNS、视频流、视频电话、语音服务\n","source":"_posts/传输层知识点.md","raw":"---\ntitle: TCP、UDP知识点\npublish: true\ndescription: 记录了一些TCP、UDP知识点\ndate: 2024-09-14 18:29:00\ntag: 计算机网络\nsticky: 2\n---\n\n# TCP、UDP\n\n## TCP粘包拆包\n\n> 为什么会有TCP粘包？应用层是如何解决TCP粘包的问题？\n\n### 什么是TCP粘包\n\nTCP粘包就是指发送方发送的若干个数据包到达接收方时粘成了一包，从接受缓冲区看，若干个数据包首位相连，好像是粘在了一块儿。TCP粘包的原因可能是来自发送方，也可能来自接收方。\n\n### TCP粘包的原因\n\n1. 发送方的原因\n\nTCP默认使用**Nagle**算法（用于减轻网络负担，提高数据传输的效率），而Nagle算法主要工作有这么两个：\n\n- 只有上一个分组得到确认，才会发送下一个分组的数据包\n- 收集多个小分组，累计数据量，在一个确认到来后一块发送\n\n发送方由于使用了**Nagle**算法，才会导致TCP粘包的现象\n\n2. 接收方的原因\n\n一般情况下，接收方收到数据包时，并不会立马交付给应用层进行处理，而是放在**缓冲窗口**中，然后应用程序再从缓冲窗口中读取收到的分组。如果应用程序的读取速度远小于数据的缓存速度，那么就会有多个包被缓存在窗口中，此时应用程序就可能会读取到首位粘在一起的数据包\n\n### 如何解决TCP粘包\n\n对于发送方，可以通过关闭Nagle算法来解决\n\n对于接收方，只能依靠应用层来解决\n\n对于应用程序，一般有两种方法来区别一大坨的数据分别由哪个分组构成：\n\n- **格式化数据**：每条数据都有固定的格式，例如大名鼎鼎的Redis在数据交互时就用`\\n`来区分每一个数据分组\n- **发送长度**：发送每条数据时，将数据的长度一并发送，例如HTTP协议中的`Content-Length`字段\n\n### UDP有木有粘包问题\n\nTCP采用了**基于流的传输**，基于流的传输不认为消息是一条一条的，是无保护消息边界的\n\n而UDP则是**面向消息传输**的，是有保护消息边界的，接收方只能一次只能接受一条独立的消息，所以**不存在粘包问题**\n\n## TPC异常\n\n如果**客户端进程崩溃**，客户端的进程在发生奔溃时，内核会发送FIN报文，与服务端进行四次挥手\n\n如果**客户端主机宕机**，客户端不会发送FIN报文，后续情况需要根据服务端的行为来判断\n\n- 如果服务端**会发送数据**，由于客户端已经宕机，服务端收不到响应报文，于是会进行超时重传，当重传总间隔时长超过一定阈值后，会断开TCP连接\n- 如果服务端不会发送数据，则需要看看服务端**是否开启了TCP keepalive机制**\n  - 如果开启了TCP keepalive机制，服务端通过发送探测报文发现客户端已经消亡，则会断开自身的TCP连接\n  - 如果没有开启，服务端的TCP连接会一直存在，并且保持着ESTABLISHED状态\n\n## HTTP Keep-Alive和TCP Keepalive\n\n### HTTP Keep-Alive\n\nHTTP协议基于TCP传输协议实现，采用**请求、应答**模式进行信息交互。也就是说，每一次的数据传输都要经历这四个过程：建立TCP连接  -->  请求数据资源  -->  响应数据资源  -->  断开TCP连接（即HTTP短连接）\n\n但现如今，一个HTML页面就可能包含了上百个数据资源，也就是说至少得建立几百个TCP连接才能把一个网页加载出来。如此浮躁的时代，如此夸张的网络延迟，用户体验肯定异常糟糕\n\n一个很直接的想法就是所有的请求应答资源都共用一个TCP连接，这样就省去了很多建立、断开TCP连接的时间。而在实际应用中，就是使用**HTTP Keep-Alive**实现这个功能的，可以使用同一个TCP连接来发送和接收多个HTTP请求/应答，避免连接建立和释放的开销，即**HTTP长连接**\n\nHTTP长连接的一个特点就是：**只要一端没有明确断开连接，就保持TCP连接状态**\n\n### TCP Keepalive\n\nTCP Keepalive机制就是**TCP连接的保活机制**，当连接的双方很长一段时间没有通信（进行数据的交互），达到触发TCP保活机制的条件，那么**内核**中的TCP协议栈就会发送探测报文\n\n- 如果对端程序正常运行，接收到探测报文后会正常响应，TCP保活时间将被重置\n- 如果对端主机宕机（注意**不是进程崩溃**，因为当操作系统回收崩溃的进程时，会发送FIN报文来断开TCP连接。而主机宕机则是对端不可知的，需要通过保活机制来探测是否是真的宕机），或其他原因导致探测报文无法正常得到响应，重复几次，**达到重发阈值后，就报告TCP连接死亡，需要断开该TCP连接**\n\n## UDP vs TCP\n\n> 弄清楚UDP和TCP的区别和应用场景，至少要记忆3个区别\n\n- 连接\n  - TCP要求在发送方和接收方通信之前建立一个TCP连接，是面向连接的协议\n  - UDP是无连接协议\n- 保证数据传输的顺序\n  - 在TCP中，由于事先建立了一条良好的连接，接收方将顺序地接收数据包\n  - 而在UDP中，接收方以无序的方式接收数据包\n- 可靠性\n  - 每当接收方通过TCP连接接收到数据包后，都会向发送方发送一个响应包，明确不需要重传这个数据包\n  - UDP是尽力而为的，只能依赖于高层协议实现可靠传输，例如[QUIC](https://en.wikipedia.org/wiki/QUIC)协议\n- 错误检查\n  - TCP中有广泛的错误检查规则，\n  - 而UDP中只有基本的校验和错误检查技术\n- 传输方法\n  - 在TCP中，数据以字节流的形式传输\n  - 而在UDP中，数据是以一个一个数据包的形式发送的\n- 广播\n  - TCP不支持广播，因为TCP协议要求发送方和接收方建立一条连接，在发送后断开连接\n  - UDP支持广播\n- TCP和UDP常见使用场景\n  - TCP：HTTPS、HTTP、SMTP、FTP\n  - UDP：DNS、视频流、视频电话、语音服务\n","slug":"传输层知识点","published":1,"updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000la5t21dfo2257","content":"<h1 id=\"TCP、UDP\"><a href=\"#TCP、UDP\" class=\"headerlink\" title=\"TCP、UDP\"></a>TCP、UDP</h1><h2 id=\"TCP粘包拆包\"><a href=\"#TCP粘包拆包\" class=\"headerlink\" title=\"TCP粘包拆包\"></a>TCP粘包拆包</h2><blockquote>\n<p>为什么会有TCP粘包？应用层是如何解决TCP粘包的问题？</p>\n</blockquote>\n<h3 id=\"什么是TCP粘包\"><a href=\"#什么是TCP粘包\" class=\"headerlink\" title=\"什么是TCP粘包\"></a>什么是TCP粘包</h3><p>TCP粘包就是指发送方发送的若干个数据包到达接收方时粘成了一包，从接受缓冲区看，若干个数据包首位相连，好像是粘在了一块儿。TCP粘包的原因可能是来自发送方，也可能来自接收方。</p>\n<h3 id=\"TCP粘包的原因\"><a href=\"#TCP粘包的原因\" class=\"headerlink\" title=\"TCP粘包的原因\"></a>TCP粘包的原因</h3><ol>\n<li>发送方的原因</li>\n</ol>\n<p>TCP默认使用<strong>Nagle</strong>算法（用于减轻网络负担，提高数据传输的效率），而Nagle算法主要工作有这么两个：</p>\n<ul>\n<li>只有上一个分组得到确认，才会发送下一个分组的数据包</li>\n<li>收集多个小分组，累计数据量，在一个确认到来后一块发送</li>\n</ul>\n<p>发送方由于使用了<strong>Nagle</strong>算法，才会导致TCP粘包的现象</p>\n<ol start=\"2\">\n<li>接收方的原因</li>\n</ol>\n<p>一般情况下，接收方收到数据包时，并不会立马交付给应用层进行处理，而是放在<strong>缓冲窗口</strong>中，然后应用程序再从缓冲窗口中读取收到的分组。如果应用程序的读取速度远小于数据的缓存速度，那么就会有多个包被缓存在窗口中，此时应用程序就可能会读取到首位粘在一起的数据包</p>\n<h3 id=\"如何解决TCP粘包\"><a href=\"#如何解决TCP粘包\" class=\"headerlink\" title=\"如何解决TCP粘包\"></a>如何解决TCP粘包</h3><p>对于发送方，可以通过关闭Nagle算法来解决</p>\n<p>对于接收方，只能依靠应用层来解决</p>\n<p>对于应用程序，一般有两种方法来区别一大坨的数据分别由哪个分组构成：</p>\n<ul>\n<li><strong>格式化数据</strong>：每条数据都有固定的格式，例如大名鼎鼎的Redis在数据交互时就用<code>\\n</code>来区分每一个数据分组</li>\n<li><strong>发送长度</strong>：发送每条数据时，将数据的长度一并发送，例如HTTP协议中的<code>Content-Length</code>字段</li>\n</ul>\n<h3 id=\"UDP有木有粘包问题\"><a href=\"#UDP有木有粘包问题\" class=\"headerlink\" title=\"UDP有木有粘包问题\"></a>UDP有木有粘包问题</h3><p>TCP采用了<strong>基于流的传输</strong>，基于流的传输不认为消息是一条一条的，是无保护消息边界的</p>\n<p>而UDP则是<strong>面向消息传输</strong>的，是有保护消息边界的，接收方只能一次只能接受一条独立的消息，所以<strong>不存在粘包问题</strong></p>\n<h2 id=\"TPC异常\"><a href=\"#TPC异常\" class=\"headerlink\" title=\"TPC异常\"></a>TPC异常</h2><p>如果<strong>客户端进程崩溃</strong>，客户端的进程在发生奔溃时，内核会发送FIN报文，与服务端进行四次挥手</p>\n<p>如果<strong>客户端主机宕机</strong>，客户端不会发送FIN报文，后续情况需要根据服务端的行为来判断</p>\n<ul>\n<li>如果服务端<strong>会发送数据</strong>，由于客户端已经宕机，服务端收不到响应报文，于是会进行超时重传，当重传总间隔时长超过一定阈值后，会断开TCP连接</li>\n<li>如果服务端不会发送数据，则需要看看服务端<strong>是否开启了TCP keepalive机制</strong><ul>\n<li>如果开启了TCP keepalive机制，服务端通过发送探测报文发现客户端已经消亡，则会断开自身的TCP连接</li>\n<li>如果没有开启，服务端的TCP连接会一直存在，并且保持着ESTABLISHED状态</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP-Keep-Alive和TCP-Keepalive\"><a href=\"#HTTP-Keep-Alive和TCP-Keepalive\" class=\"headerlink\" title=\"HTTP Keep-Alive和TCP Keepalive\"></a>HTTP Keep-Alive和TCP Keepalive</h2><h3 id=\"HTTP-Keep-Alive\"><a href=\"#HTTP-Keep-Alive\" class=\"headerlink\" title=\"HTTP Keep-Alive\"></a>HTTP Keep-Alive</h3><p>HTTP协议基于TCP传输协议实现，采用<strong>请求、应答</strong>模式进行信息交互。也就是说，每一次的数据传输都要经历这四个过程：建立TCP连接  –&gt;  请求数据资源  –&gt;  响应数据资源  –&gt;  断开TCP连接（即HTTP短连接）</p>\n<p>但现如今，一个HTML页面就可能包含了上百个数据资源，也就是说至少得建立几百个TCP连接才能把一个网页加载出来。如此浮躁的时代，如此夸张的网络延迟，用户体验肯定异常糟糕</p>\n<p>一个很直接的想法就是所有的请求应答资源都共用一个TCP连接，这样就省去了很多建立、断开TCP连接的时间。而在实际应用中，就是使用<strong>HTTP Keep-Alive</strong>实现这个功能的，可以使用同一个TCP连接来发送和接收多个HTTP请求&#x2F;应答，避免连接建立和释放的开销，即<strong>HTTP长连接</strong></p>\n<p>HTTP长连接的一个特点就是：<strong>只要一端没有明确断开连接，就保持TCP连接状态</strong></p>\n<h3 id=\"TCP-Keepalive\"><a href=\"#TCP-Keepalive\" class=\"headerlink\" title=\"TCP Keepalive\"></a>TCP Keepalive</h3><p>TCP Keepalive机制就是<strong>TCP连接的保活机制</strong>，当连接的双方很长一段时间没有通信（进行数据的交互），达到触发TCP保活机制的条件，那么<strong>内核</strong>中的TCP协议栈就会发送探测报文</p>\n<ul>\n<li>如果对端程序正常运行，接收到探测报文后会正常响应，TCP保活时间将被重置</li>\n<li>如果对端主机宕机（注意<strong>不是进程崩溃</strong>，因为当操作系统回收崩溃的进程时，会发送FIN报文来断开TCP连接。而主机宕机则是对端不可知的，需要通过保活机制来探测是否是真的宕机），或其他原因导致探测报文无法正常得到响应，重复几次，<strong>达到重发阈值后，就报告TCP连接死亡，需要断开该TCP连接</strong></li>\n</ul>\n<h2 id=\"UDP-vs-TCP\"><a href=\"#UDP-vs-TCP\" class=\"headerlink\" title=\"UDP vs TCP\"></a>UDP vs TCP</h2><blockquote>\n<p>弄清楚UDP和TCP的区别和应用场景，至少要记忆3个区别</p>\n</blockquote>\n<ul>\n<li>连接<ul>\n<li>TCP要求在发送方和接收方通信之前建立一个TCP连接，是面向连接的协议</li>\n<li>UDP是无连接协议</li>\n</ul>\n</li>\n<li>保证数据传输的顺序<ul>\n<li>在TCP中，由于事先建立了一条良好的连接，接收方将顺序地接收数据包</li>\n<li>而在UDP中，接收方以无序的方式接收数据包</li>\n</ul>\n</li>\n<li>可靠性<ul>\n<li>每当接收方通过TCP连接接收到数据包后，都会向发送方发送一个响应包，明确不需要重传这个数据包</li>\n<li>UDP是尽力而为的，只能依赖于高层协议实现可靠传输，例如<a href=\"https://en.wikipedia.org/wiki/QUIC\">QUIC</a>协议</li>\n</ul>\n</li>\n<li>错误检查<ul>\n<li>TCP中有广泛的错误检查规则，</li>\n<li>而UDP中只有基本的校验和错误检查技术</li>\n</ul>\n</li>\n<li>传输方法<ul>\n<li>在TCP中，数据以字节流的形式传输</li>\n<li>而在UDP中，数据是以一个一个数据包的形式发送的</li>\n</ul>\n</li>\n<li>广播<ul>\n<li>TCP不支持广播，因为TCP协议要求发送方和接收方建立一条连接，在发送后断开连接</li>\n<li>UDP支持广播</li>\n</ul>\n</li>\n<li>TCP和UDP常见使用场景<ul>\n<li>TCP：HTTPS、HTTP、SMTP、FTP</li>\n<li>UDP：DNS、视频流、视频电话、语音服务</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"TCP、UDP\"><a href=\"#TCP、UDP\" class=\"headerlink\" title=\"TCP、UDP\"></a>TCP、UDP</h1><h2 id=\"TCP粘包拆包\"><a href=\"#TCP粘包拆包\" class=\"headerlink\" title=\"TCP粘包拆包\"></a>TCP粘包拆包</h2><blockquote>\n<p>为什么会有TCP粘包？应用层是如何解决TCP粘包的问题？</p>\n</blockquote>\n<h3 id=\"什么是TCP粘包\"><a href=\"#什么是TCP粘包\" class=\"headerlink\" title=\"什么是TCP粘包\"></a>什么是TCP粘包</h3><p>TCP粘包就是指发送方发送的若干个数据包到达接收方时粘成了一包，从接受缓冲区看，若干个数据包首位相连，好像是粘在了一块儿。TCP粘包的原因可能是来自发送方，也可能来自接收方。</p>\n<h3 id=\"TCP粘包的原因\"><a href=\"#TCP粘包的原因\" class=\"headerlink\" title=\"TCP粘包的原因\"></a>TCP粘包的原因</h3><ol>\n<li>发送方的原因</li>\n</ol>\n<p>TCP默认使用<strong>Nagle</strong>算法（用于减轻网络负担，提高数据传输的效率），而Nagle算法主要工作有这么两个：</p>\n<ul>\n<li>只有上一个分组得到确认，才会发送下一个分组的数据包</li>\n<li>收集多个小分组，累计数据量，在一个确认到来后一块发送</li>\n</ul>\n<p>发送方由于使用了<strong>Nagle</strong>算法，才会导致TCP粘包的现象</p>\n<ol start=\"2\">\n<li>接收方的原因</li>\n</ol>\n<p>一般情况下，接收方收到数据包时，并不会立马交付给应用层进行处理，而是放在<strong>缓冲窗口</strong>中，然后应用程序再从缓冲窗口中读取收到的分组。如果应用程序的读取速度远小于数据的缓存速度，那么就会有多个包被缓存在窗口中，此时应用程序就可能会读取到首位粘在一起的数据包</p>\n<h3 id=\"如何解决TCP粘包\"><a href=\"#如何解决TCP粘包\" class=\"headerlink\" title=\"如何解决TCP粘包\"></a>如何解决TCP粘包</h3><p>对于发送方，可以通过关闭Nagle算法来解决</p>\n<p>对于接收方，只能依靠应用层来解决</p>\n<p>对于应用程序，一般有两种方法来区别一大坨的数据分别由哪个分组构成：</p>\n<ul>\n<li><strong>格式化数据</strong>：每条数据都有固定的格式，例如大名鼎鼎的Redis在数据交互时就用<code>\\n</code>来区分每一个数据分组</li>\n<li><strong>发送长度</strong>：发送每条数据时，将数据的长度一并发送，例如HTTP协议中的<code>Content-Length</code>字段</li>\n</ul>\n<h3 id=\"UDP有木有粘包问题\"><a href=\"#UDP有木有粘包问题\" class=\"headerlink\" title=\"UDP有木有粘包问题\"></a>UDP有木有粘包问题</h3><p>TCP采用了<strong>基于流的传输</strong>，基于流的传输不认为消息是一条一条的，是无保护消息边界的</p>\n<p>而UDP则是<strong>面向消息传输</strong>的，是有保护消息边界的，接收方只能一次只能接受一条独立的消息，所以<strong>不存在粘包问题</strong></p>\n<h2 id=\"TPC异常\"><a href=\"#TPC异常\" class=\"headerlink\" title=\"TPC异常\"></a>TPC异常</h2><p>如果<strong>客户端进程崩溃</strong>，客户端的进程在发生奔溃时，内核会发送FIN报文，与服务端进行四次挥手</p>\n<p>如果<strong>客户端主机宕机</strong>，客户端不会发送FIN报文，后续情况需要根据服务端的行为来判断</p>\n<ul>\n<li>如果服务端<strong>会发送数据</strong>，由于客户端已经宕机，服务端收不到响应报文，于是会进行超时重传，当重传总间隔时长超过一定阈值后，会断开TCP连接</li>\n<li>如果服务端不会发送数据，则需要看看服务端<strong>是否开启了TCP keepalive机制</strong><ul>\n<li>如果开启了TCP keepalive机制，服务端通过发送探测报文发现客户端已经消亡，则会断开自身的TCP连接</li>\n<li>如果没有开启，服务端的TCP连接会一直存在，并且保持着ESTABLISHED状态</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP-Keep-Alive和TCP-Keepalive\"><a href=\"#HTTP-Keep-Alive和TCP-Keepalive\" class=\"headerlink\" title=\"HTTP Keep-Alive和TCP Keepalive\"></a>HTTP Keep-Alive和TCP Keepalive</h2><h3 id=\"HTTP-Keep-Alive\"><a href=\"#HTTP-Keep-Alive\" class=\"headerlink\" title=\"HTTP Keep-Alive\"></a>HTTP Keep-Alive</h3><p>HTTP协议基于TCP传输协议实现，采用<strong>请求、应答</strong>模式进行信息交互。也就是说，每一次的数据传输都要经历这四个过程：建立TCP连接  –&gt;  请求数据资源  –&gt;  响应数据资源  –&gt;  断开TCP连接（即HTTP短连接）</p>\n<p>但现如今，一个HTML页面就可能包含了上百个数据资源，也就是说至少得建立几百个TCP连接才能把一个网页加载出来。如此浮躁的时代，如此夸张的网络延迟，用户体验肯定异常糟糕</p>\n<p>一个很直接的想法就是所有的请求应答资源都共用一个TCP连接，这样就省去了很多建立、断开TCP连接的时间。而在实际应用中，就是使用<strong>HTTP Keep-Alive</strong>实现这个功能的，可以使用同一个TCP连接来发送和接收多个HTTP请求&#x2F;应答，避免连接建立和释放的开销，即<strong>HTTP长连接</strong></p>\n<p>HTTP长连接的一个特点就是：<strong>只要一端没有明确断开连接，就保持TCP连接状态</strong></p>\n<h3 id=\"TCP-Keepalive\"><a href=\"#TCP-Keepalive\" class=\"headerlink\" title=\"TCP Keepalive\"></a>TCP Keepalive</h3><p>TCP Keepalive机制就是<strong>TCP连接的保活机制</strong>，当连接的双方很长一段时间没有通信（进行数据的交互），达到触发TCP保活机制的条件，那么<strong>内核</strong>中的TCP协议栈就会发送探测报文</p>\n<ul>\n<li>如果对端程序正常运行，接收到探测报文后会正常响应，TCP保活时间将被重置</li>\n<li>如果对端主机宕机（注意<strong>不是进程崩溃</strong>，因为当操作系统回收崩溃的进程时，会发送FIN报文来断开TCP连接。而主机宕机则是对端不可知的，需要通过保活机制来探测是否是真的宕机），或其他原因导致探测报文无法正常得到响应，重复几次，<strong>达到重发阈值后，就报告TCP连接死亡，需要断开该TCP连接</strong></li>\n</ul>\n<h2 id=\"UDP-vs-TCP\"><a href=\"#UDP-vs-TCP\" class=\"headerlink\" title=\"UDP vs TCP\"></a>UDP vs TCP</h2><blockquote>\n<p>弄清楚UDP和TCP的区别和应用场景，至少要记忆3个区别</p>\n</blockquote>\n<ul>\n<li>连接<ul>\n<li>TCP要求在发送方和接收方通信之前建立一个TCP连接，是面向连接的协议</li>\n<li>UDP是无连接协议</li>\n</ul>\n</li>\n<li>保证数据传输的顺序<ul>\n<li>在TCP中，由于事先建立了一条良好的连接，接收方将顺序地接收数据包</li>\n<li>而在UDP中，接收方以无序的方式接收数据包</li>\n</ul>\n</li>\n<li>可靠性<ul>\n<li>每当接收方通过TCP连接接收到数据包后，都会向发送方发送一个响应包，明确不需要重传这个数据包</li>\n<li>UDP是尽力而为的，只能依赖于高层协议实现可靠传输，例如<a href=\"https://en.wikipedia.org/wiki/QUIC\">QUIC</a>协议</li>\n</ul>\n</li>\n<li>错误检查<ul>\n<li>TCP中有广泛的错误检查规则，</li>\n<li>而UDP中只有基本的校验和错误检查技术</li>\n</ul>\n</li>\n<li>传输方法<ul>\n<li>在TCP中，数据以字节流的形式传输</li>\n<li>而在UDP中，数据是以一个一个数据包的形式发送的</li>\n</ul>\n</li>\n<li>广播<ul>\n<li>TCP不支持广播，因为TCP协议要求发送方和接收方建立一条连接，在发送后断开连接</li>\n<li>UDP支持广播</li>\n</ul>\n</li>\n<li>TCP和UDP常见使用场景<ul>\n<li>TCP：HTTPS、HTTP、SMTP、FTP</li>\n<li>UDP：DNS、视频流、视频电话、语音服务</li>\n</ul>\n</li>\n</ul>\n"},{"title":"优质资源合集","publish":true,"description":"收藏一些优质资源","_content":"\n# 优质资源合集\n\n## 2024-12-01\n- [Questionnaires tool](https://github.com/didi/xiaoju-survey)\n\n## 2024-11-17\n\n- [摸鱼背单词](https://github.com/Uahh/ToastFish)\n- [算法教程](https://github.com/krahets/hello-algo)\n\n## 2024-11-09\n\n- [如何活得更久🤪](https://github.com/geekan/HowToLiveLonger)\n\n## 2024-10-19\n\n- [基于google二次开发的搜索引擎](https://github.com/KoriIku/luxirty-search)\n- [反映CPU占用率的奔跑小猫](https://github.com/Kyome22/RunCat_for_windows)\n- [视频图片超分工具](https://github.com/k4yt3x/video2x)\n\n## 2024-10-12\n\n- [CS-Books](https://github.com/forthespada/CS-Books)\n  - 超过1000本的计算机经典书籍分享\n- [WizTree]([WizTree - The Fastest Disk Space Analyzer (diskanalyzer.com)](https://diskanalyzer.com/))\n  - 以树状图的形式分析Windows电脑硬盘的占用情况\n- [Lemon](https://lemon.qq.com/)\n  - 适用于Mac电脑的硬盘占用分析工具\n\n## 更久之前\n\n- [轻量级的AI证件照制作](https://github.com/Zeyi-Lin/HivisionIDPhotos)\n  - HivisionIDPhoto 旨在开发一种实用、系统性的证件照智能制作算法。 它利用一套完善的AI模型工作流程，实现对多种用户拍照场景的识别、抠图与证件照生成。\n- [OCR](https://github.com/hiroi-sora/Umi-OCR)\n  - 免费，开源，可批量的离线OCR软件\n- [图片高清工具](https://github.com/upscayl/upscayl)\n  - Upscayl lets you enlarge and enhance low-resolution images using advanced AI algorithms. Enlarge images without losing quality. It's almost like magic!\n\n- [cozy-reader](https://github.com/srsng/cozy-reader)\n  - 开源的 Epub 电子书的桌面阅读软件，跨平台\n\n- [PULSE](https://github.com/adamian98/pulse)\n  - 通过迭代比较输出和输入图片，去除马赛克\n\n- [The Most Dangerous Writing App](https://github.com/maebert/themostdangerouswritingapp?tab=readme-ov-file)\n  - 最危险的写作工具，只要停止写作超过若干秒，你的文章就没有啦😂\n  - 强迫自己提高产出效率🫠\n\n- [gkd](https://github.com/gkd-kit/gkd)\n  - 基于 **无障碍** + **高级选择器** + **订阅规则** 的自定义屏幕点击 APP🤪\n\n- [lux](https://github.com/iawia002/lux)\n  - 快速简单的**视频下载工具**\n\n- [摸鱼软件😁](https://github.com/DinoChan/Loaf)\n\n- [网盘搜索引擎](https://www.pansou.vip/)\n\n- [全平台通用换源工具与框架](https://github.com/RubyMetric/chsrc)\n\n- [修改器下载工具](https://github.com/dyang886/Game-Cheats-Manager)\n  - 修改器真快乐😏\n\n- [TypeScript题库](https://typeroom.cn/problems/all)\n  - TypeScript 题库 [Type Challenge](https://github.com/type-challenges/type-challenges) 的网页版。\n\n- [开源许可证选择器](https://open-source-license-chooser.toolsnav.top/en/)\n  - 回答几个问题，帮你选择一个开源许可证","source":"_posts/优质开源软件合集.md","raw":"---\ntitle: 优质资源合集\npublish: true\ndescription: 收藏一些优质资源\ntag: \n- 开源工具\n- 资源\n---\n\n# 优质资源合集\n\n## 2024-12-01\n- [Questionnaires tool](https://github.com/didi/xiaoju-survey)\n\n## 2024-11-17\n\n- [摸鱼背单词](https://github.com/Uahh/ToastFish)\n- [算法教程](https://github.com/krahets/hello-algo)\n\n## 2024-11-09\n\n- [如何活得更久🤪](https://github.com/geekan/HowToLiveLonger)\n\n## 2024-10-19\n\n- [基于google二次开发的搜索引擎](https://github.com/KoriIku/luxirty-search)\n- [反映CPU占用率的奔跑小猫](https://github.com/Kyome22/RunCat_for_windows)\n- [视频图片超分工具](https://github.com/k4yt3x/video2x)\n\n## 2024-10-12\n\n- [CS-Books](https://github.com/forthespada/CS-Books)\n  - 超过1000本的计算机经典书籍分享\n- [WizTree]([WizTree - The Fastest Disk Space Analyzer (diskanalyzer.com)](https://diskanalyzer.com/))\n  - 以树状图的形式分析Windows电脑硬盘的占用情况\n- [Lemon](https://lemon.qq.com/)\n  - 适用于Mac电脑的硬盘占用分析工具\n\n## 更久之前\n\n- [轻量级的AI证件照制作](https://github.com/Zeyi-Lin/HivisionIDPhotos)\n  - HivisionIDPhoto 旨在开发一种实用、系统性的证件照智能制作算法。 它利用一套完善的AI模型工作流程，实现对多种用户拍照场景的识别、抠图与证件照生成。\n- [OCR](https://github.com/hiroi-sora/Umi-OCR)\n  - 免费，开源，可批量的离线OCR软件\n- [图片高清工具](https://github.com/upscayl/upscayl)\n  - Upscayl lets you enlarge and enhance low-resolution images using advanced AI algorithms. Enlarge images without losing quality. It's almost like magic!\n\n- [cozy-reader](https://github.com/srsng/cozy-reader)\n  - 开源的 Epub 电子书的桌面阅读软件，跨平台\n\n- [PULSE](https://github.com/adamian98/pulse)\n  - 通过迭代比较输出和输入图片，去除马赛克\n\n- [The Most Dangerous Writing App](https://github.com/maebert/themostdangerouswritingapp?tab=readme-ov-file)\n  - 最危险的写作工具，只要停止写作超过若干秒，你的文章就没有啦😂\n  - 强迫自己提高产出效率🫠\n\n- [gkd](https://github.com/gkd-kit/gkd)\n  - 基于 **无障碍** + **高级选择器** + **订阅规则** 的自定义屏幕点击 APP🤪\n\n- [lux](https://github.com/iawia002/lux)\n  - 快速简单的**视频下载工具**\n\n- [摸鱼软件😁](https://github.com/DinoChan/Loaf)\n\n- [网盘搜索引擎](https://www.pansou.vip/)\n\n- [全平台通用换源工具与框架](https://github.com/RubyMetric/chsrc)\n\n- [修改器下载工具](https://github.com/dyang886/Game-Cheats-Manager)\n  - 修改器真快乐😏\n\n- [TypeScript题库](https://typeroom.cn/problems/all)\n  - TypeScript 题库 [Type Challenge](https://github.com/type-challenges/type-challenges) 的网页版。\n\n- [开源许可证选择器](https://open-source-license-chooser.toolsnav.top/en/)\n  - 回答几个问题，帮你选择一个开源许可证","slug":"优质开源软件合集","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000na5t297ug5by3","content":"<h1 id=\"优质资源合集\"><a href=\"#优质资源合集\" class=\"headerlink\" title=\"优质资源合集\"></a>优质资源合集</h1><h2 id=\"2024-12-01\"><a href=\"#2024-12-01\" class=\"headerlink\" title=\"2024-12-01\"></a>2024-12-01</h2><ul>\n<li><a href=\"https://github.com/didi/xiaoju-survey\">Questionnaires tool</a></li>\n</ul>\n<h2 id=\"2024-11-17\"><a href=\"#2024-11-17\" class=\"headerlink\" title=\"2024-11-17\"></a>2024-11-17</h2><ul>\n<li><a href=\"https://github.com/Uahh/ToastFish\">摸鱼背单词</a></li>\n<li><a href=\"https://github.com/krahets/hello-algo\">算法教程</a></li>\n</ul>\n<h2 id=\"2024-11-09\"><a href=\"#2024-11-09\" class=\"headerlink\" title=\"2024-11-09\"></a>2024-11-09</h2><ul>\n<li><a href=\"https://github.com/geekan/HowToLiveLonger\">如何活得更久🤪</a></li>\n</ul>\n<h2 id=\"2024-10-19\"><a href=\"#2024-10-19\" class=\"headerlink\" title=\"2024-10-19\"></a>2024-10-19</h2><ul>\n<li><a href=\"https://github.com/KoriIku/luxirty-search\">基于google二次开发的搜索引擎</a></li>\n<li><a href=\"https://github.com/Kyome22/RunCat_for_windows\">反映CPU占用率的奔跑小猫</a></li>\n<li><a href=\"https://github.com/k4yt3x/video2x\">视频图片超分工具</a></li>\n</ul>\n<h2 id=\"2024-10-12\"><a href=\"#2024-10-12\" class=\"headerlink\" title=\"2024-10-12\"></a>2024-10-12</h2><ul>\n<li><a href=\"https://github.com/forthespada/CS-Books\">CS-Books</a><ul>\n<li>超过1000本的计算机经典书籍分享</li>\n</ul>\n</li>\n<li>[WizTree](<a href=\"https://diskanalyzer.com/\">WizTree - The Fastest Disk Space Analyzer (diskanalyzer.com)</a>)<ul>\n<li>以树状图的形式分析Windows电脑硬盘的占用情况</li>\n</ul>\n</li>\n<li><a href=\"https://lemon.qq.com/\">Lemon</a><ul>\n<li>适用于Mac电脑的硬盘占用分析工具</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"更久之前\"><a href=\"#更久之前\" class=\"headerlink\" title=\"更久之前\"></a>更久之前</h2><ul>\n<li><p><a href=\"https://github.com/Zeyi-Lin/HivisionIDPhotos\">轻量级的AI证件照制作</a></p>\n<ul>\n<li>HivisionIDPhoto 旨在开发一种实用、系统性的证件照智能制作算法。 它利用一套完善的AI模型工作流程，实现对多种用户拍照场景的识别、抠图与证件照生成。</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hiroi-sora/Umi-OCR\">OCR</a></p>\n<ul>\n<li>免费，开源，可批量的离线OCR软件</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/upscayl/upscayl\">图片高清工具</a></p>\n<ul>\n<li>Upscayl lets you enlarge and enhance low-resolution images using advanced AI algorithms. Enlarge images without losing quality. It’s almost like magic!</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/srsng/cozy-reader\">cozy-reader</a></p>\n<ul>\n<li>开源的 Epub 电子书的桌面阅读软件，跨平台</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/adamian98/pulse\">PULSE</a></p>\n<ul>\n<li>通过迭代比较输出和输入图片，去除马赛克</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/maebert/themostdangerouswritingapp?tab=readme-ov-file\">The Most Dangerous Writing App</a></p>\n<ul>\n<li>最危险的写作工具，只要停止写作超过若干秒，你的文章就没有啦😂</li>\n<li>强迫自己提高产出效率🫠</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/gkd-kit/gkd\">gkd</a></p>\n<ul>\n<li>基于 <strong>无障碍</strong> + <strong>高级选择器</strong> + <strong>订阅规则</strong> 的自定义屏幕点击 APP🤪</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/iawia002/lux\">lux</a></p>\n<ul>\n<li>快速简单的<strong>视频下载工具</strong></li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/DinoChan/Loaf\">摸鱼软件😁</a></p>\n</li>\n<li><p><a href=\"https://www.pansou.vip/\">网盘搜索引擎</a></p>\n</li>\n<li><p><a href=\"https://github.com/RubyMetric/chsrc\">全平台通用换源工具与框架</a></p>\n</li>\n<li><p><a href=\"https://github.com/dyang886/Game-Cheats-Manager\">修改器下载工具</a></p>\n<ul>\n<li>修改器真快乐😏</li>\n</ul>\n</li>\n<li><p><a href=\"https://typeroom.cn/problems/all\">TypeScript题库</a></p>\n<ul>\n<li>TypeScript 题库 <a href=\"https://github.com/type-challenges/type-challenges\">Type Challenge</a> 的网页版。</li>\n</ul>\n</li>\n<li><p><a href=\"https://open-source-license-chooser.toolsnav.top/en/\">开源许可证选择器</a></p>\n<ul>\n<li>回答几个问题，帮你选择一个开源许可证</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"优质资源合集\"><a href=\"#优质资源合集\" class=\"headerlink\" title=\"优质资源合集\"></a>优质资源合集</h1><h2 id=\"2024-12-01\"><a href=\"#2024-12-01\" class=\"headerlink\" title=\"2024-12-01\"></a>2024-12-01</h2><ul>\n<li><a href=\"https://github.com/didi/xiaoju-survey\">Questionnaires tool</a></li>\n</ul>\n<h2 id=\"2024-11-17\"><a href=\"#2024-11-17\" class=\"headerlink\" title=\"2024-11-17\"></a>2024-11-17</h2><ul>\n<li><a href=\"https://github.com/Uahh/ToastFish\">摸鱼背单词</a></li>\n<li><a href=\"https://github.com/krahets/hello-algo\">算法教程</a></li>\n</ul>\n<h2 id=\"2024-11-09\"><a href=\"#2024-11-09\" class=\"headerlink\" title=\"2024-11-09\"></a>2024-11-09</h2><ul>\n<li><a href=\"https://github.com/geekan/HowToLiveLonger\">如何活得更久🤪</a></li>\n</ul>\n<h2 id=\"2024-10-19\"><a href=\"#2024-10-19\" class=\"headerlink\" title=\"2024-10-19\"></a>2024-10-19</h2><ul>\n<li><a href=\"https://github.com/KoriIku/luxirty-search\">基于google二次开发的搜索引擎</a></li>\n<li><a href=\"https://github.com/Kyome22/RunCat_for_windows\">反映CPU占用率的奔跑小猫</a></li>\n<li><a href=\"https://github.com/k4yt3x/video2x\">视频图片超分工具</a></li>\n</ul>\n<h2 id=\"2024-10-12\"><a href=\"#2024-10-12\" class=\"headerlink\" title=\"2024-10-12\"></a>2024-10-12</h2><ul>\n<li><a href=\"https://github.com/forthespada/CS-Books\">CS-Books</a><ul>\n<li>超过1000本的计算机经典书籍分享</li>\n</ul>\n</li>\n<li>[WizTree](<a href=\"https://diskanalyzer.com/\">WizTree - The Fastest Disk Space Analyzer (diskanalyzer.com)</a>)<ul>\n<li>以树状图的形式分析Windows电脑硬盘的占用情况</li>\n</ul>\n</li>\n<li><a href=\"https://lemon.qq.com/\">Lemon</a><ul>\n<li>适用于Mac电脑的硬盘占用分析工具</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"更久之前\"><a href=\"#更久之前\" class=\"headerlink\" title=\"更久之前\"></a>更久之前</h2><ul>\n<li><p><a href=\"https://github.com/Zeyi-Lin/HivisionIDPhotos\">轻量级的AI证件照制作</a></p>\n<ul>\n<li>HivisionIDPhoto 旨在开发一种实用、系统性的证件照智能制作算法。 它利用一套完善的AI模型工作流程，实现对多种用户拍照场景的识别、抠图与证件照生成。</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hiroi-sora/Umi-OCR\">OCR</a></p>\n<ul>\n<li>免费，开源，可批量的离线OCR软件</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/upscayl/upscayl\">图片高清工具</a></p>\n<ul>\n<li>Upscayl lets you enlarge and enhance low-resolution images using advanced AI algorithms. Enlarge images without losing quality. It’s almost like magic!</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/srsng/cozy-reader\">cozy-reader</a></p>\n<ul>\n<li>开源的 Epub 电子书的桌面阅读软件，跨平台</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/adamian98/pulse\">PULSE</a></p>\n<ul>\n<li>通过迭代比较输出和输入图片，去除马赛克</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/maebert/themostdangerouswritingapp?tab=readme-ov-file\">The Most Dangerous Writing App</a></p>\n<ul>\n<li>最危险的写作工具，只要停止写作超过若干秒，你的文章就没有啦😂</li>\n<li>强迫自己提高产出效率🫠</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/gkd-kit/gkd\">gkd</a></p>\n<ul>\n<li>基于 <strong>无障碍</strong> + <strong>高级选择器</strong> + <strong>订阅规则</strong> 的自定义屏幕点击 APP🤪</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/iawia002/lux\">lux</a></p>\n<ul>\n<li>快速简单的<strong>视频下载工具</strong></li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/DinoChan/Loaf\">摸鱼软件😁</a></p>\n</li>\n<li><p><a href=\"https://www.pansou.vip/\">网盘搜索引擎</a></p>\n</li>\n<li><p><a href=\"https://github.com/RubyMetric/chsrc\">全平台通用换源工具与框架</a></p>\n</li>\n<li><p><a href=\"https://github.com/dyang886/Game-Cheats-Manager\">修改器下载工具</a></p>\n<ul>\n<li>修改器真快乐😏</li>\n</ul>\n</li>\n<li><p><a href=\"https://typeroom.cn/problems/all\">TypeScript题库</a></p>\n<ul>\n<li>TypeScript 题库 <a href=\"https://github.com/type-challenges/type-challenges\">Type Challenge</a> 的网页版。</li>\n</ul>\n</li>\n<li><p><a href=\"https://open-source-license-chooser.toolsnav.top/en/\">开源许可证选择器</a></p>\n<ul>\n<li>回答几个问题，帮你选择一个开源许可证</li>\n</ul>\n</li>\n</ul>\n"},{"title":"记录使用本地缓存代替Redis","description":"记录抽象接口思路","sidebar":true,"readingTime":true,"_content":"\n# 使用本地缓存代替Redis\n> 现在因为你不想连Redis，所以你打算提供一个基于本地缓存实现的`cache.CodeCache`\n\n## 大体思路\n- 定义一个`CodeCache`接口，能够使得底层在Redis和本地缓存中无缝切换\n- 选择一个合适的本地缓存\n- 保证单机的并发安全\n\n## 定义接口\n### 在哪一级进行抽象？\n在已有的实现中，我们在repository中定义了`codeRepository`结构体<br>\n``` go\ntype CodeRepository struct {\n\tcache cache.CodeRedis\n}\n```\n在repository调用cache的Redis实现，进行存储验证码和校验验证码的操作，有如下的层次关系<br>\n![image-20240805184543232](https://raw.githubusercontent.com/lyydsheep/pic/main/202408051846343.png)<br>\n使用本地缓存替换Redis，上图中的层次关系不改变，变化的时cache的具体实现，因此memory和Redis属于同一级<br>\n我们第一步需要做的就是在Redis-memory这一等级上抽象出一个接口，并将其暴露给repository，向repository屏蔽底层细节。repository只需要通过调用接口方法，就能完成数据存储和数据查找\n### 如何思考接口的定义？\n我们可以从已有的Redis实现出发，思考接口该如何定义<br>\n``` go\nfunc (cc *CodeRedisCache) CheckCode(ctx context.Context, key string, input string) error {\n\tres, err := cc.client.Eval(ctx, luaCheckCode, []string{key}, input).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch res {\n\tcase 0:\n\t\treturn nil\n\tcase -1:\n\t\treturn ErrNotMatch\n\tcase -3:\n\t\treturn ErrExceed\n\tdefault:\n\t\treturn errors.New(\"系统错误\")\n\t}\n}\n\nfunc (cc *CodeRedisCache) SetCode(ctx context.Context, key string, val string) error {\n\t//获取返回值\n\tres, err := cc.client.Eval(ctx, luaSetCode, []string{key}, val).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch res {\n\tcase 0:\n\t\treturn nil\n\tcase -1:\n\t\treturn ErrTooFrequent\n\tdefault:\n\t\treturn errors.New(\"系统错误\")\n\n\t}\n}\n```\n从Redis实现中，可以获取两个信息\n- 两个方法`CheckCode`和`SetCode`分别进行查询数据和存储数据的操作<br>\n- 调用`lua`脚本保证`check-do something`操作是原子性的\n\n目前在cache层中，要么是对数据查询，要么是对数据存储，并结合第一条信息，很容易就能得出接口的定义\n``` go\ntype CodeCache interface {\n\tCheckCode(ctx context.Context, key string, input string) error\n\tSetCode(ctx context.Context, key string, val string) error\n}\n```\n在某些复杂的情况下，我们还需要对接口中方法的参数类型进行调整，一种万金油的方法就是**再定义一个`Data`结构体**，在`Data`结构体中设置不同底层实现所需要的字段<br>\n例如：\n``` go\ntype NameData struct {\n    Name string\n    Data string\n}\n```\n\n定义好接口后，我们还需要将接口暴露给`repository`，具体实现如下：\n``` go\ntype CodeRepository struct {\n\tcache cache.CodeCache\n}\n```\n\n## 选择一个本地缓存\n在Golang中有三个本地缓存库比较有名：\n![image-20240805190511385](https://raw.githubusercontent.com/lyydsheep/pic/main/202408051905419.png)<br>\n具体选择时应考虑一下几点：\n- 结合场景\n- 如果需要对单个key设置过期时间，选择freecache\n- 如果不注重单个key过期时间，更注重性能,选择bigcache\n\n查询官方文档，便能很容易在`CodeMemory`结构体上实现`CodeCache`接口\n\n## 并发问题\n很显然，不管是设置验证码还是校验验证码，都是`check-do something`的流程操作，存在明显的并发问题<br>\n在Redis实现中，巧妙地使用了`lua`脚本，将操作整合成一个原子操作。但是在memory实现中，我们无法通过类似的方式避免并发问题，因此只能暴力上锁、解锁来保证并发安全","source":"_posts/使用本地缓存代替Redis.md","raw":"---\ntitle: 记录使用本地缓存代替Redis\n#sticky: 999\ndescription: 记录抽象接口思路\n#descriptionHTML: \ntag:\n - Golang\n#top: 1\nsidebar: true\n#categories: [Golang]\nreadingTime: true\n#recommend: 3\n---\n\n# 使用本地缓存代替Redis\n> 现在因为你不想连Redis，所以你打算提供一个基于本地缓存实现的`cache.CodeCache`\n\n## 大体思路\n- 定义一个`CodeCache`接口，能够使得底层在Redis和本地缓存中无缝切换\n- 选择一个合适的本地缓存\n- 保证单机的并发安全\n\n## 定义接口\n### 在哪一级进行抽象？\n在已有的实现中，我们在repository中定义了`codeRepository`结构体<br>\n``` go\ntype CodeRepository struct {\n\tcache cache.CodeRedis\n}\n```\n在repository调用cache的Redis实现，进行存储验证码和校验验证码的操作，有如下的层次关系<br>\n![image-20240805184543232](https://raw.githubusercontent.com/lyydsheep/pic/main/202408051846343.png)<br>\n使用本地缓存替换Redis，上图中的层次关系不改变，变化的时cache的具体实现，因此memory和Redis属于同一级<br>\n我们第一步需要做的就是在Redis-memory这一等级上抽象出一个接口，并将其暴露给repository，向repository屏蔽底层细节。repository只需要通过调用接口方法，就能完成数据存储和数据查找\n### 如何思考接口的定义？\n我们可以从已有的Redis实现出发，思考接口该如何定义<br>\n``` go\nfunc (cc *CodeRedisCache) CheckCode(ctx context.Context, key string, input string) error {\n\tres, err := cc.client.Eval(ctx, luaCheckCode, []string{key}, input).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch res {\n\tcase 0:\n\t\treturn nil\n\tcase -1:\n\t\treturn ErrNotMatch\n\tcase -3:\n\t\treturn ErrExceed\n\tdefault:\n\t\treturn errors.New(\"系统错误\")\n\t}\n}\n\nfunc (cc *CodeRedisCache) SetCode(ctx context.Context, key string, val string) error {\n\t//获取返回值\n\tres, err := cc.client.Eval(ctx, luaSetCode, []string{key}, val).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch res {\n\tcase 0:\n\t\treturn nil\n\tcase -1:\n\t\treturn ErrTooFrequent\n\tdefault:\n\t\treturn errors.New(\"系统错误\")\n\n\t}\n}\n```\n从Redis实现中，可以获取两个信息\n- 两个方法`CheckCode`和`SetCode`分别进行查询数据和存储数据的操作<br>\n- 调用`lua`脚本保证`check-do something`操作是原子性的\n\n目前在cache层中，要么是对数据查询，要么是对数据存储，并结合第一条信息，很容易就能得出接口的定义\n``` go\ntype CodeCache interface {\n\tCheckCode(ctx context.Context, key string, input string) error\n\tSetCode(ctx context.Context, key string, val string) error\n}\n```\n在某些复杂的情况下，我们还需要对接口中方法的参数类型进行调整，一种万金油的方法就是**再定义一个`Data`结构体**，在`Data`结构体中设置不同底层实现所需要的字段<br>\n例如：\n``` go\ntype NameData struct {\n    Name string\n    Data string\n}\n```\n\n定义好接口后，我们还需要将接口暴露给`repository`，具体实现如下：\n``` go\ntype CodeRepository struct {\n\tcache cache.CodeCache\n}\n```\n\n## 选择一个本地缓存\n在Golang中有三个本地缓存库比较有名：\n![image-20240805190511385](https://raw.githubusercontent.com/lyydsheep/pic/main/202408051905419.png)<br>\n具体选择时应考虑一下几点：\n- 结合场景\n- 如果需要对单个key设置过期时间，选择freecache\n- 如果不注重单个key过期时间，更注重性能,选择bigcache\n\n查询官方文档，便能很容易在`CodeMemory`结构体上实现`CodeCache`接口\n\n## 并发问题\n很显然，不管是设置验证码还是校验验证码，都是`check-do something`的流程操作，存在明显的并发问题<br>\n在Redis实现中，巧妙地使用了`lua`脚本，将操作整合成一个原子操作。但是在memory实现中，我们无法通过类似的方式避免并发问题，因此只能暴力上锁、解锁来保证并发安全","slug":"使用本地缓存代替Redis","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000pa5t2233r35uc","content":"<h1 id=\"使用本地缓存代替Redis\"><a href=\"#使用本地缓存代替Redis\" class=\"headerlink\" title=\"使用本地缓存代替Redis\"></a>使用本地缓存代替Redis</h1><blockquote>\n<p>现在因为你不想连Redis，所以你打算提供一个基于本地缓存实现的<code>cache.CodeCache</code></p>\n</blockquote>\n<h2 id=\"大体思路\"><a href=\"#大体思路\" class=\"headerlink\" title=\"大体思路\"></a>大体思路</h2><ul>\n<li>定义一个<code>CodeCache</code>接口，能够使得底层在Redis和本地缓存中无缝切换</li>\n<li>选择一个合适的本地缓存</li>\n<li>保证单机的并发安全</li>\n</ul>\n<h2 id=\"定义接口\"><a href=\"#定义接口\" class=\"headerlink\" title=\"定义接口\"></a>定义接口</h2><h3 id=\"在哪一级进行抽象？\"><a href=\"#在哪一级进行抽象？\" class=\"headerlink\" title=\"在哪一级进行抽象？\"></a>在哪一级进行抽象？</h3><p>在已有的实现中，我们在repository中定义了<code>codeRepository</code>结构体<br></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcache cache.CodeRedis</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在repository调用cache的Redis实现，进行存储验证码和校验验证码的操作，有如下的层次关系<br><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408051846343.png\" alt=\"image-20240805184543232\"><br><br>使用本地缓存替换Redis，上图中的层次关系不改变，变化的时cache的具体实现，因此memory和Redis属于同一级<br><br>我们第一步需要做的就是在Redis-memory这一等级上抽象出一个接口，并将其暴露给repository，向repository屏蔽底层细节。repository只需要通过调用接口方法，就能完成数据存储和数据查找</p>\n<h3 id=\"如何思考接口的定义？\"><a href=\"#如何思考接口的定义？\" class=\"headerlink\" title=\"如何思考接口的定义？\"></a>如何思考接口的定义？</h3><p>我们可以从已有的Redis实现出发，思考接口该如何定义<br></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cc *CodeRedisCache)</span></span> CheckCode(ctx context.Context, key <span class=\"type\">string</span>, input <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tres, err := cc.client.Eval(ctx, luaCheckCode, []<span class=\"type\">string</span>&#123;key&#125;, input).Int()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> res &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrNotMatch</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-3</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrExceed</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;系统错误&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cc *CodeRedisCache)</span></span> SetCode(ctx context.Context, key <span class=\"type\">string</span>, val <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取返回值</span></span><br><span class=\"line\">\tres, err := cc.client.Eval(ctx, luaSetCode, []<span class=\"type\">string</span>&#123;key&#125;, val).Int()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> res &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrTooFrequent</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;系统错误&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从Redis实现中，可以获取两个信息</p>\n<ul>\n<li>两个方法<code>CheckCode</code>和<code>SetCode</code>分别进行查询数据和存储数据的操作<br></li>\n<li>调用<code>lua</code>脚本保证<code>check-do something</code>操作是原子性的</li>\n</ul>\n<p>目前在cache层中，要么是对数据查询，要么是对数据存储，并结合第一条信息，很容易就能得出接口的定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeCache <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tCheckCode(ctx context.Context, key <span class=\"type\">string</span>, input <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">\tSetCode(ctx context.Context, key <span class=\"type\">string</span>, val <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在某些复杂的情况下，我们还需要对接口中方法的参数类型进行调整，一种万金油的方法就是<strong>再定义一个<code>Data</code>结构体</strong>，在<code>Data</code>结构体中设置不同底层实现所需要的字段<br><br>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NameData <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"type\">string</span></span><br><span class=\"line\">    Data <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义好接口后，我们还需要将接口暴露给<code>repository</code>，具体实现如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcache cache.CodeCache</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择一个本地缓存\"><a href=\"#选择一个本地缓存\" class=\"headerlink\" title=\"选择一个本地缓存\"></a>选择一个本地缓存</h2><p>在Golang中有三个本地缓存库比较有名：<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408051905419.png\" alt=\"image-20240805190511385\"><br><br>具体选择时应考虑一下几点：</p>\n<ul>\n<li>结合场景</li>\n<li>如果需要对单个key设置过期时间，选择freecache</li>\n<li>如果不注重单个key过期时间，更注重性能,选择bigcache</li>\n</ul>\n<p>查询官方文档，便能很容易在<code>CodeMemory</code>结构体上实现<code>CodeCache</code>接口</p>\n<h2 id=\"并发问题\"><a href=\"#并发问题\" class=\"headerlink\" title=\"并发问题\"></a>并发问题</h2><p>很显然，不管是设置验证码还是校验验证码，都是<code>check-do something</code>的流程操作，存在明显的并发问题<br><br>在Redis实现中，巧妙地使用了<code>lua</code>脚本，将操作整合成一个原子操作。但是在memory实现中，我们无法通过类似的方式避免并发问题，因此只能暴力上锁、解锁来保证并发安全</p>\n","excerpt":"","more":"<h1 id=\"使用本地缓存代替Redis\"><a href=\"#使用本地缓存代替Redis\" class=\"headerlink\" title=\"使用本地缓存代替Redis\"></a>使用本地缓存代替Redis</h1><blockquote>\n<p>现在因为你不想连Redis，所以你打算提供一个基于本地缓存实现的<code>cache.CodeCache</code></p>\n</blockquote>\n<h2 id=\"大体思路\"><a href=\"#大体思路\" class=\"headerlink\" title=\"大体思路\"></a>大体思路</h2><ul>\n<li>定义一个<code>CodeCache</code>接口，能够使得底层在Redis和本地缓存中无缝切换</li>\n<li>选择一个合适的本地缓存</li>\n<li>保证单机的并发安全</li>\n</ul>\n<h2 id=\"定义接口\"><a href=\"#定义接口\" class=\"headerlink\" title=\"定义接口\"></a>定义接口</h2><h3 id=\"在哪一级进行抽象？\"><a href=\"#在哪一级进行抽象？\" class=\"headerlink\" title=\"在哪一级进行抽象？\"></a>在哪一级进行抽象？</h3><p>在已有的实现中，我们在repository中定义了<code>codeRepository</code>结构体<br></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcache cache.CodeRedis</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在repository调用cache的Redis实现，进行存储验证码和校验验证码的操作，有如下的层次关系<br><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408051846343.png\" alt=\"image-20240805184543232\"><br><br>使用本地缓存替换Redis，上图中的层次关系不改变，变化的时cache的具体实现，因此memory和Redis属于同一级<br><br>我们第一步需要做的就是在Redis-memory这一等级上抽象出一个接口，并将其暴露给repository，向repository屏蔽底层细节。repository只需要通过调用接口方法，就能完成数据存储和数据查找</p>\n<h3 id=\"如何思考接口的定义？\"><a href=\"#如何思考接口的定义？\" class=\"headerlink\" title=\"如何思考接口的定义？\"></a>如何思考接口的定义？</h3><p>我们可以从已有的Redis实现出发，思考接口该如何定义<br></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cc *CodeRedisCache)</span></span> CheckCode(ctx context.Context, key <span class=\"type\">string</span>, input <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tres, err := cc.client.Eval(ctx, luaCheckCode, []<span class=\"type\">string</span>&#123;key&#125;, input).Int()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> res &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrNotMatch</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-3</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrExceed</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;系统错误&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cc *CodeRedisCache)</span></span> SetCode(ctx context.Context, key <span class=\"type\">string</span>, val <span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取返回值</span></span><br><span class=\"line\">\tres, err := cc.client.Eval(ctx, luaSetCode, []<span class=\"type\">string</span>&#123;key&#125;, val).Int()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> res &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrTooFrequent</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;系统错误&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从Redis实现中，可以获取两个信息</p>\n<ul>\n<li>两个方法<code>CheckCode</code>和<code>SetCode</code>分别进行查询数据和存储数据的操作<br></li>\n<li>调用<code>lua</code>脚本保证<code>check-do something</code>操作是原子性的</li>\n</ul>\n<p>目前在cache层中，要么是对数据查询，要么是对数据存储，并结合第一条信息，很容易就能得出接口的定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeCache <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tCheckCode(ctx context.Context, key <span class=\"type\">string</span>, input <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">\tSetCode(ctx context.Context, key <span class=\"type\">string</span>, val <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在某些复杂的情况下，我们还需要对接口中方法的参数类型进行调整，一种万金油的方法就是<strong>再定义一个<code>Data</code>结构体</strong>，在<code>Data</code>结构体中设置不同底层实现所需要的字段<br><br>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NameData <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"type\">string</span></span><br><span class=\"line\">    Data <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义好接口后，我们还需要将接口暴露给<code>repository</code>，具体实现如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CodeRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcache cache.CodeCache</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择一个本地缓存\"><a href=\"#选择一个本地缓存\" class=\"headerlink\" title=\"选择一个本地缓存\"></a>选择一个本地缓存</h2><p>在Golang中有三个本地缓存库比较有名：<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408051905419.png\" alt=\"image-20240805190511385\"><br><br>具体选择时应考虑一下几点：</p>\n<ul>\n<li>结合场景</li>\n<li>如果需要对单个key设置过期时间，选择freecache</li>\n<li>如果不注重单个key过期时间，更注重性能,选择bigcache</li>\n</ul>\n<p>查询官方文档，便能很容易在<code>CodeMemory</code>结构体上实现<code>CodeCache</code>接口</p>\n<h2 id=\"并发问题\"><a href=\"#并发问题\" class=\"headerlink\" title=\"并发问题\"></a>并发问题</h2><p>很显然，不管是设置验证码还是校验验证码，都是<code>check-do something</code>的流程操作，存在明显的并发问题<br><br>在Redis实现中，巧妙地使用了<code>lua</code>脚本，将操作整合成一个原子操作。但是在memory实现中，我们无法通过类似的方式避免并发问题，因此只能暴力上锁、解锁来保证并发安全</p>\n"},{"publish":false,"_content":"\n# 分布式理论基础\n\n## 什么是分布式系统\n\n分布式系统是集中式系统的对应面，在明确分布式系统定义之前，让我们看看什么是集中式系统\n\n### 集中式系统\n\n集中式系统通常是由一台性能超强的计算机支撑的，系统所有的数据集和所有的业务单元都集中部署在这个中心节点上，所有的业务逻辑都是在中心节点上处理的\n\n![image-20240910191137362](https://raw.githubusercontent.com/lyydsheep/pic/main/202409101912496.png)\n\n#### 特点\n\n集中式系统最大的特点就是**结构简单**，因为系统所有的部分都是在这一个节点上实现的，不需要考虑多个节点之间的协作问题。\n\n也正是因为系统单机部署，导致整个系统庞大且复杂，很难进行扩展（牵一发而动全身），并且还存在单点故障、性能差等问题。\n\n### 分布式系统\n\n分布式系统就是为解决集中式系统的瓶颈而生的。分布式系统核心思想就是“分治”，将大问题拆分成一个一个小问题，将系统拆分成一个一个小服务单元，分而治之。每一个服务单元分散到不同的网络节点上，彼此之间协调服务，共同完成系统的整体功能。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101929132.png\" alt=\"image-20240910192903084\" style=\"zoom: 67%;\" />\n\n\n\n#### 特点\n\n- **分散性：**分布式系统中的节点都是独立运行的，并且可以在空间任意分布，而且可以随时变动。这种分散性可以有效的提高分布式系统的可用性和伸缩性，并且具备很强的容错能力\n- **并发性**：分布式系统中有多个进程并发运行，从而实现更高的性能\n- **异构性**：分布式系统中的节点可能具有不同的硬件和软件资源\n- **容错性**：分布式系统可以通过备份、复制以及一些容错算法来避免单点故障，提高系统的可靠性\n- **可扩展性**：分布式系统可以灵活的增加和删减系统资源来适应不同的业务场景\n- **透明性**：分布式系统对外是无感知的，对用户而言系统就是一个整体\n\n## 单机和集群以及分布式的关系\n\n### 单机\n\n单机架构比较简单，就是系统的所有服务都运行在**同一台机器上**\n\n![image-20240917142802979](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171428072.png)\n\n### 集群\n\n单机架构所有的服务都运行在一台机器上，机器的硬件资源往往是性能的瓶颈。一个很直接的想法就是一台机器不行，那就引入多台机器，这就是集群架构的做法。\n\n所以集群架构可以简单理解为是**多个单机架构组成的**，集群中每一台机器都是一个节点，**每个节点都提供着相同的服务**\n\n![image-20240917143354503](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171433611.png)\n\n### 分布式\n\n集群虽然能够有效解决单机架构的性能瓶颈，但是每个节点上依旧运行着所有的服务，耦合度太高，维护起来比较麻烦。不如从业务功能角度出发，将每个业务功能拆分成一个完全独立的子系统，这些子系统之间通过消息传递进行通信和协调工作，共同提供一个完整的系统功能。\n\n![image-20240917144228241](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171442369.png)\n\n上图所示就是一个分布式系统，并且是一个分布式集群，将电商业务拆成了多个服务部署到了不同的服务器上，并且订单服务，物流服务，还有商品服务都是集群化部署，部署了多份。当然这个例子只是为了说明分布式和集群的关系，现在真正的业务场景一般不会这样部署了，不会一台服务器部署一个应用服务，都是容器化多实例部署\n\n\n\n单机、集群、分布式、微服务\n\n分布式优点\n\n\n\n\n\nCAP理论\n\n数据一致性（C）\n\n可用性（A）\n\n分区容错性（P）\n\n\n\n要么CP要么AP","source":"_posts/分布式理论基础.md","raw":"---\npublish: false\n---\n\n# 分布式理论基础\n\n## 什么是分布式系统\n\n分布式系统是集中式系统的对应面，在明确分布式系统定义之前，让我们看看什么是集中式系统\n\n### 集中式系统\n\n集中式系统通常是由一台性能超强的计算机支撑的，系统所有的数据集和所有的业务单元都集中部署在这个中心节点上，所有的业务逻辑都是在中心节点上处理的\n\n![image-20240910191137362](https://raw.githubusercontent.com/lyydsheep/pic/main/202409101912496.png)\n\n#### 特点\n\n集中式系统最大的特点就是**结构简单**，因为系统所有的部分都是在这一个节点上实现的，不需要考虑多个节点之间的协作问题。\n\n也正是因为系统单机部署，导致整个系统庞大且复杂，很难进行扩展（牵一发而动全身），并且还存在单点故障、性能差等问题。\n\n### 分布式系统\n\n分布式系统就是为解决集中式系统的瓶颈而生的。分布式系统核心思想就是“分治”，将大问题拆分成一个一个小问题，将系统拆分成一个一个小服务单元，分而治之。每一个服务单元分散到不同的网络节点上，彼此之间协调服务，共同完成系统的整体功能。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101929132.png\" alt=\"image-20240910192903084\" style=\"zoom: 67%;\" />\n\n\n\n#### 特点\n\n- **分散性：**分布式系统中的节点都是独立运行的，并且可以在空间任意分布，而且可以随时变动。这种分散性可以有效的提高分布式系统的可用性和伸缩性，并且具备很强的容错能力\n- **并发性**：分布式系统中有多个进程并发运行，从而实现更高的性能\n- **异构性**：分布式系统中的节点可能具有不同的硬件和软件资源\n- **容错性**：分布式系统可以通过备份、复制以及一些容错算法来避免单点故障，提高系统的可靠性\n- **可扩展性**：分布式系统可以灵活的增加和删减系统资源来适应不同的业务场景\n- **透明性**：分布式系统对外是无感知的，对用户而言系统就是一个整体\n\n## 单机和集群以及分布式的关系\n\n### 单机\n\n单机架构比较简单，就是系统的所有服务都运行在**同一台机器上**\n\n![image-20240917142802979](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171428072.png)\n\n### 集群\n\n单机架构所有的服务都运行在一台机器上，机器的硬件资源往往是性能的瓶颈。一个很直接的想法就是一台机器不行，那就引入多台机器，这就是集群架构的做法。\n\n所以集群架构可以简单理解为是**多个单机架构组成的**，集群中每一台机器都是一个节点，**每个节点都提供着相同的服务**\n\n![image-20240917143354503](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171433611.png)\n\n### 分布式\n\n集群虽然能够有效解决单机架构的性能瓶颈，但是每个节点上依旧运行着所有的服务，耦合度太高，维护起来比较麻烦。不如从业务功能角度出发，将每个业务功能拆分成一个完全独立的子系统，这些子系统之间通过消息传递进行通信和协调工作，共同提供一个完整的系统功能。\n\n![image-20240917144228241](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171442369.png)\n\n上图所示就是一个分布式系统，并且是一个分布式集群，将电商业务拆成了多个服务部署到了不同的服务器上，并且订单服务，物流服务，还有商品服务都是集群化部署，部署了多份。当然这个例子只是为了说明分布式和集群的关系，现在真正的业务场景一般不会这样部署了，不会一台服务器部署一个应用服务，都是容器化多实例部署\n\n\n\n单机、集群、分布式、微服务\n\n分布式优点\n\n\n\n\n\nCAP理论\n\n数据一致性（C）\n\n可用性（A）\n\n分区容错性（P）\n\n\n\n要么CP要么AP","slug":"分布式理论基础","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6i000ra5t24g8d9o27","content":"<h1 id=\"分布式理论基础\"><a href=\"#分布式理论基础\" class=\"headerlink\" title=\"分布式理论基础\"></a>分布式理论基础</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统是集中式系统的对应面，在明确分布式系统定义之前，让我们看看什么是集中式系统</p>\n<h3 id=\"集中式系统\"><a href=\"#集中式系统\" class=\"headerlink\" title=\"集中式系统\"></a>集中式系统</h3><p>集中式系统通常是由一台性能超强的计算机支撑的，系统所有的数据集和所有的业务单元都集中部署在这个中心节点上，所有的业务逻辑都是在中心节点上处理的</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101912496.png\" alt=\"image-20240910191137362\"></p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>集中式系统最大的特点就是<strong>结构简单</strong>，因为系统所有的部分都是在这一个节点上实现的，不需要考虑多个节点之间的协作问题。</p>\n<p>也正是因为系统单机部署，导致整个系统庞大且复杂，很难进行扩展（牵一发而动全身），并且还存在单点故障、性能差等问题。</p>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统就是为解决集中式系统的瓶颈而生的。分布式系统核心思想就是“分治”，将大问题拆分成一个一个小问题，将系统拆分成一个一个小服务单元，分而治之。每一个服务单元分散到不同的网络节点上，彼此之间协调服务，共同完成系统的整体功能。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101929132.png\" alt=\"image-20240910192903084\" style=\"zoom: 67%;\" />\n\n\n\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>分散性：</strong>分布式系统中的节点都是独立运行的，并且可以在空间任意分布，而且可以随时变动。这种分散性可以有效的提高分布式系统的可用性和伸缩性，并且具备很强的容错能力</li>\n<li><strong>并发性</strong>：分布式系统中有多个进程并发运行，从而实现更高的性能</li>\n<li><strong>异构性</strong>：分布式系统中的节点可能具有不同的硬件和软件资源</li>\n<li><strong>容错性</strong>：分布式系统可以通过备份、复制以及一些容错算法来避免单点故障，提高系统的可靠性</li>\n<li><strong>可扩展性</strong>：分布式系统可以灵活的增加和删减系统资源来适应不同的业务场景</li>\n<li><strong>透明性</strong>：分布式系统对外是无感知的，对用户而言系统就是一个整体</li>\n</ul>\n<h2 id=\"单机和集群以及分布式的关系\"><a href=\"#单机和集群以及分布式的关系\" class=\"headerlink\" title=\"单机和集群以及分布式的关系\"></a>单机和集群以及分布式的关系</h2><h3 id=\"单机\"><a href=\"#单机\" class=\"headerlink\" title=\"单机\"></a>单机</h3><p>单机架构比较简单，就是系统的所有服务都运行在<strong>同一台机器上</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171428072.png\" alt=\"image-20240917142802979\"></p>\n<h3 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h3><p>单机架构所有的服务都运行在一台机器上，机器的硬件资源往往是性能的瓶颈。一个很直接的想法就是一台机器不行，那就引入多台机器，这就是集群架构的做法。</p>\n<p>所以集群架构可以简单理解为是<strong>多个单机架构组成的</strong>，集群中每一台机器都是一个节点，<strong>每个节点都提供着相同的服务</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171433611.png\" alt=\"image-20240917143354503\"></p>\n<h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3><p>集群虽然能够有效解决单机架构的性能瓶颈，但是每个节点上依旧运行着所有的服务，耦合度太高，维护起来比较麻烦。不如从业务功能角度出发，将每个业务功能拆分成一个完全独立的子系统，这些子系统之间通过消息传递进行通信和协调工作，共同提供一个完整的系统功能。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171442369.png\" alt=\"image-20240917144228241\"></p>\n<p>上图所示就是一个分布式系统，并且是一个分布式集群，将电商业务拆成了多个服务部署到了不同的服务器上，并且订单服务，物流服务，还有商品服务都是集群化部署，部署了多份。当然这个例子只是为了说明分布式和集群的关系，现在真正的业务场景一般不会这样部署了，不会一台服务器部署一个应用服务，都是容器化多实例部署</p>\n<p>单机、集群、分布式、微服务</p>\n<p>分布式优点</p>\n<p>CAP理论</p>\n<p>数据一致性（C）</p>\n<p>可用性（A）</p>\n<p>分区容错性（P）</p>\n<p>要么CP要么AP</p>\n","excerpt":"","more":"<h1 id=\"分布式理论基础\"><a href=\"#分布式理论基础\" class=\"headerlink\" title=\"分布式理论基础\"></a>分布式理论基础</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统是集中式系统的对应面，在明确分布式系统定义之前，让我们看看什么是集中式系统</p>\n<h3 id=\"集中式系统\"><a href=\"#集中式系统\" class=\"headerlink\" title=\"集中式系统\"></a>集中式系统</h3><p>集中式系统通常是由一台性能超强的计算机支撑的，系统所有的数据集和所有的业务单元都集中部署在这个中心节点上，所有的业务逻辑都是在中心节点上处理的</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101912496.png\" alt=\"image-20240910191137362\"></p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>集中式系统最大的特点就是<strong>结构简单</strong>，因为系统所有的部分都是在这一个节点上实现的，不需要考虑多个节点之间的协作问题。</p>\n<p>也正是因为系统单机部署，导致整个系统庞大且复杂，很难进行扩展（牵一发而动全身），并且还存在单点故障、性能差等问题。</p>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统就是为解决集中式系统的瓶颈而生的。分布式系统核心思想就是“分治”，将大问题拆分成一个一个小问题，将系统拆分成一个一个小服务单元，分而治之。每一个服务单元分散到不同的网络节点上，彼此之间协调服务，共同完成系统的整体功能。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409101929132.png\" alt=\"image-20240910192903084\" style=\"zoom: 67%;\" />\n\n\n\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>分散性：</strong>分布式系统中的节点都是独立运行的，并且可以在空间任意分布，而且可以随时变动。这种分散性可以有效的提高分布式系统的可用性和伸缩性，并且具备很强的容错能力</li>\n<li><strong>并发性</strong>：分布式系统中有多个进程并发运行，从而实现更高的性能</li>\n<li><strong>异构性</strong>：分布式系统中的节点可能具有不同的硬件和软件资源</li>\n<li><strong>容错性</strong>：分布式系统可以通过备份、复制以及一些容错算法来避免单点故障，提高系统的可靠性</li>\n<li><strong>可扩展性</strong>：分布式系统可以灵活的增加和删减系统资源来适应不同的业务场景</li>\n<li><strong>透明性</strong>：分布式系统对外是无感知的，对用户而言系统就是一个整体</li>\n</ul>\n<h2 id=\"单机和集群以及分布式的关系\"><a href=\"#单机和集群以及分布式的关系\" class=\"headerlink\" title=\"单机和集群以及分布式的关系\"></a>单机和集群以及分布式的关系</h2><h3 id=\"单机\"><a href=\"#单机\" class=\"headerlink\" title=\"单机\"></a>单机</h3><p>单机架构比较简单，就是系统的所有服务都运行在<strong>同一台机器上</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171428072.png\" alt=\"image-20240917142802979\"></p>\n<h3 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h3><p>单机架构所有的服务都运行在一台机器上，机器的硬件资源往往是性能的瓶颈。一个很直接的想法就是一台机器不行，那就引入多台机器，这就是集群架构的做法。</p>\n<p>所以集群架构可以简单理解为是<strong>多个单机架构组成的</strong>，集群中每一台机器都是一个节点，<strong>每个节点都提供着相同的服务</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171433611.png\" alt=\"image-20240917143354503\"></p>\n<h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3><p>集群虽然能够有效解决单机架构的性能瓶颈，但是每个节点上依旧运行着所有的服务，耦合度太高，维护起来比较麻烦。不如从业务功能角度出发，将每个业务功能拆分成一个完全独立的子系统，这些子系统之间通过消息传递进行通信和协调工作，共同提供一个完整的系统功能。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409171442369.png\" alt=\"image-20240917144228241\"></p>\n<p>上图所示就是一个分布式系统，并且是一个分布式集群，将电商业务拆成了多个服务部署到了不同的服务器上，并且订单服务，物流服务，还有商品服务都是集群化部署，部署了多份。当然这个例子只是为了说明分布式和集群的关系，现在真正的业务场景一般不会这样部署了，不会一台服务器部署一个应用服务，都是容器化多实例部署</p>\n<p>单机、集群、分布式、微服务</p>\n<p>分布式优点</p>\n<p>CAP理论</p>\n<p>数据一致性（C）</p>\n<p>可用性（A）</p>\n<p>分区容错性（P）</p>\n<p>要么CP要么AP</p>\n"},{"publish":false,"date":"2024-12-12T16:00:00.000Z","_content":"## 同步与异步\n\n同步：调用方发起请求，然后等待服务端执行完任务回包\n异步：发起者调用请求接口，任务异步处理，发起者对结果进行轮询\n\n\n## 记录一些问题\n- 为什么配置要存在DB，而不是采用Viper或者etcd？\n\t- 并发问题？\n\n\n## 有意思的点\n- 单体应用上升至分布式应用，考虑问题\n- 相对优先级，解耦、取消联合索引","source":"_posts/异步框架.md","raw":"---\npublish: false\ntags:\n  - 项目\ndate: 2024-12-13\n---\n## 同步与异步\n\n同步：调用方发起请求，然后等待服务端执行完任务回包\n异步：发起者调用请求接口，任务异步处理，发起者对结果进行轮询\n\n\n## 记录一些问题\n- 为什么配置要存在DB，而不是采用Viper或者etcd？\n\t- 并发问题？\n\n\n## 有意思的点\n- 单体应用上升至分布式应用，考虑问题\n- 相对优先级，解耦、取消联合索引","slug":"异步框架","published":1,"updated":"2024-12-27T11:03:15.344Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j000ta5t26mn0f4ae","content":"<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><p>同步：调用方发起请求，然后等待服务端执行完任务回包<br>异步：发起者调用请求接口，任务异步处理，发起者对结果进行轮询</p>\n<h2 id=\"记录一些问题\"><a href=\"#记录一些问题\" class=\"headerlink\" title=\"记录一些问题\"></a>记录一些问题</h2><ul>\n<li>为什么配置要存在DB，而不是采用Viper或者etcd？<ul>\n<li>并发问题？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有意思的点\"><a href=\"#有意思的点\" class=\"headerlink\" title=\"有意思的点\"></a>有意思的点</h2><ul>\n<li>单体应用上升至分布式应用，考虑问题</li>\n<li>相对优先级，解耦、取消联合索引</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><p>同步：调用方发起请求，然后等待服务端执行完任务回包<br>异步：发起者调用请求接口，任务异步处理，发起者对结果进行轮询</p>\n<h2 id=\"记录一些问题\"><a href=\"#记录一些问题\" class=\"headerlink\" title=\"记录一些问题\"></a>记录一些问题</h2><ul>\n<li>为什么配置要存在DB，而不是采用Viper或者etcd？<ul>\n<li>并发问题？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有意思的点\"><a href=\"#有意思的点\" class=\"headerlink\" title=\"有意思的点\"></a>有意思的点</h2><ul>\n<li>单体应用上升至分布式应用，考虑问题</li>\n<li>相对优先级，解耦、取消联合索引</li>\n</ul>\n"},{"title":"发帖功能实现","publish":true,"description":"TDD以及缓存方案","sticky":2,"_content":"\n# 发帖功能实现\n\n## 需求分析\n\n### 用例\n\n> 通过使用用例来展示某个需求的具体使用场景\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092129324.png\" width=300>\n\n- 创作者\n  - 增删改查\n- 读者\n  - 查\n\n### 内容的可见性\n\n> 创作者创作了一篇文章，那么这篇文章什么情况下可以被读者看到呢？\n\n根据生活经验，可以很容易想到：一篇文章只有在发表（通过审核）并且处于公开状态下才能被用户所看到。如此，一篇帖子就有了发表和未发表两个状态，我们可以很轻松地得出一篇帖子的**状态**转换图\n\n![image-20240909214045416](https://raw.githubusercontent.com/lyydsheep/pic/main/202409092140450.png)\n\n想象这么一个场景，用户正在浏览文章，与此同时作者也在修改文章，那么用户会实时看到作者的修改吗？\n\n这当然不会，在创作者发布之前，这些修改对读者都是不可见的\n\n一种很显然的解决办法就是**分开存储**，即一个**制作表**，一个**线上表**\n\n用户看到的是线上表中的数据，而作者修改的都是制作表中的数据，这样作者的修改对于用户而言都是不可知的，只有当线上表更新后，用户才能看到修改\n\n整理上述分析，可以得到更详细的状态图：\n\n![image-20240910200443544](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102004630.png)\n\n### 流程分析\n\n我们将两个表（制作表、线上表）的状态，分别用一位二进制表示，可以得出3中起始状态（有一种状态不可能存在）\n\n- 0 0：制作表和线上表都没有数据\n- 1 0：只有制作表中有数据\n- 1 1：制作表和线上表都有数据\n\n分析每一种起始状态可能的后续状态\n\n- 0 0\n  - 1 0：作者写了一半，木有发表\n  - 1 1：作者写好并发表了文章\n  - ![image-20240910201425755](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014800.png)\n- 1 0\n  - 1 1：作者写好并发表了文章\n  - ![image-20240910201456526](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014565.png)\n- 1 1\n  - 1 1：作者修改文章\n  - ![image-20240910202622396](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102026434.png)\n\n## TDD与编辑接口\n\n**TDD：测试驱动开发，先写测试，再写实现**\n\n- 通过撰写测试，**理清楚接口该如何定义，站在用户的角度看是否合适**\n- 通过撰写测试用例，**理清楚整个功能要考虑的主流程、异常流程**\n\n### 核心循环\n\n- 根据对需求的理解，**初步定义接口**，无所谓接口合不合适，反正还得改\n- 根据接口定义测试\n- 执行核心循环\n  - 增加测试用例\n  - 提供/修改实现\n  - 执行测试用例\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161517114.png\" alt=\"image-20240916151718031\" style=\"zoom:67%;\" />\n\n### suite测试组织套件\n\n[参考文章](https://annatarhe.github.io/2020/08/19/how-to-do-test-in-go.html)\n\n有的时候在测试之前需要连接db、redis、rpc之类的东西，然后再测试结束后将这些连接关闭。也就是说，我们的单元（集成）测试具有**生命周期**。如果是手动编写连接、关闭连接的代码会使得测试部分显得异常臃肿，好在有`suite`可以帮助我们有效地管理测试的生命周期\n\n```go\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/suite\"\n)\n\n// 定义测试结构体\ntype ExampleTestSuite struct {\n    suite.Suite\n    msg string\n}\n\n// 测试前的预备\nfunc (suite *ExampleTestSuite) SetupTest() {\n    suite.msg = \"iu is my wife\"\n    db, _ = sql.Open(\"xxx\")\n}\n\n// 测试\nfunc (suite *ExampleTestSuite) TestExample() {\n    m := &obj{\n        Msg: suite.msg\n    }\n    err := insert(m)\n    assert.Nil(suite.T(), err)\n    assert.Equal(suite.T(), suite.msg, m.Msg)\n}\n\n// 测试后的清理\nfunc (suite *ExampleTestSuite) TearDownTest() {\n    db.Close()\n}\n\n// 入口\nfunc TestExampleTestSuite(t *testing.T) {\n    suite.Run(t, new(ExampleTestSuite))\n}\n```\n\n五个步骤\n\n- **定义测试结构体**\n  - 测试结构体中应包含所需要的第三方字段，例如`suite.Suite`,`gorm.DB`, `redis.Cmdable`等\n- **入口函数**\n  - `func TestExampleTestSuite(t *testing.T)`\n  - 函数体中仅有`suite.Run(t, new(xxx))`一行代码\n- **测试前的准备工作**\n  - `func (suite *ExampleTestSuite) SetupTest()`\n- 测试\n  - `func (suite *ExampleTestSuite) TestExample()`\n- **测试后的清理**\n  - `func (suite *ExampleTestSuite) TearDownTest()`\n\n### TDD集成测试实践（一）\n\n```go\n// 测试套件\ntype ArticleSuite struct {\n\tsuite.Suite\n\tserver *gin.Engine\n\tdb     *gorm.DB\n\tl      *zap.Logger\n}\n\n// SetupTest 都用startup里的初始化方法，当然使用wire生成啦\nfunc (s *ArticleSuite) SetupTest() {\n\tvar err error\n\ts.l, err = zap.NewDevelopment()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ts.db = startup.InitDB(s.l)\n\tgin.SetMode(gin.ReleaseMode)\n\ts.server = gin.Default()\n\t// 在这里放好userClaims，表示登录状态\n\ts.server.Use(func(ctx *gin.Context) {\n\t\tctx.Set(\"userClaims\", jwt.UserClaims{\n\t\t\tUserId: 123,\n\t\t})\n\t})\n\tartHdl := startup.InitArticleHandler()\n\tartHdl.RegisterRoutes(s.server)\n}\n\nfunc (s *ArticleSuite) TestEdit() {\n\tt := s.T()\n\ttestCases := []struct {\n\t\tname string\n\t\t// 准备数据\n\t\tbefore func(t *testing.T)\n\t\t// 校验数据\n\t\tafter   func(t *testing.T)\n\t\tarticle Article\n\t\t// 预期数据\n\t\texpectCode int\n\t\texpectRes  Result[int]\n\t}{\n\t\t{\n\t\t\tname: \"新建帖子——保存成功\",\n\t\t\tbefore: func(t *testing.T) {\n\n\t\t\t},\n\t\t\tafter: func(t *testing.T) {\n\t\t\t\t// 对每一列数据都要进行检验\n\t\t\t\tvar article dao.Article\n\t\t\t\terr := s.db.Where(\"id=?\", 1).First(&article).Error\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.True(t, article.Ctime > 0)\n\t\t\t\tassert.True(t, article.Utime > 0)\n\t\t\t\tarticle.Ctime = 0\n\t\t\t\tarticle.Utime = 0\n\t\t\t\tassert.Equal(t, dao.Article{\n\t\t\t\t\tId:       1,\n\t\t\t\t\tTitle:    \"这是标题\",\n\t\t\t\t\tContent:  \"这是内容\",\n\t\t\t\t\tAuthorId: 123,\n\t\t\t\t}, article)\n\t\t\t},\n            article: Article{\n                Title: \"这是标题\",\n                Content: \"这是内容\",\n            }\n\t\t\texpectCode: http.StatusOK,\n\t\t\texpectRes: Result[int]{\n\t\t\t\tData: 1,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t//tc.before(t)\n\t\t\t// 以json格式输入\n\t\t\tarticleJson, err := json.Marshal(tc.article)\n\t\t\trequire.NoError(t, err)\n\t\t\treq, err := http.NewRequest(http.MethodPost, \"/article/edit\", bytes.NewBuffer(articleJson))\n\t\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\t\trequire.NoError(t, err)\n\t\t\tresp := httptest.NewRecorder()\n\t\t\ts.server.ServeHTTP(resp, req)\n\t\t\tvar res Result[int]\n\t\t\tassert.Equal(t, tc.expectCode, resp.Code)\n\t\t\terr = json.NewDecoder(resp.Body).Decode(&res)\n\t\t\tassert.Equal(t, tc.expectRes, res)\n\t\t\t//tc.after(t)\n\t\t})\n\t}\n}\n\n// 测试后所作的动作\nfunc (s *ArticleSuite) TearDownTest() {\n\ts.db.Exec(\"truncate table articles\")\n}\n\nfunc TestArticleSuite(t *testing.T) {\n\tsuite.Run(t, new(ArticleSuite))\n}\n\ntype Article struct {\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\ntype Result[T any] struct {\n\tMsg  string `json:\"msg\"`\n\tCode int    `json:\"code\"`\n\tData T      `json:\"data\"`\n}\n\n```\n\n- DDD侧重于设计架构、高层次战略\n\n- TDD专注于某个功能的实现\n\n在开发过程中，可以使用如下技巧，确保类型实现了特定接口接口\n\n例如，确保`ArticleHandler`类型实现了`handler`接口\n\n![image-20240907211201251](https://raw.githubusercontent.com/lyydsheep/pic/main/202409072112298.png)\n\n### TDD集成测试实践（二）\n\n在实现完创建文章功能后，接着就要实现修改文章功能\n\n依据TDD核心循环，需要再添加测试用例\n\n![image-20240916151741659](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161518765.png)\n\n由于我们将要实现的是修改文章功能，也就是说**文章是事先存在的，前端请求将会带上文章的Id**，那么在测试时需要在`before`函数中做好数据的准备工作\n\n```go\nbefore: func(t *testing.T) {\n    err := s.db.Create(&dao.Article{\n        Id:      2,\n        Title:   \"旧的标题\",\n        Content: \"旧的标题\",\n        // 和时间有关的测试，最好不用time.Now(), 因为每一次都不一样，不方便进行断言\n        AuthorId: 123,\n        Ctime:    677,\n        Utime:    677,\n    }).Error\n    require.NoError(t, err)\n},\n```\n\n更新文章涉及到更新数据库，有两个值得注意的点\n\n- 修改`utime`这个跟时间有关的字段，而在进行和时间有关的测试时，尽量不要使用`time.Now()`函数，因为每一次运行`time.Now()`结果都不相同，不便于后续的断言操作\n\n- 两种更新操作写法\n\n  - ```go\n    // 利用了gorm忽略零值的特性，根据主键（锁定要更新的行）进行更新操作\n    // 可读性差\n    // 忽略零值是指如果某个字段是原本是零值，那么就不更新该字段\n    err := dao.db.WithContext(ctx).Updates(&article).Error\n    ```\n\n  - ```go\n    // 可读性较强\n    err := dao.db.WithContext(ctx).Model(&article).\n    \t\tWhere(\"id=?\", article.Id).Updates(map[string]any{\n    \t\t\"title\":   article.Title,\n    \t\t\"content\": article.Content,\n    \t\t\"utime\":   article.Utime,\n    ```\n\n  - 忽略零值可参考 [更新 | GORM](https://gorm.io/zh_CN/docs/update.html#更新多列)\n\n## DDD：实体 —— 值对象\n\n下图所示就是一个非常经典的领域设计驱动中的领域对象中**实体**和**值对象**的一个体现\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161550256.png\" alt=\"image-20240916155000184\" style=\"zoom:67%;\" />\n\n- 实体：**独立存在的**\n- 值对象：**依赖于实体而存在，通常作为实体的属性出现**\n\n可以结合实例理解一下：在用户领域，一个人是一个实体，他是独立存在的；而在帖子领域，一个人是依赖于帖子才能成为作者，是一个值对象\n\n**在DDD里面，一个领域的实体，在另一个领域中通常作为值对象、另一个实体的属性出现**\n\n## 数据同步\n\n### 职责划分\n\n> 由之前的分析可知，我们需要一个制作表和线上表，那么该有哪一个部分来同步两个表的数据呢？\n\n理论上，项目是单体应用还是微服务应用是选择时需要参考的因素\n\n- web/聚合服务\n  - 调用不同的service来同步数据，可以理解为作者和读者各有各的服务\n- service\n  - 调用不同的repository来保存数据，从存储的角度看来，作者看到的帖子和读者看到的帖子是不一样的\n- repository\n  - 操作不同的数据源\n\n**业务简单就一个repository，复杂就用多个repository**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271441109.png\" alt=\"image-20240927144102855\" style=\"zoom:50%;\" />\n\n### 维护事务\n\n同步制作库和线上库要么同时成功，要么同时失败，因此将数据同步操作做成一个事务再合适不过了\n\n可以在两个层面上维护事务，一个是`repository`，另一个是`dao`。但是`repository`在DDD中应该是操作数据库和缓存的，如果在这一层面维护事务，结果就是跨层操作并强耦合于GORM（而且写起来不优雅🤪）。另一种方案是在`dao`层中维护事务（这就方便多啦😊），具体实现如下\n\n```go\nfunc (dao *BasicArticleDAO) Sync(ctx context.Context, article Article) (int, error) {\n\tid := article.Id\n\t// 利用GORM控制事务的生命周期\n\terr := dao.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {\n\t\tvar err error\n\t\tif id > 0 {\n\t\t\terr = dao.UpdateById(ctx, article)\n\t\t} else {\n\t\t\tid, err = dao.Insert(ctx, article)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn dao.Upsert(ctx, PublishArticle{\n\t\t\tArticle: article,\n\t\t})\n\t})\n\treturn id, err\n}\n```\n\n⚠️：GORM的`transaction`方法在底层实现时就已经帮我们维护了**事务的生命周期**\n\n> 重点是如何在GORM下实现Upsert函数\n\n```go\nfunc (dao *BasicArticleDAO) Upsert(ctx context.Context, article PublishArticle) error {\n\tnow := time.Now().UnixMilli()\n\tarticle.Utime = now\n\tarticle.Ctime = now\n\t// Upsert函数在GORM下的实现\n\treturn dao.db.WithContext(ctx).Clauses(clause.OnConflict{\n\t\tDoUpdates: clause.Assignments(map[string]interface{}{\n\t\t\t\"title\":   article.Title,\n\t\t\t\"content\": article.Content,\n\t\t\t\"utime\":   article.Utime,\n\t\t}),\n\t}).Create(&article).Error\n}\n```\n\n向`Clauses`函数中传递`OnConflict`结构体，表示如果发生冲突的话应该做什么事情\n\n`OnConfilt`中有一些比较有用的字段\n\n```go\n// DoUpdate\t\t---> 做更新操作\n// DoNothing\t---> 什么也不做\n// Where\t\t---> 数据冲突了并且符合where子句，就执行更新操作\n```\n\n**🌟：在一个事务中，一直都是同一个数据库连接**\n\n## 维护状态\n\n在先前的分析中，我们知道需要有线上库和制作库两个数据存储的地方，这两个地方存储的数据本质上是一样的，因此不必创建新的领域对象来维护，**使用衍生类型更加方便**\n\n### 状态常量定义\n\n利用常量表示一篇帖子的不同状态，这些常量可以直接利用`iota`在`domain`中定义。**一般定义常量，最好不要把零值做成有意义的值**，否则难以区分是用户没有输入还是前端传递默认数据\n\n![image-20240927090706192](https://raw.githubusercontent.com/lyydsheep/pic/main/202409270907841.png)\n\n## 使用MongoDB存储\n\n类似于大文本之类的东西，除了可以使用关系型数据库，也可以考虑使用其他存储应用，例如MongoDB\n\n**MongoDB属于NoSQL，NoSQL即Not Only SQL**，不仅仅是SQL\n\nNoSQL数据库的产生是为了解决大规模数据集合、多种数据种类带来的挑战，尤其是大数据应用难题\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530245.png\" alt=\"image-20240930153021471\" style=\"zoom:50%;\" />\n\n### MongoDB简介\n\nMongoDB的基本特性\n\n- **面向集合存储**：MongoDB集合中可以存储多个文档\n  - 类比于MySQL，MongoDB中的一个集合就像是一张表，集合中的一个文档就相当于表中的一条记录\n- **模式自由**：MongoDB采用无结构模式存储数据，也就是说，在储存数据之前不需要定义数据的结构\n  - 就像当于在MySQL中不需要预先建立表结构就能插入数据\n- **支持分片**：MongoDB支持分片，并且MongoDB自动解决了分片的各种问题，包括自动化扩容\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530677.png\" alt=\"image-20240930153009489\" style=\"zoom:67%;\" />\n\n选择MongoDB的两个理由：\n\n- **灵活的文档模型**：于MySQL不同，不需要事前在MongoDB中定义文档模型，并且可以灵活修改\n\n- **易于横向扩展**：可以通过增加MongoDB实例来应付流量和数据增长\n\n### 初始化客户端并插入文档\n\n> 需要使用MongoDB官网的go-driver\n\n![image-20240930194117517](https://raw.githubusercontent.com/lyydsheep/pic/main/202409301941675.png)\n\n### 查找文档\n\n在MongoDB中有两种构造查询条件的方式：\n\n- **bson**\n- **结构体**\n\n```go\n\t// 使用bson构造查询条件\n\tfilter := bson.D{bson.E{Key: \"id\", Value: 123}}\n\tvar art Article\n\terr = col.FindOne(ctx, filter).Decode(&art)\n\tassert.NoError(t, err)\n\tfmt.Printf(\"find article %v\\n\", art)\n\t// 使用结构体构造查询条件\n\terr = col.FindOne(ctx, Article{Id: 123}).Decode(&art)\n\tif errors.Is(err, mongo.ErrNoDocuments) {\n\t\tfmt.Printf(\"find none\")\n\t}\n```\n\n⚠️：使用结构体构造查询条件时，mongodb-go-driver默认使用结构体的全部字段作为匹配条件，需要注意某些字段**默认零值**。当然，可以使用`bson:\"field_name,omitempty\"`标签来告知mongodb-go-driver忽略字段零值\n\n🌟：可以使用`mongo.ErrNoDocuments`错误值检验是否有查询到文档\n\n### 更新文档\n\n- 构造更新条件，同构造查询条件\n- 构造更新字段\n  - **bson**\n  - **结构体**\n\n⚠️：同样的，需要注意**底层是否会采用字段零值**\n\n```go\n\tsets := bson.D{bson.E{Key: \"$set\",\n\t\tValue: bson.E{Key: \"content\", Value: \"serious content\"}}}\n\tres, err := col.UpdateOne(ctx, filter, sets)\n\t// 使用结构体构造更新字段\n\tres, err = col.UpdateOne(ctx, filter, bson.D{bson.E{Key: \"$set\", Value: Article{\n\t\tTitle: \"new title\",\n\t}}})\n```\n\n### 创建索引\n\n类似于MySQL，**一般是根据业务中常用的查询条件，来决定在什么列上构建索引**\n\n```go\n\tindexRes, err := col.Indexes().CreateOne(ctx, mongo.IndexModel{\n\t\tKeys:    bson.M{\"id\": 1},\n\t\tOptions: options.Index().SetUnique(true),\n\t})\n\tfmt.Println(indexRes)\n```\n\n### MongoDB存储数据\n\n由于MongoDB中的`_id`字段不是自增并且是一个**12字节**的切片，因此不能直接使用这个字段作为主键\n\n主键的可选方案：\n\n- **将整个id修改为string类型**\n- **使用ID生成策略**，例如**雪花算法**\n  - **1比特保留位**\n  - **41比特时间戳**\n  - **10比特机器位**，一般叫做`Worker ID`\n  - **12比特自增序号**\n  - ![image-20241003154159484](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031541579.png)\n- **使用GUID**\n- **定义一个新的接口**，但这样就失去了DAO层的统一接口\n\n**⚠️：在MongoDB中，尽量使用衍生类型而不是嵌套结构体。因为嵌套结构体中子结构体的字段标签在操作过程中无法正常生效**\n\n## 利用OSS来存储数据\n\n> 利用OSS存储线上数据，而后直接通过CDN加速访问\n\nOSS（Object Storage Service）是指兑现存储，**被大量用于存储文件、流媒体、图片等**\n\nOSS中的两个核心概念：\n\n- **Bucket**：逻辑上的分组关系，例如某个业务使用一个桶，另一个业务使用另外一个桶\n- **Object**：对象，也就是需要存储的东西\n\nACL（Access Control List）：权限控制方案\n\n![image-20241004101033272](https://raw.githubusercontent.com/lyydsheep/pic/main/202410041010143.png)\n\nOSS通常和CDN结合在一起使用，**即在OSS上存储的数据，可以通过CDN来访问**\n\n一种很常见的性能和可用性优化手段，就是使用**OSS和CDN来存储网站的静态资源**，此时OSS被当作CDN的一个回源站点\n\n![image-20241004101307223](https://raw.githubusercontent.com/lyydsheep/pic/main/202410041013265.png)\n\n## 查询接口与缓存\n\n在实现查询文章功能过程中，需要从不同用户角度出发进行思考\n\n- 对于创作者来说，需要查询自己的**文章列表**以及**某一篇文章的详细内容**，分别对应着两个接口\n  - 列表接口\n  - 详情接口\n- 对于读者，他能够**搜索某篇文章**、**浏览推荐文章列表**、**阅读文章的具体内容**。由此可见，需要提供以下接口\n  - 搜索接口\n  - 推荐接口\n  - 阅读文章接口\n\n目前仅实现创作者的**列表接口和详情接口**，以及读者的**阅读文章接口**\n\n### 列表接口\n\n#### 需求分析\n\n参考掘金的列表展示：\n\n![image-20241006141112588](https://raw.githubusercontent.com/lyydsheep/pic/main/202410061411490.png)\n\n可以发现，在列表中展示的文章对象有如下特征：\n\n- 标题\n- 创建时间\n- 简介\n- ...\n\n根据这些特征我们就能定义出与前端相对应的`ArticleVO`\n\n另一个值得注意的点是，**掘金在列表中展示的文章只有一小部分，当页面下滑时才会加载更多的文章**，这就相当于一个**分页查询**操作\n\n#### 分页形态\n\n**分页的核心目标就是避免一次操作太多数据，引发性能问题**。况且，列表页在展示的时候，也不许那么多的内容😏\n\n分页接口一般有三种定义形式：\n\n- **直接定义`Offset`和`Limit`字段**\n- **直接定义一个`Page`字段，并约定好Page的大小**\n- **直接定义一个`Cursor`字段**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061421861.png\" alt=\"image-20241006142108823\" style=\"zoom: 50%;\" />\n\n### 缓存设计\n\n> 缓存第一页分页\n\n大部分情况下，不会对分页结果进行缓存，**因为如果数据的筛选条件、排序条件、分页条件、分页的偏移量和数据量中的任何一个发生了变化，缓存就很难使用了**\n\n但可以只**缓存第一页**，毕竟大部分用户只看列表的第一页\n\n有了缓存之后，**每次进行更新操作都要将缓存删除，防止缓存不一致问题**\n\n> 业务相关的预加载\n\n**预加载本质上就是预判用户将要读取的内容，提前将内容存入缓存中**\n\n而且，因为是预测性质的，所以过期时间设置得很短\n\n![image-20241006151243081](https://raw.githubusercontent.com/lyydsheep/pic/main/202410061512142.png)\n\n> 不缓存大文档（调优😂）\n\n可以考虑在Redis内存消耗和缓存性能之间做一个权衡\n\n也就是说，并不是所有的值都需要缓存，**有一些很占用内存空间的文章就不必缓存**\n\n#### 缓存过期时间\n\n缓存的过期时间和缓存命中率有关，一般情况下，**过期时间越长，命中率越高，但数据一致性会变差；过期时间越短，命中率越低，但数据一致性会更好**\n\n- 业务相关的缓存预加载，过期时间要短\n- 根据用户身份按权给予不同的缓存时间\n\n#### 淘汰策略\n\n淘汰策略是指在缓存内存不够用的情况下，淘汰某一部分数据时的计划\n\n常规方案就是**LRU和LFU**\n\n还有一些方案：\n\n- 优先淘汰普通创作者的数据，留下大v的数据\n- 优先淘汰大对象，释放出更多的内存空间\n- 优先淘汰小对象，相比于大对象，小对象在从数据库（或OSS）中获取更加迅速\n\n### 注意事项\n\n- 使用`wrapbodyandtoken`统一处理Body和Token中的数据\n- 考虑到中文字符由多个字节组成，在处理包含中文的字符串时，应实现将其转为`[]rune`再进行`len()`操作\n- 需要将存储对象转换为`json`格式后才能存入Redis中，否则会报错\n\n\n\n\n\n","source":"_posts/发帖功能实现.md","raw":"---\ntitle: 发帖功能实现\npublish: true\ndescription: TDD以及缓存方案\ntag: \n- Go\n- 学习\nsticky: 2\n---\n\n# 发帖功能实现\n\n## 需求分析\n\n### 用例\n\n> 通过使用用例来展示某个需求的具体使用场景\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092129324.png\" width=300>\n\n- 创作者\n  - 增删改查\n- 读者\n  - 查\n\n### 内容的可见性\n\n> 创作者创作了一篇文章，那么这篇文章什么情况下可以被读者看到呢？\n\n根据生活经验，可以很容易想到：一篇文章只有在发表（通过审核）并且处于公开状态下才能被用户所看到。如此，一篇帖子就有了发表和未发表两个状态，我们可以很轻松地得出一篇帖子的**状态**转换图\n\n![image-20240909214045416](https://raw.githubusercontent.com/lyydsheep/pic/main/202409092140450.png)\n\n想象这么一个场景，用户正在浏览文章，与此同时作者也在修改文章，那么用户会实时看到作者的修改吗？\n\n这当然不会，在创作者发布之前，这些修改对读者都是不可见的\n\n一种很显然的解决办法就是**分开存储**，即一个**制作表**，一个**线上表**\n\n用户看到的是线上表中的数据，而作者修改的都是制作表中的数据，这样作者的修改对于用户而言都是不可知的，只有当线上表更新后，用户才能看到修改\n\n整理上述分析，可以得到更详细的状态图：\n\n![image-20240910200443544](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102004630.png)\n\n### 流程分析\n\n我们将两个表（制作表、线上表）的状态，分别用一位二进制表示，可以得出3中起始状态（有一种状态不可能存在）\n\n- 0 0：制作表和线上表都没有数据\n- 1 0：只有制作表中有数据\n- 1 1：制作表和线上表都有数据\n\n分析每一种起始状态可能的后续状态\n\n- 0 0\n  - 1 0：作者写了一半，木有发表\n  - 1 1：作者写好并发表了文章\n  - ![image-20240910201425755](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014800.png)\n- 1 0\n  - 1 1：作者写好并发表了文章\n  - ![image-20240910201456526](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014565.png)\n- 1 1\n  - 1 1：作者修改文章\n  - ![image-20240910202622396](https://raw.githubusercontent.com/lyydsheep/pic/main/202409102026434.png)\n\n## TDD与编辑接口\n\n**TDD：测试驱动开发，先写测试，再写实现**\n\n- 通过撰写测试，**理清楚接口该如何定义，站在用户的角度看是否合适**\n- 通过撰写测试用例，**理清楚整个功能要考虑的主流程、异常流程**\n\n### 核心循环\n\n- 根据对需求的理解，**初步定义接口**，无所谓接口合不合适，反正还得改\n- 根据接口定义测试\n- 执行核心循环\n  - 增加测试用例\n  - 提供/修改实现\n  - 执行测试用例\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161517114.png\" alt=\"image-20240916151718031\" style=\"zoom:67%;\" />\n\n### suite测试组织套件\n\n[参考文章](https://annatarhe.github.io/2020/08/19/how-to-do-test-in-go.html)\n\n有的时候在测试之前需要连接db、redis、rpc之类的东西，然后再测试结束后将这些连接关闭。也就是说，我们的单元（集成）测试具有**生命周期**。如果是手动编写连接、关闭连接的代码会使得测试部分显得异常臃肿，好在有`suite`可以帮助我们有效地管理测试的生命周期\n\n```go\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/suite\"\n)\n\n// 定义测试结构体\ntype ExampleTestSuite struct {\n    suite.Suite\n    msg string\n}\n\n// 测试前的预备\nfunc (suite *ExampleTestSuite) SetupTest() {\n    suite.msg = \"iu is my wife\"\n    db, _ = sql.Open(\"xxx\")\n}\n\n// 测试\nfunc (suite *ExampleTestSuite) TestExample() {\n    m := &obj{\n        Msg: suite.msg\n    }\n    err := insert(m)\n    assert.Nil(suite.T(), err)\n    assert.Equal(suite.T(), suite.msg, m.Msg)\n}\n\n// 测试后的清理\nfunc (suite *ExampleTestSuite) TearDownTest() {\n    db.Close()\n}\n\n// 入口\nfunc TestExampleTestSuite(t *testing.T) {\n    suite.Run(t, new(ExampleTestSuite))\n}\n```\n\n五个步骤\n\n- **定义测试结构体**\n  - 测试结构体中应包含所需要的第三方字段，例如`suite.Suite`,`gorm.DB`, `redis.Cmdable`等\n- **入口函数**\n  - `func TestExampleTestSuite(t *testing.T)`\n  - 函数体中仅有`suite.Run(t, new(xxx))`一行代码\n- **测试前的准备工作**\n  - `func (suite *ExampleTestSuite) SetupTest()`\n- 测试\n  - `func (suite *ExampleTestSuite) TestExample()`\n- **测试后的清理**\n  - `func (suite *ExampleTestSuite) TearDownTest()`\n\n### TDD集成测试实践（一）\n\n```go\n// 测试套件\ntype ArticleSuite struct {\n\tsuite.Suite\n\tserver *gin.Engine\n\tdb     *gorm.DB\n\tl      *zap.Logger\n}\n\n// SetupTest 都用startup里的初始化方法，当然使用wire生成啦\nfunc (s *ArticleSuite) SetupTest() {\n\tvar err error\n\ts.l, err = zap.NewDevelopment()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ts.db = startup.InitDB(s.l)\n\tgin.SetMode(gin.ReleaseMode)\n\ts.server = gin.Default()\n\t// 在这里放好userClaims，表示登录状态\n\ts.server.Use(func(ctx *gin.Context) {\n\t\tctx.Set(\"userClaims\", jwt.UserClaims{\n\t\t\tUserId: 123,\n\t\t})\n\t})\n\tartHdl := startup.InitArticleHandler()\n\tartHdl.RegisterRoutes(s.server)\n}\n\nfunc (s *ArticleSuite) TestEdit() {\n\tt := s.T()\n\ttestCases := []struct {\n\t\tname string\n\t\t// 准备数据\n\t\tbefore func(t *testing.T)\n\t\t// 校验数据\n\t\tafter   func(t *testing.T)\n\t\tarticle Article\n\t\t// 预期数据\n\t\texpectCode int\n\t\texpectRes  Result[int]\n\t}{\n\t\t{\n\t\t\tname: \"新建帖子——保存成功\",\n\t\t\tbefore: func(t *testing.T) {\n\n\t\t\t},\n\t\t\tafter: func(t *testing.T) {\n\t\t\t\t// 对每一列数据都要进行检验\n\t\t\t\tvar article dao.Article\n\t\t\t\terr := s.db.Where(\"id=?\", 1).First(&article).Error\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.True(t, article.Ctime > 0)\n\t\t\t\tassert.True(t, article.Utime > 0)\n\t\t\t\tarticle.Ctime = 0\n\t\t\t\tarticle.Utime = 0\n\t\t\t\tassert.Equal(t, dao.Article{\n\t\t\t\t\tId:       1,\n\t\t\t\t\tTitle:    \"这是标题\",\n\t\t\t\t\tContent:  \"这是内容\",\n\t\t\t\t\tAuthorId: 123,\n\t\t\t\t}, article)\n\t\t\t},\n            article: Article{\n                Title: \"这是标题\",\n                Content: \"这是内容\",\n            }\n\t\t\texpectCode: http.StatusOK,\n\t\t\texpectRes: Result[int]{\n\t\t\t\tData: 1,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t//tc.before(t)\n\t\t\t// 以json格式输入\n\t\t\tarticleJson, err := json.Marshal(tc.article)\n\t\t\trequire.NoError(t, err)\n\t\t\treq, err := http.NewRequest(http.MethodPost, \"/article/edit\", bytes.NewBuffer(articleJson))\n\t\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\t\trequire.NoError(t, err)\n\t\t\tresp := httptest.NewRecorder()\n\t\t\ts.server.ServeHTTP(resp, req)\n\t\t\tvar res Result[int]\n\t\t\tassert.Equal(t, tc.expectCode, resp.Code)\n\t\t\terr = json.NewDecoder(resp.Body).Decode(&res)\n\t\t\tassert.Equal(t, tc.expectRes, res)\n\t\t\t//tc.after(t)\n\t\t})\n\t}\n}\n\n// 测试后所作的动作\nfunc (s *ArticleSuite) TearDownTest() {\n\ts.db.Exec(\"truncate table articles\")\n}\n\nfunc TestArticleSuite(t *testing.T) {\n\tsuite.Run(t, new(ArticleSuite))\n}\n\ntype Article struct {\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\ntype Result[T any] struct {\n\tMsg  string `json:\"msg\"`\n\tCode int    `json:\"code\"`\n\tData T      `json:\"data\"`\n}\n\n```\n\n- DDD侧重于设计架构、高层次战略\n\n- TDD专注于某个功能的实现\n\n在开发过程中，可以使用如下技巧，确保类型实现了特定接口接口\n\n例如，确保`ArticleHandler`类型实现了`handler`接口\n\n![image-20240907211201251](https://raw.githubusercontent.com/lyydsheep/pic/main/202409072112298.png)\n\n### TDD集成测试实践（二）\n\n在实现完创建文章功能后，接着就要实现修改文章功能\n\n依据TDD核心循环，需要再添加测试用例\n\n![image-20240916151741659](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161518765.png)\n\n由于我们将要实现的是修改文章功能，也就是说**文章是事先存在的，前端请求将会带上文章的Id**，那么在测试时需要在`before`函数中做好数据的准备工作\n\n```go\nbefore: func(t *testing.T) {\n    err := s.db.Create(&dao.Article{\n        Id:      2,\n        Title:   \"旧的标题\",\n        Content: \"旧的标题\",\n        // 和时间有关的测试，最好不用time.Now(), 因为每一次都不一样，不方便进行断言\n        AuthorId: 123,\n        Ctime:    677,\n        Utime:    677,\n    }).Error\n    require.NoError(t, err)\n},\n```\n\n更新文章涉及到更新数据库，有两个值得注意的点\n\n- 修改`utime`这个跟时间有关的字段，而在进行和时间有关的测试时，尽量不要使用`time.Now()`函数，因为每一次运行`time.Now()`结果都不相同，不便于后续的断言操作\n\n- 两种更新操作写法\n\n  - ```go\n    // 利用了gorm忽略零值的特性，根据主键（锁定要更新的行）进行更新操作\n    // 可读性差\n    // 忽略零值是指如果某个字段是原本是零值，那么就不更新该字段\n    err := dao.db.WithContext(ctx).Updates(&article).Error\n    ```\n\n  - ```go\n    // 可读性较强\n    err := dao.db.WithContext(ctx).Model(&article).\n    \t\tWhere(\"id=?\", article.Id).Updates(map[string]any{\n    \t\t\"title\":   article.Title,\n    \t\t\"content\": article.Content,\n    \t\t\"utime\":   article.Utime,\n    ```\n\n  - 忽略零值可参考 [更新 | GORM](https://gorm.io/zh_CN/docs/update.html#更新多列)\n\n## DDD：实体 —— 值对象\n\n下图所示就是一个非常经典的领域设计驱动中的领域对象中**实体**和**值对象**的一个体现\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161550256.png\" alt=\"image-20240916155000184\" style=\"zoom:67%;\" />\n\n- 实体：**独立存在的**\n- 值对象：**依赖于实体而存在，通常作为实体的属性出现**\n\n可以结合实例理解一下：在用户领域，一个人是一个实体，他是独立存在的；而在帖子领域，一个人是依赖于帖子才能成为作者，是一个值对象\n\n**在DDD里面，一个领域的实体，在另一个领域中通常作为值对象、另一个实体的属性出现**\n\n## 数据同步\n\n### 职责划分\n\n> 由之前的分析可知，我们需要一个制作表和线上表，那么该有哪一个部分来同步两个表的数据呢？\n\n理论上，项目是单体应用还是微服务应用是选择时需要参考的因素\n\n- web/聚合服务\n  - 调用不同的service来同步数据，可以理解为作者和读者各有各的服务\n- service\n  - 调用不同的repository来保存数据，从存储的角度看来，作者看到的帖子和读者看到的帖子是不一样的\n- repository\n  - 操作不同的数据源\n\n**业务简单就一个repository，复杂就用多个repository**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271441109.png\" alt=\"image-20240927144102855\" style=\"zoom:50%;\" />\n\n### 维护事务\n\n同步制作库和线上库要么同时成功，要么同时失败，因此将数据同步操作做成一个事务再合适不过了\n\n可以在两个层面上维护事务，一个是`repository`，另一个是`dao`。但是`repository`在DDD中应该是操作数据库和缓存的，如果在这一层面维护事务，结果就是跨层操作并强耦合于GORM（而且写起来不优雅🤪）。另一种方案是在`dao`层中维护事务（这就方便多啦😊），具体实现如下\n\n```go\nfunc (dao *BasicArticleDAO) Sync(ctx context.Context, article Article) (int, error) {\n\tid := article.Id\n\t// 利用GORM控制事务的生命周期\n\terr := dao.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {\n\t\tvar err error\n\t\tif id > 0 {\n\t\t\terr = dao.UpdateById(ctx, article)\n\t\t} else {\n\t\t\tid, err = dao.Insert(ctx, article)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn dao.Upsert(ctx, PublishArticle{\n\t\t\tArticle: article,\n\t\t})\n\t})\n\treturn id, err\n}\n```\n\n⚠️：GORM的`transaction`方法在底层实现时就已经帮我们维护了**事务的生命周期**\n\n> 重点是如何在GORM下实现Upsert函数\n\n```go\nfunc (dao *BasicArticleDAO) Upsert(ctx context.Context, article PublishArticle) error {\n\tnow := time.Now().UnixMilli()\n\tarticle.Utime = now\n\tarticle.Ctime = now\n\t// Upsert函数在GORM下的实现\n\treturn dao.db.WithContext(ctx).Clauses(clause.OnConflict{\n\t\tDoUpdates: clause.Assignments(map[string]interface{}{\n\t\t\t\"title\":   article.Title,\n\t\t\t\"content\": article.Content,\n\t\t\t\"utime\":   article.Utime,\n\t\t}),\n\t}).Create(&article).Error\n}\n```\n\n向`Clauses`函数中传递`OnConflict`结构体，表示如果发生冲突的话应该做什么事情\n\n`OnConfilt`中有一些比较有用的字段\n\n```go\n// DoUpdate\t\t---> 做更新操作\n// DoNothing\t---> 什么也不做\n// Where\t\t---> 数据冲突了并且符合where子句，就执行更新操作\n```\n\n**🌟：在一个事务中，一直都是同一个数据库连接**\n\n## 维护状态\n\n在先前的分析中，我们知道需要有线上库和制作库两个数据存储的地方，这两个地方存储的数据本质上是一样的，因此不必创建新的领域对象来维护，**使用衍生类型更加方便**\n\n### 状态常量定义\n\n利用常量表示一篇帖子的不同状态，这些常量可以直接利用`iota`在`domain`中定义。**一般定义常量，最好不要把零值做成有意义的值**，否则难以区分是用户没有输入还是前端传递默认数据\n\n![image-20240927090706192](https://raw.githubusercontent.com/lyydsheep/pic/main/202409270907841.png)\n\n## 使用MongoDB存储\n\n类似于大文本之类的东西，除了可以使用关系型数据库，也可以考虑使用其他存储应用，例如MongoDB\n\n**MongoDB属于NoSQL，NoSQL即Not Only SQL**，不仅仅是SQL\n\nNoSQL数据库的产生是为了解决大规模数据集合、多种数据种类带来的挑战，尤其是大数据应用难题\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530245.png\" alt=\"image-20240930153021471\" style=\"zoom:50%;\" />\n\n### MongoDB简介\n\nMongoDB的基本特性\n\n- **面向集合存储**：MongoDB集合中可以存储多个文档\n  - 类比于MySQL，MongoDB中的一个集合就像是一张表，集合中的一个文档就相当于表中的一条记录\n- **模式自由**：MongoDB采用无结构模式存储数据，也就是说，在储存数据之前不需要定义数据的结构\n  - 就像当于在MySQL中不需要预先建立表结构就能插入数据\n- **支持分片**：MongoDB支持分片，并且MongoDB自动解决了分片的各种问题，包括自动化扩容\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530677.png\" alt=\"image-20240930153009489\" style=\"zoom:67%;\" />\n\n选择MongoDB的两个理由：\n\n- **灵活的文档模型**：于MySQL不同，不需要事前在MongoDB中定义文档模型，并且可以灵活修改\n\n- **易于横向扩展**：可以通过增加MongoDB实例来应付流量和数据增长\n\n### 初始化客户端并插入文档\n\n> 需要使用MongoDB官网的go-driver\n\n![image-20240930194117517](https://raw.githubusercontent.com/lyydsheep/pic/main/202409301941675.png)\n\n### 查找文档\n\n在MongoDB中有两种构造查询条件的方式：\n\n- **bson**\n- **结构体**\n\n```go\n\t// 使用bson构造查询条件\n\tfilter := bson.D{bson.E{Key: \"id\", Value: 123}}\n\tvar art Article\n\terr = col.FindOne(ctx, filter).Decode(&art)\n\tassert.NoError(t, err)\n\tfmt.Printf(\"find article %v\\n\", art)\n\t// 使用结构体构造查询条件\n\terr = col.FindOne(ctx, Article{Id: 123}).Decode(&art)\n\tif errors.Is(err, mongo.ErrNoDocuments) {\n\t\tfmt.Printf(\"find none\")\n\t}\n```\n\n⚠️：使用结构体构造查询条件时，mongodb-go-driver默认使用结构体的全部字段作为匹配条件，需要注意某些字段**默认零值**。当然，可以使用`bson:\"field_name,omitempty\"`标签来告知mongodb-go-driver忽略字段零值\n\n🌟：可以使用`mongo.ErrNoDocuments`错误值检验是否有查询到文档\n\n### 更新文档\n\n- 构造更新条件，同构造查询条件\n- 构造更新字段\n  - **bson**\n  - **结构体**\n\n⚠️：同样的，需要注意**底层是否会采用字段零值**\n\n```go\n\tsets := bson.D{bson.E{Key: \"$set\",\n\t\tValue: bson.E{Key: \"content\", Value: \"serious content\"}}}\n\tres, err := col.UpdateOne(ctx, filter, sets)\n\t// 使用结构体构造更新字段\n\tres, err = col.UpdateOne(ctx, filter, bson.D{bson.E{Key: \"$set\", Value: Article{\n\t\tTitle: \"new title\",\n\t}}})\n```\n\n### 创建索引\n\n类似于MySQL，**一般是根据业务中常用的查询条件，来决定在什么列上构建索引**\n\n```go\n\tindexRes, err := col.Indexes().CreateOne(ctx, mongo.IndexModel{\n\t\tKeys:    bson.M{\"id\": 1},\n\t\tOptions: options.Index().SetUnique(true),\n\t})\n\tfmt.Println(indexRes)\n```\n\n### MongoDB存储数据\n\n由于MongoDB中的`_id`字段不是自增并且是一个**12字节**的切片，因此不能直接使用这个字段作为主键\n\n主键的可选方案：\n\n- **将整个id修改为string类型**\n- **使用ID生成策略**，例如**雪花算法**\n  - **1比特保留位**\n  - **41比特时间戳**\n  - **10比特机器位**，一般叫做`Worker ID`\n  - **12比特自增序号**\n  - ![image-20241003154159484](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031541579.png)\n- **使用GUID**\n- **定义一个新的接口**，但这样就失去了DAO层的统一接口\n\n**⚠️：在MongoDB中，尽量使用衍生类型而不是嵌套结构体。因为嵌套结构体中子结构体的字段标签在操作过程中无法正常生效**\n\n## 利用OSS来存储数据\n\n> 利用OSS存储线上数据，而后直接通过CDN加速访问\n\nOSS（Object Storage Service）是指兑现存储，**被大量用于存储文件、流媒体、图片等**\n\nOSS中的两个核心概念：\n\n- **Bucket**：逻辑上的分组关系，例如某个业务使用一个桶，另一个业务使用另外一个桶\n- **Object**：对象，也就是需要存储的东西\n\nACL（Access Control List）：权限控制方案\n\n![image-20241004101033272](https://raw.githubusercontent.com/lyydsheep/pic/main/202410041010143.png)\n\nOSS通常和CDN结合在一起使用，**即在OSS上存储的数据，可以通过CDN来访问**\n\n一种很常见的性能和可用性优化手段，就是使用**OSS和CDN来存储网站的静态资源**，此时OSS被当作CDN的一个回源站点\n\n![image-20241004101307223](https://raw.githubusercontent.com/lyydsheep/pic/main/202410041013265.png)\n\n## 查询接口与缓存\n\n在实现查询文章功能过程中，需要从不同用户角度出发进行思考\n\n- 对于创作者来说，需要查询自己的**文章列表**以及**某一篇文章的详细内容**，分别对应着两个接口\n  - 列表接口\n  - 详情接口\n- 对于读者，他能够**搜索某篇文章**、**浏览推荐文章列表**、**阅读文章的具体内容**。由此可见，需要提供以下接口\n  - 搜索接口\n  - 推荐接口\n  - 阅读文章接口\n\n目前仅实现创作者的**列表接口和详情接口**，以及读者的**阅读文章接口**\n\n### 列表接口\n\n#### 需求分析\n\n参考掘金的列表展示：\n\n![image-20241006141112588](https://raw.githubusercontent.com/lyydsheep/pic/main/202410061411490.png)\n\n可以发现，在列表中展示的文章对象有如下特征：\n\n- 标题\n- 创建时间\n- 简介\n- ...\n\n根据这些特征我们就能定义出与前端相对应的`ArticleVO`\n\n另一个值得注意的点是，**掘金在列表中展示的文章只有一小部分，当页面下滑时才会加载更多的文章**，这就相当于一个**分页查询**操作\n\n#### 分页形态\n\n**分页的核心目标就是避免一次操作太多数据，引发性能问题**。况且，列表页在展示的时候，也不许那么多的内容😏\n\n分页接口一般有三种定义形式：\n\n- **直接定义`Offset`和`Limit`字段**\n- **直接定义一个`Page`字段，并约定好Page的大小**\n- **直接定义一个`Cursor`字段**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061421861.png\" alt=\"image-20241006142108823\" style=\"zoom: 50%;\" />\n\n### 缓存设计\n\n> 缓存第一页分页\n\n大部分情况下，不会对分页结果进行缓存，**因为如果数据的筛选条件、排序条件、分页条件、分页的偏移量和数据量中的任何一个发生了变化，缓存就很难使用了**\n\n但可以只**缓存第一页**，毕竟大部分用户只看列表的第一页\n\n有了缓存之后，**每次进行更新操作都要将缓存删除，防止缓存不一致问题**\n\n> 业务相关的预加载\n\n**预加载本质上就是预判用户将要读取的内容，提前将内容存入缓存中**\n\n而且，因为是预测性质的，所以过期时间设置得很短\n\n![image-20241006151243081](https://raw.githubusercontent.com/lyydsheep/pic/main/202410061512142.png)\n\n> 不缓存大文档（调优😂）\n\n可以考虑在Redis内存消耗和缓存性能之间做一个权衡\n\n也就是说，并不是所有的值都需要缓存，**有一些很占用内存空间的文章就不必缓存**\n\n#### 缓存过期时间\n\n缓存的过期时间和缓存命中率有关，一般情况下，**过期时间越长，命中率越高，但数据一致性会变差；过期时间越短，命中率越低，但数据一致性会更好**\n\n- 业务相关的缓存预加载，过期时间要短\n- 根据用户身份按权给予不同的缓存时间\n\n#### 淘汰策略\n\n淘汰策略是指在缓存内存不够用的情况下，淘汰某一部分数据时的计划\n\n常规方案就是**LRU和LFU**\n\n还有一些方案：\n\n- 优先淘汰普通创作者的数据，留下大v的数据\n- 优先淘汰大对象，释放出更多的内存空间\n- 优先淘汰小对象，相比于大对象，小对象在从数据库（或OSS）中获取更加迅速\n\n### 注意事项\n\n- 使用`wrapbodyandtoken`统一处理Body和Token中的数据\n- 考虑到中文字符由多个字节组成，在处理包含中文的字符串时，应实现将其转为`[]rune`再进行`len()`操作\n- 需要将存储对象转换为`json`格式后才能存入Redis中，否则会报错\n\n\n\n\n\n","slug":"发帖功能实现","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j000va5t2aa62c9mc","content":"<h1 id=\"发帖功能实现\"><a href=\"#发帖功能实现\" class=\"headerlink\" title=\"发帖功能实现\"></a>发帖功能实现</h1><h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><h3 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h3><blockquote>\n<p>通过使用用例来展示某个需求的具体使用场景</p>\n</blockquote>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092129324.png\" width=300>\n\n<ul>\n<li>创作者<ul>\n<li>增删改查</li>\n</ul>\n</li>\n<li>读者<ul>\n<li>查</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内容的可见性\"><a href=\"#内容的可见性\" class=\"headerlink\" title=\"内容的可见性\"></a>内容的可见性</h3><blockquote>\n<p>创作者创作了一篇文章，那么这篇文章什么情况下可以被读者看到呢？</p>\n</blockquote>\n<p>根据生活经验，可以很容易想到：一篇文章只有在发表（通过审核）并且处于公开状态下才能被用户所看到。如此，一篇帖子就有了发表和未发表两个状态，我们可以很轻松地得出一篇帖子的<strong>状态</strong>转换图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092140450.png\" alt=\"image-20240909214045416\"></p>\n<p>想象这么一个场景，用户正在浏览文章，与此同时作者也在修改文章，那么用户会实时看到作者的修改吗？</p>\n<p>这当然不会，在创作者发布之前，这些修改对读者都是不可见的</p>\n<p>一种很显然的解决办法就是<strong>分开存储</strong>，即一个<strong>制作表</strong>，一个<strong>线上表</strong></p>\n<p>用户看到的是线上表中的数据，而作者修改的都是制作表中的数据，这样作者的修改对于用户而言都是不可知的，只有当线上表更新后，用户才能看到修改</p>\n<p>整理上述分析，可以得到更详细的状态图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102004630.png\" alt=\"image-20240910200443544\"></p>\n<h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><p>我们将两个表（制作表、线上表）的状态，分别用一位二进制表示，可以得出3中起始状态（有一种状态不可能存在）</p>\n<ul>\n<li>0 0：制作表和线上表都没有数据</li>\n<li>1 0：只有制作表中有数据</li>\n<li>1 1：制作表和线上表都有数据</li>\n</ul>\n<p>分析每一种起始状态可能的后续状态</p>\n<ul>\n<li>0 0<ul>\n<li>1 0：作者写了一半，木有发表</li>\n<li>1 1：作者写好并发表了文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014800.png\" alt=\"image-20240910201425755\"></li>\n</ul>\n</li>\n<li>1 0<ul>\n<li>1 1：作者写好并发表了文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014565.png\" alt=\"image-20240910201456526\"></li>\n</ul>\n</li>\n<li>1 1<ul>\n<li>1 1：作者修改文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102026434.png\" alt=\"image-20240910202622396\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TDD与编辑接口\"><a href=\"#TDD与编辑接口\" class=\"headerlink\" title=\"TDD与编辑接口\"></a>TDD与编辑接口</h2><p><strong>TDD：测试驱动开发，先写测试，再写实现</strong></p>\n<ul>\n<li>通过撰写测试，<strong>理清楚接口该如何定义，站在用户的角度看是否合适</strong></li>\n<li>通过撰写测试用例，<strong>理清楚整个功能要考虑的主流程、异常流程</strong></li>\n</ul>\n<h3 id=\"核心循环\"><a href=\"#核心循环\" class=\"headerlink\" title=\"核心循环\"></a>核心循环</h3><ul>\n<li>根据对需求的理解，<strong>初步定义接口</strong>，无所谓接口合不合适，反正还得改</li>\n<li>根据接口定义测试</li>\n<li>执行核心循环<ul>\n<li>增加测试用例</li>\n<li>提供&#x2F;修改实现</li>\n<li>执行测试用例</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161517114.png\" alt=\"image-20240916151718031\" style=\"zoom:67%;\" />\n\n<h3 id=\"suite测试组织套件\"><a href=\"#suite测试组织套件\" class=\"headerlink\" title=\"suite测试组织套件\"></a>suite测试组织套件</h3><p><a href=\"https://annatarhe.github.io/2020/08/19/how-to-do-test-in-go.html\">参考文章</a></p>\n<p>有的时候在测试之前需要连接db、redis、rpc之类的东西，然后再测试结束后将这些连接关闭。也就是说，我们的单元（集成）测试具有<strong>生命周期</strong>。如果是手动编写连接、关闭连接的代码会使得测试部分显得异常臃肿，好在有<code>suite</code>可以帮助我们有效地管理测试的生命周期</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/suite&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义测试结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ExampleTestSuite <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    suite.Suite</span><br><span class=\"line\">    msg <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试前的预备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> SetupTest() &#123;</span><br><span class=\"line\">    suite.msg = <span class=\"string\">&quot;iu is my wife&quot;</span></span><br><span class=\"line\">    db, _ = sql.Open(<span class=\"string\">&quot;xxx&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> TestExample() &#123;</span><br><span class=\"line\">    m := &amp;obj&#123;</span><br><span class=\"line\">        Msg: suite.msg</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    err := insert(m)</span><br><span class=\"line\">    assert.Nil(suite.T(), err)</span><br><span class=\"line\">    assert.Equal(suite.T(), suite.msg, m.Msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试后的清理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">    db.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestExampleTestSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suite.Run(t, <span class=\"built_in\">new</span>(ExampleTestSuite))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>五个步骤</p>\n<ul>\n<li><strong>定义测试结构体</strong><ul>\n<li>测试结构体中应包含所需要的第三方字段，例如<code>suite.Suite</code>,<code>gorm.DB</code>, <code>redis.Cmdable</code>等</li>\n</ul>\n</li>\n<li><strong>入口函数</strong><ul>\n<li><code>func TestExampleTestSuite(t *testing.T)</code></li>\n<li>函数体中仅有<code>suite.Run(t, new(xxx))</code>一行代码</li>\n</ul>\n</li>\n<li><strong>测试前的准备工作</strong><ul>\n<li><code>func (suite *ExampleTestSuite) SetupTest()</code></li>\n</ul>\n</li>\n<li>测试<ul>\n<li><code>func (suite *ExampleTestSuite) TestExample()</code></li>\n</ul>\n</li>\n<li><strong>测试后的清理</strong><ul>\n<li><code>func (suite *ExampleTestSuite) TearDownTest()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TDD集成测试实践（一）\"><a href=\"#TDD集成测试实践（一）\" class=\"headerlink\" title=\"TDD集成测试实践（一）\"></a>TDD集成测试实践（一）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试套件</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ArticleSuite <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsuite.Suite</span><br><span class=\"line\">\tserver *gin.Engine</span><br><span class=\"line\">\tdb     *gorm.DB</span><br><span class=\"line\">\tl      *zap.Logger</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SetupTest 都用startup里的初始化方法，当然使用wire生成啦</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> SetupTest() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\ts.l, err = zap.NewDevelopment()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.db = startup.InitDB(s.l)</span><br><span class=\"line\">\tgin.SetMode(gin.ReleaseMode)</span><br><span class=\"line\">\ts.server = gin.Default()</span><br><span class=\"line\">\t<span class=\"comment\">// 在这里放好userClaims，表示登录状态</span></span><br><span class=\"line\">\ts.server.Use(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.Set(<span class=\"string\">&quot;userClaims&quot;</span>, jwt.UserClaims&#123;</span><br><span class=\"line\">\t\t\tUserId: <span class=\"number\">123</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tartHdl := startup.InitArticleHandler()</span><br><span class=\"line\">\tartHdl.RegisterRoutes(s.server)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> TestEdit() &#123;</span><br><span class=\"line\">\tt := s.T()</span><br><span class=\"line\">\ttestCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tname <span class=\"type\">string</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 准备数据</span></span><br><span class=\"line\">\t\tbefore <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 校验数据</span></span><br><span class=\"line\">\t\tafter   <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span></span><br><span class=\"line\">\t\tarticle Article</span><br><span class=\"line\">\t\t<span class=\"comment\">// 预期数据</span></span><br><span class=\"line\">\t\texpectCode <span class=\"type\">int</span></span><br><span class=\"line\">\t\texpectRes  Result[<span class=\"type\">int</span>]</span><br><span class=\"line\">\t&#125;&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname: <span class=\"string\">&quot;新建帖子——保存成功&quot;</span>,</span><br><span class=\"line\">\t\t\tbefore: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tafter: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 对每一列数据都要进行检验</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> article dao.Article</span><br><span class=\"line\">\t\t\t\terr := s.db.Where(<span class=\"string\">&quot;id=?&quot;</span>, <span class=\"number\">1</span>).First(&amp;article).Error</span><br><span class=\"line\">\t\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\t\tassert.True(t, article.Ctime &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tassert.True(t, article.Utime &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tarticle.Ctime = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tarticle.Utime = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tassert.Equal(t, dao.Article&#123;</span><br><span class=\"line\">\t\t\t\t\tId:       <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t\t\t\tTitle:    <span class=\"string\">&quot;这是标题&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\tContent:  <span class=\"string\">&quot;这是内容&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\tAuthorId: <span class=\"number\">123</span>,</span><br><span class=\"line\">\t\t\t\t&#125;, article)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">            article: Article&#123;</span><br><span class=\"line\">                Title: <span class=\"string\">&quot;这是标题&quot;</span>,</span><br><span class=\"line\">                Content: <span class=\"string\">&quot;这是内容&quot;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\texpectCode: http.StatusOK,</span><br><span class=\"line\">\t\t\texpectRes: Result[<span class=\"type\">int</span>]&#123;</span><br><span class=\"line\">\t\t\t\tData: <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, tc := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\tt.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//tc.before(t)</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 以json格式输入</span></span><br><span class=\"line\">\t\t\tarticleJson, err := json.Marshal(tc.article)</span><br><span class=\"line\">\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\treq, err := http.NewRequest(http.MethodPost, <span class=\"string\">&quot;/article/edit&quot;</span>, bytes.NewBuffer(articleJson))</span><br><span class=\"line\">\t\t\treq.Header.Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\tresp := httptest.NewRecorder()</span><br><span class=\"line\">\t\t\ts.server.ServeHTTP(resp, req)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> res Result[<span class=\"type\">int</span>]</span><br><span class=\"line\">\t\t\tassert.Equal(t, tc.expectCode, resp.Code)</span><br><span class=\"line\">\t\t\terr = json.NewDecoder(resp.Body).Decode(&amp;res)</span><br><span class=\"line\">\t\t\tassert.Equal(t, tc.expectRes, res)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//tc.after(t)</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试后所作的动作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">\ts.db.Exec(<span class=\"string\">&quot;truncate table articles&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestArticleSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tsuite.Run(t, <span class=\"built_in\">new</span>(ArticleSuite))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Article <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle   <span class=\"type\">string</span> <span class=\"string\">`json:&quot;title&quot;`</span></span><br><span class=\"line\">\tContent <span class=\"type\">string</span> <span class=\"string\">`json:&quot;content&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Result[T any] <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tMsg  <span class=\"type\">string</span> <span class=\"string\">`json:&quot;msg&quot;`</span></span><br><span class=\"line\">\tCode <span class=\"type\">int</span>    <span class=\"string\">`json:&quot;code&quot;`</span></span><br><span class=\"line\">\tData T      <span class=\"string\">`json:&quot;data&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>DDD侧重于设计架构、高层次战略</p>\n</li>\n<li><p>TDD专注于某个功能的实现</p>\n</li>\n</ul>\n<p>在开发过程中，可以使用如下技巧，确保类型实现了特定接口接口</p>\n<p>例如，确保<code>ArticleHandler</code>类型实现了<code>handler</code>接口</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409072112298.png\" alt=\"image-20240907211201251\"></p>\n<h3 id=\"TDD集成测试实践（二）\"><a href=\"#TDD集成测试实践（二）\" class=\"headerlink\" title=\"TDD集成测试实践（二）\"></a>TDD集成测试实践（二）</h3><p>在实现完创建文章功能后，接着就要实现修改文章功能</p>\n<p>依据TDD核心循环，需要再添加测试用例</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161518765.png\" alt=\"image-20240916151741659\"></p>\n<p>由于我们将要实现的是修改文章功能，也就是说<strong>文章是事先存在的，前端请求将会带上文章的Id</strong>，那么在测试时需要在<code>before</code>函数中做好数据的准备工作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    err := s.db.Create(&amp;dao.Article&#123;</span><br><span class=\"line\">        Id:      <span class=\"number\">2</span>,</span><br><span class=\"line\">        Title:   <span class=\"string\">&quot;旧的标题&quot;</span>,</span><br><span class=\"line\">        Content: <span class=\"string\">&quot;旧的标题&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 和时间有关的测试，最好不用time.Now(), 因为每一次都不一样，不方便进行断言</span></span><br><span class=\"line\">        AuthorId: <span class=\"number\">123</span>,</span><br><span class=\"line\">        Ctime:    <span class=\"number\">677</span>,</span><br><span class=\"line\">        Utime:    <span class=\"number\">677</span>,</span><br><span class=\"line\">    &#125;).Error</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>更新文章涉及到更新数据库，有两个值得注意的点</p>\n<ul>\n<li><p>修改<code>utime</code>这个跟时间有关的字段，而在进行和时间有关的测试时，尽量不要使用<code>time.Now()</code>函数，因为每一次运行<code>time.Now()</code>结果都不相同，不便于后续的断言操作</p>\n</li>\n<li><p>两种更新操作写法</p>\n<ul>\n<li><pre><code class=\"go\">// 利用了gorm忽略零值的特性，根据主键（锁定要更新的行）进行更新操作\n// 可读性差\n// 忽略零值是指如果某个字段是原本是零值，那么就不更新该字段\nerr := dao.db.WithContext(ctx).Updates(&amp;article).Error\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```go</span><br><span class=\"line\">  // 可读性较强</span><br><span class=\"line\">  err := dao.db.WithContext(ctx).Model(&amp;article).</span><br><span class=\"line\">  \t\tWhere(&quot;id=?&quot;, article.Id).Updates(map[string]any&#123;</span><br><span class=\"line\">  \t\t&quot;title&quot;:   article.Title,</span><br><span class=\"line\">  \t\t&quot;content&quot;: article.Content,</span><br><span class=\"line\">  \t\t&quot;utime&quot;:   article.Utime,</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>忽略零值可参考 <a href=\"https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97\">更新 | GORM</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DDD：实体-——-值对象\"><a href=\"#DDD：实体-——-值对象\" class=\"headerlink\" title=\"DDD：实体 —— 值对象\"></a>DDD：实体 —— 值对象</h2><p>下图所示就是一个非常经典的领域设计驱动中的领域对象中<strong>实体</strong>和<strong>值对象</strong>的一个体现</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161550256.png\" alt=\"image-20240916155000184\" style=\"zoom:67%;\" />\n\n<ul>\n<li>实体：<strong>独立存在的</strong></li>\n<li>值对象：<strong>依赖于实体而存在，通常作为实体的属性出现</strong></li>\n</ul>\n<p>可以结合实例理解一下：在用户领域，一个人是一个实体，他是独立存在的；而在帖子领域，一个人是依赖于帖子才能成为作者，是一个值对象</p>\n<p><strong>在DDD里面，一个领域的实体，在另一个领域中通常作为值对象、另一个实体的属性出现</strong></p>\n<h2 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h2><h3 id=\"职责划分\"><a href=\"#职责划分\" class=\"headerlink\" title=\"职责划分\"></a>职责划分</h3><blockquote>\n<p>由之前的分析可知，我们需要一个制作表和线上表，那么该有哪一个部分来同步两个表的数据呢？</p>\n</blockquote>\n<p>理论上，项目是单体应用还是微服务应用是选择时需要参考的因素</p>\n<ul>\n<li>web&#x2F;聚合服务<ul>\n<li>调用不同的service来同步数据，可以理解为作者和读者各有各的服务</li>\n</ul>\n</li>\n<li>service<ul>\n<li>调用不同的repository来保存数据，从存储的角度看来，作者看到的帖子和读者看到的帖子是不一样的</li>\n</ul>\n</li>\n<li>repository<ul>\n<li>操作不同的数据源</li>\n</ul>\n</li>\n</ul>\n<p><strong>业务简单就一个repository，复杂就用多个repository</strong></p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271441109.png\" alt=\"image-20240927144102855\" style=\"zoom:50%;\" />\n\n<h3 id=\"维护事务\"><a href=\"#维护事务\" class=\"headerlink\" title=\"维护事务\"></a>维护事务</h3><p>同步制作库和线上库要么同时成功，要么同时失败，因此将数据同步操作做成一个事务再合适不过了</p>\n<p>可以在两个层面上维护事务，一个是<code>repository</code>，另一个是<code>dao</code>。但是<code>repository</code>在DDD中应该是操作数据库和缓存的，如果在这一层面维护事务，结果就是跨层操作并强耦合于GORM（而且写起来不优雅🤪）。另一种方案是在<code>dao</code>层中维护事务（这就方便多啦😊），具体实现如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(dao *BasicArticleDAO)</span></span> Sync(ctx context.Context, article Article) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tid := article.Id</span><br><span class=\"line\">\t<span class=\"comment\">// 利用GORM控制事务的生命周期</span></span><br><span class=\"line\">\terr := dao.db.WithContext(ctx).Transaction(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(tx *gorm.DB)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> id &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = dao.UpdateById(ctx, article)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tid, err = dao.Insert(ctx, article)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dao.Upsert(ctx, PublishArticle&#123;</span><br><span class=\"line\">\t\t\tArticle: article,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> id, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：GORM的<code>transaction</code>方法在底层实现时就已经帮我们维护了<strong>事务的生命周期</strong></p>\n<blockquote>\n<p>重点是如何在GORM下实现Upsert函数</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(dao *BasicArticleDAO)</span></span> Upsert(ctx context.Context, article PublishArticle) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tnow := time.Now().UnixMilli()</span><br><span class=\"line\">\tarticle.Utime = now</span><br><span class=\"line\">\tarticle.Ctime = now</span><br><span class=\"line\">\t<span class=\"comment\">// Upsert函数在GORM下的实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dao.db.WithContext(ctx).Clauses(clause.OnConflict&#123;</span><br><span class=\"line\">\t\tDoUpdates: clause.Assignments(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;title&quot;</span>:   article.Title,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;content&quot;</span>: article.Content,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;utime&quot;</span>:   article.Utime,</span><br><span class=\"line\">\t\t&#125;),</span><br><span class=\"line\">\t&#125;).Create(&amp;article).Error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>向<code>Clauses</code>函数中传递<code>OnConflict</code>结构体，表示如果发生冲突的话应该做什么事情</p>\n<p><code>OnConfilt</code>中有一些比较有用的字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DoUpdate\t\t---&gt; 做更新操作</span></span><br><span class=\"line\"><span class=\"comment\">// DoNothing\t---&gt; 什么也不做</span></span><br><span class=\"line\"><span class=\"comment\">// Where\t\t---&gt; 数据冲突了并且符合where子句，就执行更新操作</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>🌟：在一个事务中，一直都是同一个数据库连接</strong></p>\n<h2 id=\"维护状态\"><a href=\"#维护状态\" class=\"headerlink\" title=\"维护状态\"></a>维护状态</h2><p>在先前的分析中，我们知道需要有线上库和制作库两个数据存储的地方，这两个地方存储的数据本质上是一样的，因此不必创建新的领域对象来维护，<strong>使用衍生类型更加方便</strong></p>\n<h3 id=\"状态常量定义\"><a href=\"#状态常量定义\" class=\"headerlink\" title=\"状态常量定义\"></a>状态常量定义</h3><p>利用常量表示一篇帖子的不同状态，这些常量可以直接利用<code>iota</code>在<code>domain</code>中定义。<strong>一般定义常量，最好不要把零值做成有意义的值</strong>，否则难以区分是用户没有输入还是前端传递默认数据</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409270907841.png\" alt=\"image-20240927090706192\"></p>\n<h2 id=\"使用MongoDB存储\"><a href=\"#使用MongoDB存储\" class=\"headerlink\" title=\"使用MongoDB存储\"></a>使用MongoDB存储</h2><p>类似于大文本之类的东西，除了可以使用关系型数据库，也可以考虑使用其他存储应用，例如MongoDB</p>\n<p><strong>MongoDB属于NoSQL，NoSQL即Not Only SQL</strong>，不仅仅是SQL</p>\n<p>NoSQL数据库的产生是为了解决大规模数据集合、多种数据种类带来的挑战，尤其是大数据应用难题</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530245.png\" alt=\"image-20240930153021471\" style=\"zoom:50%;\" />\n\n<h3 id=\"MongoDB简介\"><a href=\"#MongoDB简介\" class=\"headerlink\" title=\"MongoDB简介\"></a>MongoDB简介</h3><p>MongoDB的基本特性</p>\n<ul>\n<li><strong>面向集合存储</strong>：MongoDB集合中可以存储多个文档<ul>\n<li>类比于MySQL，MongoDB中的一个集合就像是一张表，集合中的一个文档就相当于表中的一条记录</li>\n</ul>\n</li>\n<li><strong>模式自由</strong>：MongoDB采用无结构模式存储数据，也就是说，在储存数据之前不需要定义数据的结构<ul>\n<li>就像当于在MySQL中不需要预先建立表结构就能插入数据</li>\n</ul>\n</li>\n<li><strong>支持分片</strong>：MongoDB支持分片，并且MongoDB自动解决了分片的各种问题，包括自动化扩容</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530677.png\" alt=\"image-20240930153009489\" style=\"zoom:67%;\" />\n\n<p>选择MongoDB的两个理由：</p>\n<ul>\n<li><p><strong>灵活的文档模型</strong>：于MySQL不同，不需要事前在MongoDB中定义文档模型，并且可以灵活修改</p>\n</li>\n<li><p><strong>易于横向扩展</strong>：可以通过增加MongoDB实例来应付流量和数据增长</p>\n</li>\n</ul>\n<h3 id=\"初始化客户端并插入文档\"><a href=\"#初始化客户端并插入文档\" class=\"headerlink\" title=\"初始化客户端并插入文档\"></a>初始化客户端并插入文档</h3><blockquote>\n<p>需要使用MongoDB官网的go-driver</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301941675.png\" alt=\"image-20240930194117517\"></p>\n<h3 id=\"查找文档\"><a href=\"#查找文档\" class=\"headerlink\" title=\"查找文档\"></a>查找文档</h3><p>在MongoDB中有两种构造查询条件的方式：</p>\n<ul>\n<li><strong>bson</strong></li>\n<li><strong>结构体</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用bson构造查询条件</span></span><br><span class=\"line\">filter := bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;id&quot;</span>, Value: <span class=\"number\">123</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> art Article</span><br><span class=\"line\">err = col.FindOne(ctx, filter).Decode(&amp;art)</span><br><span class=\"line\">assert.NoError(t, err)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;find article %v\\n&quot;</span>, art)</span><br><span class=\"line\"><span class=\"comment\">// 使用结构体构造查询条件</span></span><br><span class=\"line\">err = col.FindOne(ctx, Article&#123;Id: <span class=\"number\">123</span>&#125;).Decode(&amp;art)</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, mongo.ErrNoDocuments) &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;find none&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：使用结构体构造查询条件时，mongodb-go-driver默认使用结构体的全部字段作为匹配条件，需要注意某些字段<strong>默认零值</strong>。当然，可以使用<code>bson:&quot;field_name,omitempty&quot;</code>标签来告知mongodb-go-driver忽略字段零值</p>\n<p>🌟：可以使用<code>mongo.ErrNoDocuments</code>错误值检验是否有查询到文档</p>\n<h3 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h3><ul>\n<li>构造更新条件，同构造查询条件</li>\n<li>构造更新字段<ul>\n<li><strong>bson</strong></li>\n<li><strong>结构体</strong></li>\n</ul>\n</li>\n</ul>\n<p>⚠️：同样的，需要注意<strong>底层是否会采用字段零值</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sets := bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;$set&quot;</span>,</span><br><span class=\"line\">\tValue: bson.E&#123;Key: <span class=\"string\">&quot;content&quot;</span>, Value: <span class=\"string\">&quot;serious content&quot;</span>&#125;&#125;&#125;</span><br><span class=\"line\">res, err := col.UpdateOne(ctx, filter, sets)</span><br><span class=\"line\"><span class=\"comment\">// 使用结构体构造更新字段</span></span><br><span class=\"line\">res, err = col.UpdateOne(ctx, filter, bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;$set&quot;</span>, Value: Article&#123;</span><br><span class=\"line\">\tTitle: <span class=\"string\">&quot;new title&quot;</span>,</span><br><span class=\"line\">&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>类似于MySQL，<strong>一般是根据业务中常用的查询条件，来决定在什么列上构建索引</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">indexRes, err := col.Indexes().CreateOne(ctx, mongo.IndexModel&#123;</span><br><span class=\"line\">\tKeys:    bson.M&#123;<span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\tOptions: options.Index().SetUnique(<span class=\"literal\">true</span>),</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">fmt.Println(indexRes)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MongoDB存储数据\"><a href=\"#MongoDB存储数据\" class=\"headerlink\" title=\"MongoDB存储数据\"></a>MongoDB存储数据</h3><p>由于MongoDB中的<code>_id</code>字段不是自增并且是一个<strong>12字节</strong>的切片，因此不能直接使用这个字段作为主键</p>\n<p>主键的可选方案：</p>\n<ul>\n<li><strong>将整个id修改为string类型</strong></li>\n<li><strong>使用ID生成策略</strong>，例如<strong>雪花算法</strong><ul>\n<li><strong>1比特保留位</strong></li>\n<li><strong>41比特时间戳</strong></li>\n<li><strong>10比特机器位</strong>，一般叫做<code>Worker ID</code></li>\n<li><strong>12比特自增序号</strong></li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031541579.png\" alt=\"image-20241003154159484\"></li>\n</ul>\n</li>\n<li><strong>使用GUID</strong></li>\n<li><strong>定义一个新的接口</strong>，但这样就失去了DAO层的统一接口</li>\n</ul>\n<p><strong>⚠️：在MongoDB中，尽量使用衍生类型而不是嵌套结构体。因为嵌套结构体中子结构体的字段标签在操作过程中无法正常生效</strong></p>\n<h2 id=\"利用OSS来存储数据\"><a href=\"#利用OSS来存储数据\" class=\"headerlink\" title=\"利用OSS来存储数据\"></a>利用OSS来存储数据</h2><blockquote>\n<p>利用OSS存储线上数据，而后直接通过CDN加速访问</p>\n</blockquote>\n<p>OSS（Object Storage Service）是指兑现存储，<strong>被大量用于存储文件、流媒体、图片等</strong></p>\n<p>OSS中的两个核心概念：</p>\n<ul>\n<li><strong>Bucket</strong>：逻辑上的分组关系，例如某个业务使用一个桶，另一个业务使用另外一个桶</li>\n<li><strong>Object</strong>：对象，也就是需要存储的东西</li>\n</ul>\n<p>ACL（Access Control List）：权限控制方案</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410041010143.png\" alt=\"image-20241004101033272\"></p>\n<p>OSS通常和CDN结合在一起使用，<strong>即在OSS上存储的数据，可以通过CDN来访问</strong></p>\n<p>一种很常见的性能和可用性优化手段，就是使用<strong>OSS和CDN来存储网站的静态资源</strong>，此时OSS被当作CDN的一个回源站点</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410041013265.png\" alt=\"image-20241004101307223\"></p>\n<h2 id=\"查询接口与缓存\"><a href=\"#查询接口与缓存\" class=\"headerlink\" title=\"查询接口与缓存\"></a>查询接口与缓存</h2><p>在实现查询文章功能过程中，需要从不同用户角度出发进行思考</p>\n<ul>\n<li>对于创作者来说，需要查询自己的<strong>文章列表</strong>以及<strong>某一篇文章的详细内容</strong>，分别对应着两个接口<ul>\n<li>列表接口</li>\n<li>详情接口</li>\n</ul>\n</li>\n<li>对于读者，他能够<strong>搜索某篇文章</strong>、<strong>浏览推荐文章列表</strong>、<strong>阅读文章的具体内容</strong>。由此可见，需要提供以下接口<ul>\n<li>搜索接口</li>\n<li>推荐接口</li>\n<li>阅读文章接口</li>\n</ul>\n</li>\n</ul>\n<p>目前仅实现创作者的<strong>列表接口和详情接口</strong>，以及读者的<strong>阅读文章接口</strong></p>\n<h3 id=\"列表接口\"><a href=\"#列表接口\" class=\"headerlink\" title=\"列表接口\"></a>列表接口</h3><h4 id=\"需求分析-1\"><a href=\"#需求分析-1\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><p>参考掘金的列表展示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061411490.png\" alt=\"image-20241006141112588\"></p>\n<p>可以发现，在列表中展示的文章对象有如下特征：</p>\n<ul>\n<li>标题</li>\n<li>创建时间</li>\n<li>简介</li>\n<li>…</li>\n</ul>\n<p>根据这些特征我们就能定义出与前端相对应的<code>ArticleVO</code></p>\n<p>另一个值得注意的点是，<strong>掘金在列表中展示的文章只有一小部分，当页面下滑时才会加载更多的文章</strong>，这就相当于一个<strong>分页查询</strong>操作</p>\n<h4 id=\"分页形态\"><a href=\"#分页形态\" class=\"headerlink\" title=\"分页形态\"></a>分页形态</h4><p><strong>分页的核心目标就是避免一次操作太多数据，引发性能问题</strong>。况且，列表页在展示的时候，也不许那么多的内容😏</p>\n<p>分页接口一般有三种定义形式：</p>\n<ul>\n<li><strong>直接定义<code>Offset</code>和<code>Limit</code>字段</strong></li>\n<li><strong>直接定义一个<code>Page</code>字段，并约定好Page的大小</strong></li>\n<li><strong>直接定义一个<code>Cursor</code>字段</strong></li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061421861.png\" alt=\"image-20241006142108823\" style=\"zoom: 50%;\" />\n\n<h3 id=\"缓存设计\"><a href=\"#缓存设计\" class=\"headerlink\" title=\"缓存设计\"></a>缓存设计</h3><blockquote>\n<p>缓存第一页分页</p>\n</blockquote>\n<p>大部分情况下，不会对分页结果进行缓存，<strong>因为如果数据的筛选条件、排序条件、分页条件、分页的偏移量和数据量中的任何一个发生了变化，缓存就很难使用了</strong></p>\n<p>但可以只<strong>缓存第一页</strong>，毕竟大部分用户只看列表的第一页</p>\n<p>有了缓存之后，<strong>每次进行更新操作都要将缓存删除，防止缓存不一致问题</strong></p>\n<blockquote>\n<p>业务相关的预加载</p>\n</blockquote>\n<p><strong>预加载本质上就是预判用户将要读取的内容，提前将内容存入缓存中</strong></p>\n<p>而且，因为是预测性质的，所以过期时间设置得很短</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061512142.png\" alt=\"image-20241006151243081\"></p>\n<blockquote>\n<p>不缓存大文档（调优😂）</p>\n</blockquote>\n<p>可以考虑在Redis内存消耗和缓存性能之间做一个权衡</p>\n<p>也就是说，并不是所有的值都需要缓存，<strong>有一些很占用内存空间的文章就不必缓存</strong></p>\n<h4 id=\"缓存过期时间\"><a href=\"#缓存过期时间\" class=\"headerlink\" title=\"缓存过期时间\"></a>缓存过期时间</h4><p>缓存的过期时间和缓存命中率有关，一般情况下，<strong>过期时间越长，命中率越高，但数据一致性会变差；过期时间越短，命中率越低，但数据一致性会更好</strong></p>\n<ul>\n<li>业务相关的缓存预加载，过期时间要短</li>\n<li>根据用户身份按权给予不同的缓存时间</li>\n</ul>\n<h4 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h4><p>淘汰策略是指在缓存内存不够用的情况下，淘汰某一部分数据时的计划</p>\n<p>常规方案就是<strong>LRU和LFU</strong></p>\n<p>还有一些方案：</p>\n<ul>\n<li>优先淘汰普通创作者的数据，留下大v的数据</li>\n<li>优先淘汰大对象，释放出更多的内存空间</li>\n<li>优先淘汰小对象，相比于大对象，小对象在从数据库（或OSS）中获取更加迅速</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>使用<code>wrapbodyandtoken</code>统一处理Body和Token中的数据</li>\n<li>考虑到中文字符由多个字节组成，在处理包含中文的字符串时，应实现将其转为<code>[]rune</code>再进行<code>len()</code>操作</li>\n<li>需要将存储对象转换为<code>json</code>格式后才能存入Redis中，否则会报错</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"发帖功能实现\"><a href=\"#发帖功能实现\" class=\"headerlink\" title=\"发帖功能实现\"></a>发帖功能实现</h1><h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><h3 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h3><blockquote>\n<p>通过使用用例来展示某个需求的具体使用场景</p>\n</blockquote>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092129324.png\" width=300>\n\n<ul>\n<li>创作者<ul>\n<li>增删改查</li>\n</ul>\n</li>\n<li>读者<ul>\n<li>查</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内容的可见性\"><a href=\"#内容的可见性\" class=\"headerlink\" title=\"内容的可见性\"></a>内容的可见性</h3><blockquote>\n<p>创作者创作了一篇文章，那么这篇文章什么情况下可以被读者看到呢？</p>\n</blockquote>\n<p>根据生活经验，可以很容易想到：一篇文章只有在发表（通过审核）并且处于公开状态下才能被用户所看到。如此，一篇帖子就有了发表和未发表两个状态，我们可以很轻松地得出一篇帖子的<strong>状态</strong>转换图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409092140450.png\" alt=\"image-20240909214045416\"></p>\n<p>想象这么一个场景，用户正在浏览文章，与此同时作者也在修改文章，那么用户会实时看到作者的修改吗？</p>\n<p>这当然不会，在创作者发布之前，这些修改对读者都是不可见的</p>\n<p>一种很显然的解决办法就是<strong>分开存储</strong>，即一个<strong>制作表</strong>，一个<strong>线上表</strong></p>\n<p>用户看到的是线上表中的数据，而作者修改的都是制作表中的数据，这样作者的修改对于用户而言都是不可知的，只有当线上表更新后，用户才能看到修改</p>\n<p>整理上述分析，可以得到更详细的状态图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102004630.png\" alt=\"image-20240910200443544\"></p>\n<h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><p>我们将两个表（制作表、线上表）的状态，分别用一位二进制表示，可以得出3中起始状态（有一种状态不可能存在）</p>\n<ul>\n<li>0 0：制作表和线上表都没有数据</li>\n<li>1 0：只有制作表中有数据</li>\n<li>1 1：制作表和线上表都有数据</li>\n</ul>\n<p>分析每一种起始状态可能的后续状态</p>\n<ul>\n<li>0 0<ul>\n<li>1 0：作者写了一半，木有发表</li>\n<li>1 1：作者写好并发表了文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014800.png\" alt=\"image-20240910201425755\"></li>\n</ul>\n</li>\n<li>1 0<ul>\n<li>1 1：作者写好并发表了文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102014565.png\" alt=\"image-20240910201456526\"></li>\n</ul>\n</li>\n<li>1 1<ul>\n<li>1 1：作者修改文章</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409102026434.png\" alt=\"image-20240910202622396\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TDD与编辑接口\"><a href=\"#TDD与编辑接口\" class=\"headerlink\" title=\"TDD与编辑接口\"></a>TDD与编辑接口</h2><p><strong>TDD：测试驱动开发，先写测试，再写实现</strong></p>\n<ul>\n<li>通过撰写测试，<strong>理清楚接口该如何定义，站在用户的角度看是否合适</strong></li>\n<li>通过撰写测试用例，<strong>理清楚整个功能要考虑的主流程、异常流程</strong></li>\n</ul>\n<h3 id=\"核心循环\"><a href=\"#核心循环\" class=\"headerlink\" title=\"核心循环\"></a>核心循环</h3><ul>\n<li>根据对需求的理解，<strong>初步定义接口</strong>，无所谓接口合不合适，反正还得改</li>\n<li>根据接口定义测试</li>\n<li>执行核心循环<ul>\n<li>增加测试用例</li>\n<li>提供&#x2F;修改实现</li>\n<li>执行测试用例</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161517114.png\" alt=\"image-20240916151718031\" style=\"zoom:67%;\" />\n\n<h3 id=\"suite测试组织套件\"><a href=\"#suite测试组织套件\" class=\"headerlink\" title=\"suite测试组织套件\"></a>suite测试组织套件</h3><p><a href=\"https://annatarhe.github.io/2020/08/19/how-to-do-test-in-go.html\">参考文章</a></p>\n<p>有的时候在测试之前需要连接db、redis、rpc之类的东西，然后再测试结束后将这些连接关闭。也就是说，我们的单元（集成）测试具有<strong>生命周期</strong>。如果是手动编写连接、关闭连接的代码会使得测试部分显得异常臃肿，好在有<code>suite</code>可以帮助我们有效地管理测试的生命周期</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/suite&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义测试结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ExampleTestSuite <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    suite.Suite</span><br><span class=\"line\">    msg <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试前的预备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> SetupTest() &#123;</span><br><span class=\"line\">    suite.msg = <span class=\"string\">&quot;iu is my wife&quot;</span></span><br><span class=\"line\">    db, _ = sql.Open(<span class=\"string\">&quot;xxx&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> TestExample() &#123;</span><br><span class=\"line\">    m := &amp;obj&#123;</span><br><span class=\"line\">        Msg: suite.msg</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    err := insert(m)</span><br><span class=\"line\">    assert.Nil(suite.T(), err)</span><br><span class=\"line\">    assert.Equal(suite.T(), suite.msg, m.Msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试后的清理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(suite *ExampleTestSuite)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">    db.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestExampleTestSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    suite.Run(t, <span class=\"built_in\">new</span>(ExampleTestSuite))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>五个步骤</p>\n<ul>\n<li><strong>定义测试结构体</strong><ul>\n<li>测试结构体中应包含所需要的第三方字段，例如<code>suite.Suite</code>,<code>gorm.DB</code>, <code>redis.Cmdable</code>等</li>\n</ul>\n</li>\n<li><strong>入口函数</strong><ul>\n<li><code>func TestExampleTestSuite(t *testing.T)</code></li>\n<li>函数体中仅有<code>suite.Run(t, new(xxx))</code>一行代码</li>\n</ul>\n</li>\n<li><strong>测试前的准备工作</strong><ul>\n<li><code>func (suite *ExampleTestSuite) SetupTest()</code></li>\n</ul>\n</li>\n<li>测试<ul>\n<li><code>func (suite *ExampleTestSuite) TestExample()</code></li>\n</ul>\n</li>\n<li><strong>测试后的清理</strong><ul>\n<li><code>func (suite *ExampleTestSuite) TearDownTest()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TDD集成测试实践（一）\"><a href=\"#TDD集成测试实践（一）\" class=\"headerlink\" title=\"TDD集成测试实践（一）\"></a>TDD集成测试实践（一）</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试套件</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ArticleSuite <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsuite.Suite</span><br><span class=\"line\">\tserver *gin.Engine</span><br><span class=\"line\">\tdb     *gorm.DB</span><br><span class=\"line\">\tl      *zap.Logger</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SetupTest 都用startup里的初始化方法，当然使用wire生成啦</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> SetupTest() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\ts.l, err = zap.NewDevelopment()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.db = startup.InitDB(s.l)</span><br><span class=\"line\">\tgin.SetMode(gin.ReleaseMode)</span><br><span class=\"line\">\ts.server = gin.Default()</span><br><span class=\"line\">\t<span class=\"comment\">// 在这里放好userClaims，表示登录状态</span></span><br><span class=\"line\">\ts.server.Use(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.Set(<span class=\"string\">&quot;userClaims&quot;</span>, jwt.UserClaims&#123;</span><br><span class=\"line\">\t\t\tUserId: <span class=\"number\">123</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tartHdl := startup.InitArticleHandler()</span><br><span class=\"line\">\tartHdl.RegisterRoutes(s.server)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> TestEdit() &#123;</span><br><span class=\"line\">\tt := s.T()</span><br><span class=\"line\">\ttestCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tname <span class=\"type\">string</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 准备数据</span></span><br><span class=\"line\">\t\tbefore <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 校验数据</span></span><br><span class=\"line\">\t\tafter   <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span></span><br><span class=\"line\">\t\tarticle Article</span><br><span class=\"line\">\t\t<span class=\"comment\">// 预期数据</span></span><br><span class=\"line\">\t\texpectCode <span class=\"type\">int</span></span><br><span class=\"line\">\t\texpectRes  Result[<span class=\"type\">int</span>]</span><br><span class=\"line\">\t&#125;&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname: <span class=\"string\">&quot;新建帖子——保存成功&quot;</span>,</span><br><span class=\"line\">\t\t\tbefore: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tafter: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 对每一列数据都要进行检验</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> article dao.Article</span><br><span class=\"line\">\t\t\t\terr := s.db.Where(<span class=\"string\">&quot;id=?&quot;</span>, <span class=\"number\">1</span>).First(&amp;article).Error</span><br><span class=\"line\">\t\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\t\tassert.True(t, article.Ctime &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tassert.True(t, article.Utime &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tarticle.Ctime = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tarticle.Utime = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tassert.Equal(t, dao.Article&#123;</span><br><span class=\"line\">\t\t\t\t\tId:       <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t\t\t\tTitle:    <span class=\"string\">&quot;这是标题&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\tContent:  <span class=\"string\">&quot;这是内容&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\tAuthorId: <span class=\"number\">123</span>,</span><br><span class=\"line\">\t\t\t\t&#125;, article)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">            article: Article&#123;</span><br><span class=\"line\">                Title: <span class=\"string\">&quot;这是标题&quot;</span>,</span><br><span class=\"line\">                Content: <span class=\"string\">&quot;这是内容&quot;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\texpectCode: http.StatusOK,</span><br><span class=\"line\">\t\t\texpectRes: Result[<span class=\"type\">int</span>]&#123;</span><br><span class=\"line\">\t\t\t\tData: <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, tc := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\tt.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//tc.before(t)</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 以json格式输入</span></span><br><span class=\"line\">\t\t\tarticleJson, err := json.Marshal(tc.article)</span><br><span class=\"line\">\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\treq, err := http.NewRequest(http.MethodPost, <span class=\"string\">&quot;/article/edit&quot;</span>, bytes.NewBuffer(articleJson))</span><br><span class=\"line\">\t\t\treq.Header.Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">\t\t\trequire.NoError(t, err)</span><br><span class=\"line\">\t\t\tresp := httptest.NewRecorder()</span><br><span class=\"line\">\t\t\ts.server.ServeHTTP(resp, req)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> res Result[<span class=\"type\">int</span>]</span><br><span class=\"line\">\t\t\tassert.Equal(t, tc.expectCode, resp.Code)</span><br><span class=\"line\">\t\t\terr = json.NewDecoder(resp.Body).Decode(&amp;res)</span><br><span class=\"line\">\t\t\tassert.Equal(t, tc.expectRes, res)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//tc.after(t)</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试后所作的动作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *ArticleSuite)</span></span> TearDownTest() &#123;</span><br><span class=\"line\">\ts.db.Exec(<span class=\"string\">&quot;truncate table articles&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestArticleSuite</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tsuite.Run(t, <span class=\"built_in\">new</span>(ArticleSuite))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Article <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle   <span class=\"type\">string</span> <span class=\"string\">`json:&quot;title&quot;`</span></span><br><span class=\"line\">\tContent <span class=\"type\">string</span> <span class=\"string\">`json:&quot;content&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Result[T any] <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tMsg  <span class=\"type\">string</span> <span class=\"string\">`json:&quot;msg&quot;`</span></span><br><span class=\"line\">\tCode <span class=\"type\">int</span>    <span class=\"string\">`json:&quot;code&quot;`</span></span><br><span class=\"line\">\tData T      <span class=\"string\">`json:&quot;data&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>DDD侧重于设计架构、高层次战略</p>\n</li>\n<li><p>TDD专注于某个功能的实现</p>\n</li>\n</ul>\n<p>在开发过程中，可以使用如下技巧，确保类型实现了特定接口接口</p>\n<p>例如，确保<code>ArticleHandler</code>类型实现了<code>handler</code>接口</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409072112298.png\" alt=\"image-20240907211201251\"></p>\n<h3 id=\"TDD集成测试实践（二）\"><a href=\"#TDD集成测试实践（二）\" class=\"headerlink\" title=\"TDD集成测试实践（二）\"></a>TDD集成测试实践（二）</h3><p>在实现完创建文章功能后，接着就要实现修改文章功能</p>\n<p>依据TDD核心循环，需要再添加测试用例</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161518765.png\" alt=\"image-20240916151741659\"></p>\n<p>由于我们将要实现的是修改文章功能，也就是说<strong>文章是事先存在的，前端请求将会带上文章的Id</strong>，那么在测试时需要在<code>before</code>函数中做好数据的准备工作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    err := s.db.Create(&amp;dao.Article&#123;</span><br><span class=\"line\">        Id:      <span class=\"number\">2</span>,</span><br><span class=\"line\">        Title:   <span class=\"string\">&quot;旧的标题&quot;</span>,</span><br><span class=\"line\">        Content: <span class=\"string\">&quot;旧的标题&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 和时间有关的测试，最好不用time.Now(), 因为每一次都不一样，不方便进行断言</span></span><br><span class=\"line\">        AuthorId: <span class=\"number\">123</span>,</span><br><span class=\"line\">        Ctime:    <span class=\"number\">677</span>,</span><br><span class=\"line\">        Utime:    <span class=\"number\">677</span>,</span><br><span class=\"line\">    &#125;).Error</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>更新文章涉及到更新数据库，有两个值得注意的点</p>\n<ul>\n<li><p>修改<code>utime</code>这个跟时间有关的字段，而在进行和时间有关的测试时，尽量不要使用<code>time.Now()</code>函数，因为每一次运行<code>time.Now()</code>结果都不相同，不便于后续的断言操作</p>\n</li>\n<li><p>两种更新操作写法</p>\n<ul>\n<li><pre><code class=\"go\">// 利用了gorm忽略零值的特性，根据主键（锁定要更新的行）进行更新操作\n// 可读性差\n// 忽略零值是指如果某个字段是原本是零值，那么就不更新该字段\nerr := dao.db.WithContext(ctx).Updates(&amp;article).Error\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```go</span><br><span class=\"line\">  // 可读性较强</span><br><span class=\"line\">  err := dao.db.WithContext(ctx).Model(&amp;article).</span><br><span class=\"line\">  \t\tWhere(&quot;id=?&quot;, article.Id).Updates(map[string]any&#123;</span><br><span class=\"line\">  \t\t&quot;title&quot;:   article.Title,</span><br><span class=\"line\">  \t\t&quot;content&quot;: article.Content,</span><br><span class=\"line\">  \t\t&quot;utime&quot;:   article.Utime,</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>忽略零值可参考 <a href=\"https://gorm.io/zh_CN/docs/update.html#%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97\">更新 | GORM</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DDD：实体-——-值对象\"><a href=\"#DDD：实体-——-值对象\" class=\"headerlink\" title=\"DDD：实体 —— 值对象\"></a>DDD：实体 —— 值对象</h2><p>下图所示就是一个非常经典的领域设计驱动中的领域对象中<strong>实体</strong>和<strong>值对象</strong>的一个体现</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409161550256.png\" alt=\"image-20240916155000184\" style=\"zoom:67%;\" />\n\n<ul>\n<li>实体：<strong>独立存在的</strong></li>\n<li>值对象：<strong>依赖于实体而存在，通常作为实体的属性出现</strong></li>\n</ul>\n<p>可以结合实例理解一下：在用户领域，一个人是一个实体，他是独立存在的；而在帖子领域，一个人是依赖于帖子才能成为作者，是一个值对象</p>\n<p><strong>在DDD里面，一个领域的实体，在另一个领域中通常作为值对象、另一个实体的属性出现</strong></p>\n<h2 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h2><h3 id=\"职责划分\"><a href=\"#职责划分\" class=\"headerlink\" title=\"职责划分\"></a>职责划分</h3><blockquote>\n<p>由之前的分析可知，我们需要一个制作表和线上表，那么该有哪一个部分来同步两个表的数据呢？</p>\n</blockquote>\n<p>理论上，项目是单体应用还是微服务应用是选择时需要参考的因素</p>\n<ul>\n<li>web&#x2F;聚合服务<ul>\n<li>调用不同的service来同步数据，可以理解为作者和读者各有各的服务</li>\n</ul>\n</li>\n<li>service<ul>\n<li>调用不同的repository来保存数据，从存储的角度看来，作者看到的帖子和读者看到的帖子是不一样的</li>\n</ul>\n</li>\n<li>repository<ul>\n<li>操作不同的数据源</li>\n</ul>\n</li>\n</ul>\n<p><strong>业务简单就一个repository，复杂就用多个repository</strong></p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271441109.png\" alt=\"image-20240927144102855\" style=\"zoom:50%;\" />\n\n<h3 id=\"维护事务\"><a href=\"#维护事务\" class=\"headerlink\" title=\"维护事务\"></a>维护事务</h3><p>同步制作库和线上库要么同时成功，要么同时失败，因此将数据同步操作做成一个事务再合适不过了</p>\n<p>可以在两个层面上维护事务，一个是<code>repository</code>，另一个是<code>dao</code>。但是<code>repository</code>在DDD中应该是操作数据库和缓存的，如果在这一层面维护事务，结果就是跨层操作并强耦合于GORM（而且写起来不优雅🤪）。另一种方案是在<code>dao</code>层中维护事务（这就方便多啦😊），具体实现如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(dao *BasicArticleDAO)</span></span> Sync(ctx context.Context, article Article) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tid := article.Id</span><br><span class=\"line\">\t<span class=\"comment\">// 利用GORM控制事务的生命周期</span></span><br><span class=\"line\">\terr := dao.db.WithContext(ctx).Transaction(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(tx *gorm.DB)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> id &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr = dao.UpdateById(ctx, article)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tid, err = dao.Insert(ctx, article)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dao.Upsert(ctx, PublishArticle&#123;</span><br><span class=\"line\">\t\t\tArticle: article,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> id, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：GORM的<code>transaction</code>方法在底层实现时就已经帮我们维护了<strong>事务的生命周期</strong></p>\n<blockquote>\n<p>重点是如何在GORM下实现Upsert函数</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(dao *BasicArticleDAO)</span></span> Upsert(ctx context.Context, article PublishArticle) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tnow := time.Now().UnixMilli()</span><br><span class=\"line\">\tarticle.Utime = now</span><br><span class=\"line\">\tarticle.Ctime = now</span><br><span class=\"line\">\t<span class=\"comment\">// Upsert函数在GORM下的实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dao.db.WithContext(ctx).Clauses(clause.OnConflict&#123;</span><br><span class=\"line\">\t\tDoUpdates: clause.Assignments(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;title&quot;</span>:   article.Title,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;content&quot;</span>: article.Content,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;utime&quot;</span>:   article.Utime,</span><br><span class=\"line\">\t\t&#125;),</span><br><span class=\"line\">\t&#125;).Create(&amp;article).Error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>向<code>Clauses</code>函数中传递<code>OnConflict</code>结构体，表示如果发生冲突的话应该做什么事情</p>\n<p><code>OnConfilt</code>中有一些比较有用的字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DoUpdate\t\t---&gt; 做更新操作</span></span><br><span class=\"line\"><span class=\"comment\">// DoNothing\t---&gt; 什么也不做</span></span><br><span class=\"line\"><span class=\"comment\">// Where\t\t---&gt; 数据冲突了并且符合where子句，就执行更新操作</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>🌟：在一个事务中，一直都是同一个数据库连接</strong></p>\n<h2 id=\"维护状态\"><a href=\"#维护状态\" class=\"headerlink\" title=\"维护状态\"></a>维护状态</h2><p>在先前的分析中，我们知道需要有线上库和制作库两个数据存储的地方，这两个地方存储的数据本质上是一样的，因此不必创建新的领域对象来维护，<strong>使用衍生类型更加方便</strong></p>\n<h3 id=\"状态常量定义\"><a href=\"#状态常量定义\" class=\"headerlink\" title=\"状态常量定义\"></a>状态常量定义</h3><p>利用常量表示一篇帖子的不同状态，这些常量可以直接利用<code>iota</code>在<code>domain</code>中定义。<strong>一般定义常量，最好不要把零值做成有意义的值</strong>，否则难以区分是用户没有输入还是前端传递默认数据</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409270907841.png\" alt=\"image-20240927090706192\"></p>\n<h2 id=\"使用MongoDB存储\"><a href=\"#使用MongoDB存储\" class=\"headerlink\" title=\"使用MongoDB存储\"></a>使用MongoDB存储</h2><p>类似于大文本之类的东西，除了可以使用关系型数据库，也可以考虑使用其他存储应用，例如MongoDB</p>\n<p><strong>MongoDB属于NoSQL，NoSQL即Not Only SQL</strong>，不仅仅是SQL</p>\n<p>NoSQL数据库的产生是为了解决大规模数据集合、多种数据种类带来的挑战，尤其是大数据应用难题</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530245.png\" alt=\"image-20240930153021471\" style=\"zoom:50%;\" />\n\n<h3 id=\"MongoDB简介\"><a href=\"#MongoDB简介\" class=\"headerlink\" title=\"MongoDB简介\"></a>MongoDB简介</h3><p>MongoDB的基本特性</p>\n<ul>\n<li><strong>面向集合存储</strong>：MongoDB集合中可以存储多个文档<ul>\n<li>类比于MySQL，MongoDB中的一个集合就像是一张表，集合中的一个文档就相当于表中的一条记录</li>\n</ul>\n</li>\n<li><strong>模式自由</strong>：MongoDB采用无结构模式存储数据，也就是说，在储存数据之前不需要定义数据的结构<ul>\n<li>就像当于在MySQL中不需要预先建立表结构就能插入数据</li>\n</ul>\n</li>\n<li><strong>支持分片</strong>：MongoDB支持分片，并且MongoDB自动解决了分片的各种问题，包括自动化扩容</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301530677.png\" alt=\"image-20240930153009489\" style=\"zoom:67%;\" />\n\n<p>选择MongoDB的两个理由：</p>\n<ul>\n<li><p><strong>灵活的文档模型</strong>：于MySQL不同，不需要事前在MongoDB中定义文档模型，并且可以灵活修改</p>\n</li>\n<li><p><strong>易于横向扩展</strong>：可以通过增加MongoDB实例来应付流量和数据增长</p>\n</li>\n</ul>\n<h3 id=\"初始化客户端并插入文档\"><a href=\"#初始化客户端并插入文档\" class=\"headerlink\" title=\"初始化客户端并插入文档\"></a>初始化客户端并插入文档</h3><blockquote>\n<p>需要使用MongoDB官网的go-driver</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409301941675.png\" alt=\"image-20240930194117517\"></p>\n<h3 id=\"查找文档\"><a href=\"#查找文档\" class=\"headerlink\" title=\"查找文档\"></a>查找文档</h3><p>在MongoDB中有两种构造查询条件的方式：</p>\n<ul>\n<li><strong>bson</strong></li>\n<li><strong>结构体</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用bson构造查询条件</span></span><br><span class=\"line\">filter := bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;id&quot;</span>, Value: <span class=\"number\">123</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> art Article</span><br><span class=\"line\">err = col.FindOne(ctx, filter).Decode(&amp;art)</span><br><span class=\"line\">assert.NoError(t, err)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;find article %v\\n&quot;</span>, art)</span><br><span class=\"line\"><span class=\"comment\">// 使用结构体构造查询条件</span></span><br><span class=\"line\">err = col.FindOne(ctx, Article&#123;Id: <span class=\"number\">123</span>&#125;).Decode(&amp;art)</span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, mongo.ErrNoDocuments) &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;find none&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️：使用结构体构造查询条件时，mongodb-go-driver默认使用结构体的全部字段作为匹配条件，需要注意某些字段<strong>默认零值</strong>。当然，可以使用<code>bson:&quot;field_name,omitempty&quot;</code>标签来告知mongodb-go-driver忽略字段零值</p>\n<p>🌟：可以使用<code>mongo.ErrNoDocuments</code>错误值检验是否有查询到文档</p>\n<h3 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h3><ul>\n<li>构造更新条件，同构造查询条件</li>\n<li>构造更新字段<ul>\n<li><strong>bson</strong></li>\n<li><strong>结构体</strong></li>\n</ul>\n</li>\n</ul>\n<p>⚠️：同样的，需要注意<strong>底层是否会采用字段零值</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sets := bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;$set&quot;</span>,</span><br><span class=\"line\">\tValue: bson.E&#123;Key: <span class=\"string\">&quot;content&quot;</span>, Value: <span class=\"string\">&quot;serious content&quot;</span>&#125;&#125;&#125;</span><br><span class=\"line\">res, err := col.UpdateOne(ctx, filter, sets)</span><br><span class=\"line\"><span class=\"comment\">// 使用结构体构造更新字段</span></span><br><span class=\"line\">res, err = col.UpdateOne(ctx, filter, bson.D&#123;bson.E&#123;Key: <span class=\"string\">&quot;$set&quot;</span>, Value: Article&#123;</span><br><span class=\"line\">\tTitle: <span class=\"string\">&quot;new title&quot;</span>,</span><br><span class=\"line\">&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>类似于MySQL，<strong>一般是根据业务中常用的查询条件，来决定在什么列上构建索引</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">indexRes, err := col.Indexes().CreateOne(ctx, mongo.IndexModel&#123;</span><br><span class=\"line\">\tKeys:    bson.M&#123;<span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\tOptions: options.Index().SetUnique(<span class=\"literal\">true</span>),</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">fmt.Println(indexRes)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MongoDB存储数据\"><a href=\"#MongoDB存储数据\" class=\"headerlink\" title=\"MongoDB存储数据\"></a>MongoDB存储数据</h3><p>由于MongoDB中的<code>_id</code>字段不是自增并且是一个<strong>12字节</strong>的切片，因此不能直接使用这个字段作为主键</p>\n<p>主键的可选方案：</p>\n<ul>\n<li><strong>将整个id修改为string类型</strong></li>\n<li><strong>使用ID生成策略</strong>，例如<strong>雪花算法</strong><ul>\n<li><strong>1比特保留位</strong></li>\n<li><strong>41比特时间戳</strong></li>\n<li><strong>10比特机器位</strong>，一般叫做<code>Worker ID</code></li>\n<li><strong>12比特自增序号</strong></li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031541579.png\" alt=\"image-20241003154159484\"></li>\n</ul>\n</li>\n<li><strong>使用GUID</strong></li>\n<li><strong>定义一个新的接口</strong>，但这样就失去了DAO层的统一接口</li>\n</ul>\n<p><strong>⚠️：在MongoDB中，尽量使用衍生类型而不是嵌套结构体。因为嵌套结构体中子结构体的字段标签在操作过程中无法正常生效</strong></p>\n<h2 id=\"利用OSS来存储数据\"><a href=\"#利用OSS来存储数据\" class=\"headerlink\" title=\"利用OSS来存储数据\"></a>利用OSS来存储数据</h2><blockquote>\n<p>利用OSS存储线上数据，而后直接通过CDN加速访问</p>\n</blockquote>\n<p>OSS（Object Storage Service）是指兑现存储，<strong>被大量用于存储文件、流媒体、图片等</strong></p>\n<p>OSS中的两个核心概念：</p>\n<ul>\n<li><strong>Bucket</strong>：逻辑上的分组关系，例如某个业务使用一个桶，另一个业务使用另外一个桶</li>\n<li><strong>Object</strong>：对象，也就是需要存储的东西</li>\n</ul>\n<p>ACL（Access Control List）：权限控制方案</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410041010143.png\" alt=\"image-20241004101033272\"></p>\n<p>OSS通常和CDN结合在一起使用，<strong>即在OSS上存储的数据，可以通过CDN来访问</strong></p>\n<p>一种很常见的性能和可用性优化手段，就是使用<strong>OSS和CDN来存储网站的静态资源</strong>，此时OSS被当作CDN的一个回源站点</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410041013265.png\" alt=\"image-20241004101307223\"></p>\n<h2 id=\"查询接口与缓存\"><a href=\"#查询接口与缓存\" class=\"headerlink\" title=\"查询接口与缓存\"></a>查询接口与缓存</h2><p>在实现查询文章功能过程中，需要从不同用户角度出发进行思考</p>\n<ul>\n<li>对于创作者来说，需要查询自己的<strong>文章列表</strong>以及<strong>某一篇文章的详细内容</strong>，分别对应着两个接口<ul>\n<li>列表接口</li>\n<li>详情接口</li>\n</ul>\n</li>\n<li>对于读者，他能够<strong>搜索某篇文章</strong>、<strong>浏览推荐文章列表</strong>、<strong>阅读文章的具体内容</strong>。由此可见，需要提供以下接口<ul>\n<li>搜索接口</li>\n<li>推荐接口</li>\n<li>阅读文章接口</li>\n</ul>\n</li>\n</ul>\n<p>目前仅实现创作者的<strong>列表接口和详情接口</strong>，以及读者的<strong>阅读文章接口</strong></p>\n<h3 id=\"列表接口\"><a href=\"#列表接口\" class=\"headerlink\" title=\"列表接口\"></a>列表接口</h3><h4 id=\"需求分析-1\"><a href=\"#需求分析-1\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><p>参考掘金的列表展示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061411490.png\" alt=\"image-20241006141112588\"></p>\n<p>可以发现，在列表中展示的文章对象有如下特征：</p>\n<ul>\n<li>标题</li>\n<li>创建时间</li>\n<li>简介</li>\n<li>…</li>\n</ul>\n<p>根据这些特征我们就能定义出与前端相对应的<code>ArticleVO</code></p>\n<p>另一个值得注意的点是，<strong>掘金在列表中展示的文章只有一小部分，当页面下滑时才会加载更多的文章</strong>，这就相当于一个<strong>分页查询</strong>操作</p>\n<h4 id=\"分页形态\"><a href=\"#分页形态\" class=\"headerlink\" title=\"分页形态\"></a>分页形态</h4><p><strong>分页的核心目标就是避免一次操作太多数据，引发性能问题</strong>。况且，列表页在展示的时候，也不许那么多的内容😏</p>\n<p>分页接口一般有三种定义形式：</p>\n<ul>\n<li><strong>直接定义<code>Offset</code>和<code>Limit</code>字段</strong></li>\n<li><strong>直接定义一个<code>Page</code>字段，并约定好Page的大小</strong></li>\n<li><strong>直接定义一个<code>Cursor</code>字段</strong></li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061421861.png\" alt=\"image-20241006142108823\" style=\"zoom: 50%;\" />\n\n<h3 id=\"缓存设计\"><a href=\"#缓存设计\" class=\"headerlink\" title=\"缓存设计\"></a>缓存设计</h3><blockquote>\n<p>缓存第一页分页</p>\n</blockquote>\n<p>大部分情况下，不会对分页结果进行缓存，<strong>因为如果数据的筛选条件、排序条件、分页条件、分页的偏移量和数据量中的任何一个发生了变化，缓存就很难使用了</strong></p>\n<p>但可以只<strong>缓存第一页</strong>，毕竟大部分用户只看列表的第一页</p>\n<p>有了缓存之后，<strong>每次进行更新操作都要将缓存删除，防止缓存不一致问题</strong></p>\n<blockquote>\n<p>业务相关的预加载</p>\n</blockquote>\n<p><strong>预加载本质上就是预判用户将要读取的内容，提前将内容存入缓存中</strong></p>\n<p>而且，因为是预测性质的，所以过期时间设置得很短</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410061512142.png\" alt=\"image-20241006151243081\"></p>\n<blockquote>\n<p>不缓存大文档（调优😂）</p>\n</blockquote>\n<p>可以考虑在Redis内存消耗和缓存性能之间做一个权衡</p>\n<p>也就是说，并不是所有的值都需要缓存，<strong>有一些很占用内存空间的文章就不必缓存</strong></p>\n<h4 id=\"缓存过期时间\"><a href=\"#缓存过期时间\" class=\"headerlink\" title=\"缓存过期时间\"></a>缓存过期时间</h4><p>缓存的过期时间和缓存命中率有关，一般情况下，<strong>过期时间越长，命中率越高，但数据一致性会变差；过期时间越短，命中率越低，但数据一致性会更好</strong></p>\n<ul>\n<li>业务相关的缓存预加载，过期时间要短</li>\n<li>根据用户身份按权给予不同的缓存时间</li>\n</ul>\n<h4 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h4><p>淘汰策略是指在缓存内存不够用的情况下，淘汰某一部分数据时的计划</p>\n<p>常规方案就是<strong>LRU和LFU</strong></p>\n<p>还有一些方案：</p>\n<ul>\n<li>优先淘汰普通创作者的数据，留下大v的数据</li>\n<li>优先淘汰大对象，释放出更多的内存空间</li>\n<li>优先淘汰小对象，相比于大对象，小对象在从数据库（或OSS）中获取更加迅速</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>使用<code>wrapbodyandtoken</code>统一处理Body和Token中的数据</li>\n<li>考虑到中文字符由多个字节组成，在处理包含中文的字符串时，应实现将其转为<code>[]rune</code>再进行<code>len()</code>操作</li>\n<li>需要将存储对象转换为<code>json</code>格式后才能存入Redis中，否则会报错</li>\n</ul>\n"},{"description":"记录定时微服务项目","_content":"\n# 定时微服务\n\n## 前置准备\n\n### 背景和现状\n\n市面上已有的定时微服务技术：Java Timer、Rocket MQ、xxl-job、Quartz、Robfig/Cron\n\n- 很多公司的业务只需要一个简单的“定时”功能。为了满足一个简单定时功能而引入过于强大而且臃肿的任务调度组件是不合适的\n- 设计一个**功能聚焦、轻量级、维护成本低**的定时微服务组件是很有必要的\n\n**定时微服务LyyTimer**\n\n1. 依赖简单：只需要提供MySQL、Redis和Kafka组件的支持即可，接入和维护的成本低\n2. 学习成本低：整个定时微服务功能聚焦，容易上手\n3. 特性优：LyyTimer具有高精准、高负载、异常处理等特性，能基本满足大部分的定时需求\n\n### 难点\n\n#### **高精准**\n\n相对于单点定时（例如Java.Timer）基本能做到毫秒级触发，几乎所有定时任务框架或者消息队列，都只能保证秒级别误差\n\n常见导致时间误差大的原因：\n\n- 定时脚本运行耗时\n- 等待定时脚本运行\n- 消息队列中消息堆积\n- 分布式定时器延时受网络影响\n- 数据库中查找任务数据耗时\n- 特殊时间段任务过多\n\n#### **高负载**\n\n能够支持同时处理大量任务，并且尽可能少的堆积任务\n\n高负载解决思路和方法：\n\n- 应用层方面减少任务量，选择将同一时刻的多个独立任务合并成一个“计划列表”\n- 分库分表：将一个大型数据库分成多个较小的数据库，并将每个数据库进一步分成多个较小的表，每个表只包含部分数据\n  - 垂直分表：保持列完整\n  - 水平分表：只保留部分列\n  - 分库分表组合\n- 数据分区：将大数据拆分成多个小数据分区，将这些小分区存储在不同的物理设备或服务器上，提供数据的存取效率和处理速度\n- 线程池技术\n  - 复用线程，降低了资源消耗\n  - 高效地管理多个线程\n\n#### **任务异常处理**\n\n>  定时任务需求可以允许有一定的误差，但是不能不触发\n\n**任务异常的原因：**\n\n- 创建（激活）任务接口异常：在创建任务阶段发生异常，系统可以直接将异常原因返回给用户。用户感知到异常后，可通过主动重试解决问题，即该阶段的异常不应该由框架解决\n\n- 任务流转异常：一旦任务成功存储在数据库中，就认为该定时任务创建成功，微服务框架就要负责该任务后续的流转（查询数据库、发送消息队列、缓存等）。因此，框架需要解决任务流转过程中发生的异常\n- 任务触发阶段异常：当任务执行后，系统需要回调告知业务方任务结果。对于业务方来说，如果回调失败导致结果丢失，就相当于该任务没有执行过\n\n\n\n**常用的解决方案**\n\n- **（立即）重试机制**：可以应付一些偶发性异常，例如数据库抖动、Redis抖动\n- **失败兜底机制**：一般来说，兜底策略都是采用一些“无脑”脚本，全表扫描数据库，针对失败记录进行重试操作。但是兜底策略一般在性能上不占优势，所以需要选择合适的时间间隔执行兜底脚本\n- **失败报警机制**：当短时间内有大量任务失败时，需要及时报警\n- **人工干预**\n\n## 架构设计\n\n### 实现思路\n\n**定时器本质实现思路：查询 + 触发**，以及暴露给用户一个**注册任务**接口\n\n- **注册**定时器：接受用户的创建请求，明确每一个任务的**执行时间**\n- **查询**数据库：每隔一段时间间隔就**查询**任务列表，筛选出未触发的任务\n- **触发**任务：触发**执行时间小于当前时间（时刻）**的任务\n\n#### 存储结构优化：有序表\n\n**基于有序数据结构，加快数据查询**\n\n常见的有序数据结构：红黑树、跳表、平衡树等，这些数据结构通过在插入操作均摊查询操作的时间复杂度实现**查询时间复杂度$$O(N) ---> O(logN)$$**的优化\n\n#### 存储结构优化：横向切片\n\n**根据时间区间对数据分片，减少查询时涉及的数据数量**\n\n每次查询数据的时候，真正的目标是**即将执行**的任务，而**稍后执行**的任务属于无关任务。基于这个理念，我们可以将数据进行横向切分，例如每一分钟划分一个数据切片，然后从包含目标数据的数据切片中查询数据\n\n这种做法可以将大大降低每一次查询的任务数量级：N ---> N'，其中N' << N，即使没有改变查询的时间复杂度，但减少了查询时涉及的数据数量\n\n#### 存储结构优化：纵向切片\n\n**对数据分区进行分桶，提高数据操作的并发度**\n\n截止到上一步，时间数据分区是定时器中的最小资源单位，每一个数据分区都由一个goroutine（或线程）控制。为了提高数据操作的并发度，可以对分区中的数据进一步**分桶**，把每一个桶交付给一个goroutine（或线程）处理，在纵向增加分桶的维度，提高并发度\n\n> 总结：依然是“查询 + 触发”的定时器机制，只不过相较于丐版定时器有如下变化：每次查询都只查询一个（当前）时间范围内的数据，这些数据由ZSet数据结构存储。接着基于并发的考虑，令多个goroutine负责从分区中的多个桶中查询数据，最后将触发获取到的任务。\n\n### 整体架构\n\n#### 定时任务调度流程\n\n任务调度流程**服务架构：三个模块 + 两个协程池**\n\nLyyTimer是一个**去中心化的定时任务调度框架**，定时任务调度服务根据职责边界可以将服务拆分为：**调度器模块**、**触发器模块**、**执行模块**，这三个模块存在着依赖关系。父模块通过协程池异步启动子模块执行相应工作\n\n![image-20241125183915443](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251841204.png)\n\n#### 定时任务生成流程\n\n**定时任务的创建设计到Web Server和Migrator Scheduler两个模块**\n\n- 用户通过Web Server提供的API创建定时任务\n- Migrator Scheduler定时根据cron表达式预热定时任务数据\n\n![image-20241125185145008](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251851062.png)\n\n> 为什么需要两种方式预热数据？\n>\n> 为了确保在定时脚本执行间隔内创建的任务生效。例如，定时脚本每两小时执行一次，每一次执行都会预热两小时后的数据。第一次定时脚本执行时刻是18:58，创建了18:58-20:58定时任务。倘若有用户在19:00想要创建一个19:58分的定时任务，那么只依靠定时脚本是无法实现的，因为下一次定时脚本的执行时间是20:58。综上所诉，仅仅有定时脚本是有缺陷的，还需要一个Web Server模块完成任务的第一次创建，确保用户在任何时候创建的任务都能生效。\n\n### 调度流程模块化\n\n#### 调度器模块\n\n**确定二维数据分区目标对象，统筹分配触发器**\n\n调度器的作用就是要确保在分布式场景下，每一个二维数据分区都能被一个触发器负责处理，既不能遗漏，也不能重复\n\n- 调度器基于time ticker每秒钟进行一次工作，根据当前时刻推算出**分钟级别**的字符串表达式\n- 根据配置中最大桶数量，依次拼接分钟Key值得到若干个二维数据分区的Key值。例如`20:47:39_0`、`20:48:11_1`\n- 尝试抢占数据分区的分布式锁，并把锁的过期时间设置为**大于1倍分片时间，小于2倍分片时间**\n- 如果抢锁成功，就调度一个触发器进行作业\n\n#### 触发器模块\n\n**按时唤醒二维数据分区中的定时任务**\n\n- 触发器被创建后，每秒对负责的数据分区进行扫描，以当前时刻为基准，将符合条件的定时任务取出并交付给执行器执行\n- 当触发器协程完成任务后，需要将分布式锁的过期时间延期至**大于两个分区时间**\n\n> 为什么要对分布式锁进行延期？\n>\n> 回答这个问题之前，需要补充的一点：为了对前一分钟的数据分区执行失败做兜底，每次触发器对当前分区进行扫描时都会对前一分钟的数据分区进行重试扫描。\n>\n> 因此，如果前一个数据分区的任务执行失败，那么该分区的分布式锁无法得到延时，必然会在当前分钟内再次获得进而进行重试操作。反之，分布式锁得到了延时，那么当前分钟内就不会重复执行已成功执行的任务。\n>\n> 也正是出于这个机制考虑，延迟的时间必须大于两个分区时间\n\n问题在于很难实现百分百的分布式事务，即无法保证**完成分区任务 + 延迟分布式锁**操作是原子的，因此这里只能是**At least once**语义。\n\n#### 执行器模块\n\n**执行定时任务**\n\n- 一个执行器由触发器调度，对应一个具体的定时任务\n- 执行器首先对定时任务进行幂等检查\n- 执行任务\n- 更新定时任务的状态\n\n### 任务迁移模块化\n\nLyyTimer项目使用MySQL + Redis二级存储模型，并设置了一个Migrator根据时间由近及远**通过处于激活状态的定时器（cron表达式）生成一系列定时任务**，并迁移同步至两个存储介质中\n\n#### Migrator模块\n\n- 每隔一段时间步长就扫描所有的定时器，根据处于激活状态的定时器生成未来两个时间步长的定时任务（本质上就一个时间步长，都是为了失败兜底😂）\n  - 例如，每隔一小时就进行一次全表扫描，若14:45:34对所有的定时器进行一次扫描，迁移模块就会生成14:45:34 - 16:45:34这两个小时的定时任务并迁移至MySQL和Redis中。但14:45:34 - 15:45:34这个时间段的任务已经在13:45:34被Migrator模块生成并存储了，所以本质上迁移模块只生成了一小时的任务。重复的任务将会由于唯一约束而插入失败，所以不必担心任务重复插入\n\n##### 串行打点还是批量打点？\n\n串行打点就是指每次根据cron表达式**只生成最近的一次**定时任务，然后在执行器执行完这个任务后就立马生成下一次的定时任务，如此循环。\n\n串行打点比较节约资源，可以缓解生成任务过多导致的短时间内资源浪费问题，但是针对于短间隔高频执行的定时器（例如：1s执行一次）就有些力不从心了。\n\n**优化方案：批量打点**\n\n每隔一段时间程序就根据cron表达式生成一个时间步长的任务，这样可以有效解决短间隔高频率的任务生成问题。但如果用户对定时器进行频繁的修改，那为了保证数据一致性，就需要引入删除、修改已生成任务等复杂操作。为了规避这种情况，我们可以要求用户无法对已有的定时器进行修改，只允许**激活**和**去激活**两种操作\n\n此外，即使用户**去激活**某一个定时器，我们也无需修改已有的任务，只需要在回调之前检查定时器状态是否合法即可。\n\n## 存储结构设计\n\n**定时器表**\n\n| 字段              | 类型          | 说明                            |\n| ----------------- | ------------- | ------------------------------- |\n| timer_id          | bigint        | 自增主键ID（或有序UUID）        |\n| ctime             | bigint        | 创建时间（避免时区问题）        |\n| utime             | bigint        | 修改时间                        |\n| app               | varchar(128)  | 业务方标识                      |\n| name              | varchar(256)  | 任务名                          |\n| status            | tinyint       | 任务状态：0新建、1激活、2未激活 |\n| cron              | varchar(256)  | cron表达式，用于生成定时任务    |\n| notify_http_param | varchar(8192) | 回调上下文                      |\n\n**定时任务表**\n\n| 字段      | 类型         | 说明                            |\n| --------- | ------------ | ------------------------------- |\n| task_id   | bigint       | 自增主键ID                      |\n| ctime     | bigint       | 创建时间                        |\n| utime     | bigint       | 修改时间                        |\n| timer_id  | bigint       | 对应的定时器ID                  |\n| app       | varchar(128) | 业务方标识                      |\n| output    | var(1024)    | 执行结果                        |\n| status    | tinyint      | 任务状态：0待执行、1成功、2失败 |\n| run_timer | bigint       | 开始运行时间                    |\n| cost_time | bigint       | 误差时间                        |\n\n**单个分片结构**：\n\nKey：时间 + bucket编号 = “2024121115:54:51_01”\n\nMember：timerId + unix当前时间戳\n\nScore：unix当前时间戳\n\n\n\n一个可能的优化点：\n\n在任务状态上建立索引  ----->  存在**数据倾斜**\n","source":"_posts/定时微服务.md","raw":"---\ndescription: 记录定时微服务项目\ntag: 项目\n---\n\n# 定时微服务\n\n## 前置准备\n\n### 背景和现状\n\n市面上已有的定时微服务技术：Java Timer、Rocket MQ、xxl-job、Quartz、Robfig/Cron\n\n- 很多公司的业务只需要一个简单的“定时”功能。为了满足一个简单定时功能而引入过于强大而且臃肿的任务调度组件是不合适的\n- 设计一个**功能聚焦、轻量级、维护成本低**的定时微服务组件是很有必要的\n\n**定时微服务LyyTimer**\n\n1. 依赖简单：只需要提供MySQL、Redis和Kafka组件的支持即可，接入和维护的成本低\n2. 学习成本低：整个定时微服务功能聚焦，容易上手\n3. 特性优：LyyTimer具有高精准、高负载、异常处理等特性，能基本满足大部分的定时需求\n\n### 难点\n\n#### **高精准**\n\n相对于单点定时（例如Java.Timer）基本能做到毫秒级触发，几乎所有定时任务框架或者消息队列，都只能保证秒级别误差\n\n常见导致时间误差大的原因：\n\n- 定时脚本运行耗时\n- 等待定时脚本运行\n- 消息队列中消息堆积\n- 分布式定时器延时受网络影响\n- 数据库中查找任务数据耗时\n- 特殊时间段任务过多\n\n#### **高负载**\n\n能够支持同时处理大量任务，并且尽可能少的堆积任务\n\n高负载解决思路和方法：\n\n- 应用层方面减少任务量，选择将同一时刻的多个独立任务合并成一个“计划列表”\n- 分库分表：将一个大型数据库分成多个较小的数据库，并将每个数据库进一步分成多个较小的表，每个表只包含部分数据\n  - 垂直分表：保持列完整\n  - 水平分表：只保留部分列\n  - 分库分表组合\n- 数据分区：将大数据拆分成多个小数据分区，将这些小分区存储在不同的物理设备或服务器上，提供数据的存取效率和处理速度\n- 线程池技术\n  - 复用线程，降低了资源消耗\n  - 高效地管理多个线程\n\n#### **任务异常处理**\n\n>  定时任务需求可以允许有一定的误差，但是不能不触发\n\n**任务异常的原因：**\n\n- 创建（激活）任务接口异常：在创建任务阶段发生异常，系统可以直接将异常原因返回给用户。用户感知到异常后，可通过主动重试解决问题，即该阶段的异常不应该由框架解决\n\n- 任务流转异常：一旦任务成功存储在数据库中，就认为该定时任务创建成功，微服务框架就要负责该任务后续的流转（查询数据库、发送消息队列、缓存等）。因此，框架需要解决任务流转过程中发生的异常\n- 任务触发阶段异常：当任务执行后，系统需要回调告知业务方任务结果。对于业务方来说，如果回调失败导致结果丢失，就相当于该任务没有执行过\n\n\n\n**常用的解决方案**\n\n- **（立即）重试机制**：可以应付一些偶发性异常，例如数据库抖动、Redis抖动\n- **失败兜底机制**：一般来说，兜底策略都是采用一些“无脑”脚本，全表扫描数据库，针对失败记录进行重试操作。但是兜底策略一般在性能上不占优势，所以需要选择合适的时间间隔执行兜底脚本\n- **失败报警机制**：当短时间内有大量任务失败时，需要及时报警\n- **人工干预**\n\n## 架构设计\n\n### 实现思路\n\n**定时器本质实现思路：查询 + 触发**，以及暴露给用户一个**注册任务**接口\n\n- **注册**定时器：接受用户的创建请求，明确每一个任务的**执行时间**\n- **查询**数据库：每隔一段时间间隔就**查询**任务列表，筛选出未触发的任务\n- **触发**任务：触发**执行时间小于当前时间（时刻）**的任务\n\n#### 存储结构优化：有序表\n\n**基于有序数据结构，加快数据查询**\n\n常见的有序数据结构：红黑树、跳表、平衡树等，这些数据结构通过在插入操作均摊查询操作的时间复杂度实现**查询时间复杂度$$O(N) ---> O(logN)$$**的优化\n\n#### 存储结构优化：横向切片\n\n**根据时间区间对数据分片，减少查询时涉及的数据数量**\n\n每次查询数据的时候，真正的目标是**即将执行**的任务，而**稍后执行**的任务属于无关任务。基于这个理念，我们可以将数据进行横向切分，例如每一分钟划分一个数据切片，然后从包含目标数据的数据切片中查询数据\n\n这种做法可以将大大降低每一次查询的任务数量级：N ---> N'，其中N' << N，即使没有改变查询的时间复杂度，但减少了查询时涉及的数据数量\n\n#### 存储结构优化：纵向切片\n\n**对数据分区进行分桶，提高数据操作的并发度**\n\n截止到上一步，时间数据分区是定时器中的最小资源单位，每一个数据分区都由一个goroutine（或线程）控制。为了提高数据操作的并发度，可以对分区中的数据进一步**分桶**，把每一个桶交付给一个goroutine（或线程）处理，在纵向增加分桶的维度，提高并发度\n\n> 总结：依然是“查询 + 触发”的定时器机制，只不过相较于丐版定时器有如下变化：每次查询都只查询一个（当前）时间范围内的数据，这些数据由ZSet数据结构存储。接着基于并发的考虑，令多个goroutine负责从分区中的多个桶中查询数据，最后将触发获取到的任务。\n\n### 整体架构\n\n#### 定时任务调度流程\n\n任务调度流程**服务架构：三个模块 + 两个协程池**\n\nLyyTimer是一个**去中心化的定时任务调度框架**，定时任务调度服务根据职责边界可以将服务拆分为：**调度器模块**、**触发器模块**、**执行模块**，这三个模块存在着依赖关系。父模块通过协程池异步启动子模块执行相应工作\n\n![image-20241125183915443](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251841204.png)\n\n#### 定时任务生成流程\n\n**定时任务的创建设计到Web Server和Migrator Scheduler两个模块**\n\n- 用户通过Web Server提供的API创建定时任务\n- Migrator Scheduler定时根据cron表达式预热定时任务数据\n\n![image-20241125185145008](https://raw.githubusercontent.com/lyydsheep/pic/main/202411251851062.png)\n\n> 为什么需要两种方式预热数据？\n>\n> 为了确保在定时脚本执行间隔内创建的任务生效。例如，定时脚本每两小时执行一次，每一次执行都会预热两小时后的数据。第一次定时脚本执行时刻是18:58，创建了18:58-20:58定时任务。倘若有用户在19:00想要创建一个19:58分的定时任务，那么只依靠定时脚本是无法实现的，因为下一次定时脚本的执行时间是20:58。综上所诉，仅仅有定时脚本是有缺陷的，还需要一个Web Server模块完成任务的第一次创建，确保用户在任何时候创建的任务都能生效。\n\n### 调度流程模块化\n\n#### 调度器模块\n\n**确定二维数据分区目标对象，统筹分配触发器**\n\n调度器的作用就是要确保在分布式场景下，每一个二维数据分区都能被一个触发器负责处理，既不能遗漏，也不能重复\n\n- 调度器基于time ticker每秒钟进行一次工作，根据当前时刻推算出**分钟级别**的字符串表达式\n- 根据配置中最大桶数量，依次拼接分钟Key值得到若干个二维数据分区的Key值。例如`20:47:39_0`、`20:48:11_1`\n- 尝试抢占数据分区的分布式锁，并把锁的过期时间设置为**大于1倍分片时间，小于2倍分片时间**\n- 如果抢锁成功，就调度一个触发器进行作业\n\n#### 触发器模块\n\n**按时唤醒二维数据分区中的定时任务**\n\n- 触发器被创建后，每秒对负责的数据分区进行扫描，以当前时刻为基准，将符合条件的定时任务取出并交付给执行器执行\n- 当触发器协程完成任务后，需要将分布式锁的过期时间延期至**大于两个分区时间**\n\n> 为什么要对分布式锁进行延期？\n>\n> 回答这个问题之前，需要补充的一点：为了对前一分钟的数据分区执行失败做兜底，每次触发器对当前分区进行扫描时都会对前一分钟的数据分区进行重试扫描。\n>\n> 因此，如果前一个数据分区的任务执行失败，那么该分区的分布式锁无法得到延时，必然会在当前分钟内再次获得进而进行重试操作。反之，分布式锁得到了延时，那么当前分钟内就不会重复执行已成功执行的任务。\n>\n> 也正是出于这个机制考虑，延迟的时间必须大于两个分区时间\n\n问题在于很难实现百分百的分布式事务，即无法保证**完成分区任务 + 延迟分布式锁**操作是原子的，因此这里只能是**At least once**语义。\n\n#### 执行器模块\n\n**执行定时任务**\n\n- 一个执行器由触发器调度，对应一个具体的定时任务\n- 执行器首先对定时任务进行幂等检查\n- 执行任务\n- 更新定时任务的状态\n\n### 任务迁移模块化\n\nLyyTimer项目使用MySQL + Redis二级存储模型，并设置了一个Migrator根据时间由近及远**通过处于激活状态的定时器（cron表达式）生成一系列定时任务**，并迁移同步至两个存储介质中\n\n#### Migrator模块\n\n- 每隔一段时间步长就扫描所有的定时器，根据处于激活状态的定时器生成未来两个时间步长的定时任务（本质上就一个时间步长，都是为了失败兜底😂）\n  - 例如，每隔一小时就进行一次全表扫描，若14:45:34对所有的定时器进行一次扫描，迁移模块就会生成14:45:34 - 16:45:34这两个小时的定时任务并迁移至MySQL和Redis中。但14:45:34 - 15:45:34这个时间段的任务已经在13:45:34被Migrator模块生成并存储了，所以本质上迁移模块只生成了一小时的任务。重复的任务将会由于唯一约束而插入失败，所以不必担心任务重复插入\n\n##### 串行打点还是批量打点？\n\n串行打点就是指每次根据cron表达式**只生成最近的一次**定时任务，然后在执行器执行完这个任务后就立马生成下一次的定时任务，如此循环。\n\n串行打点比较节约资源，可以缓解生成任务过多导致的短时间内资源浪费问题，但是针对于短间隔高频执行的定时器（例如：1s执行一次）就有些力不从心了。\n\n**优化方案：批量打点**\n\n每隔一段时间程序就根据cron表达式生成一个时间步长的任务，这样可以有效解决短间隔高频率的任务生成问题。但如果用户对定时器进行频繁的修改，那为了保证数据一致性，就需要引入删除、修改已生成任务等复杂操作。为了规避这种情况，我们可以要求用户无法对已有的定时器进行修改，只允许**激活**和**去激活**两种操作\n\n此外，即使用户**去激活**某一个定时器，我们也无需修改已有的任务，只需要在回调之前检查定时器状态是否合法即可。\n\n## 存储结构设计\n\n**定时器表**\n\n| 字段              | 类型          | 说明                            |\n| ----------------- | ------------- | ------------------------------- |\n| timer_id          | bigint        | 自增主键ID（或有序UUID）        |\n| ctime             | bigint        | 创建时间（避免时区问题）        |\n| utime             | bigint        | 修改时间                        |\n| app               | varchar(128)  | 业务方标识                      |\n| name              | varchar(256)  | 任务名                          |\n| status            | tinyint       | 任务状态：0新建、1激活、2未激活 |\n| cron              | varchar(256)  | cron表达式，用于生成定时任务    |\n| notify_http_param | varchar(8192) | 回调上下文                      |\n\n**定时任务表**\n\n| 字段      | 类型         | 说明                            |\n| --------- | ------------ | ------------------------------- |\n| task_id   | bigint       | 自增主键ID                      |\n| ctime     | bigint       | 创建时间                        |\n| utime     | bigint       | 修改时间                        |\n| timer_id  | bigint       | 对应的定时器ID                  |\n| app       | varchar(128) | 业务方标识                      |\n| output    | var(1024)    | 执行结果                        |\n| status    | tinyint      | 任务状态：0待执行、1成功、2失败 |\n| run_timer | bigint       | 开始运行时间                    |\n| cost_time | bigint       | 误差时间                        |\n\n**单个分片结构**：\n\nKey：时间 + bucket编号 = “2024121115:54:51_01”\n\nMember：timerId + unix当前时间戳\n\nScore：unix当前时间戳\n\n\n\n一个可能的优化点：\n\n在任务状态上建立索引  ----->  存在**数据倾斜**\n","slug":"定时微服务","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j000ya5t249oj8dxi","content":"<h1 id=\"定时微服务\"><a href=\"#定时微服务\" class=\"headerlink\" title=\"定时微服务\"></a>定时微服务</h1><h2 id=\"前置准备\"><a href=\"#前置准备\" class=\"headerlink\" title=\"前置准备\"></a>前置准备</h2><h3 id=\"背景和现状\"><a href=\"#背景和现状\" class=\"headerlink\" title=\"背景和现状\"></a>背景和现状</h3><p>市面上已有的定时微服务技术：Java Timer、Rocket MQ、xxl-job、Quartz、Robfig&#x2F;Cron</p>\n<ul>\n<li>很多公司的业务只需要一个简单的“定时”功能。为了满足一个简单定时功能而引入过于强大而且臃肿的任务调度组件是不合适的</li>\n<li>设计一个<strong>功能聚焦、轻量级、维护成本低</strong>的定时微服务组件是很有必要的</li>\n</ul>\n<p><strong>定时微服务LyyTimer</strong></p>\n<ol>\n<li>依赖简单：只需要提供MySQL、Redis和Kafka组件的支持即可，接入和维护的成本低</li>\n<li>学习成本低：整个定时微服务功能聚焦，容易上手</li>\n<li>特性优：LyyTimer具有高精准、高负载、异常处理等特性，能基本满足大部分的定时需求</li>\n</ol>\n<h3 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h3><h4 id=\"高精准\"><a href=\"#高精准\" class=\"headerlink\" title=\"高精准\"></a><strong>高精准</strong></h4><p>相对于单点定时（例如Java.Timer）基本能做到毫秒级触发，几乎所有定时任务框架或者消息队列，都只能保证秒级别误差</p>\n<p>常见导致时间误差大的原因：</p>\n<ul>\n<li>定时脚本运行耗时</li>\n<li>等待定时脚本运行</li>\n<li>消息队列中消息堆积</li>\n<li>分布式定时器延时受网络影响</li>\n<li>数据库中查找任务数据耗时</li>\n<li>特殊时间段任务过多</li>\n</ul>\n<h4 id=\"高负载\"><a href=\"#高负载\" class=\"headerlink\" title=\"高负载\"></a><strong>高负载</strong></h4><p>能够支持同时处理大量任务，并且尽可能少的堆积任务</p>\n<p>高负载解决思路和方法：</p>\n<ul>\n<li>应用层方面减少任务量，选择将同一时刻的多个独立任务合并成一个“计划列表”</li>\n<li>分库分表：将一个大型数据库分成多个较小的数据库，并将每个数据库进一步分成多个较小的表，每个表只包含部分数据<ul>\n<li>垂直分表：保持列完整</li>\n<li>水平分表：只保留部分列</li>\n<li>分库分表组合</li>\n</ul>\n</li>\n<li>数据分区：将大数据拆分成多个小数据分区，将这些小分区存储在不同的物理设备或服务器上，提供数据的存取效率和处理速度</li>\n<li>线程池技术<ul>\n<li>复用线程，降低了资源消耗</li>\n<li>高效地管理多个线程</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"任务异常处理\"><a href=\"#任务异常处理\" class=\"headerlink\" title=\"任务异常处理\"></a><strong>任务异常处理</strong></h4><blockquote>\n<p> 定时任务需求可以允许有一定的误差，但是不能不触发</p>\n</blockquote>\n<p><strong>任务异常的原因：</strong></p>\n<ul>\n<li><p>创建（激活）任务接口异常：在创建任务阶段发生异常，系统可以直接将异常原因返回给用户。用户感知到异常后，可通过主动重试解决问题，即该阶段的异常不应该由框架解决</p>\n</li>\n<li><p>任务流转异常：一旦任务成功存储在数据库中，就认为该定时任务创建成功，微服务框架就要负责该任务后续的流转（查询数据库、发送消息队列、缓存等）。因此，框架需要解决任务流转过程中发生的异常</p>\n</li>\n<li><p>任务触发阶段异常：当任务执行后，系统需要回调告知业务方任务结果。对于业务方来说，如果回调失败导致结果丢失，就相当于该任务没有执行过</p>\n</li>\n</ul>\n<p><strong>常用的解决方案</strong></p>\n<ul>\n<li><strong>（立即）重试机制</strong>：可以应付一些偶发性异常，例如数据库抖动、Redis抖动</li>\n<li><strong>失败兜底机制</strong>：一般来说，兜底策略都是采用一些“无脑”脚本，全表扫描数据库，针对失败记录进行重试操作。但是兜底策略一般在性能上不占优势，所以需要选择合适的时间间隔执行兜底脚本</li>\n<li><strong>失败报警机制</strong>：当短时间内有大量任务失败时，需要及时报警</li>\n<li><strong>人工干预</strong></li>\n</ul>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p><strong>定时器本质实现思路：查询 + 触发</strong>，以及暴露给用户一个<strong>注册任务</strong>接口</p>\n<ul>\n<li><strong>注册</strong>定时器：接受用户的创建请求，明确每一个任务的<strong>执行时间</strong></li>\n<li><strong>查询</strong>数据库：每隔一段时间间隔就<strong>查询</strong>任务列表，筛选出未触发的任务</li>\n<li><strong>触发</strong>任务：触发<strong>执行时间小于当前时间（时刻）</strong>的任务</li>\n</ul>\n<h4 id=\"存储结构优化：有序表\"><a href=\"#存储结构优化：有序表\" class=\"headerlink\" title=\"存储结构优化：有序表\"></a>存储结构优化：有序表</h4><p><strong>基于有序数据结构，加快数据查询</strong></p>\n<p>常见的有序数据结构：红黑树、跳表、平衡树等，这些数据结构通过在插入操作均摊查询操作的时间复杂度实现**查询时间复杂度$$O(N) —&gt; O(logN)$$**的优化</p>\n<h4 id=\"存储结构优化：横向切片\"><a href=\"#存储结构优化：横向切片\" class=\"headerlink\" title=\"存储结构优化：横向切片\"></a>存储结构优化：横向切片</h4><p><strong>根据时间区间对数据分片，减少查询时涉及的数据数量</strong></p>\n<p>每次查询数据的时候，真正的目标是<strong>即将执行</strong>的任务，而<strong>稍后执行</strong>的任务属于无关任务。基于这个理念，我们可以将数据进行横向切分，例如每一分钟划分一个数据切片，然后从包含目标数据的数据切片中查询数据</p>\n<p>这种做法可以将大大降低每一次查询的任务数量级：N —&gt; N’，其中N’ &lt;&lt; N，即使没有改变查询的时间复杂度，但减少了查询时涉及的数据数量</p>\n<h4 id=\"存储结构优化：纵向切片\"><a href=\"#存储结构优化：纵向切片\" class=\"headerlink\" title=\"存储结构优化：纵向切片\"></a>存储结构优化：纵向切片</h4><p><strong>对数据分区进行分桶，提高数据操作的并发度</strong></p>\n<p>截止到上一步，时间数据分区是定时器中的最小资源单位，每一个数据分区都由一个goroutine（或线程）控制。为了提高数据操作的并发度，可以对分区中的数据进一步<strong>分桶</strong>，把每一个桶交付给一个goroutine（或线程）处理，在纵向增加分桶的维度，提高并发度</p>\n<blockquote>\n<p>总结：依然是“查询 + 触发”的定时器机制，只不过相较于丐版定时器有如下变化：每次查询都只查询一个（当前）时间范围内的数据，这些数据由ZSet数据结构存储。接着基于并发的考虑，令多个goroutine负责从分区中的多个桶中查询数据，最后将触发获取到的任务。</p>\n</blockquote>\n<h3 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h3><h4 id=\"定时任务调度流程\"><a href=\"#定时任务调度流程\" class=\"headerlink\" title=\"定时任务调度流程\"></a>定时任务调度流程</h4><p>任务调度流程<strong>服务架构：三个模块 + 两个协程池</strong></p>\n<p>LyyTimer是一个<strong>去中心化的定时任务调度框架</strong>，定时任务调度服务根据职责边界可以将服务拆分为：<strong>调度器模块</strong>、<strong>触发器模块</strong>、<strong>执行模块</strong>，这三个模块存在着依赖关系。父模块通过协程池异步启动子模块执行相应工作</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251841204.png\" alt=\"image-20241125183915443\"></p>\n<h4 id=\"定时任务生成流程\"><a href=\"#定时任务生成流程\" class=\"headerlink\" title=\"定时任务生成流程\"></a>定时任务生成流程</h4><p><strong>定时任务的创建设计到Web Server和Migrator Scheduler两个模块</strong></p>\n<ul>\n<li>用户通过Web Server提供的API创建定时任务</li>\n<li>Migrator Scheduler定时根据cron表达式预热定时任务数据</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251851062.png\" alt=\"image-20241125185145008\"></p>\n<blockquote>\n<p>为什么需要两种方式预热数据？</p>\n<p>为了确保在定时脚本执行间隔内创建的任务生效。例如，定时脚本每两小时执行一次，每一次执行都会预热两小时后的数据。第一次定时脚本执行时刻是18:58，创建了18:58-20:58定时任务。倘若有用户在19:00想要创建一个19:58分的定时任务，那么只依靠定时脚本是无法实现的，因为下一次定时脚本的执行时间是20:58。综上所诉，仅仅有定时脚本是有缺陷的，还需要一个Web Server模块完成任务的第一次创建，确保用户在任何时候创建的任务都能生效。</p>\n</blockquote>\n<h3 id=\"调度流程模块化\"><a href=\"#调度流程模块化\" class=\"headerlink\" title=\"调度流程模块化\"></a>调度流程模块化</h3><h4 id=\"调度器模块\"><a href=\"#调度器模块\" class=\"headerlink\" title=\"调度器模块\"></a>调度器模块</h4><p><strong>确定二维数据分区目标对象，统筹分配触发器</strong></p>\n<p>调度器的作用就是要确保在分布式场景下，每一个二维数据分区都能被一个触发器负责处理，既不能遗漏，也不能重复</p>\n<ul>\n<li>调度器基于time ticker每秒钟进行一次工作，根据当前时刻推算出<strong>分钟级别</strong>的字符串表达式</li>\n<li>根据配置中最大桶数量，依次拼接分钟Key值得到若干个二维数据分区的Key值。例如<code>20:47:39_0</code>、<code>20:48:11_1</code></li>\n<li>尝试抢占数据分区的分布式锁，并把锁的过期时间设置为<strong>大于1倍分片时间，小于2倍分片时间</strong></li>\n<li>如果抢锁成功，就调度一个触发器进行作业</li>\n</ul>\n<h4 id=\"触发器模块\"><a href=\"#触发器模块\" class=\"headerlink\" title=\"触发器模块\"></a>触发器模块</h4><p><strong>按时唤醒二维数据分区中的定时任务</strong></p>\n<ul>\n<li>触发器被创建后，每秒对负责的数据分区进行扫描，以当前时刻为基准，将符合条件的定时任务取出并交付给执行器执行</li>\n<li>当触发器协程完成任务后，需要将分布式锁的过期时间延期至<strong>大于两个分区时间</strong></li>\n</ul>\n<blockquote>\n<p>为什么要对分布式锁进行延期？</p>\n<p>回答这个问题之前，需要补充的一点：为了对前一分钟的数据分区执行失败做兜底，每次触发器对当前分区进行扫描时都会对前一分钟的数据分区进行重试扫描。</p>\n<p>因此，如果前一个数据分区的任务执行失败，那么该分区的分布式锁无法得到延时，必然会在当前分钟内再次获得进而进行重试操作。反之，分布式锁得到了延时，那么当前分钟内就不会重复执行已成功执行的任务。</p>\n<p>也正是出于这个机制考虑，延迟的时间必须大于两个分区时间</p>\n</blockquote>\n<p>问题在于很难实现百分百的分布式事务，即无法保证<strong>完成分区任务 + 延迟分布式锁</strong>操作是原子的，因此这里只能是<strong>At least once</strong>语义。</p>\n<h4 id=\"执行器模块\"><a href=\"#执行器模块\" class=\"headerlink\" title=\"执行器模块\"></a>执行器模块</h4><p><strong>执行定时任务</strong></p>\n<ul>\n<li>一个执行器由触发器调度，对应一个具体的定时任务</li>\n<li>执行器首先对定时任务进行幂等检查</li>\n<li>执行任务</li>\n<li>更新定时任务的状态</li>\n</ul>\n<h3 id=\"任务迁移模块化\"><a href=\"#任务迁移模块化\" class=\"headerlink\" title=\"任务迁移模块化\"></a>任务迁移模块化</h3><p>LyyTimer项目使用MySQL + Redis二级存储模型，并设置了一个Migrator根据时间由近及远<strong>通过处于激活状态的定时器（cron表达式）生成一系列定时任务</strong>，并迁移同步至两个存储介质中</p>\n<h4 id=\"Migrator模块\"><a href=\"#Migrator模块\" class=\"headerlink\" title=\"Migrator模块\"></a>Migrator模块</h4><ul>\n<li>每隔一段时间步长就扫描所有的定时器，根据处于激活状态的定时器生成未来两个时间步长的定时任务（本质上就一个时间步长，都是为了失败兜底😂）<ul>\n<li>例如，每隔一小时就进行一次全表扫描，若14:45:34对所有的定时器进行一次扫描，迁移模块就会生成14:45:34 - 16:45:34这两个小时的定时任务并迁移至MySQL和Redis中。但14:45:34 - 15:45:34这个时间段的任务已经在13:45:34被Migrator模块生成并存储了，所以本质上迁移模块只生成了一小时的任务。重复的任务将会由于唯一约束而插入失败，所以不必担心任务重复插入</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"串行打点还是批量打点？\"><a href=\"#串行打点还是批量打点？\" class=\"headerlink\" title=\"串行打点还是批量打点？\"></a>串行打点还是批量打点？</h5><p>串行打点就是指每次根据cron表达式<strong>只生成最近的一次</strong>定时任务，然后在执行器执行完这个任务后就立马生成下一次的定时任务，如此循环。</p>\n<p>串行打点比较节约资源，可以缓解生成任务过多导致的短时间内资源浪费问题，但是针对于短间隔高频执行的定时器（例如：1s执行一次）就有些力不从心了。</p>\n<p><strong>优化方案：批量打点</strong></p>\n<p>每隔一段时间程序就根据cron表达式生成一个时间步长的任务，这样可以有效解决短间隔高频率的任务生成问题。但如果用户对定时器进行频繁的修改，那为了保证数据一致性，就需要引入删除、修改已生成任务等复杂操作。为了规避这种情况，我们可以要求用户无法对已有的定时器进行修改，只允许<strong>激活</strong>和<strong>去激活</strong>两种操作</p>\n<p>此外，即使用户<strong>去激活</strong>某一个定时器，我们也无需修改已有的任务，只需要在回调之前检查定时器状态是否合法即可。</p>\n<h2 id=\"存储结构设计\"><a href=\"#存储结构设计\" class=\"headerlink\" title=\"存储结构设计\"></a>存储结构设计</h2><p><strong>定时器表</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer_id</td>\n<td>bigint</td>\n<td>自增主键ID（或有序UUID）</td>\n</tr>\n<tr>\n<td>ctime</td>\n<td>bigint</td>\n<td>创建时间（避免时区问题）</td>\n</tr>\n<tr>\n<td>utime</td>\n<td>bigint</td>\n<td>修改时间</td>\n</tr>\n<tr>\n<td>app</td>\n<td>varchar(128)</td>\n<td>业务方标识</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar(256)</td>\n<td>任务名</td>\n</tr>\n<tr>\n<td>status</td>\n<td>tinyint</td>\n<td>任务状态：0新建、1激活、2未激活</td>\n</tr>\n<tr>\n<td>cron</td>\n<td>varchar(256)</td>\n<td>cron表达式，用于生成定时任务</td>\n</tr>\n<tr>\n<td>notify_http_param</td>\n<td>varchar(8192)</td>\n<td>回调上下文</td>\n</tr>\n</tbody></table>\n<p><strong>定时任务表</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>task_id</td>\n<td>bigint</td>\n<td>自增主键ID</td>\n</tr>\n<tr>\n<td>ctime</td>\n<td>bigint</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>utime</td>\n<td>bigint</td>\n<td>修改时间</td>\n</tr>\n<tr>\n<td>timer_id</td>\n<td>bigint</td>\n<td>对应的定时器ID</td>\n</tr>\n<tr>\n<td>app</td>\n<td>varchar(128)</td>\n<td>业务方标识</td>\n</tr>\n<tr>\n<td>output</td>\n<td>var(1024)</td>\n<td>执行结果</td>\n</tr>\n<tr>\n<td>status</td>\n<td>tinyint</td>\n<td>任务状态：0待执行、1成功、2失败</td>\n</tr>\n<tr>\n<td>run_timer</td>\n<td>bigint</td>\n<td>开始运行时间</td>\n</tr>\n<tr>\n<td>cost_time</td>\n<td>bigint</td>\n<td>误差时间</td>\n</tr>\n</tbody></table>\n<p><strong>单个分片结构</strong>：</p>\n<p>Key：时间 + bucket编号 &#x3D; “2024121115:54:51_01”</p>\n<p>Member：timerId + unix当前时间戳</p>\n<p>Score：unix当前时间戳</p>\n<p>一个可能的优化点：</p>\n<p>在任务状态上建立索引  —–&gt;  存在<strong>数据倾斜</strong></p>\n","excerpt":"","more":"<h1 id=\"定时微服务\"><a href=\"#定时微服务\" class=\"headerlink\" title=\"定时微服务\"></a>定时微服务</h1><h2 id=\"前置准备\"><a href=\"#前置准备\" class=\"headerlink\" title=\"前置准备\"></a>前置准备</h2><h3 id=\"背景和现状\"><a href=\"#背景和现状\" class=\"headerlink\" title=\"背景和现状\"></a>背景和现状</h3><p>市面上已有的定时微服务技术：Java Timer、Rocket MQ、xxl-job、Quartz、Robfig&#x2F;Cron</p>\n<ul>\n<li>很多公司的业务只需要一个简单的“定时”功能。为了满足一个简单定时功能而引入过于强大而且臃肿的任务调度组件是不合适的</li>\n<li>设计一个<strong>功能聚焦、轻量级、维护成本低</strong>的定时微服务组件是很有必要的</li>\n</ul>\n<p><strong>定时微服务LyyTimer</strong></p>\n<ol>\n<li>依赖简单：只需要提供MySQL、Redis和Kafka组件的支持即可，接入和维护的成本低</li>\n<li>学习成本低：整个定时微服务功能聚焦，容易上手</li>\n<li>特性优：LyyTimer具有高精准、高负载、异常处理等特性，能基本满足大部分的定时需求</li>\n</ol>\n<h3 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h3><h4 id=\"高精准\"><a href=\"#高精准\" class=\"headerlink\" title=\"高精准\"></a><strong>高精准</strong></h4><p>相对于单点定时（例如Java.Timer）基本能做到毫秒级触发，几乎所有定时任务框架或者消息队列，都只能保证秒级别误差</p>\n<p>常见导致时间误差大的原因：</p>\n<ul>\n<li>定时脚本运行耗时</li>\n<li>等待定时脚本运行</li>\n<li>消息队列中消息堆积</li>\n<li>分布式定时器延时受网络影响</li>\n<li>数据库中查找任务数据耗时</li>\n<li>特殊时间段任务过多</li>\n</ul>\n<h4 id=\"高负载\"><a href=\"#高负载\" class=\"headerlink\" title=\"高负载\"></a><strong>高负载</strong></h4><p>能够支持同时处理大量任务，并且尽可能少的堆积任务</p>\n<p>高负载解决思路和方法：</p>\n<ul>\n<li>应用层方面减少任务量，选择将同一时刻的多个独立任务合并成一个“计划列表”</li>\n<li>分库分表：将一个大型数据库分成多个较小的数据库，并将每个数据库进一步分成多个较小的表，每个表只包含部分数据<ul>\n<li>垂直分表：保持列完整</li>\n<li>水平分表：只保留部分列</li>\n<li>分库分表组合</li>\n</ul>\n</li>\n<li>数据分区：将大数据拆分成多个小数据分区，将这些小分区存储在不同的物理设备或服务器上，提供数据的存取效率和处理速度</li>\n<li>线程池技术<ul>\n<li>复用线程，降低了资源消耗</li>\n<li>高效地管理多个线程</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"任务异常处理\"><a href=\"#任务异常处理\" class=\"headerlink\" title=\"任务异常处理\"></a><strong>任务异常处理</strong></h4><blockquote>\n<p> 定时任务需求可以允许有一定的误差，但是不能不触发</p>\n</blockquote>\n<p><strong>任务异常的原因：</strong></p>\n<ul>\n<li><p>创建（激活）任务接口异常：在创建任务阶段发生异常，系统可以直接将异常原因返回给用户。用户感知到异常后，可通过主动重试解决问题，即该阶段的异常不应该由框架解决</p>\n</li>\n<li><p>任务流转异常：一旦任务成功存储在数据库中，就认为该定时任务创建成功，微服务框架就要负责该任务后续的流转（查询数据库、发送消息队列、缓存等）。因此，框架需要解决任务流转过程中发生的异常</p>\n</li>\n<li><p>任务触发阶段异常：当任务执行后，系统需要回调告知业务方任务结果。对于业务方来说，如果回调失败导致结果丢失，就相当于该任务没有执行过</p>\n</li>\n</ul>\n<p><strong>常用的解决方案</strong></p>\n<ul>\n<li><strong>（立即）重试机制</strong>：可以应付一些偶发性异常，例如数据库抖动、Redis抖动</li>\n<li><strong>失败兜底机制</strong>：一般来说，兜底策略都是采用一些“无脑”脚本，全表扫描数据库，针对失败记录进行重试操作。但是兜底策略一般在性能上不占优势，所以需要选择合适的时间间隔执行兜底脚本</li>\n<li><strong>失败报警机制</strong>：当短时间内有大量任务失败时，需要及时报警</li>\n<li><strong>人工干预</strong></li>\n</ul>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p><strong>定时器本质实现思路：查询 + 触发</strong>，以及暴露给用户一个<strong>注册任务</strong>接口</p>\n<ul>\n<li><strong>注册</strong>定时器：接受用户的创建请求，明确每一个任务的<strong>执行时间</strong></li>\n<li><strong>查询</strong>数据库：每隔一段时间间隔就<strong>查询</strong>任务列表，筛选出未触发的任务</li>\n<li><strong>触发</strong>任务：触发<strong>执行时间小于当前时间（时刻）</strong>的任务</li>\n</ul>\n<h4 id=\"存储结构优化：有序表\"><a href=\"#存储结构优化：有序表\" class=\"headerlink\" title=\"存储结构优化：有序表\"></a>存储结构优化：有序表</h4><p><strong>基于有序数据结构，加快数据查询</strong></p>\n<p>常见的有序数据结构：红黑树、跳表、平衡树等，这些数据结构通过在插入操作均摊查询操作的时间复杂度实现**查询时间复杂度$$O(N) —&gt; O(logN)$$**的优化</p>\n<h4 id=\"存储结构优化：横向切片\"><a href=\"#存储结构优化：横向切片\" class=\"headerlink\" title=\"存储结构优化：横向切片\"></a>存储结构优化：横向切片</h4><p><strong>根据时间区间对数据分片，减少查询时涉及的数据数量</strong></p>\n<p>每次查询数据的时候，真正的目标是<strong>即将执行</strong>的任务，而<strong>稍后执行</strong>的任务属于无关任务。基于这个理念，我们可以将数据进行横向切分，例如每一分钟划分一个数据切片，然后从包含目标数据的数据切片中查询数据</p>\n<p>这种做法可以将大大降低每一次查询的任务数量级：N —&gt; N’，其中N’ &lt;&lt; N，即使没有改变查询的时间复杂度，但减少了查询时涉及的数据数量</p>\n<h4 id=\"存储结构优化：纵向切片\"><a href=\"#存储结构优化：纵向切片\" class=\"headerlink\" title=\"存储结构优化：纵向切片\"></a>存储结构优化：纵向切片</h4><p><strong>对数据分区进行分桶，提高数据操作的并发度</strong></p>\n<p>截止到上一步，时间数据分区是定时器中的最小资源单位，每一个数据分区都由一个goroutine（或线程）控制。为了提高数据操作的并发度，可以对分区中的数据进一步<strong>分桶</strong>，把每一个桶交付给一个goroutine（或线程）处理，在纵向增加分桶的维度，提高并发度</p>\n<blockquote>\n<p>总结：依然是“查询 + 触发”的定时器机制，只不过相较于丐版定时器有如下变化：每次查询都只查询一个（当前）时间范围内的数据，这些数据由ZSet数据结构存储。接着基于并发的考虑，令多个goroutine负责从分区中的多个桶中查询数据，最后将触发获取到的任务。</p>\n</blockquote>\n<h3 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h3><h4 id=\"定时任务调度流程\"><a href=\"#定时任务调度流程\" class=\"headerlink\" title=\"定时任务调度流程\"></a>定时任务调度流程</h4><p>任务调度流程<strong>服务架构：三个模块 + 两个协程池</strong></p>\n<p>LyyTimer是一个<strong>去中心化的定时任务调度框架</strong>，定时任务调度服务根据职责边界可以将服务拆分为：<strong>调度器模块</strong>、<strong>触发器模块</strong>、<strong>执行模块</strong>，这三个模块存在着依赖关系。父模块通过协程池异步启动子模块执行相应工作</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251841204.png\" alt=\"image-20241125183915443\"></p>\n<h4 id=\"定时任务生成流程\"><a href=\"#定时任务生成流程\" class=\"headerlink\" title=\"定时任务生成流程\"></a>定时任务生成流程</h4><p><strong>定时任务的创建设计到Web Server和Migrator Scheduler两个模块</strong></p>\n<ul>\n<li>用户通过Web Server提供的API创建定时任务</li>\n<li>Migrator Scheduler定时根据cron表达式预热定时任务数据</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411251851062.png\" alt=\"image-20241125185145008\"></p>\n<blockquote>\n<p>为什么需要两种方式预热数据？</p>\n<p>为了确保在定时脚本执行间隔内创建的任务生效。例如，定时脚本每两小时执行一次，每一次执行都会预热两小时后的数据。第一次定时脚本执行时刻是18:58，创建了18:58-20:58定时任务。倘若有用户在19:00想要创建一个19:58分的定时任务，那么只依靠定时脚本是无法实现的，因为下一次定时脚本的执行时间是20:58。综上所诉，仅仅有定时脚本是有缺陷的，还需要一个Web Server模块完成任务的第一次创建，确保用户在任何时候创建的任务都能生效。</p>\n</blockquote>\n<h3 id=\"调度流程模块化\"><a href=\"#调度流程模块化\" class=\"headerlink\" title=\"调度流程模块化\"></a>调度流程模块化</h3><h4 id=\"调度器模块\"><a href=\"#调度器模块\" class=\"headerlink\" title=\"调度器模块\"></a>调度器模块</h4><p><strong>确定二维数据分区目标对象，统筹分配触发器</strong></p>\n<p>调度器的作用就是要确保在分布式场景下，每一个二维数据分区都能被一个触发器负责处理，既不能遗漏，也不能重复</p>\n<ul>\n<li>调度器基于time ticker每秒钟进行一次工作，根据当前时刻推算出<strong>分钟级别</strong>的字符串表达式</li>\n<li>根据配置中最大桶数量，依次拼接分钟Key值得到若干个二维数据分区的Key值。例如<code>20:47:39_0</code>、<code>20:48:11_1</code></li>\n<li>尝试抢占数据分区的分布式锁，并把锁的过期时间设置为<strong>大于1倍分片时间，小于2倍分片时间</strong></li>\n<li>如果抢锁成功，就调度一个触发器进行作业</li>\n</ul>\n<h4 id=\"触发器模块\"><a href=\"#触发器模块\" class=\"headerlink\" title=\"触发器模块\"></a>触发器模块</h4><p><strong>按时唤醒二维数据分区中的定时任务</strong></p>\n<ul>\n<li>触发器被创建后，每秒对负责的数据分区进行扫描，以当前时刻为基准，将符合条件的定时任务取出并交付给执行器执行</li>\n<li>当触发器协程完成任务后，需要将分布式锁的过期时间延期至<strong>大于两个分区时间</strong></li>\n</ul>\n<blockquote>\n<p>为什么要对分布式锁进行延期？</p>\n<p>回答这个问题之前，需要补充的一点：为了对前一分钟的数据分区执行失败做兜底，每次触发器对当前分区进行扫描时都会对前一分钟的数据分区进行重试扫描。</p>\n<p>因此，如果前一个数据分区的任务执行失败，那么该分区的分布式锁无法得到延时，必然会在当前分钟内再次获得进而进行重试操作。反之，分布式锁得到了延时，那么当前分钟内就不会重复执行已成功执行的任务。</p>\n<p>也正是出于这个机制考虑，延迟的时间必须大于两个分区时间</p>\n</blockquote>\n<p>问题在于很难实现百分百的分布式事务，即无法保证<strong>完成分区任务 + 延迟分布式锁</strong>操作是原子的，因此这里只能是<strong>At least once</strong>语义。</p>\n<h4 id=\"执行器模块\"><a href=\"#执行器模块\" class=\"headerlink\" title=\"执行器模块\"></a>执行器模块</h4><p><strong>执行定时任务</strong></p>\n<ul>\n<li>一个执行器由触发器调度，对应一个具体的定时任务</li>\n<li>执行器首先对定时任务进行幂等检查</li>\n<li>执行任务</li>\n<li>更新定时任务的状态</li>\n</ul>\n<h3 id=\"任务迁移模块化\"><a href=\"#任务迁移模块化\" class=\"headerlink\" title=\"任务迁移模块化\"></a>任务迁移模块化</h3><p>LyyTimer项目使用MySQL + Redis二级存储模型，并设置了一个Migrator根据时间由近及远<strong>通过处于激活状态的定时器（cron表达式）生成一系列定时任务</strong>，并迁移同步至两个存储介质中</p>\n<h4 id=\"Migrator模块\"><a href=\"#Migrator模块\" class=\"headerlink\" title=\"Migrator模块\"></a>Migrator模块</h4><ul>\n<li>每隔一段时间步长就扫描所有的定时器，根据处于激活状态的定时器生成未来两个时间步长的定时任务（本质上就一个时间步长，都是为了失败兜底😂）<ul>\n<li>例如，每隔一小时就进行一次全表扫描，若14:45:34对所有的定时器进行一次扫描，迁移模块就会生成14:45:34 - 16:45:34这两个小时的定时任务并迁移至MySQL和Redis中。但14:45:34 - 15:45:34这个时间段的任务已经在13:45:34被Migrator模块生成并存储了，所以本质上迁移模块只生成了一小时的任务。重复的任务将会由于唯一约束而插入失败，所以不必担心任务重复插入</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"串行打点还是批量打点？\"><a href=\"#串行打点还是批量打点？\" class=\"headerlink\" title=\"串行打点还是批量打点？\"></a>串行打点还是批量打点？</h5><p>串行打点就是指每次根据cron表达式<strong>只生成最近的一次</strong>定时任务，然后在执行器执行完这个任务后就立马生成下一次的定时任务，如此循环。</p>\n<p>串行打点比较节约资源，可以缓解生成任务过多导致的短时间内资源浪费问题，但是针对于短间隔高频执行的定时器（例如：1s执行一次）就有些力不从心了。</p>\n<p><strong>优化方案：批量打点</strong></p>\n<p>每隔一段时间程序就根据cron表达式生成一个时间步长的任务，这样可以有效解决短间隔高频率的任务生成问题。但如果用户对定时器进行频繁的修改，那为了保证数据一致性，就需要引入删除、修改已生成任务等复杂操作。为了规避这种情况，我们可以要求用户无法对已有的定时器进行修改，只允许<strong>激活</strong>和<strong>去激活</strong>两种操作</p>\n<p>此外，即使用户<strong>去激活</strong>某一个定时器，我们也无需修改已有的任务，只需要在回调之前检查定时器状态是否合法即可。</p>\n<h2 id=\"存储结构设计\"><a href=\"#存储结构设计\" class=\"headerlink\" title=\"存储结构设计\"></a>存储结构设计</h2><p><strong>定时器表</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>timer_id</td>\n<td>bigint</td>\n<td>自增主键ID（或有序UUID）</td>\n</tr>\n<tr>\n<td>ctime</td>\n<td>bigint</td>\n<td>创建时间（避免时区问题）</td>\n</tr>\n<tr>\n<td>utime</td>\n<td>bigint</td>\n<td>修改时间</td>\n</tr>\n<tr>\n<td>app</td>\n<td>varchar(128)</td>\n<td>业务方标识</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar(256)</td>\n<td>任务名</td>\n</tr>\n<tr>\n<td>status</td>\n<td>tinyint</td>\n<td>任务状态：0新建、1激活、2未激活</td>\n</tr>\n<tr>\n<td>cron</td>\n<td>varchar(256)</td>\n<td>cron表达式，用于生成定时任务</td>\n</tr>\n<tr>\n<td>notify_http_param</td>\n<td>varchar(8192)</td>\n<td>回调上下文</td>\n</tr>\n</tbody></table>\n<p><strong>定时任务表</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>task_id</td>\n<td>bigint</td>\n<td>自增主键ID</td>\n</tr>\n<tr>\n<td>ctime</td>\n<td>bigint</td>\n<td>创建时间</td>\n</tr>\n<tr>\n<td>utime</td>\n<td>bigint</td>\n<td>修改时间</td>\n</tr>\n<tr>\n<td>timer_id</td>\n<td>bigint</td>\n<td>对应的定时器ID</td>\n</tr>\n<tr>\n<td>app</td>\n<td>varchar(128)</td>\n<td>业务方标识</td>\n</tr>\n<tr>\n<td>output</td>\n<td>var(1024)</td>\n<td>执行结果</td>\n</tr>\n<tr>\n<td>status</td>\n<td>tinyint</td>\n<td>任务状态：0待执行、1成功、2失败</td>\n</tr>\n<tr>\n<td>run_timer</td>\n<td>bigint</td>\n<td>开始运行时间</td>\n</tr>\n<tr>\n<td>cost_time</td>\n<td>bigint</td>\n<td>误差时间</td>\n</tr>\n</tbody></table>\n<p><strong>单个分片结构</strong>：</p>\n<p>Key：时间 + bucket编号 &#x3D; “2024121115:54:51_01”</p>\n<p>Member：timerId + unix当前时间戳</p>\n<p>Score：unix当前时间戳</p>\n<p>一个可能的优化点：</p>\n<p>在任务状态上建立索引  —–&gt;  存在<strong>数据倾斜</strong></p>\n"},{"_content":"ETF\n\nSecurity Basket：Basic fee * 6\nGrow Basket：S&P500\nHigh Grow Basket：danger\nLuxury Basket：entertainment\n\n先填满第一个箱子\n","source":"_posts/理睬.md","raw":"ETF\n\nSecurity Basket：Basic fee * 6\nGrow Basket：S&P500\nHigh Grow Basket：danger\nLuxury Basket：entertainment\n\n先填满第一个箱子\n","slug":"理睬","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j000za5t2383l0shx","content":"<p>ETF</p>\n<p>Security Basket：Basic fee * 6<br>Grow Basket：S&amp;P500<br>High Grow Basket：danger<br>Luxury Basket：entertainment</p>\n<p>先填满第一个箱子</p>\n","excerpt":"","more":"<p>ETF</p>\n<p>Security Basket：Basic fee * 6<br>Grow Basket：S&amp;P500<br>High Grow Basket：danger<br>Luxury Basket：entertainment</p>\n<p>先填满第一个箱子</p>\n"},{"title":"数据链路层知识点","publish":true,"description":"记录了一些网络层的知识点","date":"2024-09-22T16:00:00.000Z","_content":"\n\n\n# 数据链路层知识点\n\n## ARP协议\n\n> 搞清楚ARP协议的用途是什么\n\n参考书籍《图解TCP/IP 第五版》\n\n### ARP协议概要\n\nARP协议可以根据目标IP地址找到下一跳的设备（如果目标主机在同一个链路上，那么就是目标主机，否则就是路由器）的MAC地址。ARP协议只适用于IPv4，不能用于IPv6，但IPv6可以用ICMPv6代替ARP发送邻居探索消息。\n\n### ARP的工作机制\n\n简单来说，就是从一个IP地址广播ARP请求包，目标IP地址将自身的MAC地址填入其中的ARP响应包返回到源IP地址\n\n源IP地址的设备接收到ARP响应包后，建立一个IP-MAC地址的映射并存储在缓存表中。这样当下一次发送数据包时就可以直接从缓存表中读取出MAC地址，加快发送数据包的速度\n\n不过MAC地址的缓存是有一定期限的，超过这个期限，缓存内容就被清除。这使得即使MAC地址与IP地址的映射关系发生变化，也能够正确地发送数据包给目标设备。\n\n### RARP\n\nRARP是ARP的逆过程，从MAC地址定位IP地址的一种协议。RARP主要依赖一个RARP服务器，在这个服务器上注册了许多设备的MAC地址与IP地址的映射\n\n🌰：当主机A想要直到自己的IP地址时，就可以向RARP服务器发送一个RARP请求包，RARP服务器接收到请求包后，查看映射关系，将IP地址放入RARP响应包中并返回给主机A\n\n![image-20240923144758648](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231447673.png)","source":"_posts/数据链路层知识点.md","raw":"---\ntitle: 数据链路层知识点\npublish: true\ndescription: 记录了一些网络层的知识点\ndate: 2024-09-23 \ntag: 计算机网络\n---\n\n\n\n# 数据链路层知识点\n\n## ARP协议\n\n> 搞清楚ARP协议的用途是什么\n\n参考书籍《图解TCP/IP 第五版》\n\n### ARP协议概要\n\nARP协议可以根据目标IP地址找到下一跳的设备（如果目标主机在同一个链路上，那么就是目标主机，否则就是路由器）的MAC地址。ARP协议只适用于IPv4，不能用于IPv6，但IPv6可以用ICMPv6代替ARP发送邻居探索消息。\n\n### ARP的工作机制\n\n简单来说，就是从一个IP地址广播ARP请求包，目标IP地址将自身的MAC地址填入其中的ARP响应包返回到源IP地址\n\n源IP地址的设备接收到ARP响应包后，建立一个IP-MAC地址的映射并存储在缓存表中。这样当下一次发送数据包时就可以直接从缓存表中读取出MAC地址，加快发送数据包的速度\n\n不过MAC地址的缓存是有一定期限的，超过这个期限，缓存内容就被清除。这使得即使MAC地址与IP地址的映射关系发生变化，也能够正确地发送数据包给目标设备。\n\n### RARP\n\nRARP是ARP的逆过程，从MAC地址定位IP地址的一种协议。RARP主要依赖一个RARP服务器，在这个服务器上注册了许多设备的MAC地址与IP地址的映射\n\n🌰：当主机A想要直到自己的IP地址时，就可以向RARP服务器发送一个RARP请求包，RARP服务器接收到请求包后，查看映射关系，将IP地址放入RARP响应包中并返回给主机A\n\n![image-20240923144758648](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231447673.png)","slug":"数据链路层知识点","published":1,"updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j0011a5t24hlzhtnu","content":"<h1 id=\"数据链路层知识点\"><a href=\"#数据链路层知识点\" class=\"headerlink\" title=\"数据链路层知识点\"></a>数据链路层知识点</h1><h2 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h2><blockquote>\n<p>搞清楚ARP协议的用途是什么</p>\n</blockquote>\n<p>参考书籍《图解TCP&#x2F;IP 第五版》</p>\n<h3 id=\"ARP协议概要\"><a href=\"#ARP协议概要\" class=\"headerlink\" title=\"ARP协议概要\"></a>ARP协议概要</h3><p>ARP协议可以根据目标IP地址找到下一跳的设备（如果目标主机在同一个链路上，那么就是目标主机，否则就是路由器）的MAC地址。ARP协议只适用于IPv4，不能用于IPv6，但IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p>\n<h3 id=\"ARP的工作机制\"><a href=\"#ARP的工作机制\" class=\"headerlink\" title=\"ARP的工作机制\"></a>ARP的工作机制</h3><p>简单来说，就是从一个IP地址广播ARP请求包，目标IP地址将自身的MAC地址填入其中的ARP响应包返回到源IP地址</p>\n<p>源IP地址的设备接收到ARP响应包后，建立一个IP-MAC地址的映射并存储在缓存表中。这样当下一次发送数据包时就可以直接从缓存表中读取出MAC地址，加快发送数据包的速度</p>\n<p>不过MAC地址的缓存是有一定期限的，超过这个期限，缓存内容就被清除。这使得即使MAC地址与IP地址的映射关系发生变化，也能够正确地发送数据包给目标设备。</p>\n<h3 id=\"RARP\"><a href=\"#RARP\" class=\"headerlink\" title=\"RARP\"></a>RARP</h3><p>RARP是ARP的逆过程，从MAC地址定位IP地址的一种协议。RARP主要依赖一个RARP服务器，在这个服务器上注册了许多设备的MAC地址与IP地址的映射</p>\n<p>🌰：当主机A想要直到自己的IP地址时，就可以向RARP服务器发送一个RARP请求包，RARP服务器接收到请求包后，查看映射关系，将IP地址放入RARP响应包中并返回给主机A</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231447673.png\" alt=\"image-20240923144758648\"></p>\n","excerpt":"","more":"<h1 id=\"数据链路层知识点\"><a href=\"#数据链路层知识点\" class=\"headerlink\" title=\"数据链路层知识点\"></a>数据链路层知识点</h1><h2 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h2><blockquote>\n<p>搞清楚ARP协议的用途是什么</p>\n</blockquote>\n<p>参考书籍《图解TCP&#x2F;IP 第五版》</p>\n<h3 id=\"ARP协议概要\"><a href=\"#ARP协议概要\" class=\"headerlink\" title=\"ARP协议概要\"></a>ARP协议概要</h3><p>ARP协议可以根据目标IP地址找到下一跳的设备（如果目标主机在同一个链路上，那么就是目标主机，否则就是路由器）的MAC地址。ARP协议只适用于IPv4，不能用于IPv6，但IPv6可以用ICMPv6代替ARP发送邻居探索消息。</p>\n<h3 id=\"ARP的工作机制\"><a href=\"#ARP的工作机制\" class=\"headerlink\" title=\"ARP的工作机制\"></a>ARP的工作机制</h3><p>简单来说，就是从一个IP地址广播ARP请求包，目标IP地址将自身的MAC地址填入其中的ARP响应包返回到源IP地址</p>\n<p>源IP地址的设备接收到ARP响应包后，建立一个IP-MAC地址的映射并存储在缓存表中。这样当下一次发送数据包时就可以直接从缓存表中读取出MAC地址，加快发送数据包的速度</p>\n<p>不过MAC地址的缓存是有一定期限的，超过这个期限，缓存内容就被清除。这使得即使MAC地址与IP地址的映射关系发生变化，也能够正确地发送数据包给目标设备。</p>\n<h3 id=\"RARP\"><a href=\"#RARP\" class=\"headerlink\" title=\"RARP\"></a>RARP</h3><p>RARP是ARP的逆过程，从MAC地址定位IP地址的一种协议。RARP主要依赖一个RARP服务器，在这个服务器上注册了许多设备的MAC地址与IP地址的映射</p>\n<p>🌰：当主机A想要直到自己的IP地址时，就可以向RARP服务器发送一个RARP请求包，RARP服务器接收到请求包后，查看映射关系，将IP地址放入RARP响应包中并返回给主机A</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231447673.png\" alt=\"image-20240923144758648\"></p>\n"},{"title":"换取Mac OS","publish":false,"_content":"\n## 大纲\n\n### 自我介绍\n\n- 姓名 \n- 班级 \n- 政治面貌\n  - 共青团员\n- 排名\n  -  **12/393**\n  - **163 ----> 12**\n- 成绩\n  -  **忘了均分**\n  -  离散数学2 98\n  - 计算机数学基础 98\n  - 计算机组织与结构 93\n  - 大学物理(软) 96\n  - 操作系统 92\n  - 大学英语3 98\n  - 概率与统计A 99\n  - 数据结构与算法 97\n  -  计算机组织与结构实验 95\n- 获奖情况\n  - 学习优秀奖学金（一等）\n  - 科技创新奖学金\n  - CCF CSP 第31次认证 院级二等奖\n  - 第十九届百度之星程序设计大赛初赛 省级三等奖\n  - 2023年第四届全国大学生算法设计与编程挑战赛（秋季赛） 国家级三等奖\n  - 2023年第十三届APMCM亚太地区大学生数学建模竞赛 国家级三等奖\n  - 2023年全国大学生信息技术认证挑战赛 国家级三等奖\n  - 2024年第五届全国大学生算法设计与编程挑战赛（春季赛） 国家级三等奖\n  - 第五届全国高校计算机能力挑战赛-C++ 国家级二等奖\n  - 第十五届蓝桥杯全国软件和信息技术专业人才大赛辽宁赛区 省级二等奖\n  - 2024年美国大学生数学建模竞赛 国家级H奖\n  - 2024年第二届全国大学生信息技术认证挑战赛 国家级三等奖\n  - 2024年中国高校计算机大赛-AIGC创新赛-应用赛道（校赛） 校级一等奖\n  - 2023首届大学生算法大赛 优秀奖\n  - 116积分\n- 身份\n\n### 成绩、科创、后端\n\n- 成绩\n  - 大一学年60 -----> 大二学年12\n  - 过程\n    - 认真听讲\n    - 仔细做笔记\n    - 重复重复重复\n- 科创奖项\n  - 科创积分116\n  - 国家级奖项8项\n  - 作为创中一份子，积极投身于科创竞赛\n- 后端\n  - 开源短链项目\n  - 深入学习MySQL原理\n  - 深入学习Redis原理\n  - 博客\n  - 思路：\n    - 后端架构技术，自学Go语言并积累近2w字学习笔记\n    - 为了更好地提高系统性能，深入学习MySQL、Redis底层原理，与底层C语言实现代码斗智斗勇\n    - 个人博客\n- 科研\n  - 大创（蹭）\n  - 论文\n\n### 学生工作\n\n- 例会\n- 培养大一/二同学\n\n### 总结\n\n## aba\n\n- 自我介绍：一年以来的积累\n  - 特点\n- 目录\n- 过程--->结果\n- 量---->总结过程---->精神\n- 项目：承担什么角色、什么提升\n- 成果罗列页\n\n## 稿子\n\n​    尊敬的各位评委老师，晚上好！我是来自软 2213 班的李源东。很荣幸参加本次国家奖学金汇报。我汇报的主题是 “脚踏实地 源远流长 只争朝夕 勤勉致远”（翻页）\n\n   大二学年，我荣获了一等学习优秀奖学金、校三好学生、科技创新奖学金等荣誉。（翻页）\n\n**一、脚踏实地，实现成绩飞跃**\n\n   面对大一上不尽人意的成绩，我内心充满不甘。我不愿就此消沉，更不愿让父母失望。从此，我成为了自习室的常客、教室前排的坚守者，300余页的笔记，300多个日夜的辛勤努力，终于在大二学年，我实现了专业排名从**33%****到3%****的飞跃**，从**仅有**一门课程成绩90+，到大二学年10门必修课90+。（翻页）\n\n**二、只争朝夕，磨砺科技创新**\n\n​    无论是春华秋实还是冬冷夏热，洛谷、力扣见证了我日复一日的勤奋练习。大二学年，我以汗水浇灌，共获得了12项竞赛荣誉，其中包括8项国家级奖项和2项省级奖项，科创积分也实现了从0到116分的飞跃。（翻页）\n\n   在科研领域，我不仅巩固了理论知识，在研究生的指导下阅读了10余篇论文，还躬行实践，与团队成员共同开发化工大模型大创项目。（翻页）\n\n   我积极探索后端最新技术，深入Go语言的底层原理，探索高性能架构设计，独立搭建了个人博客，分享所见所闻。（翻页）\n\n   至今，已有底层原理笔记近**2万字**，**独立开发并开源**短链系统，发布**20**余篇技术文章，总字数超过**6万字**。（翻页）\n\n**三、饮水思源，散发萤火之光**\n\n   作为腾讯组的核心成员，我不仅积极参与技术栈建设，为团队成员提供丰富的学习资源，还致力于培养团队后端技术人才，积极回应团队成员的疑问。技术栈已收录博客**二十**篇 个人贡献**3**篇 23级组员十人 **百分百** 学习优秀奖学金。用行动诠释**“****有一分热，就要发一分光”**的精神。（翻页）\n\n**总结**\n\n   我始终坚信：不驰于空想，不骛于虚声，唯有以**求实**的态度，**踏实**的工作，才能走得更远。（翻页）\n\n   展望未来，愿我们都能为真理的**源远根深**而只争朝夕，为争做**南金东箭**而拼搏奋斗。\n\n   我的汇报到此结束，谢谢大家。","source":"_posts/换取Mac OS第一步.md","raw":"---\ntitle: 换取Mac OS\npublish: false\n\n---\n\n## 大纲\n\n### 自我介绍\n\n- 姓名 \n- 班级 \n- 政治面貌\n  - 共青团员\n- 排名\n  -  **12/393**\n  - **163 ----> 12**\n- 成绩\n  -  **忘了均分**\n  -  离散数学2 98\n  - 计算机数学基础 98\n  - 计算机组织与结构 93\n  - 大学物理(软) 96\n  - 操作系统 92\n  - 大学英语3 98\n  - 概率与统计A 99\n  - 数据结构与算法 97\n  -  计算机组织与结构实验 95\n- 获奖情况\n  - 学习优秀奖学金（一等）\n  - 科技创新奖学金\n  - CCF CSP 第31次认证 院级二等奖\n  - 第十九届百度之星程序设计大赛初赛 省级三等奖\n  - 2023年第四届全国大学生算法设计与编程挑战赛（秋季赛） 国家级三等奖\n  - 2023年第十三届APMCM亚太地区大学生数学建模竞赛 国家级三等奖\n  - 2023年全国大学生信息技术认证挑战赛 国家级三等奖\n  - 2024年第五届全国大学生算法设计与编程挑战赛（春季赛） 国家级三等奖\n  - 第五届全国高校计算机能力挑战赛-C++ 国家级二等奖\n  - 第十五届蓝桥杯全国软件和信息技术专业人才大赛辽宁赛区 省级二等奖\n  - 2024年美国大学生数学建模竞赛 国家级H奖\n  - 2024年第二届全国大学生信息技术认证挑战赛 国家级三等奖\n  - 2024年中国高校计算机大赛-AIGC创新赛-应用赛道（校赛） 校级一等奖\n  - 2023首届大学生算法大赛 优秀奖\n  - 116积分\n- 身份\n\n### 成绩、科创、后端\n\n- 成绩\n  - 大一学年60 -----> 大二学年12\n  - 过程\n    - 认真听讲\n    - 仔细做笔记\n    - 重复重复重复\n- 科创奖项\n  - 科创积分116\n  - 国家级奖项8项\n  - 作为创中一份子，积极投身于科创竞赛\n- 后端\n  - 开源短链项目\n  - 深入学习MySQL原理\n  - 深入学习Redis原理\n  - 博客\n  - 思路：\n    - 后端架构技术，自学Go语言并积累近2w字学习笔记\n    - 为了更好地提高系统性能，深入学习MySQL、Redis底层原理，与底层C语言实现代码斗智斗勇\n    - 个人博客\n- 科研\n  - 大创（蹭）\n  - 论文\n\n### 学生工作\n\n- 例会\n- 培养大一/二同学\n\n### 总结\n\n## aba\n\n- 自我介绍：一年以来的积累\n  - 特点\n- 目录\n- 过程--->结果\n- 量---->总结过程---->精神\n- 项目：承担什么角色、什么提升\n- 成果罗列页\n\n## 稿子\n\n​    尊敬的各位评委老师，晚上好！我是来自软 2213 班的李源东。很荣幸参加本次国家奖学金汇报。我汇报的主题是 “脚踏实地 源远流长 只争朝夕 勤勉致远”（翻页）\n\n   大二学年，我荣获了一等学习优秀奖学金、校三好学生、科技创新奖学金等荣誉。（翻页）\n\n**一、脚踏实地，实现成绩飞跃**\n\n   面对大一上不尽人意的成绩，我内心充满不甘。我不愿就此消沉，更不愿让父母失望。从此，我成为了自习室的常客、教室前排的坚守者，300余页的笔记，300多个日夜的辛勤努力，终于在大二学年，我实现了专业排名从**33%****到3%****的飞跃**，从**仅有**一门课程成绩90+，到大二学年10门必修课90+。（翻页）\n\n**二、只争朝夕，磨砺科技创新**\n\n​    无论是春华秋实还是冬冷夏热，洛谷、力扣见证了我日复一日的勤奋练习。大二学年，我以汗水浇灌，共获得了12项竞赛荣誉，其中包括8项国家级奖项和2项省级奖项，科创积分也实现了从0到116分的飞跃。（翻页）\n\n   在科研领域，我不仅巩固了理论知识，在研究生的指导下阅读了10余篇论文，还躬行实践，与团队成员共同开发化工大模型大创项目。（翻页）\n\n   我积极探索后端最新技术，深入Go语言的底层原理，探索高性能架构设计，独立搭建了个人博客，分享所见所闻。（翻页）\n\n   至今，已有底层原理笔记近**2万字**，**独立开发并开源**短链系统，发布**20**余篇技术文章，总字数超过**6万字**。（翻页）\n\n**三、饮水思源，散发萤火之光**\n\n   作为腾讯组的核心成员，我不仅积极参与技术栈建设，为团队成员提供丰富的学习资源，还致力于培养团队后端技术人才，积极回应团队成员的疑问。技术栈已收录博客**二十**篇 个人贡献**3**篇 23级组员十人 **百分百** 学习优秀奖学金。用行动诠释**“****有一分热，就要发一分光”**的精神。（翻页）\n\n**总结**\n\n   我始终坚信：不驰于空想，不骛于虚声，唯有以**求实**的态度，**踏实**的工作，才能走得更远。（翻页）\n\n   展望未来，愿我们都能为真理的**源远根深**而只争朝夕，为争做**南金东箭**而拼搏奋斗。\n\n   我的汇报到此结束，谢谢大家。","slug":"换取Mac OS第一步","published":1,"date":"2024-12-27T11:03:15.344Z","updated":"2024-12-27T11:03:15.344Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j0013a5t2bsvu15js","content":"<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ul>\n<li>姓名 </li>\n<li>班级 </li>\n<li>政治面貌<ul>\n<li>共青团员</li>\n</ul>\n</li>\n<li>排名<ul>\n<li><strong>12&#x2F;393</strong></li>\n<li><strong>163 —-&gt; 12</strong></li>\n</ul>\n</li>\n<li>成绩<ul>\n<li><strong>忘了均分</strong></li>\n<li>离散数学2 98</li>\n<li>计算机数学基础 98</li>\n<li>计算机组织与结构 93</li>\n<li>大学物理(软) 96</li>\n<li>操作系统 92</li>\n<li>大学英语3 98</li>\n<li>概率与统计A 99</li>\n<li>数据结构与算法 97</li>\n<li>计算机组织与结构实验 95</li>\n</ul>\n</li>\n<li>获奖情况<ul>\n<li>学习优秀奖学金（一等）</li>\n<li>科技创新奖学金</li>\n<li>CCF CSP 第31次认证 院级二等奖</li>\n<li>第十九届百度之星程序设计大赛初赛 省级三等奖</li>\n<li>2023年第四届全国大学生算法设计与编程挑战赛（秋季赛） 国家级三等奖</li>\n<li>2023年第十三届APMCM亚太地区大学生数学建模竞赛 国家级三等奖</li>\n<li>2023年全国大学生信息技术认证挑战赛 国家级三等奖</li>\n<li>2024年第五届全国大学生算法设计与编程挑战赛（春季赛） 国家级三等奖</li>\n<li>第五届全国高校计算机能力挑战赛-C++ 国家级二等奖</li>\n<li>第十五届蓝桥杯全国软件和信息技术专业人才大赛辽宁赛区 省级二等奖</li>\n<li>2024年美国大学生数学建模竞赛 国家级H奖</li>\n<li>2024年第二届全国大学生信息技术认证挑战赛 国家级三等奖</li>\n<li>2024年中国高校计算机大赛-AIGC创新赛-应用赛道（校赛） 校级一等奖</li>\n<li>2023首届大学生算法大赛 优秀奖</li>\n<li>116积分</li>\n</ul>\n</li>\n<li>身份</li>\n</ul>\n<h3 id=\"成绩、科创、后端\"><a href=\"#成绩、科创、后端\" class=\"headerlink\" title=\"成绩、科创、后端\"></a>成绩、科创、后端</h3><ul>\n<li>成绩<ul>\n<li>大一学年60 —–&gt; 大二学年12</li>\n<li>过程<ul>\n<li>认真听讲</li>\n<li>仔细做笔记</li>\n<li>重复重复重复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>科创奖项<ul>\n<li>科创积分116</li>\n<li>国家级奖项8项</li>\n<li>作为创中一份子，积极投身于科创竞赛</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>开源短链项目</li>\n<li>深入学习MySQL原理</li>\n<li>深入学习Redis原理</li>\n<li>博客</li>\n<li>思路：<ul>\n<li>后端架构技术，自学Go语言并积累近2w字学习笔记</li>\n<li>为了更好地提高系统性能，深入学习MySQL、Redis底层原理，与底层C语言实现代码斗智斗勇</li>\n<li>个人博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>科研<ul>\n<li>大创（蹭）</li>\n<li>论文</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学生工作\"><a href=\"#学生工作\" class=\"headerlink\" title=\"学生工作\"></a>学生工作</h3><ul>\n<li>例会</li>\n<li>培养大一&#x2F;二同学</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h2 id=\"aba\"><a href=\"#aba\" class=\"headerlink\" title=\"aba\"></a>aba</h2><ul>\n<li>自我介绍：一年以来的积累<ul>\n<li>特点</li>\n</ul>\n</li>\n<li>目录</li>\n<li>过程—&gt;结果</li>\n<li>量—-&gt;总结过程—-&gt;精神</li>\n<li>项目：承担什么角色、什么提升</li>\n<li>成果罗列页</li>\n</ul>\n<h2 id=\"稿子\"><a href=\"#稿子\" class=\"headerlink\" title=\"稿子\"></a>稿子</h2><p>​    尊敬的各位评委老师，晚上好！我是来自软 2213 班的李源东。很荣幸参加本次国家奖学金汇报。我汇报的主题是 “脚踏实地 源远流长 只争朝夕 勤勉致远”（翻页）</p>\n<p>   大二学年，我荣获了一等学习优秀奖学金、校三好学生、科技创新奖学金等荣誉。（翻页）</p>\n<p><strong>一、脚踏实地，实现成绩飞跃</strong></p>\n<p>   面对大一上不尽人意的成绩，我内心充满不甘。我不愿就此消沉，更不愿让父母失望。从此，我成为了自习室的常客、教室前排的坚守者，300余页的笔记，300多个日夜的辛勤努力，终于在大二学年，我实现了专业排名从**33%**<strong>到3%*<em><strong>的飞跃</strong>，从</em>*仅有</strong>一门课程成绩90+，到大二学年10门必修课90+。（翻页）</p>\n<p><strong>二、只争朝夕，磨砺科技创新</strong></p>\n<p>​    无论是春华秋实还是冬冷夏热，洛谷、力扣见证了我日复一日的勤奋练习。大二学年，我以汗水浇灌，共获得了12项竞赛荣誉，其中包括8项国家级奖项和2项省级奖项，科创积分也实现了从0到116分的飞跃。（翻页）</p>\n<p>   在科研领域，我不仅巩固了理论知识，在研究生的指导下阅读了10余篇论文，还躬行实践，与团队成员共同开发化工大模型大创项目。（翻页）</p>\n<p>   我积极探索后端最新技术，深入Go语言的底层原理，探索高性能架构设计，独立搭建了个人博客，分享所见所闻。（翻页）</p>\n<p>   至今，已有底层原理笔记近<strong>2万字</strong>，<strong>独立开发并开源</strong>短链系统，发布<strong>20</strong>余篇技术文章，总字数超过<strong>6万字</strong>。（翻页）</p>\n<p><strong>三、饮水思源，散发萤火之光</strong></p>\n<p>   作为腾讯组的核心成员，我不仅积极参与技术栈建设，为团队成员提供丰富的学习资源，还致力于培养团队后端技术人才，积极回应团队成员的疑问。技术栈已收录博客<strong>二十</strong>篇 个人贡献<strong>3</strong>篇 23级组员十人 <strong>百分百</strong> 学习优秀奖学金。用行动诠释<strong>“****有一分热，就要发一分光”</strong>的精神。（翻页）</p>\n<p><strong>总结</strong></p>\n<p>   我始终坚信：不驰于空想，不骛于虚声，唯有以<strong>求实</strong>的态度，<strong>踏实</strong>的工作，才能走得更远。（翻页）</p>\n<p>   展望未来，愿我们都能为真理的<strong>源远根深</strong>而只争朝夕，为争做<strong>南金东箭</strong>而拼搏奋斗。</p>\n<p>   我的汇报到此结束，谢谢大家。</p>\n","excerpt":"","more":"<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><ul>\n<li>姓名 </li>\n<li>班级 </li>\n<li>政治面貌<ul>\n<li>共青团员</li>\n</ul>\n</li>\n<li>排名<ul>\n<li><strong>12&#x2F;393</strong></li>\n<li><strong>163 —-&gt; 12</strong></li>\n</ul>\n</li>\n<li>成绩<ul>\n<li><strong>忘了均分</strong></li>\n<li>离散数学2 98</li>\n<li>计算机数学基础 98</li>\n<li>计算机组织与结构 93</li>\n<li>大学物理(软) 96</li>\n<li>操作系统 92</li>\n<li>大学英语3 98</li>\n<li>概率与统计A 99</li>\n<li>数据结构与算法 97</li>\n<li>计算机组织与结构实验 95</li>\n</ul>\n</li>\n<li>获奖情况<ul>\n<li>学习优秀奖学金（一等）</li>\n<li>科技创新奖学金</li>\n<li>CCF CSP 第31次认证 院级二等奖</li>\n<li>第十九届百度之星程序设计大赛初赛 省级三等奖</li>\n<li>2023年第四届全国大学生算法设计与编程挑战赛（秋季赛） 国家级三等奖</li>\n<li>2023年第十三届APMCM亚太地区大学生数学建模竞赛 国家级三等奖</li>\n<li>2023年全国大学生信息技术认证挑战赛 国家级三等奖</li>\n<li>2024年第五届全国大学生算法设计与编程挑战赛（春季赛） 国家级三等奖</li>\n<li>第五届全国高校计算机能力挑战赛-C++ 国家级二等奖</li>\n<li>第十五届蓝桥杯全国软件和信息技术专业人才大赛辽宁赛区 省级二等奖</li>\n<li>2024年美国大学生数学建模竞赛 国家级H奖</li>\n<li>2024年第二届全国大学生信息技术认证挑战赛 国家级三等奖</li>\n<li>2024年中国高校计算机大赛-AIGC创新赛-应用赛道（校赛） 校级一等奖</li>\n<li>2023首届大学生算法大赛 优秀奖</li>\n<li>116积分</li>\n</ul>\n</li>\n<li>身份</li>\n</ul>\n<h3 id=\"成绩、科创、后端\"><a href=\"#成绩、科创、后端\" class=\"headerlink\" title=\"成绩、科创、后端\"></a>成绩、科创、后端</h3><ul>\n<li>成绩<ul>\n<li>大一学年60 —–&gt; 大二学年12</li>\n<li>过程<ul>\n<li>认真听讲</li>\n<li>仔细做笔记</li>\n<li>重复重复重复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>科创奖项<ul>\n<li>科创积分116</li>\n<li>国家级奖项8项</li>\n<li>作为创中一份子，积极投身于科创竞赛</li>\n</ul>\n</li>\n<li>后端<ul>\n<li>开源短链项目</li>\n<li>深入学习MySQL原理</li>\n<li>深入学习Redis原理</li>\n<li>博客</li>\n<li>思路：<ul>\n<li>后端架构技术，自学Go语言并积累近2w字学习笔记</li>\n<li>为了更好地提高系统性能，深入学习MySQL、Redis底层原理，与底层C语言实现代码斗智斗勇</li>\n<li>个人博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>科研<ul>\n<li>大创（蹭）</li>\n<li>论文</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"学生工作\"><a href=\"#学生工作\" class=\"headerlink\" title=\"学生工作\"></a>学生工作</h3><ul>\n<li>例会</li>\n<li>培养大一&#x2F;二同学</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h2 id=\"aba\"><a href=\"#aba\" class=\"headerlink\" title=\"aba\"></a>aba</h2><ul>\n<li>自我介绍：一年以来的积累<ul>\n<li>特点</li>\n</ul>\n</li>\n<li>目录</li>\n<li>过程—&gt;结果</li>\n<li>量—-&gt;总结过程—-&gt;精神</li>\n<li>项目：承担什么角色、什么提升</li>\n<li>成果罗列页</li>\n</ul>\n<h2 id=\"稿子\"><a href=\"#稿子\" class=\"headerlink\" title=\"稿子\"></a>稿子</h2><p>​    尊敬的各位评委老师，晚上好！我是来自软 2213 班的李源东。很荣幸参加本次国家奖学金汇报。我汇报的主题是 “脚踏实地 源远流长 只争朝夕 勤勉致远”（翻页）</p>\n<p>   大二学年，我荣获了一等学习优秀奖学金、校三好学生、科技创新奖学金等荣誉。（翻页）</p>\n<p><strong>一、脚踏实地，实现成绩飞跃</strong></p>\n<p>   面对大一上不尽人意的成绩，我内心充满不甘。我不愿就此消沉，更不愿让父母失望。从此，我成为了自习室的常客、教室前排的坚守者，300余页的笔记，300多个日夜的辛勤努力，终于在大二学年，我实现了专业排名从**33%**<strong>到3%*<em><strong>的飞跃</strong>，从</em>*仅有</strong>一门课程成绩90+，到大二学年10门必修课90+。（翻页）</p>\n<p><strong>二、只争朝夕，磨砺科技创新</strong></p>\n<p>​    无论是春华秋实还是冬冷夏热，洛谷、力扣见证了我日复一日的勤奋练习。大二学年，我以汗水浇灌，共获得了12项竞赛荣誉，其中包括8项国家级奖项和2项省级奖项，科创积分也实现了从0到116分的飞跃。（翻页）</p>\n<p>   在科研领域，我不仅巩固了理论知识，在研究生的指导下阅读了10余篇论文，还躬行实践，与团队成员共同开发化工大模型大创项目。（翻页）</p>\n<p>   我积极探索后端最新技术，深入Go语言的底层原理，探索高性能架构设计，独立搭建了个人博客，分享所见所闻。（翻页）</p>\n<p>   至今，已有底层原理笔记近<strong>2万字</strong>，<strong>独立开发并开源</strong>短链系统，发布<strong>20</strong>余篇技术文章，总字数超过<strong>6万字</strong>。（翻页）</p>\n<p><strong>三、饮水思源，散发萤火之光</strong></p>\n<p>   作为腾讯组的核心成员，我不仅积极参与技术栈建设，为团队成员提供丰富的学习资源，还致力于培养团队后端技术人才，积极回应团队成员的疑问。技术栈已收录博客<strong>二十</strong>篇 个人贡献<strong>3</strong>篇 23级组员十人 <strong>百分百</strong> 学习优秀奖学金。用行动诠释<strong>“****有一分热，就要发一分光”</strong>的精神。（翻页）</p>\n<p><strong>总结</strong></p>\n<p>   我始终坚信：不驰于空想，不骛于虚声，唯有以<strong>求实</strong>的态度，<strong>踏实</strong>的工作，才能走得更远。（翻页）</p>\n<p>   展望未来，愿我们都能为真理的<strong>源远根深</strong>而只争朝夕，为争做<strong>南金东箭</strong>而拼搏奋斗。</p>\n<p>   我的汇报到此结束，谢谢大家。</p>\n"},{"publish":false,"_content":"\n\n\n# 用户态和内核态\n\n> 为什么要区分内核态和用户态？\n>\n> 内核态和用户态之间是如何切换的？\n>\n> 什么时候会陷入内核态？\n>\n> 用户线程和内核线程的区别？\n\n","source":"_posts/用户态和内核态.md","raw":"---\npublish: false\n---\n\n\n\n# 用户态和内核态\n\n> 为什么要区分内核态和用户态？\n>\n> 内核态和用户态之间是如何切换的？\n>\n> 什么时候会陷入内核态？\n>\n> 用户线程和内核线程的区别？\n\n","slug":"用户态和内核态","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6j0016a5t2d1iubhgl","content":"<h1 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h1><blockquote>\n<p>为什么要区分内核态和用户态？</p>\n<p>内核态和用户态之间是如何切换的？</p>\n<p>什么时候会陷入内核态？</p>\n<p>用户线程和内核线程的区别？</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h1><blockquote>\n<p>为什么要区分内核态和用户态？</p>\n<p>内核态和用户态之间是如何切换的？</p>\n<p>什么时候会陷入内核态？</p>\n<p>用户线程和内核线程的区别？</p>\n</blockquote>\n"},{"title":"短链系统","description":"记录短链系统制作","publish":true,"_content":"\n\n\n# 短链系统\n\n## 认识短链\n\n短链即短链接，例如[这个链接](http://gk.link/a/10q2I)，很简短。而长链接或者叫做原始链接则有一点长，例如[这个链接](https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D)\n\n可以发现，上述两个链接都跳转至同一个页面，那么有了原始链接后，为什么还要生成一个短链接？或者说短链接有什么价值🤔？\n\n相比于原始链接，短链的优势就在于**短**。因此，短链在实际应用中具有如下优势：\n\n- **简洁明了**：只需要简单几个字符就能实现[超长链接](https://mp.weixin.qq.com/s?__biz=MzA4MjIyNTY0MQ==&mid=2647743787&idx=1&sn=1caec8eb1b81d6ee5dd7ba7fa05ac0f1&chksm=87ad0dadb0da84bb7beb5e4373a14e89fba1130c1bd2a51f4baa8021ec0abe496ce94603b6b4&token=894028224&lang=zh_CN#rd)的跳转功能\n- **便于使用**\n  - 相同字符限制情况下，短链可以传递更多信息\n  - 用短链生成的二维码更容易被识别\n- **节约成本**：有些平台的短信服务按照字符数计费，从这个角度出发，短链可以节约成本\n\n### 短链的原理\n\n以这个[短链](http://gk.link/a/10q2I)为例子，探究短链的原理\n\n输入`curl -i http://gk.link/a/10q2I`命令，其中`-i`表示**连带相应头**一同输出，结果如下图所示：\n\n![image-20241015184327080](https://raw.githubusercontent.com/lyydsheep/pic/main/202410151843629.png)\n\n其中有两个重要信息已经被我框起来了。\n\n**相应状态码302**表示临时重定向，用于告知接收方当前地址只是一个临时地址，真正的地址在`Location`字段中\n\n**头部字段Location**代表了真正的目的地址，当接收方收到这个响应后，会取出并访问Location字段中的地址\n\n![image-20241015185124443](https://raw.githubusercontent.com/lyydsheep/pic/main/202410151851474.png)\n\n简单概括，我们访问一个极短的链接，然后重定向到原始地址（一般原始地址比短链长得多）\n\n### 如何生成短链\n\n#### 哈希算法\n\n很显然，短链和原始链接最好是一对一关系。那么可以将问题转换成**如何为一个链接找到唯一的对应值？**\n\n一种很直接的想法：我们可以将原始链接通过一次（或多次）**哈希计算**，得到一个对应值。但是现如今有众多哈希算法，例如MD5、SHA-1、SHA-256，又该如何选择？\n\n我们可以从加密程度的角度将哈希算法分为两大类：**加密哈希**、**非加密哈希**。当输入值经过加密哈希计算后，无法从输出值反推出输入值，保证了输入值的安全性，但代价是需要耗费更多的计算资源（时间）。在短链场景中，相较于原文的保密性，运算速度是我们更加关心的因素。因此，可以采用非加密哈希，例如[MurmurHash](https://www.ifuyun.com/tool/murmurhash)，来生成短链。\n\n使用哈希算法的场景，不可避免会出现**哈希冲突**问题即不同的输入值通过哈希计算时得到了相同的输出值。借鉴`bcrypt`加密算法中的**加盐**操作，当某一个输入值发生哈希冲突后，可以在添加一段**特殊字符**后再进行哈希运算，反复操作直至冲突消失。\n\n```go\n/*\nwww.baidu.com\n哈希冲突 ---> 添加特殊字符\nwww.baidu.com[hello_world]\n*/\n```\n\n通过哈希算法得到一个数值后，例如3510643912，我们还可以利用**62进制（0-9、a-z、A-Z共62个URL合法字符）**将结果进一步缩短\n\n🌰：3510643912 ---> 3PAiQU，这样我们就可以利用更短的字符串作为短链\n\n#### 唯一ID算法\n\n除了使用哈希算法简化长链，还能为每一个长链请求分配一个唯一的ID，这个唯一ID就相当于哈希算法中的哈希值。当然，唯一ID也能在**base62进制**下进一步化简\n\n那么现在的问题就是，**如何设计一个ID分号器？**\n\n##### MySQL自增ID分号\n\n通过MySQL自增主键为长链分发一个唯一ID，但这种方法存在**高并发性能问题**。一种解决思路是：预先为集群中的每一个服务分配一个可用的ID范围，只有当服务中可使用的ID不足时才会向数据源请求新的ID\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161917898.png\" alt=\"image-20241016191703853\" style=\"zoom:50%;\" />\n\n如上图所示，`biz_tag`表示业务类型，`max_id`表示当前业务可分发的最大ID，`step`表示步长，即每个服务一次预可申请多少个ID号码\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161920030.png\" alt=\"image-20241016191959985\" style=\"zoom:50%;\" />\n\n当ID不够用了，就像数据库再申请一批\n\n此外，还可以引入**队列缓冲 + 批量写入**架构，在区间快满时就申请一批新的ID号码，等区间满了再一次性写入数据库中，实现异步进行获取和写入操作，保证服务持续的高并发\n\n例如，**现有10000个ID号码，当剩余的ID号不足1000时，就向数据源请求再分发10000个ID号，在上一批ID用完时，将数据批量写入数据库中**\n\nMySQL自增ID优点：\n\n- 简单方便，容易实现\n\n缺点：\n\n- 整体性能吞吐量低，高并发场景下容易出现单点瓶颈\n\n##### Redis自增ID\n\nRedis基于内存实现，并发性能高（10w），但使用Redis作为分号器需要考虑**持久化和灾备**\n\n优点：\n\n- 整体吞吐量比数据好\n\n缺点：\n\n- Redis实例或集群宕机后，很难找回最新的ID\n\n##### 雪花算法生成ID\n\n前两种方案都是远程ID生成，一般来说，远程ID生成效率（本身对应的组件耗时 + 网络耗时）不如本地ID生成。雪花算法生成ID方案就是一种本地ID方案，不依赖于其他的服务。\n\n雪花算法使用一个long类型的整数（64位bit）来表示一个ID，具体由**1bit空闲 + 41bit时间戳（毫秒级别） + 10bit机器ID（或机房ID + 机器ID） + 12bit序列号**组成。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161948837.png\" alt=\"image-20241016194848744\" style=\"zoom:50%;\" />\n\n优点：\n\n- 高性能、低延迟、去中心化、整体按时间有序\n\n缺点：\n\n- 要求机器时间同步在秒级别，否则会产生ID冲突\n- 如果某台机器时钟回拨这有可能发生ID冲突\n\n## 设计短链\n\n### 重定向状态码的选择\n\n由之前的分析我们知道了短链系统的大致工作原理：浏览器访问短链，短链服务向浏览器返回一个**重定向状态码**和**对应的长链**。接着，浏览器访问长链获取并获取到目标资源。\n\n![image-20241015185124443](https://raw.githubusercontent.com/lyydsheep/pic/main/202410182126756.png)\n\n在短链系统中一般只考虑使用**永久重定向301**或**临时重定向302**状态码\n\n两个状态码区别如下：\n\n- **301状态码表示永久重定向，浏览器收到改状态码时，会将`Location`字段值缓存在本地，当将再次访问短链时就直接从缓存中拿出长链地址并访问，节约了一次访问短链服务的次数**\n- **302状态码表示临时重定向，浏览器不会缓存响应头部中的`Location`字段**\n- **在短链系统中，浏览器的缓存行为可能并非是我们预期的，尤其需要对短链进行分析的情况**\n  - 🌰：将一个短链通过短信发送给1w个用户，如果使用302状态码就可以测试出这1w个用户针对短链的点击次数。但是在使用301状态码情况下，每一个用户最多只会被统计一次。（因为浏览器缓存了长链地址）\n\n### 接口设计","source":"_posts/短链系统.md","raw":"---\ntitle: 短链系统\ndescription: 记录短链系统制作\npublish: true\ntag:\n- 项目\n---\n\n\n\n# 短链系统\n\n## 认识短链\n\n短链即短链接，例如[这个链接](http://gk.link/a/10q2I)，很简短。而长链接或者叫做原始链接则有一点长，例如[这个链接](https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D)\n\n可以发现，上述两个链接都跳转至同一个页面，那么有了原始链接后，为什么还要生成一个短链接？或者说短链接有什么价值🤔？\n\n相比于原始链接，短链的优势就在于**短**。因此，短链在实际应用中具有如下优势：\n\n- **简洁明了**：只需要简单几个字符就能实现[超长链接](https://mp.weixin.qq.com/s?__biz=MzA4MjIyNTY0MQ==&mid=2647743787&idx=1&sn=1caec8eb1b81d6ee5dd7ba7fa05ac0f1&chksm=87ad0dadb0da84bb7beb5e4373a14e89fba1130c1bd2a51f4baa8021ec0abe496ce94603b6b4&token=894028224&lang=zh_CN#rd)的跳转功能\n- **便于使用**\n  - 相同字符限制情况下，短链可以传递更多信息\n  - 用短链生成的二维码更容易被识别\n- **节约成本**：有些平台的短信服务按照字符数计费，从这个角度出发，短链可以节约成本\n\n### 短链的原理\n\n以这个[短链](http://gk.link/a/10q2I)为例子，探究短链的原理\n\n输入`curl -i http://gk.link/a/10q2I`命令，其中`-i`表示**连带相应头**一同输出，结果如下图所示：\n\n![image-20241015184327080](https://raw.githubusercontent.com/lyydsheep/pic/main/202410151843629.png)\n\n其中有两个重要信息已经被我框起来了。\n\n**相应状态码302**表示临时重定向，用于告知接收方当前地址只是一个临时地址，真正的地址在`Location`字段中\n\n**头部字段Location**代表了真正的目的地址，当接收方收到这个响应后，会取出并访问Location字段中的地址\n\n![image-20241015185124443](https://raw.githubusercontent.com/lyydsheep/pic/main/202410151851474.png)\n\n简单概括，我们访问一个极短的链接，然后重定向到原始地址（一般原始地址比短链长得多）\n\n### 如何生成短链\n\n#### 哈希算法\n\n很显然，短链和原始链接最好是一对一关系。那么可以将问题转换成**如何为一个链接找到唯一的对应值？**\n\n一种很直接的想法：我们可以将原始链接通过一次（或多次）**哈希计算**，得到一个对应值。但是现如今有众多哈希算法，例如MD5、SHA-1、SHA-256，又该如何选择？\n\n我们可以从加密程度的角度将哈希算法分为两大类：**加密哈希**、**非加密哈希**。当输入值经过加密哈希计算后，无法从输出值反推出输入值，保证了输入值的安全性，但代价是需要耗费更多的计算资源（时间）。在短链场景中，相较于原文的保密性，运算速度是我们更加关心的因素。因此，可以采用非加密哈希，例如[MurmurHash](https://www.ifuyun.com/tool/murmurhash)，来生成短链。\n\n使用哈希算法的场景，不可避免会出现**哈希冲突**问题即不同的输入值通过哈希计算时得到了相同的输出值。借鉴`bcrypt`加密算法中的**加盐**操作，当某一个输入值发生哈希冲突后，可以在添加一段**特殊字符**后再进行哈希运算，反复操作直至冲突消失。\n\n```go\n/*\nwww.baidu.com\n哈希冲突 ---> 添加特殊字符\nwww.baidu.com[hello_world]\n*/\n```\n\n通过哈希算法得到一个数值后，例如3510643912，我们还可以利用**62进制（0-9、a-z、A-Z共62个URL合法字符）**将结果进一步缩短\n\n🌰：3510643912 ---> 3PAiQU，这样我们就可以利用更短的字符串作为短链\n\n#### 唯一ID算法\n\n除了使用哈希算法简化长链，还能为每一个长链请求分配一个唯一的ID，这个唯一ID就相当于哈希算法中的哈希值。当然，唯一ID也能在**base62进制**下进一步化简\n\n那么现在的问题就是，**如何设计一个ID分号器？**\n\n##### MySQL自增ID分号\n\n通过MySQL自增主键为长链分发一个唯一ID，但这种方法存在**高并发性能问题**。一种解决思路是：预先为集群中的每一个服务分配一个可用的ID范围，只有当服务中可使用的ID不足时才会向数据源请求新的ID\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161917898.png\" alt=\"image-20241016191703853\" style=\"zoom:50%;\" />\n\n如上图所示，`biz_tag`表示业务类型，`max_id`表示当前业务可分发的最大ID，`step`表示步长，即每个服务一次预可申请多少个ID号码\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161920030.png\" alt=\"image-20241016191959985\" style=\"zoom:50%;\" />\n\n当ID不够用了，就像数据库再申请一批\n\n此外，还可以引入**队列缓冲 + 批量写入**架构，在区间快满时就申请一批新的ID号码，等区间满了再一次性写入数据库中，实现异步进行获取和写入操作，保证服务持续的高并发\n\n例如，**现有10000个ID号码，当剩余的ID号不足1000时，就向数据源请求再分发10000个ID号，在上一批ID用完时，将数据批量写入数据库中**\n\nMySQL自增ID优点：\n\n- 简单方便，容易实现\n\n缺点：\n\n- 整体性能吞吐量低，高并发场景下容易出现单点瓶颈\n\n##### Redis自增ID\n\nRedis基于内存实现，并发性能高（10w），但使用Redis作为分号器需要考虑**持久化和灾备**\n\n优点：\n\n- 整体吞吐量比数据好\n\n缺点：\n\n- Redis实例或集群宕机后，很难找回最新的ID\n\n##### 雪花算法生成ID\n\n前两种方案都是远程ID生成，一般来说，远程ID生成效率（本身对应的组件耗时 + 网络耗时）不如本地ID生成。雪花算法生成ID方案就是一种本地ID方案，不依赖于其他的服务。\n\n雪花算法使用一个long类型的整数（64位bit）来表示一个ID，具体由**1bit空闲 + 41bit时间戳（毫秒级别） + 10bit机器ID（或机房ID + 机器ID） + 12bit序列号**组成。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161948837.png\" alt=\"image-20241016194848744\" style=\"zoom:50%;\" />\n\n优点：\n\n- 高性能、低延迟、去中心化、整体按时间有序\n\n缺点：\n\n- 要求机器时间同步在秒级别，否则会产生ID冲突\n- 如果某台机器时钟回拨这有可能发生ID冲突\n\n## 设计短链\n\n### 重定向状态码的选择\n\n由之前的分析我们知道了短链系统的大致工作原理：浏览器访问短链，短链服务向浏览器返回一个**重定向状态码**和**对应的长链**。接着，浏览器访问长链获取并获取到目标资源。\n\n![image-20241015185124443](https://raw.githubusercontent.com/lyydsheep/pic/main/202410182126756.png)\n\n在短链系统中一般只考虑使用**永久重定向301**或**临时重定向302**状态码\n\n两个状态码区别如下：\n\n- **301状态码表示永久重定向，浏览器收到改状态码时，会将`Location`字段值缓存在本地，当将再次访问短链时就直接从缓存中拿出长链地址并访问，节约了一次访问短链服务的次数**\n- **302状态码表示临时重定向，浏览器不会缓存响应头部中的`Location`字段**\n- **在短链系统中，浏览器的缓存行为可能并非是我们预期的，尤其需要对短链进行分析的情况**\n  - 🌰：将一个短链通过短信发送给1w个用户，如果使用302状态码就可以测试出这1w个用户针对短链的点击次数。但是在使用301状态码情况下，每一个用户最多只会被统计一次。（因为浏览器缓存了长链地址）\n\n### 接口设计","slug":"短链系统","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6k0018a5t20hb54uqq","content":"<h1 id=\"短链系统\"><a href=\"#短链系统\" class=\"headerlink\" title=\"短链系统\"></a>短链系统</h1><h2 id=\"认识短链\"><a href=\"#认识短链\" class=\"headerlink\" title=\"认识短链\"></a>认识短链</h2><p>短链即短链接，例如<a href=\"http://gk.link/a/10q2I\">这个链接</a>，很简短。而长链接或者叫做原始链接则有一点长，例如<a href=\"https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI=\">这个链接</a></p>\n<p>可以发现，上述两个链接都跳转至同一个页面，那么有了原始链接后，为什么还要生成一个短链接？或者说短链接有什么价值🤔？</p>\n<p>相比于原始链接，短链的优势就在于<strong>短</strong>。因此，短链在实际应用中具有如下优势：</p>\n<ul>\n<li><strong>简洁明了</strong>：只需要简单几个字符就能实现<a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MjIyNTY0MQ==&mid=2647743787&idx=1&sn=1caec8eb1b81d6ee5dd7ba7fa05ac0f1&chksm=87ad0dadb0da84bb7beb5e4373a14e89fba1130c1bd2a51f4baa8021ec0abe496ce94603b6b4&token=894028224&lang=zh_CN#rd\">超长链接</a>的跳转功能</li>\n<li><strong>便于使用</strong><ul>\n<li>相同字符限制情况下，短链可以传递更多信息</li>\n<li>用短链生成的二维码更容易被识别</li>\n</ul>\n</li>\n<li><strong>节约成本</strong>：有些平台的短信服务按照字符数计费，从这个角度出发，短链可以节约成本</li>\n</ul>\n<h3 id=\"短链的原理\"><a href=\"#短链的原理\" class=\"headerlink\" title=\"短链的原理\"></a>短链的原理</h3><p>以这个<a href=\"http://gk.link/a/10q2I\">短链</a>为例子，探究短链的原理</p>\n<p>输入<code>curl -i http://gk.link/a/10q2I</code>命令，其中<code>-i</code>表示<strong>连带相应头</strong>一同输出，结果如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410151843629.png\" alt=\"image-20241015184327080\"></p>\n<p>其中有两个重要信息已经被我框起来了。</p>\n<p><strong>相应状态码302</strong>表示临时重定向，用于告知接收方当前地址只是一个临时地址，真正的地址在<code>Location</code>字段中</p>\n<p><strong>头部字段Location</strong>代表了真正的目的地址，当接收方收到这个响应后，会取出并访问Location字段中的地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410151851474.png\" alt=\"image-20241015185124443\"></p>\n<p>简单概括，我们访问一个极短的链接，然后重定向到原始地址（一般原始地址比短链长得多）</p>\n<h3 id=\"如何生成短链\"><a href=\"#如何生成短链\" class=\"headerlink\" title=\"如何生成短链\"></a>如何生成短链</h3><h4 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h4><p>很显然，短链和原始链接最好是一对一关系。那么可以将问题转换成<strong>如何为一个链接找到唯一的对应值？</strong></p>\n<p>一种很直接的想法：我们可以将原始链接通过一次（或多次）<strong>哈希计算</strong>，得到一个对应值。但是现如今有众多哈希算法，例如MD5、SHA-1、SHA-256，又该如何选择？</p>\n<p>我们可以从加密程度的角度将哈希算法分为两大类：<strong>加密哈希</strong>、<strong>非加密哈希</strong>。当输入值经过加密哈希计算后，无法从输出值反推出输入值，保证了输入值的安全性，但代价是需要耗费更多的计算资源（时间）。在短链场景中，相较于原文的保密性，运算速度是我们更加关心的因素。因此，可以采用非加密哈希，例如<a href=\"https://www.ifuyun.com/tool/murmurhash\">MurmurHash</a>，来生成短链。</p>\n<p>使用哈希算法的场景，不可避免会出现<strong>哈希冲突</strong>问题即不同的输入值通过哈希计算时得到了相同的输出值。借鉴<code>bcrypt</code>加密算法中的<strong>加盐</strong>操作，当某一个输入值发生哈希冲突后，可以在添加一段<strong>特殊字符</strong>后再进行哈希运算，反复操作直至冲突消失。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">www.baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">哈希冲突 ---&gt; 添加特殊字符</span></span><br><span class=\"line\"><span class=\"comment\">www.baidu.com[hello_world]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>通过哈希算法得到一个数值后，例如3510643912，我们还可以利用<strong>62进制（0-9、a-z、A-Z共62个URL合法字符）</strong>将结果进一步缩短</p>\n<p>🌰：3510643912 —&gt; 3PAiQU，这样我们就可以利用更短的字符串作为短链</p>\n<h4 id=\"唯一ID算法\"><a href=\"#唯一ID算法\" class=\"headerlink\" title=\"唯一ID算法\"></a>唯一ID算法</h4><p>除了使用哈希算法简化长链，还能为每一个长链请求分配一个唯一的ID，这个唯一ID就相当于哈希算法中的哈希值。当然，唯一ID也能在<strong>base62进制</strong>下进一步化简</p>\n<p>那么现在的问题就是，<strong>如何设计一个ID分号器？</strong></p>\n<h5 id=\"MySQL自增ID分号\"><a href=\"#MySQL自增ID分号\" class=\"headerlink\" title=\"MySQL自增ID分号\"></a>MySQL自增ID分号</h5><p>通过MySQL自增主键为长链分发一个唯一ID，但这种方法存在<strong>高并发性能问题</strong>。一种解决思路是：预先为集群中的每一个服务分配一个可用的ID范围，只有当服务中可使用的ID不足时才会向数据源请求新的ID</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161917898.png\" alt=\"image-20241016191703853\" style=\"zoom:50%;\" />\n\n<p>如上图所示，<code>biz_tag</code>表示业务类型，<code>max_id</code>表示当前业务可分发的最大ID，<code>step</code>表示步长，即每个服务一次预可申请多少个ID号码</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161920030.png\" alt=\"image-20241016191959985\" style=\"zoom:50%;\" />\n\n<p>当ID不够用了，就像数据库再申请一批</p>\n<p>此外，还可以引入<strong>队列缓冲 + 批量写入</strong>架构，在区间快满时就申请一批新的ID号码，等区间满了再一次性写入数据库中，实现异步进行获取和写入操作，保证服务持续的高并发</p>\n<p>例如，<strong>现有10000个ID号码，当剩余的ID号不足1000时，就向数据源请求再分发10000个ID号，在上一批ID用完时，将数据批量写入数据库中</strong></p>\n<p>MySQL自增ID优点：</p>\n<ul>\n<li>简单方便，容易实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>整体性能吞吐量低，高并发场景下容易出现单点瓶颈</li>\n</ul>\n<h5 id=\"Redis自增ID\"><a href=\"#Redis自增ID\" class=\"headerlink\" title=\"Redis自增ID\"></a>Redis自增ID</h5><p>Redis基于内存实现，并发性能高（10w），但使用Redis作为分号器需要考虑<strong>持久化和灾备</strong></p>\n<p>优点：</p>\n<ul>\n<li>整体吞吐量比数据好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>Redis实例或集群宕机后，很难找回最新的ID</li>\n</ul>\n<h5 id=\"雪花算法生成ID\"><a href=\"#雪花算法生成ID\" class=\"headerlink\" title=\"雪花算法生成ID\"></a>雪花算法生成ID</h5><p>前两种方案都是远程ID生成，一般来说，远程ID生成效率（本身对应的组件耗时 + 网络耗时）不如本地ID生成。雪花算法生成ID方案就是一种本地ID方案，不依赖于其他的服务。</p>\n<p>雪花算法使用一个long类型的整数（64位bit）来表示一个ID，具体由<strong>1bit空闲 + 41bit时间戳（毫秒级别） + 10bit机器ID（或机房ID + 机器ID） + 12bit序列号</strong>组成。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161948837.png\" alt=\"image-20241016194848744\" style=\"zoom:50%;\" />\n\n<p>优点：</p>\n<ul>\n<li>高性能、低延迟、去中心化、整体按时间有序</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>要求机器时间同步在秒级别，否则会产生ID冲突</li>\n<li>如果某台机器时钟回拨这有可能发生ID冲突</li>\n</ul>\n<h2 id=\"设计短链\"><a href=\"#设计短链\" class=\"headerlink\" title=\"设计短链\"></a>设计短链</h2><h3 id=\"重定向状态码的选择\"><a href=\"#重定向状态码的选择\" class=\"headerlink\" title=\"重定向状态码的选择\"></a>重定向状态码的选择</h3><p>由之前的分析我们知道了短链系统的大致工作原理：浏览器访问短链，短链服务向浏览器返回一个<strong>重定向状态码</strong>和<strong>对应的长链</strong>。接着，浏览器访问长链获取并获取到目标资源。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410182126756.png\" alt=\"image-20241015185124443\"></p>\n<p>在短链系统中一般只考虑使用<strong>永久重定向301</strong>或<strong>临时重定向302</strong>状态码</p>\n<p>两个状态码区别如下：</p>\n<ul>\n<li><strong>301状态码表示永久重定向，浏览器收到改状态码时，会将<code>Location</code>字段值缓存在本地，当将再次访问短链时就直接从缓存中拿出长链地址并访问，节约了一次访问短链服务的次数</strong></li>\n<li><strong>302状态码表示临时重定向，浏览器不会缓存响应头部中的<code>Location</code>字段</strong></li>\n<li><strong>在短链系统中，浏览器的缓存行为可能并非是我们预期的，尤其需要对短链进行分析的情况</strong><ul>\n<li>🌰：将一个短链通过短信发送给1w个用户，如果使用302状态码就可以测试出这1w个用户针对短链的点击次数。但是在使用301状态码情况下，每一个用户最多只会被统计一次。（因为浏览器缓存了长链地址）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h3>","excerpt":"","more":"<h1 id=\"短链系统\"><a href=\"#短链系统\" class=\"headerlink\" title=\"短链系统\"></a>短链系统</h1><h2 id=\"认识短链\"><a href=\"#认识短链\" class=\"headerlink\" title=\"认识短链\"></a>认识短链</h2><p>短链即短链接，例如<a href=\"http://gk.link/a/10q2I\">这个链接</a>，很简短。而长链接或者叫做原始链接则有一点长，例如<a href=\"https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI=\">这个链接</a></p>\n<p>可以发现，上述两个链接都跳转至同一个页面，那么有了原始链接后，为什么还要生成一个短链接？或者说短链接有什么价值🤔？</p>\n<p>相比于原始链接，短链的优势就在于<strong>短</strong>。因此，短链在实际应用中具有如下优势：</p>\n<ul>\n<li><strong>简洁明了</strong>：只需要简单几个字符就能实现<a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MjIyNTY0MQ==&mid=2647743787&idx=1&sn=1caec8eb1b81d6ee5dd7ba7fa05ac0f1&chksm=87ad0dadb0da84bb7beb5e4373a14e89fba1130c1bd2a51f4baa8021ec0abe496ce94603b6b4&token=894028224&lang=zh_CN#rd\">超长链接</a>的跳转功能</li>\n<li><strong>便于使用</strong><ul>\n<li>相同字符限制情况下，短链可以传递更多信息</li>\n<li>用短链生成的二维码更容易被识别</li>\n</ul>\n</li>\n<li><strong>节约成本</strong>：有些平台的短信服务按照字符数计费，从这个角度出发，短链可以节约成本</li>\n</ul>\n<h3 id=\"短链的原理\"><a href=\"#短链的原理\" class=\"headerlink\" title=\"短链的原理\"></a>短链的原理</h3><p>以这个<a href=\"http://gk.link/a/10q2I\">短链</a>为例子，探究短链的原理</p>\n<p>输入<code>curl -i http://gk.link/a/10q2I</code>命令，其中<code>-i</code>表示<strong>连带相应头</strong>一同输出，结果如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410151843629.png\" alt=\"image-20241015184327080\"></p>\n<p>其中有两个重要信息已经被我框起来了。</p>\n<p><strong>相应状态码302</strong>表示临时重定向，用于告知接收方当前地址只是一个临时地址，真正的地址在<code>Location</code>字段中</p>\n<p><strong>头部字段Location</strong>代表了真正的目的地址，当接收方收到这个响应后，会取出并访问Location字段中的地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410151851474.png\" alt=\"image-20241015185124443\"></p>\n<p>简单概括，我们访问一个极短的链接，然后重定向到原始地址（一般原始地址比短链长得多）</p>\n<h3 id=\"如何生成短链\"><a href=\"#如何生成短链\" class=\"headerlink\" title=\"如何生成短链\"></a>如何生成短链</h3><h4 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h4><p>很显然，短链和原始链接最好是一对一关系。那么可以将问题转换成<strong>如何为一个链接找到唯一的对应值？</strong></p>\n<p>一种很直接的想法：我们可以将原始链接通过一次（或多次）<strong>哈希计算</strong>，得到一个对应值。但是现如今有众多哈希算法，例如MD5、SHA-1、SHA-256，又该如何选择？</p>\n<p>我们可以从加密程度的角度将哈希算法分为两大类：<strong>加密哈希</strong>、<strong>非加密哈希</strong>。当输入值经过加密哈希计算后，无法从输出值反推出输入值，保证了输入值的安全性，但代价是需要耗费更多的计算资源（时间）。在短链场景中，相较于原文的保密性，运算速度是我们更加关心的因素。因此，可以采用非加密哈希，例如<a href=\"https://www.ifuyun.com/tool/murmurhash\">MurmurHash</a>，来生成短链。</p>\n<p>使用哈希算法的场景，不可避免会出现<strong>哈希冲突</strong>问题即不同的输入值通过哈希计算时得到了相同的输出值。借鉴<code>bcrypt</code>加密算法中的<strong>加盐</strong>操作，当某一个输入值发生哈希冲突后，可以在添加一段<strong>特殊字符</strong>后再进行哈希运算，反复操作直至冲突消失。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">www.baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">哈希冲突 ---&gt; 添加特殊字符</span></span><br><span class=\"line\"><span class=\"comment\">www.baidu.com[hello_world]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>通过哈希算法得到一个数值后，例如3510643912，我们还可以利用<strong>62进制（0-9、a-z、A-Z共62个URL合法字符）</strong>将结果进一步缩短</p>\n<p>🌰：3510643912 —&gt; 3PAiQU，这样我们就可以利用更短的字符串作为短链</p>\n<h4 id=\"唯一ID算法\"><a href=\"#唯一ID算法\" class=\"headerlink\" title=\"唯一ID算法\"></a>唯一ID算法</h4><p>除了使用哈希算法简化长链，还能为每一个长链请求分配一个唯一的ID，这个唯一ID就相当于哈希算法中的哈希值。当然，唯一ID也能在<strong>base62进制</strong>下进一步化简</p>\n<p>那么现在的问题就是，<strong>如何设计一个ID分号器？</strong></p>\n<h5 id=\"MySQL自增ID分号\"><a href=\"#MySQL自增ID分号\" class=\"headerlink\" title=\"MySQL自增ID分号\"></a>MySQL自增ID分号</h5><p>通过MySQL自增主键为长链分发一个唯一ID，但这种方法存在<strong>高并发性能问题</strong>。一种解决思路是：预先为集群中的每一个服务分配一个可用的ID范围，只有当服务中可使用的ID不足时才会向数据源请求新的ID</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161917898.png\" alt=\"image-20241016191703853\" style=\"zoom:50%;\" />\n\n<p>如上图所示，<code>biz_tag</code>表示业务类型，<code>max_id</code>表示当前业务可分发的最大ID，<code>step</code>表示步长，即每个服务一次预可申请多少个ID号码</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161920030.png\" alt=\"image-20241016191959985\" style=\"zoom:50%;\" />\n\n<p>当ID不够用了，就像数据库再申请一批</p>\n<p>此外，还可以引入<strong>队列缓冲 + 批量写入</strong>架构，在区间快满时就申请一批新的ID号码，等区间满了再一次性写入数据库中，实现异步进行获取和写入操作，保证服务持续的高并发</p>\n<p>例如，<strong>现有10000个ID号码，当剩余的ID号不足1000时，就向数据源请求再分发10000个ID号，在上一批ID用完时，将数据批量写入数据库中</strong></p>\n<p>MySQL自增ID优点：</p>\n<ul>\n<li>简单方便，容易实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>整体性能吞吐量低，高并发场景下容易出现单点瓶颈</li>\n</ul>\n<h5 id=\"Redis自增ID\"><a href=\"#Redis自增ID\" class=\"headerlink\" title=\"Redis自增ID\"></a>Redis自增ID</h5><p>Redis基于内存实现，并发性能高（10w），但使用Redis作为分号器需要考虑<strong>持久化和灾备</strong></p>\n<p>优点：</p>\n<ul>\n<li>整体吞吐量比数据好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>Redis实例或集群宕机后，很难找回最新的ID</li>\n</ul>\n<h5 id=\"雪花算法生成ID\"><a href=\"#雪花算法生成ID\" class=\"headerlink\" title=\"雪花算法生成ID\"></a>雪花算法生成ID</h5><p>前两种方案都是远程ID生成，一般来说，远程ID生成效率（本身对应的组件耗时 + 网络耗时）不如本地ID生成。雪花算法生成ID方案就是一种本地ID方案，不依赖于其他的服务。</p>\n<p>雪花算法使用一个long类型的整数（64位bit）来表示一个ID，具体由<strong>1bit空闲 + 41bit时间戳（毫秒级别） + 10bit机器ID（或机房ID + 机器ID） + 12bit序列号</strong>组成。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410161948837.png\" alt=\"image-20241016194848744\" style=\"zoom:50%;\" />\n\n<p>优点：</p>\n<ul>\n<li>高性能、低延迟、去中心化、整体按时间有序</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>要求机器时间同步在秒级别，否则会产生ID冲突</li>\n<li>如果某台机器时钟回拨这有可能发生ID冲突</li>\n</ul>\n<h2 id=\"设计短链\"><a href=\"#设计短链\" class=\"headerlink\" title=\"设计短链\"></a>设计短链</h2><h3 id=\"重定向状态码的选择\"><a href=\"#重定向状态码的选择\" class=\"headerlink\" title=\"重定向状态码的选择\"></a>重定向状态码的选择</h3><p>由之前的分析我们知道了短链系统的大致工作原理：浏览器访问短链，短链服务向浏览器返回一个<strong>重定向状态码</strong>和<strong>对应的长链</strong>。接着，浏览器访问长链获取并获取到目标资源。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410182126756.png\" alt=\"image-20241015185124443\"></p>\n<p>在短链系统中一般只考虑使用<strong>永久重定向301</strong>或<strong>临时重定向302</strong>状态码</p>\n<p>两个状态码区别如下：</p>\n<ul>\n<li><strong>301状态码表示永久重定向，浏览器收到改状态码时，会将<code>Location</code>字段值缓存在本地，当将再次访问短链时就直接从缓存中拿出长链地址并访问，节约了一次访问短链服务的次数</strong></li>\n<li><strong>302状态码表示临时重定向，浏览器不会缓存响应头部中的<code>Location</code>字段</strong></li>\n<li><strong>在短链系统中，浏览器的缓存行为可能并非是我们预期的，尤其需要对短链进行分析的情况</strong><ul>\n<li>🌰：将一个短链通过短信发送给1w个用户，如果使用302状态码就可以测试出这1w个用户针对短链的点击次数。但是在使用301状态码情况下，每一个用户最多只会被统计一次。（因为浏览器缓存了长链地址）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h3>"},{"title":"网络代理","publish":true,"description":"记录一些有关网络代理的知识点","date":"2024-09-26T16:00:00.000Z","sticky":2,"_content":"\n\n\n# 网络代理\n\n## 正向代理和反向代理\n\n### 正向代理\n\n**正向代理（forward proxy）**：是一个位于客户端和服务器之间的代理服务器，客户端为了获取服务器上的内容，将原本要发送给服务器的资源请求发送给代理服务器，然后代理服务器将请求转交给目标服务器，最后代理服务器把资源结果返回给客户端\n\n抽象地理解🌟，正向代理就是代理服务器去**代理**客户端\n\n正向代理一般有如下用途：\n\n- **突破访问限制**：通过代理服务器，可以突破客户端自身的IP访问限制\n- **提高访问速度**：代理服务器一般都配有较大的硬盘缓冲区，会将部分请求的响应保存在缓冲区中，当代理服务器再次接收到相同的请求时，可直接返回缓冲区中的结果，提高访问速度\n- **隐藏客户端IP**：客户端可以隐藏自身的IP，免受攻击\n\n### 反向代理\n\n反向代理（reverse proxy）：代理服务器接收客户端的请求，然后将该请求转发给内部网络上的服务器，最后将请求的响应返回给客户端\n\n抽象地理解🌟：反向代理就是“代理服务器”**代理**目标服务器去和客户端进行交互\n\n反向代理一般有如下用途：\n\n- **负载均衡**：代理服务器可以根据所有真实服务器的负载情况，将客户请求转发至不同的真实服务器上\n- **提高访问速度**\n- **隐藏服务器IP**\n- **提供安全保障**：反向代理服务器可以作为**应用层**上的防火墙，为网站提供应对网络攻击（例如DDOS）的防护\n\n### 区别\n\n- 正向代理是客户端的代理，反向代理是服务端的代理\n- 正向代理一般是客户端架设的，而反向代理是一般是服务端架设的\n- 正向代理多用于突破访问限制，而反向代理多用于负载均衡、安全防护等\n\n## 负载均衡\n\n> 常见的负载均衡有哪些方案？\n>\n> 四层负载和七层负载有什么区别？\n\n**负载均衡（Load Balancing）**：调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件就被称为“负载均衡”","source":"_posts/网络代理.md","raw":"---\ntitle: 网络代理\npublish: true\ndescription: 记录一些有关网络代理的知识点\ndate: 2024-09-27\ntag: 计算机网络\nsticky: 2\n---\n\n\n\n# 网络代理\n\n## 正向代理和反向代理\n\n### 正向代理\n\n**正向代理（forward proxy）**：是一个位于客户端和服务器之间的代理服务器，客户端为了获取服务器上的内容，将原本要发送给服务器的资源请求发送给代理服务器，然后代理服务器将请求转交给目标服务器，最后代理服务器把资源结果返回给客户端\n\n抽象地理解🌟，正向代理就是代理服务器去**代理**客户端\n\n正向代理一般有如下用途：\n\n- **突破访问限制**：通过代理服务器，可以突破客户端自身的IP访问限制\n- **提高访问速度**：代理服务器一般都配有较大的硬盘缓冲区，会将部分请求的响应保存在缓冲区中，当代理服务器再次接收到相同的请求时，可直接返回缓冲区中的结果，提高访问速度\n- **隐藏客户端IP**：客户端可以隐藏自身的IP，免受攻击\n\n### 反向代理\n\n反向代理（reverse proxy）：代理服务器接收客户端的请求，然后将该请求转发给内部网络上的服务器，最后将请求的响应返回给客户端\n\n抽象地理解🌟：反向代理就是“代理服务器”**代理**目标服务器去和客户端进行交互\n\n反向代理一般有如下用途：\n\n- **负载均衡**：代理服务器可以根据所有真实服务器的负载情况，将客户请求转发至不同的真实服务器上\n- **提高访问速度**\n- **隐藏服务器IP**\n- **提供安全保障**：反向代理服务器可以作为**应用层**上的防火墙，为网站提供应对网络攻击（例如DDOS）的防护\n\n### 区别\n\n- 正向代理是客户端的代理，反向代理是服务端的代理\n- 正向代理一般是客户端架设的，而反向代理是一般是服务端架设的\n- 正向代理多用于突破访问限制，而反向代理多用于负载均衡、安全防护等\n\n## 负载均衡\n\n> 常见的负载均衡有哪些方案？\n>\n> 四层负载和七层负载有什么区别？\n\n**负载均衡（Load Balancing）**：调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件就被称为“负载均衡”","slug":"网络代理","published":1,"updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001aa5t26g27ffq2","content":"<h1 id=\"网络代理\"><a href=\"#网络代理\" class=\"headerlink\" title=\"网络代理\"></a>网络代理</h1><h2 id=\"正向代理和反向代理\"><a href=\"#正向代理和反向代理\" class=\"headerlink\" title=\"正向代理和反向代理\"></a>正向代理和反向代理</h2><h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p><strong>正向代理（forward proxy）</strong>：是一个位于客户端和服务器之间的代理服务器，客户端为了获取服务器上的内容，将原本要发送给服务器的资源请求发送给代理服务器，然后代理服务器将请求转交给目标服务器，最后代理服务器把资源结果返回给客户端</p>\n<p>抽象地理解🌟，正向代理就是代理服务器去<strong>代理</strong>客户端</p>\n<p>正向代理一般有如下用途：</p>\n<ul>\n<li><strong>突破访问限制</strong>：通过代理服务器，可以突破客户端自身的IP访问限制</li>\n<li><strong>提高访问速度</strong>：代理服务器一般都配有较大的硬盘缓冲区，会将部分请求的响应保存在缓冲区中，当代理服务器再次接收到相同的请求时，可直接返回缓冲区中的结果，提高访问速度</li>\n<li><strong>隐藏客户端IP</strong>：客户端可以隐藏自身的IP，免受攻击</li>\n</ul>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>反向代理（reverse proxy）：代理服务器接收客户端的请求，然后将该请求转发给内部网络上的服务器，最后将请求的响应返回给客户端</p>\n<p>抽象地理解🌟：反向代理就是“代理服务器”<strong>代理</strong>目标服务器去和客户端进行交互</p>\n<p>反向代理一般有如下用途：</p>\n<ul>\n<li><strong>负载均衡</strong>：代理服务器可以根据所有真实服务器的负载情况，将客户请求转发至不同的真实服务器上</li>\n<li><strong>提高访问速度</strong></li>\n<li><strong>隐藏服务器IP</strong></li>\n<li><strong>提供安全保障</strong>：反向代理服务器可以作为<strong>应用层</strong>上的防火墙，为网站提供应对网络攻击（例如DDOS）的防护</li>\n</ul>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>正向代理是客户端的代理，反向代理是服务端的代理</li>\n<li>正向代理一般是客户端架设的，而反向代理是一般是服务端架设的</li>\n<li>正向代理多用于突破访问限制，而反向代理多用于负载均衡、安全防护等</li>\n</ul>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><blockquote>\n<p>常见的负载均衡有哪些方案？</p>\n<p>四层负载和七层负载有什么区别？</p>\n</blockquote>\n<p><strong>负载均衡（Load Balancing）</strong>：调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件就被称为“负载均衡”</p>\n","excerpt":"","more":"<h1 id=\"网络代理\"><a href=\"#网络代理\" class=\"headerlink\" title=\"网络代理\"></a>网络代理</h1><h2 id=\"正向代理和反向代理\"><a href=\"#正向代理和反向代理\" class=\"headerlink\" title=\"正向代理和反向代理\"></a>正向代理和反向代理</h2><h3 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h3><p><strong>正向代理（forward proxy）</strong>：是一个位于客户端和服务器之间的代理服务器，客户端为了获取服务器上的内容，将原本要发送给服务器的资源请求发送给代理服务器，然后代理服务器将请求转交给目标服务器，最后代理服务器把资源结果返回给客户端</p>\n<p>抽象地理解🌟，正向代理就是代理服务器去<strong>代理</strong>客户端</p>\n<p>正向代理一般有如下用途：</p>\n<ul>\n<li><strong>突破访问限制</strong>：通过代理服务器，可以突破客户端自身的IP访问限制</li>\n<li><strong>提高访问速度</strong>：代理服务器一般都配有较大的硬盘缓冲区，会将部分请求的响应保存在缓冲区中，当代理服务器再次接收到相同的请求时，可直接返回缓冲区中的结果，提高访问速度</li>\n<li><strong>隐藏客户端IP</strong>：客户端可以隐藏自身的IP，免受攻击</li>\n</ul>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>反向代理（reverse proxy）：代理服务器接收客户端的请求，然后将该请求转发给内部网络上的服务器，最后将请求的响应返回给客户端</p>\n<p>抽象地理解🌟：反向代理就是“代理服务器”<strong>代理</strong>目标服务器去和客户端进行交互</p>\n<p>反向代理一般有如下用途：</p>\n<ul>\n<li><strong>负载均衡</strong>：代理服务器可以根据所有真实服务器的负载情况，将客户请求转发至不同的真实服务器上</li>\n<li><strong>提高访问速度</strong></li>\n<li><strong>隐藏服务器IP</strong></li>\n<li><strong>提供安全保障</strong>：反向代理服务器可以作为<strong>应用层</strong>上的防火墙，为网站提供应对网络攻击（例如DDOS）的防护</li>\n</ul>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>正向代理是客户端的代理，反向代理是服务端的代理</li>\n<li>正向代理一般是客户端架设的，而反向代理是一般是服务端架设的</li>\n<li>正向代理多用于突破访问限制，而反向代理多用于负载均衡、安全防护等</li>\n</ul>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><blockquote>\n<p>常见的负载均衡有哪些方案？</p>\n<p>四层负载和七层负载有什么区别？</p>\n</blockquote>\n<p><strong>负载均衡（Load Balancing）</strong>：调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件就被称为“负载均衡”</p>\n"},{"title":"网络层知识点","publish":true,"description":"记录了一些网络层的知识点","date":"2024-09-21T10:29:00.000Z","sticky":3,"_content":"\n\n\n# 网络层知识点\n\n## IP\n\n> IP是什么？报文格式是怎样的？\n>\n> IP地址的分类？\n>\n> 如何进行路由？\n\n[参考文章](https://xiaolincoding.com/network/4_ip/ip_base.html)\n\n### IP基本认识\n\n网络层的主要作用是**实现端到端（主机到主机）之间的通信**\n\n> IP和MAC的关系\n\nMAC负责实现同一个网络内**直连**的两台设备之间的通信，而IP负责实现不同网络的两台**不相连**的设备之间的通信\n\n在数据传输过程中，源IP地址和目标IP地址一般是不会变化的，而源MAC地址和目标MAC地址是一直在变化的。\n\n### IP地址\n\nIPv4地址由32位0、1正整数表示\n\n🌰：`11000000  10101000  00000001  00000001`\n\n32位整数中有一部分充当**网络号**，另一部分充当**主机号**，所以可以说IP地址是由<font color='blue'>**网络标识**</font>和<font color='blue'>**主机标识**</font>这两部分构成\n\n> 为什么要分离网络号和主机号？\n\n因为两台设备在进行通信之前，先判断是否在同一个广播域内，即网络号是否相同，如果是则可以把数据包直接发送到目标主机\n\n为了表示方便，可以将每8位分为一组，每组用十进制表示，用**`.`**作为组与组之间的分隔符号\n\n🌰：`192.168.1.1`\n\nIP地址并非以主机为最小配置单位，而是以网卡来配置的。即一台服务器、路由器至少有两个网卡，等价于至少有两个IP地址\n\n![image-20240921105702834](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211057876.png)\n\n#### IP地址的分类\n\n> 互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了**分类地址**。\n>\n> （但是现在IPv4早就不够用哩🤪，于是就有了IPv6）\n\nIPv4地址分为5大类：A、B、C、D、E类，需要重点关注的只有A、B、C这三类IP地址\n\n由前文知，IP地址由网络号和主机号构成，A、B、C三类IP地址的区别就在于主机号的位数，具体如下图：\n\n![image-20240921132334887](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211323959.png)\n\n以C类IP地址为例，虽然C类主机号占有8位，但是C类地址的最大主机个数为：$$ 2^8 - 2 = 254 $$\n\n这里**减2**是减去两个比较特殊的主机号：\n\n- 主机号全0\n  - 指定某个网络\n- 主机号全1\n  - 指定某个网络下的所有主机，用于广播\n\nIP分类的优点就是简单明了、选路（基于网络地址）简单\n\n缺点也是有的😑：\n\n- 某一类网络下**无法再细分IP地址类型**，🌰：一个学校使用了B类的IP地址，现有按照不同学院划分地址层次的需求，但是IP分类是无法实现这类需求的，**灵活性较差**\n\n- **不能很好的与现实网络匹配**：要么IP地址包含的主机数量太多，要么就是太少\n\n#### 无分类地址CIDR\n\n取消对IP地址分类的概念，采用`a.b.c.d/x`的形式标识一个IP地址。其中前`x`位属于网络号，这使得IP地址更加灵活\n\n##### 子网掩码\n\n子网掩码可以也可以用于区分网络号和主机号，但是这里的网络号既包含了网络地址又包含了子网网络地址，如下图\n\n![image-20240921135312707](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211353765.png)\n\n- 未做子网划分的IP地址：网络地址 + 主机地址\n- 做子网划分的IP地址：网络地址 + （子网网络地址 + 子网主机地址）\n\n子网掩码更多是和分类IP地址或无分类IP地址一同使用，用于在某个网段下面细分子网类型\n\n🌰：![image-20240921135545704](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211355750.png)\n\n这里C类IP地址中主机地址原本有8位，现借出2位作为**子网网络地址**，因此在例子中，共有4个子网，如下图\n\n![image-20240921135737594](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211357645.png)\n\n#### 公有IP地址与私有IP地址\n\n在A、B、C三类IP地址中，实际上分有公有IP地址和私有IP地址\n\n![image-20240921140902040](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211409097.png)\n\n在不同的地域中，私有IP地址可以重复，但公有IP地址在整个互联网范围内是唯一的\n\n#### IP地址与路由控制\n\n在发送IP包时，首先拿着IP包中的目标地址和本主机（路由器）的路由表进行匹配，找到具有相同**网络地址**的记录，再根据该记录将IP包转发至下一个路由器或主机。如果匹配过程中发现有多个相同的网络地址，则选择相同位数最多的网络地址，即最长匹配；反之，如果匹配过程中没有一个匹配成功😪，则转发至默认下一跳地址\n\n> 换回地址不会流向网络\n\n特殊IP地址<font color='blue'>**127.0.0.1**</font>被计算机作为<font color='blue'>**环回地址**</font>（同`localhost`）。使用这个IP地址时，数据包是不会流向网络的\n","source":"_posts/网络层知识点.md","raw":"---\ntitle: 网络层知识点\npublish: true\ndescription: 记录了一些网络层的知识点\ndate: 2024-09-21 18:29:00\ntag: 计算机网络\nsticky: 3\n---\n\n\n\n# 网络层知识点\n\n## IP\n\n> IP是什么？报文格式是怎样的？\n>\n> IP地址的分类？\n>\n> 如何进行路由？\n\n[参考文章](https://xiaolincoding.com/network/4_ip/ip_base.html)\n\n### IP基本认识\n\n网络层的主要作用是**实现端到端（主机到主机）之间的通信**\n\n> IP和MAC的关系\n\nMAC负责实现同一个网络内**直连**的两台设备之间的通信，而IP负责实现不同网络的两台**不相连**的设备之间的通信\n\n在数据传输过程中，源IP地址和目标IP地址一般是不会变化的，而源MAC地址和目标MAC地址是一直在变化的。\n\n### IP地址\n\nIPv4地址由32位0、1正整数表示\n\n🌰：`11000000  10101000  00000001  00000001`\n\n32位整数中有一部分充当**网络号**，另一部分充当**主机号**，所以可以说IP地址是由<font color='blue'>**网络标识**</font>和<font color='blue'>**主机标识**</font>这两部分构成\n\n> 为什么要分离网络号和主机号？\n\n因为两台设备在进行通信之前，先判断是否在同一个广播域内，即网络号是否相同，如果是则可以把数据包直接发送到目标主机\n\n为了表示方便，可以将每8位分为一组，每组用十进制表示，用**`.`**作为组与组之间的分隔符号\n\n🌰：`192.168.1.1`\n\nIP地址并非以主机为最小配置单位，而是以网卡来配置的。即一台服务器、路由器至少有两个网卡，等价于至少有两个IP地址\n\n![image-20240921105702834](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211057876.png)\n\n#### IP地址的分类\n\n> 互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了**分类地址**。\n>\n> （但是现在IPv4早就不够用哩🤪，于是就有了IPv6）\n\nIPv4地址分为5大类：A、B、C、D、E类，需要重点关注的只有A、B、C这三类IP地址\n\n由前文知，IP地址由网络号和主机号构成，A、B、C三类IP地址的区别就在于主机号的位数，具体如下图：\n\n![image-20240921132334887](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211323959.png)\n\n以C类IP地址为例，虽然C类主机号占有8位，但是C类地址的最大主机个数为：$$ 2^8 - 2 = 254 $$\n\n这里**减2**是减去两个比较特殊的主机号：\n\n- 主机号全0\n  - 指定某个网络\n- 主机号全1\n  - 指定某个网络下的所有主机，用于广播\n\nIP分类的优点就是简单明了、选路（基于网络地址）简单\n\n缺点也是有的😑：\n\n- 某一类网络下**无法再细分IP地址类型**，🌰：一个学校使用了B类的IP地址，现有按照不同学院划分地址层次的需求，但是IP分类是无法实现这类需求的，**灵活性较差**\n\n- **不能很好的与现实网络匹配**：要么IP地址包含的主机数量太多，要么就是太少\n\n#### 无分类地址CIDR\n\n取消对IP地址分类的概念，采用`a.b.c.d/x`的形式标识一个IP地址。其中前`x`位属于网络号，这使得IP地址更加灵活\n\n##### 子网掩码\n\n子网掩码可以也可以用于区分网络号和主机号，但是这里的网络号既包含了网络地址又包含了子网网络地址，如下图\n\n![image-20240921135312707](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211353765.png)\n\n- 未做子网划分的IP地址：网络地址 + 主机地址\n- 做子网划分的IP地址：网络地址 + （子网网络地址 + 子网主机地址）\n\n子网掩码更多是和分类IP地址或无分类IP地址一同使用，用于在某个网段下面细分子网类型\n\n🌰：![image-20240921135545704](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211355750.png)\n\n这里C类IP地址中主机地址原本有8位，现借出2位作为**子网网络地址**，因此在例子中，共有4个子网，如下图\n\n![image-20240921135737594](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211357645.png)\n\n#### 公有IP地址与私有IP地址\n\n在A、B、C三类IP地址中，实际上分有公有IP地址和私有IP地址\n\n![image-20240921140902040](https://raw.githubusercontent.com/lyydsheep/pic/main/202409211409097.png)\n\n在不同的地域中，私有IP地址可以重复，但公有IP地址在整个互联网范围内是唯一的\n\n#### IP地址与路由控制\n\n在发送IP包时，首先拿着IP包中的目标地址和本主机（路由器）的路由表进行匹配，找到具有相同**网络地址**的记录，再根据该记录将IP包转发至下一个路由器或主机。如果匹配过程中发现有多个相同的网络地址，则选择相同位数最多的网络地址，即最长匹配；反之，如果匹配过程中没有一个匹配成功😪，则转发至默认下一跳地址\n\n> 换回地址不会流向网络\n\n特殊IP地址<font color='blue'>**127.0.0.1**</font>被计算机作为<font color='blue'>**环回地址**</font>（同`localhost`）。使用这个IP地址时，数据包是不会流向网络的\n","slug":"网络层知识点","published":1,"updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001ba5t2dt3q415q","content":"<h1 id=\"网络层知识点\"><a href=\"#网络层知识点\" class=\"headerlink\" title=\"网络层知识点\"></a>网络层知识点</h1><h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><blockquote>\n<p>IP是什么？报文格式是怎样的？</p>\n<p>IP地址的分类？</p>\n<p>如何进行路由？</p>\n</blockquote>\n<p><a href=\"https://xiaolincoding.com/network/4_ip/ip_base.html\">参考文章</a></p>\n<h3 id=\"IP基本认识\"><a href=\"#IP基本认识\" class=\"headerlink\" title=\"IP基本认识\"></a>IP基本认识</h3><p>网络层的主要作用是<strong>实现端到端（主机到主机）之间的通信</strong></p>\n<blockquote>\n<p>IP和MAC的关系</p>\n</blockquote>\n<p>MAC负责实现同一个网络内<strong>直连</strong>的两台设备之间的通信，而IP负责实现不同网络的两台<strong>不相连</strong>的设备之间的通信</p>\n<p>在数据传输过程中，源IP地址和目标IP地址一般是不会变化的，而源MAC地址和目标MAC地址是一直在变化的。</p>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><p>IPv4地址由32位0、1正整数表示</p>\n<p>🌰：<code>11000000  10101000  00000001  00000001</code></p>\n<p>32位整数中有一部分充当<strong>网络号</strong>，另一部分充当<strong>主机号</strong>，所以可以说IP地址是由<font color='blue'><strong>网络标识</strong></font>和<font color='blue'><strong>主机标识</strong></font>这两部分构成</p>\n<blockquote>\n<p>为什么要分离网络号和主机号？</p>\n</blockquote>\n<p>因为两台设备在进行通信之前，先判断是否在同一个广播域内，即网络号是否相同，如果是则可以把数据包直接发送到目标主机</p>\n<p>为了表示方便，可以将每8位分为一组，每组用十进制表示，用**<code>.</code>**作为组与组之间的分隔符号</p>\n<p>🌰：<code>192.168.1.1</code></p>\n<p>IP地址并非以主机为最小配置单位，而是以网卡来配置的。即一台服务器、路由器至少有两个网卡，等价于至少有两个IP地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211057876.png\" alt=\"image-20240921105702834\"></p>\n<h4 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h4><blockquote>\n<p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。</p>\n<p>（但是现在IPv4早就不够用哩🤪，于是就有了IPv6）</p>\n</blockquote>\n<p>IPv4地址分为5大类：A、B、C、D、E类，需要重点关注的只有A、B、C这三类IP地址</p>\n<p>由前文知，IP地址由网络号和主机号构成，A、B、C三类IP地址的区别就在于主机号的位数，具体如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211323959.png\" alt=\"image-20240921132334887\"></p>\n<p>以C类IP地址为例，虽然C类主机号占有8位，但是C类地址的最大主机个数为：$$ 2^8 - 2 &#x3D; 254 $$</p>\n<p>这里<strong>减2</strong>是减去两个比较特殊的主机号：</p>\n<ul>\n<li>主机号全0<ul>\n<li>指定某个网络</li>\n</ul>\n</li>\n<li>主机号全1<ul>\n<li>指定某个网络下的所有主机，用于广播</li>\n</ul>\n</li>\n</ul>\n<p>IP分类的优点就是简单明了、选路（基于网络地址）简单</p>\n<p>缺点也是有的😑：</p>\n<ul>\n<li><p>某一类网络下<strong>无法再细分IP地址类型</strong>，🌰：一个学校使用了B类的IP地址，现有按照不同学院划分地址层次的需求，但是IP分类是无法实现这类需求的，<strong>灵活性较差</strong></p>\n</li>\n<li><p><strong>不能很好的与现实网络匹配</strong>：要么IP地址包含的主机数量太多，要么就是太少</p>\n</li>\n</ul>\n<h4 id=\"无分类地址CIDR\"><a href=\"#无分类地址CIDR\" class=\"headerlink\" title=\"无分类地址CIDR\"></a>无分类地址CIDR</h4><p>取消对IP地址分类的概念，采用<code>a.b.c.d/x</code>的形式标识一个IP地址。其中前<code>x</code>位属于网络号，这使得IP地址更加灵活</p>\n<h5 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h5><p>子网掩码可以也可以用于区分网络号和主机号，但是这里的网络号既包含了网络地址又包含了子网网络地址，如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211353765.png\" alt=\"image-20240921135312707\"></p>\n<ul>\n<li>未做子网划分的IP地址：网络地址 + 主机地址</li>\n<li>做子网划分的IP地址：网络地址 + （子网网络地址 + 子网主机地址）</li>\n</ul>\n<p>子网掩码更多是和分类IP地址或无分类IP地址一同使用，用于在某个网段下面细分子网类型</p>\n<p>🌰：<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211355750.png\" alt=\"image-20240921135545704\"></p>\n<p>这里C类IP地址中主机地址原本有8位，现借出2位作为<strong>子网网络地址</strong>，因此在例子中，共有4个子网，如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211357645.png\" alt=\"image-20240921135737594\"></p>\n<h4 id=\"公有IP地址与私有IP地址\"><a href=\"#公有IP地址与私有IP地址\" class=\"headerlink\" title=\"公有IP地址与私有IP地址\"></a>公有IP地址与私有IP地址</h4><p>在A、B、C三类IP地址中，实际上分有公有IP地址和私有IP地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211409097.png\" alt=\"image-20240921140902040\"></p>\n<p>在不同的地域中，私有IP地址可以重复，但公有IP地址在整个互联网范围内是唯一的</p>\n<h4 id=\"IP地址与路由控制\"><a href=\"#IP地址与路由控制\" class=\"headerlink\" title=\"IP地址与路由控制\"></a>IP地址与路由控制</h4><p>在发送IP包时，首先拿着IP包中的目标地址和本主机（路由器）的路由表进行匹配，找到具有相同<strong>网络地址</strong>的记录，再根据该记录将IP包转发至下一个路由器或主机。如果匹配过程中发现有多个相同的网络地址，则选择相同位数最多的网络地址，即最长匹配；反之，如果匹配过程中没有一个匹配成功😪，则转发至默认下一跳地址</p>\n<blockquote>\n<p>换回地址不会流向网络</p>\n</blockquote>\n<p>特殊IP地址<font color='blue'><strong>127.0.0.1</strong></font>被计算机作为<font color='blue'><strong>环回地址</strong></font>（同<code>localhost</code>）。使用这个IP地址时，数据包是不会流向网络的</p>\n","excerpt":"","more":"<h1 id=\"网络层知识点\"><a href=\"#网络层知识点\" class=\"headerlink\" title=\"网络层知识点\"></a>网络层知识点</h1><h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><blockquote>\n<p>IP是什么？报文格式是怎样的？</p>\n<p>IP地址的分类？</p>\n<p>如何进行路由？</p>\n</blockquote>\n<p><a href=\"https://xiaolincoding.com/network/4_ip/ip_base.html\">参考文章</a></p>\n<h3 id=\"IP基本认识\"><a href=\"#IP基本认识\" class=\"headerlink\" title=\"IP基本认识\"></a>IP基本认识</h3><p>网络层的主要作用是<strong>实现端到端（主机到主机）之间的通信</strong></p>\n<blockquote>\n<p>IP和MAC的关系</p>\n</blockquote>\n<p>MAC负责实现同一个网络内<strong>直连</strong>的两台设备之间的通信，而IP负责实现不同网络的两台<strong>不相连</strong>的设备之间的通信</p>\n<p>在数据传输过程中，源IP地址和目标IP地址一般是不会变化的，而源MAC地址和目标MAC地址是一直在变化的。</p>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><p>IPv4地址由32位0、1正整数表示</p>\n<p>🌰：<code>11000000  10101000  00000001  00000001</code></p>\n<p>32位整数中有一部分充当<strong>网络号</strong>，另一部分充当<strong>主机号</strong>，所以可以说IP地址是由<font color='blue'><strong>网络标识</strong></font>和<font color='blue'><strong>主机标识</strong></font>这两部分构成</p>\n<blockquote>\n<p>为什么要分离网络号和主机号？</p>\n</blockquote>\n<p>因为两台设备在进行通信之前，先判断是否在同一个广播域内，即网络号是否相同，如果是则可以把数据包直接发送到目标主机</p>\n<p>为了表示方便，可以将每8位分为一组，每组用十进制表示，用**<code>.</code>**作为组与组之间的分隔符号</p>\n<p>🌰：<code>192.168.1.1</code></p>\n<p>IP地址并非以主机为最小配置单位，而是以网卡来配置的。即一台服务器、路由器至少有两个网卡，等价于至少有两个IP地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211057876.png\" alt=\"image-20240921105702834\"></p>\n<h4 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h4><blockquote>\n<p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。</p>\n<p>（但是现在IPv4早就不够用哩🤪，于是就有了IPv6）</p>\n</blockquote>\n<p>IPv4地址分为5大类：A、B、C、D、E类，需要重点关注的只有A、B、C这三类IP地址</p>\n<p>由前文知，IP地址由网络号和主机号构成，A、B、C三类IP地址的区别就在于主机号的位数，具体如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211323959.png\" alt=\"image-20240921132334887\"></p>\n<p>以C类IP地址为例，虽然C类主机号占有8位，但是C类地址的最大主机个数为：$$ 2^8 - 2 &#x3D; 254 $$</p>\n<p>这里<strong>减2</strong>是减去两个比较特殊的主机号：</p>\n<ul>\n<li>主机号全0<ul>\n<li>指定某个网络</li>\n</ul>\n</li>\n<li>主机号全1<ul>\n<li>指定某个网络下的所有主机，用于广播</li>\n</ul>\n</li>\n</ul>\n<p>IP分类的优点就是简单明了、选路（基于网络地址）简单</p>\n<p>缺点也是有的😑：</p>\n<ul>\n<li><p>某一类网络下<strong>无法再细分IP地址类型</strong>，🌰：一个学校使用了B类的IP地址，现有按照不同学院划分地址层次的需求，但是IP分类是无法实现这类需求的，<strong>灵活性较差</strong></p>\n</li>\n<li><p><strong>不能很好的与现实网络匹配</strong>：要么IP地址包含的主机数量太多，要么就是太少</p>\n</li>\n</ul>\n<h4 id=\"无分类地址CIDR\"><a href=\"#无分类地址CIDR\" class=\"headerlink\" title=\"无分类地址CIDR\"></a>无分类地址CIDR</h4><p>取消对IP地址分类的概念，采用<code>a.b.c.d/x</code>的形式标识一个IP地址。其中前<code>x</code>位属于网络号，这使得IP地址更加灵活</p>\n<h5 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h5><p>子网掩码可以也可以用于区分网络号和主机号，但是这里的网络号既包含了网络地址又包含了子网网络地址，如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211353765.png\" alt=\"image-20240921135312707\"></p>\n<ul>\n<li>未做子网划分的IP地址：网络地址 + 主机地址</li>\n<li>做子网划分的IP地址：网络地址 + （子网网络地址 + 子网主机地址）</li>\n</ul>\n<p>子网掩码更多是和分类IP地址或无分类IP地址一同使用，用于在某个网段下面细分子网类型</p>\n<p>🌰：<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211355750.png\" alt=\"image-20240921135545704\"></p>\n<p>这里C类IP地址中主机地址原本有8位，现借出2位作为<strong>子网网络地址</strong>，因此在例子中，共有4个子网，如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211357645.png\" alt=\"image-20240921135737594\"></p>\n<h4 id=\"公有IP地址与私有IP地址\"><a href=\"#公有IP地址与私有IP地址\" class=\"headerlink\" title=\"公有IP地址与私有IP地址\"></a>公有IP地址与私有IP地址</h4><p>在A、B、C三类IP地址中，实际上分有公有IP地址和私有IP地址</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409211409097.png\" alt=\"image-20240921140902040\"></p>\n<p>在不同的地域中，私有IP地址可以重复，但公有IP地址在整个互联网范围内是唯一的</p>\n<h4 id=\"IP地址与路由控制\"><a href=\"#IP地址与路由控制\" class=\"headerlink\" title=\"IP地址与路由控制\"></a>IP地址与路由控制</h4><p>在发送IP包时，首先拿着IP包中的目标地址和本主机（路由器）的路由表进行匹配，找到具有相同<strong>网络地址</strong>的记录，再根据该记录将IP包转发至下一个路由器或主机。如果匹配过程中发现有多个相同的网络地址，则选择相同位数最多的网络地址，即最长匹配；反之，如果匹配过程中没有一个匹配成功😪，则转发至默认下一跳地址</p>\n<blockquote>\n<p>换回地址不会流向网络</p>\n</blockquote>\n<p>特殊IP地址<font color='blue'><strong>127.0.0.1</strong></font>被计算机作为<font color='blue'><strong>环回地址</strong></font>（同<code>localhost</code>）。使用这个IP地址时，数据包是不会流向网络的</p>\n"},{"_content":"---\n\n---\n两阶段提交（2PC）\n\t- 准备阶段\n\t- 提交阶段\n\t- 频繁的锁，死锁问题\n\t- 很多的锁，数据延迟高\n\t- 数据丢失\n\n基于MQ的消息投递\n-  MQ自动应答机制导致消息丢失：要确保数据真正持久化到数据库后才能将MQ中的消息删除\n- 高并发场景下消息积压：使用双向消息队列 + 数据库持久化任务，确保每一个任务能够完成","source":"_posts/草稿.md","raw":"---\n\n---\n两阶段提交（2PC）\n\t- 准备阶段\n\t- 提交阶段\n\t- 频繁的锁，死锁问题\n\t- 很多的锁，数据延迟高\n\t- 数据丢失\n\n基于MQ的消息投递\n-  MQ自动应答机制导致消息丢失：要确保数据真正持久化到数据库后才能将MQ中的消息删除\n- 高并发场景下消息积压：使用双向消息队列 + 数据库持久化任务，确保每一个任务能够完成","slug":"草稿","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001da5t2ciorfwlo","content":"<hr>\n<hr>\n<p>两阶段提交（2PC）<br>    - 准备阶段<br>    - 提交阶段<br>    - 频繁的锁，死锁问题<br>    - 很多的锁，数据延迟高<br>    - 数据丢失</p>\n<p>基于MQ的消息投递</p>\n<ul>\n<li>MQ自动应答机制导致消息丢失：要确保数据真正持久化到数据库后才能将MQ中的消息删除</li>\n<li>高并发场景下消息积压：使用双向消息队列 + 数据库持久化任务，确保每一个任务能够完成</li>\n</ul>\n","excerpt":"","more":"<hr>\n<hr>\n<p>两阶段提交（2PC）<br>    - 准备阶段<br>    - 提交阶段<br>    - 频繁的锁，死锁问题<br>    - 很多的锁，数据延迟高<br>    - 数据丢失</p>\n<p>基于MQ的消息投递</p>\n<ul>\n<li>MQ自动应答机制导致消息丢失：要确保数据真正持久化到数据库后才能将MQ中的消息删除</li>\n<li>高并发场景下消息积压：使用双向消息队列 + 数据库持久化任务，确保每一个任务能够完成</li>\n</ul>\n"},{"date":"2024-12-14T16:00:00.000Z","_content":"\n# 设计模式\n\n> 这是[Easy搞定Golang设计模式](https://www.bilibili.com/video/BV1Eg411m7rV/?spm_id_from=333.1387.collection.video_card.click&vd_source=a15269894d9b8114cb5f9bb663d22be9)的学习记录\n\n## 面向对象设计原则\n\n### 单一职责原则\n\n类的职责单一，对外只提供一种功能，而引起类的变化的原因通常只有一个。这是为了避免别人看代码时产生歧义，提高代码的逻辑性\n\n设计一个类，对外提供的功能应该单一，接口单一，仅有这个接口会影响这个类。一个类的一个接口应具备这个类的功能含义，职责单一并且不复杂\n\n### 开闭原则\n\n> 对扩展开放，对修改关闭\n\n如果我们想为某个类增添新的功能，最好的方法是基于接口或者组合的方式对其进行扩展，而不是在原有的类代码上进行修改。比如一个类已经有了99个方法，那么增添第100个方法时就很有可能导致前面99个方法无法正常工作（毕竟谁知道那99个方法用了什么奇技淫巧）\n\n所以开闭原则的核心思想就是：不是通过修改代码,而是通过增添代码来给系统添加功能\n\n### 依赖倒转原则（重要）\n\n感觉依赖倒转原则的核心就是**面向接口编程**\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412121814145.png\" />\n\n首先需要做好中间抽象层的设计，然后依照这抽象层一次将实现层的每一个模块进行实现。这一步提现了实现层**向上依赖抽象层**\n另一方面，抽象层向业务逻辑层暴露出功能的接口，业务逻辑层只需要根据暴露出来的接口实现对也的业务逻辑即可，无需关系功能具体是如何实现\n\n### 合成复用原则\n\n如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用组合，就大大降低了这种依赖关系。对于组合和继承，优先使用组合。（Go天然实现组合😂）\n比如父类有100个方法，而子类只想使用其中的某一个方法，那么子类采用组合的方式就能屏蔽掉父类的其他99个方法\n\n### 迪米特法则\n\n一个对象应当对其他对象尽可能了解得少，从而降低各个对象之间的耦合，提高系统的可维护性。\n\n## 创建型模式\n### 简单工厂模式\n\n**业务逻辑层 --->  工厂模块 ---> 基础类模块**\n\n反例：业务逻辑层 ---> 基础类模块\n```go\ntype Fruit struct {  \n}  \n  \nfunc (f *Fruit) Name() {  \n    }  \n  \nfunc NewFruit(name string) *Fruit {  \n    res := &Fruit{}  \n    switch {  \n    case name == \"apple\":  \n       // do something  \n    case name == \"pear\":  \n       // do something  \n    default:  \n       // do something  \n    }  \n    return res  \n}  \n  \nfunc main() {  \n    apple := NewFruit(\"apple\")  \n    apple.Name()  \n    pear := NewFruit(\"pear\")  \n    pear.Name()  \n}\n```\n简单工厂模式实现代码：\n```go\ntype Fruit interface {  \n    Show()  \n}  \n  \ntype Apple struct {  \n}  \n  \nfunc (a *Apple) Show() {  \n}  \n  \ntype Pear struct{  \n}  \n  \nfunc (p *Pear) Show() {  \n}  \n  \ntype Banana struct{  \n}  \n  \nfunc (b *Banana) Show() {  \n}  \n  \ntype Factory struct{}  \n  \nfunc (f *Factory) CreateFruit(name string) (Fruit, bool) {  \n    var fruit Fruit  \n    ok := false  \n    switch {  \n    case name == \"apple\":  \n       fruit, ok = new(Apple), true  \n    case name == \"pear\":  \n       fruit, ok = new(Pear), true  \n    case name == \"banana\":  \n       fruit, ok = new(Banana), true  \n    }  \n    return fruit, ok  \n}  \n  \n\n```\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412151724598.png)\n\n**优点**：\n1. 实现了对象创建和使用的分离\n**缺点**：\n1. 违法“开闭原则”\n2. 工厂类职责过重，一旦不能工作，系统深受影响\n3. 复杂度和理解度随着类的个数增加\n\n### 工厂模式\n\n工厂模式就是“简单工厂模式 + 开闭原则”\n在Go里面，实现工厂模式比较常见的写法就是`Newxxx()`\n```go\nfunc NewFactory() *Factory {  \n    return &Factory{}  \n}\n```\n### 单例模式\n\n> 保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用\n\n**饿汉式**：\n```go\ntype single struct{}  \n  \nvar instance = new(single)  \n  \nfunc (s *single) Show() {  \n    // do something  \n}  \n  \nfunc GetInstance() *single {  \n    return instance  \n}\n```\n**懒汉式**：延迟初始化，直到调用GetInstance方法时才进行初始化。需要重点关心的是如何保证并发安全\n\t- 锁\n\t- 原子操作\n\t- once\n```go\ntype single struct{}  \n  \nvar (  \n    instance *single  \n    mtx sync.RWMutex  \n    lock uint32  \n    once sync.Once  \n)  \n  \nfunc GetInstance() *single {  \n    // 保证并发安全：锁、原子操作、once  \n    // 原子操作  \n    //if atomic.LoadUint32(&lock) == 1 {  \n    // return instance    //}    //mtx.Lock()    //defer mtx.Unlock()    //instance = new(single)    //return instance        // once  \n    once.Do(func() {  \n       instance = new(single)  \n    })  \n    return instance  \n}\n```\n## 结构型模式\n\n### 代理模式\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412182052160.png)\n\n**Subject**：具体主题和代理主题的公共接口\n**RealSubject**：具体主题\n**Proxy**：代理主题，**包含了对具体主题角色的引用**，通常可以在代理主题中封装具体主题需要执行的一些流程，提高代码复用性\n\n```go\ntype D interface {  \n    Dance()  \n}  \n  \ntype KunDance struct {  \n}  \n  \nfunc (k *KunDance) Dance() {  \n    fmt.Println(\"KunDance\")  \n}  \n  \ntype KunKunDance struct{}  \n  \nfunc (k *KunKunDance) Dance() {}  \n  \ntype SingDanceRap struct {  \n    d D  \n}  \n  \nfunc (s *SingDanceRap) Dance() {  \n    s.Sing()  \n    // 动态调用某一个Dance方法  \n    s.d.Dance()  \n    s.Rap()  \n}  \n  \nfunc (s *SingDanceRap) Sing() {}  \n  \nfunc (s *SingDanceRap) Rap() {}  \n  \nfunc NewSingDanceRap(d D) D {  \n    return &SingDanceRap{  \n       d: d,  \n    }  \n}\n```\n感觉核心点在于，实现一个公共的接口，封装一些重复性的代码，提高复用🤔\n\n### 装饰器模式\n\n装饰器模式和代理模式很像，都是在原有接口上进行功能的扩展。典型的模板就是**结构体 组合 待扩展的接口**\n```go\ntype Phone interface {  \n    Show()  \n}  \n  \ntype Hua struct {  \n}  \n  \nfunc (h *Hua) Show() {  \n  \n}  \n  \ntype PhonePlus struct {  \n    Phone  \n}  \n  \nfunc (pp *PhonePlus) Show() {  \n  \n}  \n  \nfunc (pp *PhonePlus) AnotherMethod() {  \n  \n}\n```\n\n### 适配器模式\n\n适配器模式可以实现一个类或接口能够在一个与之毫不相干的接口环境运行、作用\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412202127687.png)\n\n```go\ntype V5 interface{  \n    Use5() }  \n  \ntype V220 interface{  \n    Use220()  \n}  \n  \ntype Adapter struct {  \n    v220 V220  \n}  \n  \nfunc (a *Adapter) Use5() {  \n    a.v220.Use220()  \n}  \n  \nfunc NewAdapter(v220 V220) *Adapter {  \n    return &Adapter{v220: v220}  \n}\n```\n\n### 外观模式\n\n外观模式本质上就是添加一个中间层，这个中间层向上层提供了底层API的封装，降低了业务层和底层的耦合\n```go\ntype A struct {}  \n  \nfunc (a *A)work() {  \n    }  \n  \ntype T struct {  \n    a *A  \n}\n```\n\n## 行为型模式\n### 模板方法模式\n\n模板方法模式可以用于统一接口方法的操作步骤，忽视每个实例对于方法的具体实现\n（Go确实不适合按照严格的设计模式类图进行编码）\n\n```go\ntype Work interface {  \n    Step1()  \n    Step2()  \n    Step3()  \n}  \n  \ntype WorkFlow interface {  \n    DoSomething()  \n}  \n  \ntype BasicWorkFlow struct {  \n    Work  \n}  \n  \nfunc (wf *BasicWorkFlow) DoSomething() {  \n    wf.Step1()  \n    wf.Step2()  \n    wf.Step3()  \n}\n```\n\n### 命令模式\n\n命令模式是在一个功能类上提供特殊的命令类，用于区分功能类中的特定功能。向业务方屏蔽了功能类的具体细节。在命令类的基础上组合出一个中间类，中间类向业务方提供统一的接口，进一步屏蔽了不同命令之间的差异\n\n```go\ntype Doctor struct {}  \n  \nfunc (d *Doctor) treatEye() {  \n    }  \n  \ntype Cmd interface {  \n    Treat()  \n}  \n  \ntype Nurse struct {  \n    cmds []Cmd  \n}  \n  \nfunc (n *Nurse) Notify() {  \n    if n.cmds == nil {  \n       return  \n    }  \n    for i := range n.cmds {  \n       n.cmds[i].Treat()  \n    }  \n}  \n  \nfunc (d *Doctor) treatNose() {}  \n  \ntype cmdEye struct {  \n    d *Doctor  \n}  \n  \nfunc (c *cmdEye) Treat() {  \n    c.d.treatEye()  \n}  \n  \ntype cmdNose struct {  \n    d *Doctor  \n}\n```\n### 策略模式\n\n为环境类配置一个接口，通过这个接口用户可以自由切换功能相同但实现不同的算法\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412242041157.png)\n\n```go\ntype Strategy interface {  \n    UseWeapon()  \n}  \n  \ntype AK struct{}  \n  \nfunc (a *AK) UseWeapon() {  \n    fmt.Println(\"ak\")  \n}  \n  \ntype Knife struct{}  \n  \nfunc (k *Knife) UseWeapon() { fmt.Println(\"k\") }  \n  \ntype Person struct {  \n    s Strategy  \n}  \n  \nfunc (p *Person) SetStrategy(s Strategy) {  \n    p.s = s  \n}  \n  \nfunc (p *Person) Fight() {  \n    p.s.UseWeapon()  \n}\n\n```\n### 观察者模式\n\n如果系统需要创建一个触发链，A对象的行为影响B对象，B对象的行为影响C对象...，就可以使用观察者模式创建一种链式触发机制\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412242129694.png)\n\n```go\ntype Listener interface {  \n    OnTeacherComing()  \n}  \n  \ntype StuZ3 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuZ3) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype StuZ4 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuZ4) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype StuW5 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuW5) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype Notifier interface {  \n    Add(l Listener)  \n    Del(l Listener)  \n    Notify()  \n}  \n  \ntype Monitor struct {  \n    listeners []Listener  \n}  \n  \nfunc (m *Monitor) Add(l Listener) {  \n    if m.listeners != nil {  \n       m.listeners = append(m.listeners, l)  \n    }  \n}  \n  \nfunc (m *Monitor) Del(l Listener) {  \n    //TODO implement me  \n    panic(\"implement me\")  \n}  \n  \nfunc (m *Monitor) Notify() {  \n    for i := range m.listeners {  \n       m.listeners[i].OnTeacherComing()  \n    }  \n}\n```\n","source":"_posts/设计模式.md","raw":"---\ndate: 2024-12-15\n---\n\n# 设计模式\n\n> 这是[Easy搞定Golang设计模式](https://www.bilibili.com/video/BV1Eg411m7rV/?spm_id_from=333.1387.collection.video_card.click&vd_source=a15269894d9b8114cb5f9bb663d22be9)的学习记录\n\n## 面向对象设计原则\n\n### 单一职责原则\n\n类的职责单一，对外只提供一种功能，而引起类的变化的原因通常只有一个。这是为了避免别人看代码时产生歧义，提高代码的逻辑性\n\n设计一个类，对外提供的功能应该单一，接口单一，仅有这个接口会影响这个类。一个类的一个接口应具备这个类的功能含义，职责单一并且不复杂\n\n### 开闭原则\n\n> 对扩展开放，对修改关闭\n\n如果我们想为某个类增添新的功能，最好的方法是基于接口或者组合的方式对其进行扩展，而不是在原有的类代码上进行修改。比如一个类已经有了99个方法，那么增添第100个方法时就很有可能导致前面99个方法无法正常工作（毕竟谁知道那99个方法用了什么奇技淫巧）\n\n所以开闭原则的核心思想就是：不是通过修改代码,而是通过增添代码来给系统添加功能\n\n### 依赖倒转原则（重要）\n\n感觉依赖倒转原则的核心就是**面向接口编程**\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412121814145.png\" />\n\n首先需要做好中间抽象层的设计，然后依照这抽象层一次将实现层的每一个模块进行实现。这一步提现了实现层**向上依赖抽象层**\n另一方面，抽象层向业务逻辑层暴露出功能的接口，业务逻辑层只需要根据暴露出来的接口实现对也的业务逻辑即可，无需关系功能具体是如何实现\n\n### 合成复用原则\n\n如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用组合，就大大降低了这种依赖关系。对于组合和继承，优先使用组合。（Go天然实现组合😂）\n比如父类有100个方法，而子类只想使用其中的某一个方法，那么子类采用组合的方式就能屏蔽掉父类的其他99个方法\n\n### 迪米特法则\n\n一个对象应当对其他对象尽可能了解得少，从而降低各个对象之间的耦合，提高系统的可维护性。\n\n## 创建型模式\n### 简单工厂模式\n\n**业务逻辑层 --->  工厂模块 ---> 基础类模块**\n\n反例：业务逻辑层 ---> 基础类模块\n```go\ntype Fruit struct {  \n}  \n  \nfunc (f *Fruit) Name() {  \n    }  \n  \nfunc NewFruit(name string) *Fruit {  \n    res := &Fruit{}  \n    switch {  \n    case name == \"apple\":  \n       // do something  \n    case name == \"pear\":  \n       // do something  \n    default:  \n       // do something  \n    }  \n    return res  \n}  \n  \nfunc main() {  \n    apple := NewFruit(\"apple\")  \n    apple.Name()  \n    pear := NewFruit(\"pear\")  \n    pear.Name()  \n}\n```\n简单工厂模式实现代码：\n```go\ntype Fruit interface {  \n    Show()  \n}  \n  \ntype Apple struct {  \n}  \n  \nfunc (a *Apple) Show() {  \n}  \n  \ntype Pear struct{  \n}  \n  \nfunc (p *Pear) Show() {  \n}  \n  \ntype Banana struct{  \n}  \n  \nfunc (b *Banana) Show() {  \n}  \n  \ntype Factory struct{}  \n  \nfunc (f *Factory) CreateFruit(name string) (Fruit, bool) {  \n    var fruit Fruit  \n    ok := false  \n    switch {  \n    case name == \"apple\":  \n       fruit, ok = new(Apple), true  \n    case name == \"pear\":  \n       fruit, ok = new(Pear), true  \n    case name == \"banana\":  \n       fruit, ok = new(Banana), true  \n    }  \n    return fruit, ok  \n}  \n  \n\n```\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412151724598.png)\n\n**优点**：\n1. 实现了对象创建和使用的分离\n**缺点**：\n1. 违法“开闭原则”\n2. 工厂类职责过重，一旦不能工作，系统深受影响\n3. 复杂度和理解度随着类的个数增加\n\n### 工厂模式\n\n工厂模式就是“简单工厂模式 + 开闭原则”\n在Go里面，实现工厂模式比较常见的写法就是`Newxxx()`\n```go\nfunc NewFactory() *Factory {  \n    return &Factory{}  \n}\n```\n### 单例模式\n\n> 保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用\n\n**饿汉式**：\n```go\ntype single struct{}  \n  \nvar instance = new(single)  \n  \nfunc (s *single) Show() {  \n    // do something  \n}  \n  \nfunc GetInstance() *single {  \n    return instance  \n}\n```\n**懒汉式**：延迟初始化，直到调用GetInstance方法时才进行初始化。需要重点关心的是如何保证并发安全\n\t- 锁\n\t- 原子操作\n\t- once\n```go\ntype single struct{}  \n  \nvar (  \n    instance *single  \n    mtx sync.RWMutex  \n    lock uint32  \n    once sync.Once  \n)  \n  \nfunc GetInstance() *single {  \n    // 保证并发安全：锁、原子操作、once  \n    // 原子操作  \n    //if atomic.LoadUint32(&lock) == 1 {  \n    // return instance    //}    //mtx.Lock()    //defer mtx.Unlock()    //instance = new(single)    //return instance        // once  \n    once.Do(func() {  \n       instance = new(single)  \n    })  \n    return instance  \n}\n```\n## 结构型模式\n\n### 代理模式\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412182052160.png)\n\n**Subject**：具体主题和代理主题的公共接口\n**RealSubject**：具体主题\n**Proxy**：代理主题，**包含了对具体主题角色的引用**，通常可以在代理主题中封装具体主题需要执行的一些流程，提高代码复用性\n\n```go\ntype D interface {  \n    Dance()  \n}  \n  \ntype KunDance struct {  \n}  \n  \nfunc (k *KunDance) Dance() {  \n    fmt.Println(\"KunDance\")  \n}  \n  \ntype KunKunDance struct{}  \n  \nfunc (k *KunKunDance) Dance() {}  \n  \ntype SingDanceRap struct {  \n    d D  \n}  \n  \nfunc (s *SingDanceRap) Dance() {  \n    s.Sing()  \n    // 动态调用某一个Dance方法  \n    s.d.Dance()  \n    s.Rap()  \n}  \n  \nfunc (s *SingDanceRap) Sing() {}  \n  \nfunc (s *SingDanceRap) Rap() {}  \n  \nfunc NewSingDanceRap(d D) D {  \n    return &SingDanceRap{  \n       d: d,  \n    }  \n}\n```\n感觉核心点在于，实现一个公共的接口，封装一些重复性的代码，提高复用🤔\n\n### 装饰器模式\n\n装饰器模式和代理模式很像，都是在原有接口上进行功能的扩展。典型的模板就是**结构体 组合 待扩展的接口**\n```go\ntype Phone interface {  \n    Show()  \n}  \n  \ntype Hua struct {  \n}  \n  \nfunc (h *Hua) Show() {  \n  \n}  \n  \ntype PhonePlus struct {  \n    Phone  \n}  \n  \nfunc (pp *PhonePlus) Show() {  \n  \n}  \n  \nfunc (pp *PhonePlus) AnotherMethod() {  \n  \n}\n```\n\n### 适配器模式\n\n适配器模式可以实现一个类或接口能够在一个与之毫不相干的接口环境运行、作用\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412202127687.png)\n\n```go\ntype V5 interface{  \n    Use5() }  \n  \ntype V220 interface{  \n    Use220()  \n}  \n  \ntype Adapter struct {  \n    v220 V220  \n}  \n  \nfunc (a *Adapter) Use5() {  \n    a.v220.Use220()  \n}  \n  \nfunc NewAdapter(v220 V220) *Adapter {  \n    return &Adapter{v220: v220}  \n}\n```\n\n### 外观模式\n\n外观模式本质上就是添加一个中间层，这个中间层向上层提供了底层API的封装，降低了业务层和底层的耦合\n```go\ntype A struct {}  \n  \nfunc (a *A)work() {  \n    }  \n  \ntype T struct {  \n    a *A  \n}\n```\n\n## 行为型模式\n### 模板方法模式\n\n模板方法模式可以用于统一接口方法的操作步骤，忽视每个实例对于方法的具体实现\n（Go确实不适合按照严格的设计模式类图进行编码）\n\n```go\ntype Work interface {  \n    Step1()  \n    Step2()  \n    Step3()  \n}  \n  \ntype WorkFlow interface {  \n    DoSomething()  \n}  \n  \ntype BasicWorkFlow struct {  \n    Work  \n}  \n  \nfunc (wf *BasicWorkFlow) DoSomething() {  \n    wf.Step1()  \n    wf.Step2()  \n    wf.Step3()  \n}\n```\n\n### 命令模式\n\n命令模式是在一个功能类上提供特殊的命令类，用于区分功能类中的特定功能。向业务方屏蔽了功能类的具体细节。在命令类的基础上组合出一个中间类，中间类向业务方提供统一的接口，进一步屏蔽了不同命令之间的差异\n\n```go\ntype Doctor struct {}  \n  \nfunc (d *Doctor) treatEye() {  \n    }  \n  \ntype Cmd interface {  \n    Treat()  \n}  \n  \ntype Nurse struct {  \n    cmds []Cmd  \n}  \n  \nfunc (n *Nurse) Notify() {  \n    if n.cmds == nil {  \n       return  \n    }  \n    for i := range n.cmds {  \n       n.cmds[i].Treat()  \n    }  \n}  \n  \nfunc (d *Doctor) treatNose() {}  \n  \ntype cmdEye struct {  \n    d *Doctor  \n}  \n  \nfunc (c *cmdEye) Treat() {  \n    c.d.treatEye()  \n}  \n  \ntype cmdNose struct {  \n    d *Doctor  \n}\n```\n### 策略模式\n\n为环境类配置一个接口，通过这个接口用户可以自由切换功能相同但实现不同的算法\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412242041157.png)\n\n```go\ntype Strategy interface {  \n    UseWeapon()  \n}  \n  \ntype AK struct{}  \n  \nfunc (a *AK) UseWeapon() {  \n    fmt.Println(\"ak\")  \n}  \n  \ntype Knife struct{}  \n  \nfunc (k *Knife) UseWeapon() { fmt.Println(\"k\") }  \n  \ntype Person struct {  \n    s Strategy  \n}  \n  \nfunc (p *Person) SetStrategy(s Strategy) {  \n    p.s = s  \n}  \n  \nfunc (p *Person) Fight() {  \n    p.s.UseWeapon()  \n}\n\n```\n### 观察者模式\n\n如果系统需要创建一个触发链，A对象的行为影响B对象，B对象的行为影响C对象...，就可以使用观察者模式创建一种链式触发机制\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412242129694.png)\n\n```go\ntype Listener interface {  \n    OnTeacherComing()  \n}  \n  \ntype StuZ3 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuZ3) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype StuZ4 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuZ4) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype StuW5 struct {  \n    badThing string  \n}  \n  \nfunc (s *StuW5) OnTeacherComing() {  \n    fmt.Println(\"z3 stop\", s.badThing)  \n}  \n  \ntype Notifier interface {  \n    Add(l Listener)  \n    Del(l Listener)  \n    Notify()  \n}  \n  \ntype Monitor struct {  \n    listeners []Listener  \n}  \n  \nfunc (m *Monitor) Add(l Listener) {  \n    if m.listeners != nil {  \n       m.listeners = append(m.listeners, l)  \n    }  \n}  \n  \nfunc (m *Monitor) Del(l Listener) {  \n    //TODO implement me  \n    panic(\"implement me\")  \n}  \n  \nfunc (m *Monitor) Notify() {  \n    for i := range m.listeners {  \n       m.listeners[i].OnTeacherComing()  \n    }  \n}\n```\n","slug":"设计模式","published":1,"updated":"2024-12-27T11:31:47.220Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001ga5t2foln64hw","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><blockquote>\n<p>这是<a href=\"https://www.bilibili.com/video/BV1Eg411m7rV/?spm_id_from=333.1387.collection.video_card.click&vd_source=a15269894d9b8114cb5f9bb663d22be9\">Easy搞定Golang设计模式</a>的学习记录</p>\n</blockquote>\n<h2 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h2><h3 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h3><p>类的职责单一，对外只提供一种功能，而引起类的变化的原因通常只有一个。这是为了避免别人看代码时产生歧义，提高代码的逻辑性</p>\n<p>设计一个类，对外提供的功能应该单一，接口单一，仅有这个接口会影响这个类。一个类的一个接口应具备这个类的功能含义，职责单一并且不复杂</p>\n<h3 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h3><blockquote>\n<p>对扩展开放，对修改关闭</p>\n</blockquote>\n<p>如果我们想为某个类增添新的功能，最好的方法是基于接口或者组合的方式对其进行扩展，而不是在原有的类代码上进行修改。比如一个类已经有了99个方法，那么增添第100个方法时就很有可能导致前面99个方法无法正常工作（毕竟谁知道那99个方法用了什么奇技淫巧）</p>\n<p>所以开闭原则的核心思想就是：不是通过修改代码,而是通过增添代码来给系统添加功能</p>\n<h3 id=\"依赖倒转原则（重要）\"><a href=\"#依赖倒转原则（重要）\" class=\"headerlink\" title=\"依赖倒转原则（重要）\"></a>依赖倒转原则（重要）</h3><p>感觉依赖倒转原则的核心就是<strong>面向接口编程</strong><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412121814145.png\" /></p>\n<p>首先需要做好中间抽象层的设计，然后依照这抽象层一次将实现层的每一个模块进行实现。这一步提现了实现层<strong>向上依赖抽象层</strong><br>另一方面，抽象层向业务逻辑层暴露出功能的接口，业务逻辑层只需要根据暴露出来的接口实现对也的业务逻辑即可，无需关系功能具体是如何实现</p>\n<h3 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用组合，就大大降低了这种依赖关系。对于组合和继承，优先使用组合。（Go天然实现组合😂）<br>比如父类有100个方法，而子类只想使用其中的某一个方法，那么子类采用组合的方式就能屏蔽掉父类的其他99个方法</p>\n<h3 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h3><p>一个对象应当对其他对象尽可能了解得少，从而降低各个对象之间的耦合，提高系统的可维护性。</p>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p><strong>业务逻辑层 —&gt;  工厂模块 —&gt; 基础类模块</strong></p>\n<p>反例：业务逻辑层 —&gt; 基础类模块</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fruit <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Fruit)</span></span> Name() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFruit</span><span class=\"params\">(name <span class=\"type\">string</span>)</span></span> *Fruit &#123;  </span><br><span class=\"line\">    res := &amp;Fruit&#123;&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;apple&quot;</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;pear&quot;</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">    apple := NewFruit(<span class=\"string\">&quot;apple&quot;</span>)  </span><br><span class=\"line\">    apple.Name()  </span><br><span class=\"line\">    pear := NewFruit(<span class=\"string\">&quot;pear&quot;</span>)  </span><br><span class=\"line\">    pear.Name()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单工厂模式实现代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fruit <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Show()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Apple <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Apple)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Pear <span class=\"keyword\">struct</span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pear)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Banana <span class=\"keyword\">struct</span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Banana)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Factory <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Factory)</span></span> CreateFruit(name <span class=\"type\">string</span>) (Fruit, <span class=\"type\">bool</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> fruit Fruit  </span><br><span class=\"line\">    ok := <span class=\"literal\">false</span>  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;apple&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Apple), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;pear&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Pear), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;banana&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Banana), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fruit, ok  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412151724598.png\" alt=\"image.png\"></p>\n<p><strong>优点</strong>：</p>\n<ol>\n<li>实现了对象创建和使用的分离<br><strong>缺点</strong>：</li>\n<li>违法“开闭原则”</li>\n<li>工厂类职责过重，一旦不能工作，系统深受影响</li>\n<li>复杂度和理解度随着类的个数增加</li>\n</ol>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式就是“简单工厂模式 + 开闭原则”<br>在Go里面，实现工厂模式比较常见的写法就是<code>Newxxx()</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFactory</span><span class=\"params\">()</span></span> *Factory &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Factory&#123;&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><blockquote>\n<p>保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用</p>\n</blockquote>\n<p><strong>饿汉式</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> single <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"built_in\">new</span>(single)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *single)</span></span> Show() &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// do something  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span> *single &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式</strong>：延迟初始化，直到调用GetInstance方法时才进行初始化。需要重点关心的是如何保证并发安全<br>    - 锁<br>    - 原子操作<br>    - once</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> single <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> (  </span><br><span class=\"line\">    instance *single  </span><br><span class=\"line\">    mtx sync.RWMutex  </span><br><span class=\"line\">    lock <span class=\"type\">uint32</span>  </span><br><span class=\"line\">    once sync.Once  </span><br><span class=\"line\">)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span> *single &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 保证并发安全：锁、原子操作、once  </span></span><br><span class=\"line\">    <span class=\"comment\">// 原子操作  </span></span><br><span class=\"line\">    <span class=\"comment\">//if atomic.LoadUint32(&amp;lock) == 1 &#123;  </span></span><br><span class=\"line\">    <span class=\"comment\">// return instance    //&#125;    //mtx.Lock()    //defer mtx.Unlock()    //instance = new(single)    //return instance        // once  </span></span><br><span class=\"line\">    once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">       instance = <span class=\"built_in\">new</span>(single)  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412182052160.png\" alt=\"image.png\"></p>\n<p><strong>Subject</strong>：具体主题和代理主题的公共接口<br><strong>RealSubject</strong>：具体主题<br><strong>Proxy</strong>：代理主题，<strong>包含了对具体主题角色的引用</strong>，通常可以在代理主题中封装具体主题需要执行的一些流程，提高代码复用性</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> D <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Dance()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> KunDance <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *KunDance)</span></span> Dance() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;KunDance&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> KunKunDance <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *KunKunDance)</span></span> Dance() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> SingDanceRap <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d D  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Dance() &#123;  </span><br><span class=\"line\">    s.Sing()  </span><br><span class=\"line\">    <span class=\"comment\">// 动态调用某一个Dance方法  </span></span><br><span class=\"line\">    s.d.Dance()  </span><br><span class=\"line\">    s.Rap()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Sing() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Rap() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSingDanceRap</span><span class=\"params\">(d D)</span></span> D &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;SingDanceRap&#123;  </span><br><span class=\"line\">       d: d,  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉核心点在于，实现一个公共的接口，封装一些重复性的代码，提高复用🤔</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p>装饰器模式和代理模式很像，都是在原有接口上进行功能的扩展。典型的模板就是<strong>结构体 组合 待扩展的接口</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Phone <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Show()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Hua <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Hua)</span></span> Show() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> PhonePlus <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    Phone  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *PhonePlus)</span></span> Show() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *PhonePlus)</span></span> AnotherMethod() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>适配器模式可以实现一个类或接口能够在一个与之毫不相干的接口环境运行、作用</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412202127687.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> V5 <span class=\"keyword\">interface</span>&#123;  </span><br><span class=\"line\">    Use5() &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> V220 <span class=\"keyword\">interface</span>&#123;  </span><br><span class=\"line\">    Use220()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Adapter <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    v220 V220  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Adapter)</span></span> Use5() &#123;  </span><br><span class=\"line\">    a.v220.Use220()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAdapter</span><span class=\"params\">(v220 V220)</span></span> *Adapter &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Adapter&#123;v220: v220&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式本质上就是添加一个中间层，这个中间层向上层提供了底层API的封装，降低了业务层和底层的耦合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> A <span class=\"keyword\">struct</span> &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *A)</span></span>work() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    a *A  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><p>模板方法模式可以用于统一接口方法的操作步骤，忽视每个实例对于方法的具体实现<br>（Go确实不适合按照严格的设计模式类图进行编码）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Work <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Step1()  </span><br><span class=\"line\">    Step2()  </span><br><span class=\"line\">    Step3()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> WorkFlow <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    DoSomething()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> BasicWorkFlow <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    Work  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wf *BasicWorkFlow)</span></span> DoSomething() &#123;  </span><br><span class=\"line\">    wf.Step1()  </span><br><span class=\"line\">    wf.Step2()  </span><br><span class=\"line\">    wf.Step3()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>命令模式是在一个功能类上提供特殊的命令类，用于区分功能类中的特定功能。向业务方屏蔽了功能类的具体细节。在命令类的基础上组合出一个中间类，中间类向业务方提供统一的接口，进一步屏蔽了不同命令之间的差异</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Doctor <span class=\"keyword\">struct</span> &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d *Doctor)</span></span> treatEye() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Treat()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Nurse <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    cmds []Cmd  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Nurse)</span></span> Notify() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n.cmds == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">return</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> n.cmds &#123;  </span><br><span class=\"line\">       n.cmds[i].Treat()  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d *Doctor)</span></span> treatNose() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> cmdEye <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d *Doctor  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cmdEye)</span></span> Treat() &#123;  </span><br><span class=\"line\">    c.d.treatEye()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> cmdNose <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d *Doctor  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><p>为环境类配置一个接口，通过这个接口用户可以自由切换功能相同但实现不同的算法</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412242041157.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Strategy <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    UseWeapon()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> AK <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AK)</span></span> UseWeapon() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;ak&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Knife <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *Knife)</span></span> UseWeapon() &#123; fmt.Println(<span class=\"string\">&quot;k&quot;</span>) &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    s Strategy  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span></span> SetStrategy(s Strategy) &#123;  </span><br><span class=\"line\">    p.s = s  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span></span> Fight() &#123;  </span><br><span class=\"line\">    p.s.UseWeapon()  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>如果系统需要创建一个触发链，A对象的行为影响B对象，B对象的行为影响C对象…，就可以使用观察者模式创建一种链式触发机制<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412242129694.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Listener <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    OnTeacherComing()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuZ3 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuZ3)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuZ4 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuZ4)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuW5 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuW5)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Notifier <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Add(l Listener)  </span><br><span class=\"line\">    Del(l Listener)  </span><br><span class=\"line\">    Notify()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Monitor <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    listeners []Listener  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Add(l Listener) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> m.listeners != <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">       m.listeners = <span class=\"built_in\">append</span>(m.listeners, l)  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Del(l Listener) &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//TODO implement me  </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;implement me&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Notify() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> m.listeners &#123;  </span><br><span class=\"line\">       m.listeners[i].OnTeacherComing()  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><blockquote>\n<p>这是<a href=\"https://www.bilibili.com/video/BV1Eg411m7rV/?spm_id_from=333.1387.collection.video_card.click&vd_source=a15269894d9b8114cb5f9bb663d22be9\">Easy搞定Golang设计模式</a>的学习记录</p>\n</blockquote>\n<h2 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h2><h3 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h3><p>类的职责单一，对外只提供一种功能，而引起类的变化的原因通常只有一个。这是为了避免别人看代码时产生歧义，提高代码的逻辑性</p>\n<p>设计一个类，对外提供的功能应该单一，接口单一，仅有这个接口会影响这个类。一个类的一个接口应具备这个类的功能含义，职责单一并且不复杂</p>\n<h3 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h3><blockquote>\n<p>对扩展开放，对修改关闭</p>\n</blockquote>\n<p>如果我们想为某个类增添新的功能，最好的方法是基于接口或者组合的方式对其进行扩展，而不是在原有的类代码上进行修改。比如一个类已经有了99个方法，那么增添第100个方法时就很有可能导致前面99个方法无法正常工作（毕竟谁知道那99个方法用了什么奇技淫巧）</p>\n<p>所以开闭原则的核心思想就是：不是通过修改代码,而是通过增添代码来给系统添加功能</p>\n<h3 id=\"依赖倒转原则（重要）\"><a href=\"#依赖倒转原则（重要）\" class=\"headerlink\" title=\"依赖倒转原则（重要）\"></a>依赖倒转原则（重要）</h3><p>感觉依赖倒转原则的核心就是<strong>面向接口编程</strong><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412121814145.png\" /></p>\n<p>首先需要做好中间抽象层的设计，然后依照这抽象层一次将实现层的每一个模块进行实现。这一步提现了实现层<strong>向上依赖抽象层</strong><br>另一方面，抽象层向业务逻辑层暴露出功能的接口，业务逻辑层只需要根据暴露出来的接口实现对也的业务逻辑即可，无需关系功能具体是如何实现</p>\n<h3 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用组合，就大大降低了这种依赖关系。对于组合和继承，优先使用组合。（Go天然实现组合😂）<br>比如父类有100个方法，而子类只想使用其中的某一个方法，那么子类采用组合的方式就能屏蔽掉父类的其他99个方法</p>\n<h3 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h3><p>一个对象应当对其他对象尽可能了解得少，从而降低各个对象之间的耦合，提高系统的可维护性。</p>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p><strong>业务逻辑层 —&gt;  工厂模块 —&gt; 基础类模块</strong></p>\n<p>反例：业务逻辑层 —&gt; 基础类模块</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fruit <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Fruit)</span></span> Name() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFruit</span><span class=\"params\">(name <span class=\"type\">string</span>)</span></span> *Fruit &#123;  </span><br><span class=\"line\">    res := &amp;Fruit&#123;&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;apple&quot;</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;pear&quot;</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:  </span><br><span class=\"line\">       <span class=\"comment\">// do something  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">    apple := NewFruit(<span class=\"string\">&quot;apple&quot;</span>)  </span><br><span class=\"line\">    apple.Name()  </span><br><span class=\"line\">    pear := NewFruit(<span class=\"string\">&quot;pear&quot;</span>)  </span><br><span class=\"line\">    pear.Name()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单工厂模式实现代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Fruit <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Show()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Apple <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Apple)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Pear <span class=\"keyword\">struct</span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Pear)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Banana <span class=\"keyword\">struct</span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Banana)</span></span> Show() &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Factory <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Factory)</span></span> CreateFruit(name <span class=\"type\">string</span>) (Fruit, <span class=\"type\">bool</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> fruit Fruit  </span><br><span class=\"line\">    ok := <span class=\"literal\">false</span>  </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;apple&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Apple), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;pear&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Pear), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> name == <span class=\"string\">&quot;banana&quot;</span>:  </span><br><span class=\"line\">       fruit, ok = <span class=\"built_in\">new</span>(Banana), <span class=\"literal\">true</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fruit, ok  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412151724598.png\" alt=\"image.png\"></p>\n<p><strong>优点</strong>：</p>\n<ol>\n<li>实现了对象创建和使用的分离<br><strong>缺点</strong>：</li>\n<li>违法“开闭原则”</li>\n<li>工厂类职责过重，一旦不能工作，系统深受影响</li>\n<li>复杂度和理解度随着类的个数增加</li>\n</ol>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式就是“简单工厂模式 + 开闭原则”<br>在Go里面，实现工厂模式比较常见的写法就是<code>Newxxx()</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFactory</span><span class=\"params\">()</span></span> *Factory &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Factory&#123;&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><blockquote>\n<p>保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用</p>\n</blockquote>\n<p><strong>饿汉式</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> single <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"built_in\">new</span>(single)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *single)</span></span> Show() &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// do something  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span> *single &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式</strong>：延迟初始化，直到调用GetInstance方法时才进行初始化。需要重点关心的是如何保证并发安全<br>    - 锁<br>    - 原子操作<br>    - once</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> single <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> (  </span><br><span class=\"line\">    instance *single  </span><br><span class=\"line\">    mtx sync.RWMutex  </span><br><span class=\"line\">    lock <span class=\"type\">uint32</span>  </span><br><span class=\"line\">    once sync.Once  </span><br><span class=\"line\">)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span> *single &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 保证并发安全：锁、原子操作、once  </span></span><br><span class=\"line\">    <span class=\"comment\">// 原子操作  </span></span><br><span class=\"line\">    <span class=\"comment\">//if atomic.LoadUint32(&amp;lock) == 1 &#123;  </span></span><br><span class=\"line\">    <span class=\"comment\">// return instance    //&#125;    //mtx.Lock()    //defer mtx.Unlock()    //instance = new(single)    //return instance        // once  </span></span><br><span class=\"line\">    once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;  </span><br><span class=\"line\">       instance = <span class=\"built_in\">new</span>(single)  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412182052160.png\" alt=\"image.png\"></p>\n<p><strong>Subject</strong>：具体主题和代理主题的公共接口<br><strong>RealSubject</strong>：具体主题<br><strong>Proxy</strong>：代理主题，<strong>包含了对具体主题角色的引用</strong>，通常可以在代理主题中封装具体主题需要执行的一些流程，提高代码复用性</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> D <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Dance()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> KunDance <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *KunDance)</span></span> Dance() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;KunDance&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> KunKunDance <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *KunKunDance)</span></span> Dance() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> SingDanceRap <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d D  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Dance() &#123;  </span><br><span class=\"line\">    s.Sing()  </span><br><span class=\"line\">    <span class=\"comment\">// 动态调用某一个Dance方法  </span></span><br><span class=\"line\">    s.d.Dance()  </span><br><span class=\"line\">    s.Rap()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Sing() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SingDanceRap)</span></span> Rap() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSingDanceRap</span><span class=\"params\">(d D)</span></span> D &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;SingDanceRap&#123;  </span><br><span class=\"line\">       d: d,  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉核心点在于，实现一个公共的接口，封装一些重复性的代码，提高复用🤔</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p>装饰器模式和代理模式很像，都是在原有接口上进行功能的扩展。典型的模板就是<strong>结构体 组合 待扩展的接口</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Phone <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Show()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Hua <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Hua)</span></span> Show() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> PhonePlus <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    Phone  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *PhonePlus)</span></span> Show() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *PhonePlus)</span></span> AnotherMethod() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>适配器模式可以实现一个类或接口能够在一个与之毫不相干的接口环境运行、作用</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412202127687.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> V5 <span class=\"keyword\">interface</span>&#123;  </span><br><span class=\"line\">    Use5() &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> V220 <span class=\"keyword\">interface</span>&#123;  </span><br><span class=\"line\">    Use220()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Adapter <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    v220 V220  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Adapter)</span></span> Use5() &#123;  </span><br><span class=\"line\">    a.v220.Use220()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAdapter</span><span class=\"params\">(v220 V220)</span></span> *Adapter &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Adapter&#123;v220: v220&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><p>外观模式本质上就是添加一个中间层，这个中间层向上层提供了底层API的封装，降低了业务层和底层的耦合</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> A <span class=\"keyword\">struct</span> &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *A)</span></span>work() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    a *A  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><p>模板方法模式可以用于统一接口方法的操作步骤，忽视每个实例对于方法的具体实现<br>（Go确实不适合按照严格的设计模式类图进行编码）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Work <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Step1()  </span><br><span class=\"line\">    Step2()  </span><br><span class=\"line\">    Step3()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> WorkFlow <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    DoSomething()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> BasicWorkFlow <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    Work  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wf *BasicWorkFlow)</span></span> DoSomething() &#123;  </span><br><span class=\"line\">    wf.Step1()  </span><br><span class=\"line\">    wf.Step2()  </span><br><span class=\"line\">    wf.Step3()  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><p>命令模式是在一个功能类上提供特殊的命令类，用于区分功能类中的特定功能。向业务方屏蔽了功能类的具体细节。在命令类的基础上组合出一个中间类，中间类向业务方提供统一的接口，进一步屏蔽了不同命令之间的差异</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Doctor <span class=\"keyword\">struct</span> &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d *Doctor)</span></span> treatEye() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Treat()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Nurse <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    cmds []Cmd  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Nurse)</span></span> Notify() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n.cmds == <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">return</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> n.cmds &#123;  </span><br><span class=\"line\">       n.cmds[i].Treat()  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d *Doctor)</span></span> treatNose() &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> cmdEye <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d *Doctor  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cmdEye)</span></span> Treat() &#123;  </span><br><span class=\"line\">    c.d.treatEye()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> cmdNose <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    d *Doctor  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><p>为环境类配置一个接口，通过这个接口用户可以自由切换功能相同但实现不同的算法</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412242041157.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Strategy <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    UseWeapon()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> AK <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AK)</span></span> UseWeapon() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;ak&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Knife <span class=\"keyword\">struct</span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(k *Knife)</span></span> UseWeapon() &#123; fmt.Println(<span class=\"string\">&quot;k&quot;</span>) &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    s Strategy  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span></span> SetStrategy(s Strategy) &#123;  </span><br><span class=\"line\">    p.s = s  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span></span> Fight() &#123;  </span><br><span class=\"line\">    p.s.UseWeapon()  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>如果系统需要创建一个触发链，A对象的行为影响B对象，B对象的行为影响C对象…，就可以使用观察者模式创建一种链式触发机制<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412242129694.png\" alt=\"image.png\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Listener <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    OnTeacherComing()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuZ3 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuZ3)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuZ4 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuZ4)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> StuW5 <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    badThing <span class=\"type\">string</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *StuW5)</span></span> OnTeacherComing() &#123;  </span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;z3 stop&quot;</span>, s.badThing)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Notifier <span class=\"keyword\">interface</span> &#123;  </span><br><span class=\"line\">    Add(l Listener)  </span><br><span class=\"line\">    Del(l Listener)  </span><br><span class=\"line\">    Notify()  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">type</span> Monitor <span class=\"keyword\">struct</span> &#123;  </span><br><span class=\"line\">    listeners []Listener  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Add(l Listener) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> m.listeners != <span class=\"literal\">nil</span> &#123;  </span><br><span class=\"line\">       m.listeners = <span class=\"built_in\">append</span>(m.listeners, l)  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Del(l Listener) &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//TODO implement me  </span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;implement me&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Monitor)</span></span> Notify() &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> m.listeners &#123;  </span><br><span class=\"line\">       m.listeners[i].OnTeacherComing()  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"publish":false,"_content":"# 读书笔记\n\n## 身份资本\n\n这一章的观点：**那些真正决定你未来职业道路的，并不是你在学校学的专业和GPA，而是两三个能让别人对你产生兴趣的身份资本。**\n\n对于身份资本的理解：是一个人的过往经历、技能，直观上就是**简历**\n\n正如《劝学》：**吾尝终日而思矣，不如须臾之所学也**。与其过度的进行自我探索，不如花更多的时间积累身份资本。但这也并不意味着不需要进行自我探索，作者借助**埃里克森求学经历**说明**经历身份认同危机和积累身份资本，可以而且应该同时进行**\n\n这一章还有一个比较重要的点就是**要积累有价值的身份资本**\n\n借助文章中的🌰：一个人可以选择去咖啡馆充当服务生，但这种身份资本并没有显著的价值，无法引起别人的关注；而作为一名动画制作者，具有一定的技术能力，相较于前者则更有价值\n\n## 弱连接\n\n> 富兰克林效应：当你为某人提供帮助之后，你会更喜欢（帮助）这个人\n\n这一章的观点：**那些我们不怎么了解、不怎么认识的人，往往是对我们的人生改变最大、帮助最大的人。**\n\n一个人的强连接就是他熟悉的一群人，可以说就是他所处的圈子；反之，弱连接就是圈子之外的人\n\n古语云：**物以类聚，人以群分**。性格、知识储备量越相近的人越容易聚成一圈，形成强连接，此时想要有所突破，那么必定需要借助圈子之外的力量（**他山之玉，可以攻石**）。作者借以他自身为例，证实**弱连接有时会带来意想不到的资源**\n\n但当我们求助于**弱连接**时，应该注意我们的提问方式应该**具体、针对性强**，与其空泛地问如何做，不如直接看他人的成功的凭证（产出、结果）。\n\n🌰：~~请问这个图书提案怎么写？~~\t请问能借我看看你的图书提案吗？","source":"_posts/读书笔记.md","raw":"---\npublish: false\n---\n# 读书笔记\n\n## 身份资本\n\n这一章的观点：**那些真正决定你未来职业道路的，并不是你在学校学的专业和GPA，而是两三个能让别人对你产生兴趣的身份资本。**\n\n对于身份资本的理解：是一个人的过往经历、技能，直观上就是**简历**\n\n正如《劝学》：**吾尝终日而思矣，不如须臾之所学也**。与其过度的进行自我探索，不如花更多的时间积累身份资本。但这也并不意味着不需要进行自我探索，作者借助**埃里克森求学经历**说明**经历身份认同危机和积累身份资本，可以而且应该同时进行**\n\n这一章还有一个比较重要的点就是**要积累有价值的身份资本**\n\n借助文章中的🌰：一个人可以选择去咖啡馆充当服务生，但这种身份资本并没有显著的价值，无法引起别人的关注；而作为一名动画制作者，具有一定的技术能力，相较于前者则更有价值\n\n## 弱连接\n\n> 富兰克林效应：当你为某人提供帮助之后，你会更喜欢（帮助）这个人\n\n这一章的观点：**那些我们不怎么了解、不怎么认识的人，往往是对我们的人生改变最大、帮助最大的人。**\n\n一个人的强连接就是他熟悉的一群人，可以说就是他所处的圈子；反之，弱连接就是圈子之外的人\n\n古语云：**物以类聚，人以群分**。性格、知识储备量越相近的人越容易聚成一圈，形成强连接，此时想要有所突破，那么必定需要借助圈子之外的力量（**他山之玉，可以攻石**）。作者借以他自身为例，证实**弱连接有时会带来意想不到的资源**\n\n但当我们求助于**弱连接**时，应该注意我们的提问方式应该**具体、针对性强**，与其空泛地问如何做，不如直接看他人的成功的凭证（产出、结果）。\n\n🌰：~~请问这个图书提案怎么写？~~\t请问能借我看看你的图书提案吗？","slug":"读书笔记","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001ia5t287w23lc6","content":"<h1 id=\"读书笔记\"><a href=\"#读书笔记\" class=\"headerlink\" title=\"读书笔记\"></a>读书笔记</h1><h2 id=\"身份资本\"><a href=\"#身份资本\" class=\"headerlink\" title=\"身份资本\"></a>身份资本</h2><p>这一章的观点：<strong>那些真正决定你未来职业道路的，并不是你在学校学的专业和GPA，而是两三个能让别人对你产生兴趣的身份资本。</strong></p>\n<p>对于身份资本的理解：是一个人的过往经历、技能，直观上就是<strong>简历</strong></p>\n<p>正如《劝学》：<strong>吾尝终日而思矣，不如须臾之所学也</strong>。与其过度的进行自我探索，不如花更多的时间积累身份资本。但这也并不意味着不需要进行自我探索，作者借助<strong>埃里克森求学经历</strong>说明<strong>经历身份认同危机和积累身份资本，可以而且应该同时进行</strong></p>\n<p>这一章还有一个比较重要的点就是<strong>要积累有价值的身份资本</strong></p>\n<p>借助文章中的🌰：一个人可以选择去咖啡馆充当服务生，但这种身份资本并没有显著的价值，无法引起别人的关注；而作为一名动画制作者，具有一定的技术能力，相较于前者则更有价值</p>\n<h2 id=\"弱连接\"><a href=\"#弱连接\" class=\"headerlink\" title=\"弱连接\"></a>弱连接</h2><blockquote>\n<p>富兰克林效应：当你为某人提供帮助之后，你会更喜欢（帮助）这个人</p>\n</blockquote>\n<p>这一章的观点：<strong>那些我们不怎么了解、不怎么认识的人，往往是对我们的人生改变最大、帮助最大的人。</strong></p>\n<p>一个人的强连接就是他熟悉的一群人，可以说就是他所处的圈子；反之，弱连接就是圈子之外的人</p>\n<p>古语云：<strong>物以类聚，人以群分</strong>。性格、知识储备量越相近的人越容易聚成一圈，形成强连接，此时想要有所突破，那么必定需要借助圈子之外的力量（<strong>他山之玉，可以攻石</strong>）。作者借以他自身为例，证实<strong>弱连接有时会带来意想不到的资源</strong></p>\n<p>但当我们求助于<strong>弱连接</strong>时，应该注意我们的提问方式应该<strong>具体、针对性强</strong>，与其空泛地问如何做，不如直接看他人的成功的凭证（产出、结果）。</p>\n<p>🌰：<del>请问这个图书提案怎么写？</del>\t请问能借我看看你的图书提案吗？</p>\n","excerpt":"","more":"<h1 id=\"读书笔记\"><a href=\"#读书笔记\" class=\"headerlink\" title=\"读书笔记\"></a>读书笔记</h1><h2 id=\"身份资本\"><a href=\"#身份资本\" class=\"headerlink\" title=\"身份资本\"></a>身份资本</h2><p>这一章的观点：<strong>那些真正决定你未来职业道路的，并不是你在学校学的专业和GPA，而是两三个能让别人对你产生兴趣的身份资本。</strong></p>\n<p>对于身份资本的理解：是一个人的过往经历、技能，直观上就是<strong>简历</strong></p>\n<p>正如《劝学》：<strong>吾尝终日而思矣，不如须臾之所学也</strong>。与其过度的进行自我探索，不如花更多的时间积累身份资本。但这也并不意味着不需要进行自我探索，作者借助<strong>埃里克森求学经历</strong>说明<strong>经历身份认同危机和积累身份资本，可以而且应该同时进行</strong></p>\n<p>这一章还有一个比较重要的点就是<strong>要积累有价值的身份资本</strong></p>\n<p>借助文章中的🌰：一个人可以选择去咖啡馆充当服务生，但这种身份资本并没有显著的价值，无法引起别人的关注；而作为一名动画制作者，具有一定的技术能力，相较于前者则更有价值</p>\n<h2 id=\"弱连接\"><a href=\"#弱连接\" class=\"headerlink\" title=\"弱连接\"></a>弱连接</h2><blockquote>\n<p>富兰克林效应：当你为某人提供帮助之后，你会更喜欢（帮助）这个人</p>\n</blockquote>\n<p>这一章的观点：<strong>那些我们不怎么了解、不怎么认识的人，往往是对我们的人生改变最大、帮助最大的人。</strong></p>\n<p>一个人的强连接就是他熟悉的一群人，可以说就是他所处的圈子；反之，弱连接就是圈子之外的人</p>\n<p>古语云：<strong>物以类聚，人以群分</strong>。性格、知识储备量越相近的人越容易聚成一圈，形成强连接，此时想要有所突破，那么必定需要借助圈子之外的力量（<strong>他山之玉，可以攻石</strong>）。作者借以他自身为例，证实<strong>弱连接有时会带来意想不到的资源</strong></p>\n<p>但当我们求助于<strong>弱连接</strong>时，应该注意我们的提问方式应该<strong>具体、针对性强</strong>，与其空泛地问如何做，不如直接看他人的成功的凭证（产出、结果）。</p>\n<p>🌰：<del>请问这个图书提案怎么写？</del>\t请问能借我看看你的图书提案吗？</p>\n"},{"_content":"- 表\n\t- 任务信息表\n\t- 消费者类型表\n\t- 任务位置表\n- 分布式锁（看门狗机制）\n- 最大重试间隔\n\t- 渐进式重试（正数表示），直至最大重试间隔、最大重试次数\n\t- 均匀重试（负数表示），直至最大重试次数\n- 排序字段设计（融合优先级）\n\t- 时间\n\t\t- 任务创建时间\n\t\t\t- 饥饿\n\t\t- 任务修改时间\n\t\t\t- 丢失重试间隔\n\t- 优先级（重要性）\n\t\t- 联合索引\n\t- order_time\n\t\t- 创建时间 - 优先级\n\t\t- 更新时间 - 优先级\n\t\t- 更新时间 + 重试间隔\n\t\t- 只有小于当前时间的order_time才会被调度\n- 滚表\n\t","source":"_posts/Asyncflow/草稿.md","raw":"- 表\n\t- 任务信息表\n\t- 消费者类型表\n\t- 任务位置表\n- 分布式锁（看门狗机制）\n- 最大重试间隔\n\t- 渐进式重试（正数表示），直至最大重试间隔、最大重试次数\n\t- 均匀重试（负数表示），直至最大重试次数\n- 排序字段设计（融合优先级）\n\t- 时间\n\t\t- 任务创建时间\n\t\t\t- 饥饿\n\t\t- 任务修改时间\n\t\t\t- 丢失重试间隔\n\t- 优先级（重要性）\n\t\t- 联合索引\n\t- order_time\n\t\t- 创建时间 - 优先级\n\t\t- 更新时间 - 优先级\n\t\t- 更新时间 + 重试间隔\n\t\t- 只有小于当前时间的order_time才会被调度\n- 滚表\n\t","slug":"Asyncflow/草稿","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2025-01-20T13:35:53.875Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001la5t227e25nl2","content":"<ul>\n<li>表<ul>\n<li>任务信息表</li>\n<li>消费者类型表</li>\n<li>任务位置表</li>\n</ul>\n</li>\n<li>分布式锁（看门狗机制）</li>\n<li>最大重试间隔<ul>\n<li>渐进式重试（正数表示），直至最大重试间隔、最大重试次数</li>\n<li>均匀重试（负数表示），直至最大重试次数</li>\n</ul>\n</li>\n<li>排序字段设计（融合优先级）<ul>\n<li>时间<ul>\n<li>任务创建时间<ul>\n<li>饥饿</li>\n</ul>\n</li>\n<li>任务修改时间<ul>\n<li>丢失重试间隔</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级（重要性）<ul>\n<li>联合索引</li>\n</ul>\n</li>\n<li>order_time<ul>\n<li>创建时间 - 优先级</li>\n<li>更新时间 - 优先级</li>\n<li>更新时间 + 重试间隔</li>\n<li>只有小于当前时间的order_time才会被调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>滚表</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>表<ul>\n<li>任务信息表</li>\n<li>消费者类型表</li>\n<li>任务位置表</li>\n</ul>\n</li>\n<li>分布式锁（看门狗机制）</li>\n<li>最大重试间隔<ul>\n<li>渐进式重试（正数表示），直至最大重试间隔、最大重试次数</li>\n<li>均匀重试（负数表示），直至最大重试次数</li>\n</ul>\n</li>\n<li>排序字段设计（融合优先级）<ul>\n<li>时间<ul>\n<li>任务创建时间<ul>\n<li>饥饿</li>\n</ul>\n</li>\n<li>任务修改时间<ul>\n<li>丢失重试间隔</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级（重要性）<ul>\n<li>联合索引</li>\n</ul>\n</li>\n<li>order_time<ul>\n<li>创建时间 - 优先级</li>\n<li>更新时间 - 优先级</li>\n<li>更新时间 + 重试间隔</li>\n<li>只有小于当前时间的order_time才会被调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>滚表</li>\n</ul>\n"},{"excalidraw-plugin":"parsed","_content":"==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'\n\n\n# Excalidraw Data\n## Text Elements\nBroker ^vpVFc8Jz\n\nConsumer ^HlcmoCYz\n\nPull Message ^iEKLY3mc\n\nProcessing ^4SqNDxs2\n\nsuccess ^i4gc31t0\n\nTrue ^6S02Vu74\n\nFalse ^thrRj5N6\n\n%%\n## Drawing\n```compressed-json\nN4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebQA2bQAOGjoghH0EDihmbgBtcDBQMBLoeHF0QOwojmVg1JLIRhZ2LjQARgAGABYAVn5S5tZOADlOMW52pKSAZk6eTt6pgchC\n\nZgARdKgEYm4AMwIwlYgSbggAIQBOegB9dcIARwA1ACUAUQBZAFVcbBYoZ7MLjHPaEfD4ADKsHqEj+bGYzGcklwUGwkgapWYUFIbAA1ggAOokdTcPiFATYvEIKEwGHoQQeDGQHF+SQccK5NCdY5sOC/NQwSadbnkiDWOoVEWNCCYbjOGbxADsyW67RmSXafUV8Xi7R4iuOgrQ8vaiR1ip4vRmMx4l0VSWOWJx+IAwmx8GxSGcAMTCv2dJkQTS/XHK\n\nFkcYhuj1eiTesTEbrEXCBijE9FoeIzbSXToKy62i2LU39UWSBCEZTSSbtS7aHhJeJJS4zXrde229WOhA7SZ9U25pbdY5h4RwACSxE5qAKjUgAEVcABBboE0gzCEEmaKmZPPaaCh7Hg3B4ABQg5IAuo7KfiIcjSHB2Qizsx73BA5phBG3sFMtkpzOjTFLOJy7BInQIA8HyEIqY57AAWnOHAnh8NyEE8STnE8YxMqUsCIGcuCkDiVDkmAAC+l7HEIc\n\nBJtsYGoO027xJ0LEzJcvS6vExxEBwuLcBwQjgjxbDYPiDEHPgRyioQEZYIRvSBns5CZBOAlCfgxzhsQT5ToJ4KFORAzAZA+EVNAWBQIGQytJM8SWscNmjOMFSKm2OpMTMQ4yRsWw9mgknSdKpwSPQcBPAAYtgSQAFJGEpYKQtC5nImiIhINezqEmmkyZVSNJ0hADKnFpwiVrpuWiry/KwEKUqlOKdL1ZAsrGuxnTaFMLbNoqJbSkaqDOFMHWqtMa\n\nrtL0lw6kk3nSk6VJRp6Pr+sKH4hiOQgRotMboNi1jMHygTZCmOUdF02hbpcbbdPElxXXaPBktKZYVlWaDdHEDYWr0vTTI9Sw9F2/moFaXQFq2w4suOk75GREALsuq7rpu267vuh7HmeVGivNt5vhVEivkR77HJ+m3ED+GRZDksOziZpQhegBLrOcADSuAABJPDFAAyIwcLJPMGM4mCSJ0ADiuGmeUhHEWwpGzpRjRXqKNF0cDnksSxlo2jdPGyfx\n\naD6ZpooemJwOBQgIKcFAEKEEYFReXWzZJD0iqLK7nSzNb2QRbg+hggN7THNsmBWRI5xZV6pOhEEskVMsoqh1Ai5EMobToMEexWY5TBQOYBCpxWGfQLygZ6NkuDx6QalGxpPKkBWskEAAKpZZyR1S0cyXJrXoLg8RKSpCC16gxuleTBNj/XorkBQbdhx3UeBrgQhQGwLzhPbFTYkIVum/HHPlpW4eMXWvSGcZScyxIvEZaKTkZ9Mly5y0zkcBMHSd\n\nIqUxtgs3E+U2MEei+xDj72CgxCAAArXAUxxas2IPEAA8usKBUlzjtByJIH4DwErggKuZOECIkQojRIGXG2ViAkjQE9TEN5qTJRfO6Eqs8ypsg5NwZqEBqrYAFHVY4jVJTHD7vKFinUli9TbM/boH0ZiGjlHMLMbYugaiSD/SaNY8qundEtWMK0AwxzEhtLaOidoQDjDsRMyZjipioemVA3QkjZnzLMPU9pegWluscF6J9uBZibGo1sPAugyIkaaB\n\nAQ05E427AxLW3RhQyNoZADa0MAJwwRiuNcG4tw7j3AeI8p5zzKy0dSfGHCJDaQ/F+Cmv5qYARVtKNWKINbMVYvMfsM19Z8XUsJU2olxKgKkuAuhREoDnFko4WoPSTbSiyMQcZEZZLKGmTxUIUA3T6ADjIHYJ42CyVPuPHGURSApzlhQMsuAGKHNmRGRcZyLlXJntKOAez/y00aIBRozUSidDIg0j5ZEwCOOcfWGYbikgeJ4F4wF/jLiBI+iEvsP9\n\n4gRLVH87GwVe6EUVEPf2I9Hm9OlNpKe9MygERoeSJWFEr7SjMmcO+1kmDDAzvmYOD8mWtDGB/BOix3bKI+scNYQCEAgICmAwVkD1g8FIAADUwGwVmDwhBszCsoHmmB4IQkuAATWwHgpKtJCE4mIciVE6ISlEjsaSEpBCmGMgnuVcpqAuE8L4V/LhgjOHCIUWI9Uk1eisS6PmfUfVSgDWcLaOI3Qcw/R4C2FsrZtwlO2stFaa0jHaRTbGeMViTpWv\n\nek4u6oLwWQuhc9Y+b1UCwvhcEnoSLwmRKBgxK6Ux2hdVmqUFJE40kgQyUjbJqM8kY0KRiuhWU7zEynhASppNqmUz/DTNAeR/mQCaaKxirTtYdI7ZAXihtp6EtKGbAZYqhnXlGQsyZyy66HsgHMy9SyVmmzWRsrZ9Fdn7KfXNY5pySIPK/aUOZdy/0hAJTM0oLz9k9oBbOMA3y4N/JWGAT5JRgVFtcfqCFniX4wuSHCyRtbQlMQbWi2cF5R2rCxRI\n\nXAKQQTD1Htc0oxKnWkrpRSxoVKjKFBMmS8yDLX7Mu4DmKJ0pH5cs/hu+JbbrSJ2Cr5YBFtxUyUgRzFuUA5wQpuASF48RWY8BeGwOcMx6D6BPJ0XYIJEq2thMaxEpqyEWtOrwG1jDCbMIs6w1kU8XV8l4bVd1AjahNW9W1MR3R1Q5mbJcINOYAH9TlPWdo2gAbzFBT9fsoaKRZSzegX0abDGhkzaYn0Oakx5uoQ4wtLiwWYdLTh8tr1T7VoI4isJK\n\nLG3ROBg2YJipepXUhqObt7zSh9qySjXJ6MClY2KUc8dZTnwVOqVU8m866n5BXRANdLSFRtOCSxTpB9uk3vA7u/pimz1HIvRMx9x3jj3uu1M27z6sSvrUO+15BynkjJOcB+W/6ns3OIL985oGAOQEg28pdZEUNwaQwhsjSGYdoeqyW7DcPmtBNa8R9rpHlYUZOFR/ulxcWqTAxPCMJK4Zsd4JSy+3Hr7kszvHRlb8WXfwE5yly3ALSON6LaHUgr5M\n\nivO0FBmkCzD7naOcIQzAPhQDeBzKBzgYAcBgLdIQHnpSgnwa59ARC7OkPNbNqklqKtJKKvQ6z9J3OBhZI6hbzqeS+bdYxYUgWJRetFCInb2hwtNk6FFmLrF5HGn1B1Pn90ZNuXtGy792Xit6Py6KYMGbqk5fMaV6xopbEVeR8W2raPSwVqa3hmtWPkWopE5iGJpIwa5mEzuiAXaYZQ97UuTJyMclo3yZjIpJQNsUInQ+KdM7k9ztqZD6cG2tsMU1\n\nrt7dXT92MdO+bCSSnv1XcWY9g9J2MARgfdv5fEB8AvoMG+nZH2wcW9GcD/7O+7u3PuaDgHEGPvQZKDD+DvyEfQ8BXnjD7ihesGGOCKdabWle6KM2mKxA8k1Gi4JO+KV+zGDurGN8NOHGdOJQPG1OFki8HOnAkwAaDo7KrO4mCckarEW4SQ5uQqfka+F2ECZwHM+A2A+gbALo2q8UlmOuhqdqLCceJuTmseY6+UuuRUNuDq7CDuwhkArq/mruHqQW\n\nQiXucoqocQ7EM0W4mWEAQc8QvQyQ9e1BoMOo0WyaCeuW+i6ahWae5hEA5yag980oOe9imotYCwaiTEehpoeh5uPilaH0nU0w3UvUVovWj0TavYaijinQYMA2NEQ2re0o6wDwc4uImASCHwkgSQewLcPA4sewnQLoY4RgbwIwVk+Og+82U4RUb4y234E+i6U+1EtEzSs+m67S+2jee6V+x6IuwykAewNsdsDsfiWYvUrEairs4WMRvWcWpQgxvs/s\n\ngclUtK7cEgboHAzAQgmQ3c0owYYQDKHQxBqxYcRc6c9KCA2cLO+c7gZxJc68JMooFcUQ1cDGX2shjc/grcax6AGxWxOxgYEysB/cksdGeKbxt6061SU8R+c8C8p8EAfx2xTAK8a8G8W8IxaAu8/Rx+h8xekw58mBRQDO5kQQRAcgjhgwHKBBNC6o5uYmXOaA6ofKFo7sguwq66lsEqZwPAbwnQygEI8ElwmR5wzAEIcApAMAuI2qUC2qY4EI+qVu\n\nEA+uJCZq5C9Cpu9i5ug+YhxUmuTGbC3mTuNUQcbuoonqXIIWg0YKbh9o4WHkv0nE9WYa3AP0nU0eehswxaP0jeFC6eeW/oVhxikYthFiCYZWNiTm1oF0HYM0Ae0w8QH0cxkAfhp8tonUmYwSKiehlB1oERaArsloRZDYcRqSw2kA2APMNwLwkgMqzAFAIwuoPABIIQ3QMqBIYwc4uEEATw8QuRrMygxAIwUuiCzAi4rBbAmAjcBI3ZyRqR6RmR2R\n\nuR+RhRxRpR5RUBIheMk6TqNRxMdRNSVMk+y6zR6sbRO2W6nRi+PRZ29BoulGMBfcYoHMCBEJu+yBekGkRJ2BaBGA4IhAFJLOgmNCSZ+BHAZBpItoiSwSjetBCmd5OJjMEAiouACAQgLoUAJ4LorMLwzAWmUALwi4MUPATwkgY4ipYhKp9mRuAh+Imp1qxut4upEhnm9uU4PmJp/C5pShnu0o3u+Y4icaP8ioU00apoIeIMiQE0Hh+ot0rYiw2hfp\n\noZlhBWwZ/pme5W9i0ZNoLs8ScKDYoFRejWpItYpoNobaXsOZmYeZnWDEXkzYMiSoxxnaUMCR04cMlZ1ZtZ9ZjZeoLZuAbZHZhm3ZvZ/Zg5w55wo545bBU5hAM5SGEAc5aRGRWROReRBRRRJRZRfeYAA+luVRL4tRs6K2DR9Sp5rRkw7Re2XsXRBsN5q+gy95BOj5hE5FYJpOSB0JTqxs35JJ9KzOYFpILEzpTQ1J4FjJIMHE7soMzlqwQunJ6+Yu\n\nZwLchAXwrgLwuIMqcAQgHMc4Oo8EkgMUm8ewVA3BBqhUVFhu6pWU9FNCLmvBbm9qrFUh7FxpfmppihHulpKhbUbkyWmonEw1EWjiBoooQcbpWs3Wj0MeDYs1Fu8e0YqagZqlRWiN2aliEZ2eTm7syW0arEmYGW2o3i+JGYn0wS0WbkcKCwMR2pNeBZCacwbYXCze7+FZVZNZdZDZTZ/lgVnZIVfZPAA5Q5I58QY5E5sV8VcMSVC5qVy5GVa52VFR\n\n+VO5DuUJ5MB5q2x50+LR66c+l5NV15L+K+J6qAXJl2JyB+169+oo92W+VtR+J+L2Z+b2F+n6Rt1+P2T+lyV+QGXtZOooEOjRKGn+cO3+m5H+gKyoOYrhQS24cKMicOzgqoCQ9YcKmo0eQaF8P+s4MO0ZDYCaXUTE38t0yZJQzg9kyQ5NTE0a1BwoeoiGv+sGk0ldnEXscaLEpoJZgKSdUl7susOYrinEMwDdOdkd4eeNOoYKLEHipdYASdMZUKH0\n\nCwPAjiDYzYI9MGs4X+kB/egqhOYoMUr5/tRKXVKBVOaBPAtOJQXGWBfVEgZJAFYQQFtktJcaYFEFHQlo4WMaAugCdBjViFkC4s4F6wXwY42q+RMAnQNwUCIwvQBIi4Lo9ATwOKZ1Spl1apjm+azmjFDCD11uT1J9XmTqHF71XF0oFpjuP11pnEyQUwURXkMirE/WYN3AYiaoQSaiehcKllZhaNFhSeex60qNuiuWGlkZ2DConUWZ5NVo1BmoehxN\n\nxlTJSW09ad7sHEUWvpdNjEOomY4WN05uLN5Zyp7N3lXNflrZ7ZfNCVoVgt4VItYtMV05s5KRyVi5aVK5mV65OVeVc2Kt1RRMD4GtpV5Z9MqwkCzMbMnM3MfMAsHAQs+gIsYsoJgKvGssJEOVFE+OM+lVF58wVoK92h3R7tvRCFe9LV1GrMR9nVk83VX519NKeEv5/GJBwFG64RbTnO3KvYejV0vUcNcFwu5TymZwIwNwbwLomwPM8QUA+ApAHMXw\n\nMUCAyg2A2AFAJ4uQaDlFtmqpDmuDt1ODtFeDhUeptuhpJDb1LuXQn1wW1D8oloMZEx0aLseoyZOhQmTi9o0WM9EKqorYI18NC0ylgjpQKe1h5M6lGNWeThTmtDSZ9kUKU05odoSjviGYWYmo8SvWvWU0PQZa1eGsGoP89YUFpZblKGPZAtQtEVUV4tLjCV0tKVS56Vq5WVG5u9uDQ+j4u5o+ex4+R5Qd2tZ5eTWsHRBth2S+7xx+t5AD56FtD29t\n\n0rttV6PRp+myLtxAH6x07tWIN+ftPtj+IG3t7tgdrNIdgKYdnLo9sGXzNot0/YMeAzidtY8SMiW4bauobaqoG9EdsGpo0jUwrKd0bsyLidmonU+NP0SoqoSoTElwvryGgK9YyQEKiwjYgNslnE4b3Q2gvWcZba1BN038GoibudyouovWjiN0MifQNo4bcQ2oU9N0HiHiU0V0Zbf+WYk9fQrs7UQRgM3diQPQHiAeHiNbYKNYnbsGbYCQUWYKXs0w\n\nAaVejQcQjYt0tdUedbWd4dSbTdSWPObraoDYeo9bgKaovu9lXQxYaiNosw07s4bpXsYKU9nsrsv9sGK9gRoK1BcKkKuYw92dm9jQ8LUKiLJdKLoNwBcQPzEesWEWjYD7IH+hz740jYwo77s9ydiZ1BwSg4CwzESHqGtYGjpo2oao24aoK9cOfQCQ9ot0fQmY7bj0RHQK6hNYU07s/0woHENHFb87KiS7uYl9QHfrs4YKyWhY6oz8hZ9YWHTiConE\n\n2ok0P839Inu7MOX7fzv06oExeh9kK7qGyoqWUwP0rs0bt0rHX7UwP7toWGNYmWJQW4CQTEbkM0iZoSbYVnSW0ajp9keh7ErJSSTnSW/70nAS7S97one7s4AbIlCoW47s24sbfOcOj0GZ2oMxzEkW3QrH50xdNn9kTD0aDkgKrrdaHrpobaeofOrH29ZG+OQJT5uAPMNT7tH53AqBjO6n2TjT9OtKLTA1XTNJvAMx79E1ANSw9Yji7zQzC1DBS1Eg\n\nCE+gIwUCY4+A2q3QLw2AygLwLocAUC+gMq2ALoIwFF+Dypuz1F11gh2D2pluzFhDBpxDDupD1zZpFDPF31fFCibpP0+YVoCobY1ogLA0cKebDr3hOYwogNfDoj5iKlyewjNh/DGe0Lmlrpubqox7lbTEaiuYaLlaehyQC7k0Go+oIl0a+ZqA01FoX0cNxjiRpQdjNLjj0Vk5DLUtbjMtLLXjCtHLuVNqBVi26txV9RgrZVqsOt22Yr1VB20oJT1t\n\nCvsrp6TVerCrdthr8yirarTtGr2yWrl+urP6t+z+SvgGRrf2ZvR+Zr5ZFrsGVrgvjds45deb1dP0bdzY5oP0idyoEW1NGicauYbarHQ0ubXQOo0bbkZH9eDb2gAemoNYrhcn8ZofUKyQG7CwW7TlO6ZdeoEPzbehvUIl5oofLYCQBTbaUWnE7r4bHU0eLiVHG7v0SQof2Hjij0E0moBHQPidubuYbsjNdo9kuYbf+hTlDHQ97bfQNHebJnEKv0Cl\n\n9kbfJHCfSouoOSWLjnYAE0vuAaCjt038rYCaofVo8fTlHEE0Swd0FoaXUlPDbncadbbaPXTvNrLvrYvu0mJ7wl+PhnYATsZsMXUTI1YkurYU/lmFYjfMlg6WG/sFyBTdt9Gi/ftjNHaBt9+O7EBdtMDTYz8/8GA5sIJzTb6g2+HUYfu5Bh7RYFQvUOHEsHj585PSmYYPmojL4dRHofze0NuDw7B5AUZ/KAU2BgHX8poO7a1sBzz5OJXY0wNyHGke\n\niPQP2j7SARfwEEcdqCofJiL7gC5ekJomYUGFB1nDxJsw2ocgYsEoE/xVBUlYJE2HJo5hHE6OXNkAO1AgC3EbSYQW/1EFz0I2EfPQkp1jZ90RqJQLTq2B07vsGwrbUPk4jaRXRhqHEFemN3PY+cawSoIHgHnzDWhAOGnS1qHR3quCHywJMUB8Da7m9mQp9KcF1wqA9dOMTTCJmcE6DnBFcDwTAC3HFhCB1gMqIwEYFxC4BOgMUDmBFCCCBgcCrTH7\n\nqFn75SDescwJsMinebhoI+2YZvnJxjSKIJGueJxCvU0Z2h86cwAPI3lTK9g4grYJsBm2mp9A2w7uOkJi3VBahi+vOQIfdwRrw9fQaiPYL0E0BBkRGZib0PEmwC8pzuhUVKBoECA3c6KQhe6qcxYpEM2KKxUoHIQ+rksW87lECH0A+AxQXQpAIQC3A5g8xcAIwVeL0BuCKp4ILwGYL4yF4BMzgfLQlrPm1hgp7Q1BQamgCtDzBxuPTekeZWix2hYK\n\n81PomL0PILo3KNvN/HbwyGWs6u4iaLPMCkxjDpg+LOHF0GVDbgxhMeDiDERbAijhQbkRjkGx6BVdMwugxoHqA6jChzK3fHSn0ATbRdNOvuGaFNAsrChOi2bc9o8zmAFgvYnHdiL9Dy5JYX+7iTUGCimL5gZR6ZGkaCmuhzAawr/FdDF1Xbj8poloJiB4lmAAd4B40QItGg+iuwxhSnVjuxBTrrCHod0W6HCgDGFoAW6iK6HpUVCsdZ2wnGPHWiEH\n\nsQAx3bR6AOG1B2g3OlY8IdqDUT6hL+1XBUDKJrDSMCaJXCRAsBcERikcKwuNEsCLquc5OufHfgHnPjp0JoGjaCu2MjaoCLQFlEStwNgy1hcwEKK6BCg37Vs0B5ovASqH4F09BwN0GQmXRGj84Qi00VUPKIrHniZ2ubcYu5xkEWg06idfQluJ9I1gFKWorMZOMbB/NLBP/ROl8w2HzA6eXvaNFZyzDdQdQdaRMnZytDhsksSQy0NqHrDxlR+742Lj\n\n53YjRZ9OyQ7rC60roMdlRIlG/pmCs7n9pxTYG6Dkjujexu6ubDfqkJXpeFdQtXYiY0GcAGioUi7Gqj9AtBeQJo8AkSef2B6jstCUAkdnV0yENdw6x+dVufkN5u1ChHtMZDr3doqsbsek9Xr+it4ms9JvtY1sfQZj71cACpdqogXa7FDOu59brpSm5Ga0hW5VXWlVQXySt6qJtS2L1UYISAIQDwDUPQHwC9AhAzgJIC6CaFfAIoMqVmFAAJB2B+hg\n\n3dkIGG9wV0NEGgzDH+0bzhptQdYe1o2CzID0sJWNbBjdDzZx182IlfUE/0J6nw20bvb+JaBjTiiawK7MUF9yrSdQLhHiK4Qvz6C3DgWqPB4YqCeEvCUaKPeHntE2KHRqYPw8yGcywYVYZCQLJihd02nPUp4O06EeQxcqDY4RlLREciNRHojMR2IoQLiPxGEjiRXLYXpUCWzU9pqNzekmNRMoCphu41ZkYxBK4+i9CHIjklyLHwlVBWfI6VrbyZ6R\n\nifkak9If63KmPQHKIlWGu2Fn7TQE+6bJ0rqFy5CSSgiQVsHozbZTVbonTW1slhmgz0foEWIHvEDy7dsbO01WQYmm37nQOIOonDkeKhRpCRBYnVdtxKmi4cA0MaX6G5H7HulLQ38KLFClBTMziZAAitrGJq6sRF6JwsrgkCK5NhIhNdOmZWP0JxjLoQggNPqE1Cz9TQOYQApNCbKcRKxiQMYa2LUT5gpJ84uSXIx6xCDyOCaVvupKFmaS9e2k7Vp9\n\nkhJmTLaWvKOcb31Y2StepvSyUfia6EQW4BQ2Eq5LQClDSQnkqGeLwXSS9Gk0vc8rLwCkK86qpTFXqbTAShTFu6ACKPpmMw8xNArMUWPECgRfANMBIKBBCHWAwBzgWUxnLiRylWlREkAmPDIhJYyY5BkAcNDaDrDTUIUbaQGjpW0LOFuA9UxMgUxkRuycyvhEmqgFrDMlfRcwffvZGlncUvqQ049pcPHbjTUuuDf0l7FmnPDXhi0sxMtIOhEQ1p2z\n\nfaWCK3KUJtpIIjaf/KKEvcpwx053PIRuawjWaEAK6SiLREYisROIvEQ8AJFEila/jYfLyw+m2VSQ38G0M/Psh0iq038RvAySBlqg5gXEJyuyX/qq8cSZMfOdTFhmQl4Z8ItwfVxRmxc6w9YXrHWihSw0F+6OPNqqBbQcRVE8lesKx1Jndjo03UK0LGj8FgBEgY0diI2Eo584FFLMyTs2AVBSi2w/qXUSUFgkCy8eiZd2XCis7cTFZ/YfpvbJUXFi\n\nW+slcLCJRCJZjlQEiQIYsCoLyM4cco44Xzn4Wksp2Ks2jvi1kFWjcw6o2eihPEXWglFEKWtGeJ4WNBN58SL+iDSEGMju6I0MFOFh9KUEvCdoLIRtkdrrJnaBvMOVfkjmGSrJ++epUfjMmJzbJd6S3iDiTnSsU51GL4OnOlYdcs57ksobnP5bQyC562XyTL3nxXlAplchqowtrnSwh5D9QCqQpYjxImREmd2CXSiI0FORIzMKegDXhIJ9AioJBMGE\n\nXDtB4IXwD4PYB5hfAng2ATYutL4L6ksst3IBVy0e78FnuEIjoFc2gUfcGog084XTN6x3yfSD8oYdaUzAxleoxGMGPWAkpY9WSO2FsBNGiFw0lK005+XNLfmQtQyewYlRj3ejKhbQXQKgVvwmltTa88fIpmMK3BeDmp1PPUIvVNByzYFJjBBTdOQX3THp6C56VgvyhvS9ywTCprkNwBPB+lkJQZXpOYU8i1sS6YVhVQ6D+TZl5co7HpLKYAMlloEM\n\n4JIFxBzg5wPMIwDzCSAUAvg8EFuDAAQDnBxYPMEIEgh4CDzzIVQGoB7lHlXRksw/TiKV3iz0iSO8YmrksK1IXsBwWg/1aUB2FfwxiwfKNZAEoZcIcV9w9oAgDTVpqCVJiVHp/NWnHRf5oIp7h8qBF3dgFby85uAt4pQioFMI0UIzyaKihlI4JNpc1UlWS0iGFOFjMMr8SjKKRlVK0PEiUmkKd5WyhONwwsqFi/68FOVnnMVXHkyI4TfVRHCgAjAX\n\nQ9y9YDMBuD4B2gmAegBzHaA8xOg2qL4IPDhzpNqMZyLJjfSAhpMkKXwZgPtjHCsxCAmRJBNgAtBfBcQkgB4IQBii4Iz1OBIiJkzIhUpshm2YuaKzaQg8bOhtbVVXJCl9db6RyiAFE3ZhcxeY/MQWMLFFgSxXVGTeWLlIUTqh4+NWbQgND5x1g5KpG0NQSTFGRrtCMaxiBCn+p+rtCSauHu8IzXprKSkAcFmpVsK5rv5+axtVZh+XvLdpgCrUmWse\n\nq/KwF/yqhtKBOkBY61rlC6RtibUdV3aPS/uPBArWdqz6IEanOUNZUtsYiPQHMKQuAmjrXSh/fhV0HoXTrGFXk0JgjMXU4Fk4UsJdegEIBvBWYPMbVDMH0B6oQNOTCDWqvyagpLQxTCuXBoWXVyFu4OAUQjPt5b1VB2Ya9qxvDbMaYB9kMcfjgqWvZqlRvThXn3S0xFMtZEIaNlvo1K1N8qrIZSBHSC8igGIDMBhAz2BQMYGcDBBkgxQbdlBi2AGX\n\nJwjoFbgZuzDDUG0i4YJVlAuAd8GgGVCBJO6YeP1DTUc4QBQQmAV2jqx3y9r2l2vTXg1tmQNFR4DAcKFFFihcE4YA2obVyHj5XQupAHH+Iwwmi58m8s2jeRdEWBsS+c0fbcJNASobatt4c/ALtv0mtKE5BrC9Zkzuz4BPwFAPonqqQo+a/NAWoLXhokAebR58SUgYY0W0U98wJUuUBRv0qJYE1dhIQnGnS13QpgEKsztrIazoteAbGwacmvoT+kuN\n\nmahaYSpzXkAVpQmnOCJp4KFrZNEmw5pNL2nC7xNduF6lWtkI1rTpySVTYXPmL0YW12msUPBGlXk4dI9TCOToxq7+zYslm3UQwDGof0HEy8hznrCnXDMZ1YylhZPiPy5NwtsvNyPMH6mK8Ha8GxaqZB+IQATwGkVAB8A5DRAeN06SgPCTOAB7wQQekPcoDD0LFbY28AhT7CgB+wA4+AcjSHEsh3EzgYgbICiVfg3FC4acEuAHGIDEB6gxwZ4lXHZA\n\n1xImLMNDbE0w0JNsNKTQMJ6CbgcBvii8CQNHvwCx6EQoe1EuvE3isBMSqAbEl0gQBHxlGZ8S0IjsgTnAV1a65gDzA3Vbqd1e6g9UepPXo7+4l60eYvU+2HitCElcHjEWIyBIaNHQCuivQsHUCjKjOjqF9Bp3M6r5rOu4Zxu42c6keqebnUtN51fyjoAurXKJr/lFrRdTmcXScxAWQHpdRpKqPLuU3Sh61J5Rtarqvzq7cA80zzPppKHdr2MiGvtW\n\ndBtKU04aj8UkC2Gs3zapEM0CwQ5tt1ObZ13k5XaujC0boItV0esNFq1Ve64tZtZ5ElpK2IzYcwolWRyrrAIpr9lrDPj/ECRlLVkIczVjUoRmSH79b+pDC/rjYKGNJdSg7Q0v231bUApKJrawsgSGrjVpq81ZautW2r7Vjq3AM6v62iQbtzqcqWyuPF84F+g4ExW9rm0091BMhkCIDp0nbaeqHGeVuZM6UtrrJFkyBEBoI0w64dCO4gzxiQrdAIpI\n\nwdYJgGYAuqQ4v5THfczP73QH9ZGoTMZzbTyHH9sLbBgDQuh9Z1QAXK6JNH3lz7qDl8u5sc3Z0/6w9fGt4WcEE0gHXlMm8TRQjF3SaCGIuhA5cyQOcUUDZ0+ImpqclvkJVzXKXZnNMk6NZBsWGCpZveaUKJMNYHFpQIhg275uTVBVawavzO7ODYrcYeQtg38HgpPu3AgiRPA4gxACIR9FpAj1+6PjokDkD8cbVDFk9NCOGonvT3LF6R2e04qXouJX\n\nEi9BcfALnox1lxq9NsWvUwFWNVRPizcfAJHr72fGgTUyARGiTH1gnJ9qInEnfFn2M6ksC+tI6MwkBwA9gi4ZQDFEwDtA4Ai4S4BQHwAcxcAEUGKOcCgRPBxYyyAo0PMcD+xOA4mkRNV19x4seo5R0PGVKoK7G150BqYBX0jUvM7od0bYQfO3DlS3F7+rowAp6Ncas1IZHnftDzWgH5i4ByXYCMk0MVjmSpA6eCJl3fdq18xhQlyuVUrG1d9ksPXK\n\nuzlEHqU+Co4laEzDHiDjv0tAORJoMOIyZhg/ZRDMOVgsBWEy1zbesgT3rH1z619e+p4Cfrv1v6/9Wk0A2XqQNSGNzYUfbhnqkd3QVZmCigABg6zC6/M9UMgjQRYICEJCChDQgYQsIOEADb+USMKxIj3Z2DF5ouBlERg2qAkFAA+BjgZU4sD4NyZ4AmYRgLcBUJ5prPAbFYoWkVi7raTKJpoTx6VjqsWVMnkNhAVs9gHbMGI76u0Js/c2zEahAa7n\n\nLcONsJ2h4KN38eNVqewZ/UosQApUNH3YhGm59ZO9jY/NDIc6+jyPAAx/KAMOmRjUxsYxqWgOTHxC8Bi5q90BW1rUDSuyZRgebVYHQzWuvAzrodzNL9dV/NibqC4SUH6RRNAGebs4FBEbQGZhhfFsuM5mlVek243rQPHIsPdMW545DJOIIktiazDhL8fnh+6FLXxrZiCeyDDEyhXCSE0sUz2ulYTKceE7CGpiF6SCxelEyZfQDl7K9Yemva8UgSsn\n\n2TnJ7k7yf5OCnhTop8U5KdxNd6e98loQIpefBknR9GJHeNSen10nK0DJndtevSMFmH1XsJ9S+skBvqP1X6n9X+v31ihD91DaMaDDJ3kanEXQMmcEdKDryaEFfKSXSQkSUDOJDOytJaHEFmcl5xfZ+acOULdGkLvRm0+niGM/zBd51OAyLvGN4XvlEB6Y0RdepzGyGCxxXedLYPrbMDWm+yXsD030WCDhmi+qDrCDAxWj+YuRusrVApnqao23zuDI\n\nEuCHsz4ykS+gaLlnm7jF5yYYC0903nvdCWiABwuDpCiHeafaq3Glqvxtj2//CNL9GSCtXvF7sZgYHLA0Faql72XSShm+QRpoyolTQr1Fq0a9jDph47RYaNUmqzVFqq1TartUOqnV+Rq7a4anBySPYbi9iC/34Felpt72joAkD5xeQz9V2wgJtrCPA7Qdxk7fLjZhlOW2THJrkzyb5MCmhTIpsUxKZcODaabBoyeeFiYirCpg2gvwf4b8TZhq2VK9\n\nUMNECEA6ebQO6ZLtZN6Q7DD4OqHUkZtqw75YqRqM0hrrkQAIIUEGCHBEQjIRUI6ETCNhDYA5WpzhG40N6zoYM2ZGZmpYBJQjTJ1MB+NczhPXeaVWmNa7ApYaLdn8DaVVVkwuFhtJ9AA81oOGghe6vTTkLfVgTRhf51YWCLo13C6WomsunJCiBxTcgYDMqbFrFFrXCtb0nYGaKz3fA25O2seSZzc0fXRqCLSP9LNyKrixN2h44s02jBi40wuEvzq6\n\nY1Zxs3gR7MSB4gEIeYE8CEBuQr1p51VU9Y2UvXrzkJW84JZxLfXneXyZGULNENVbU7modO5jN47d012DHGTC0YLvqhFDz2Spfr0RvbaUMQ0ESjGWkM1HhJa7WtCqaxsGSDDwt5rWcGcvi23LUtzy7LZ8sK23DtNhJPMCbLHHGBbsO8draZJzsf40dH+J4dVDG3ebqhnbSPYt5GGTJyD8wx3GuB3BHgrwT4D8D+BYhAQwIKm4reG3/xZKHnVo6aFe\n\n0zaAjiQErloT/bDUN+9D028dnNtxz4jEO+OTbdOp22UjCFRfWcB3t72D73QHK0UZhURoU2a9SaGJXjIeJo7UWvhfmy8jwS62/U5O7RzbCHWFg+YrYVnaZ2dXZdEmq09xvLt2m+dwxgtSNZws3VxrHpsTRWvk1vcgVzNci0Gcouaae79kwgBtZhLSs9rDEUcQGhiKOVSFJuw4wnE7F1oIUgzA5XbpusO7GiTujg+JfiQQS4ab1y+x9aaoeaJALcak\n\n7bj+O970AgzveEpFBMT6FgqeqEwZZhNJwc91l5UmZd2JUkTkyJ1EzZZIB2Xy4mJxy72fdsDmvbw5322OYDsNx/LBJv3eM7D2rwwr4+iK3vCisHzYrRjiQO0CEAjACQkgG4L0A4BIIXkEUKCOLGIAUANU+gN4DldWVP0rS3Uy0WaYkplSObiL2qRVgEqRoxZ0DlMgfOmB5ssX5prq5aZ6vWmud2a1Nb1ZiflqtpUmhu7E+Sc+mFNfpua23bIsd3Mn\n\nXdqi6tcqb9woE+TrtUPZGXMOBAOjSqX48kWkL0ZKZxPjGIFlcI5uslpp3OqDqzmQISFc4IueXOrn1zm57c7uf3Onr17Q8oOyFo0liX2iHfZkhfd3xX2ENTt4ksho1crqtXa5jc1ubgA7mVuBrwO3lZhUqJ4+nkTvtJ37A7Tw0MQ2WU/ybaMdUWaLrUsKGzCsQZ6+jDiPaMatNZ8uRBJmgW3ebF3iXpdyl3/ohbkvv9pLoa56dAVQH67iTyaxscrW\n\n+m5d/pmBe3aWNLWNNzknJzy7FD8RtdBTvXRrELaYCzjomRM6gF/Ypn3F8EhULNwafMH7dyr1mg2aHmWO1XkCdQKQBeBQJegjZI+2a7acWvqCVruZbFpeOfXb77/e++IbSUlBjj2YfDvR0Lbzj6+rEmQUgNujuxUlj9zTvG9ixJv7K0bdHBm5qrQ2pMysvHBpPhvAO1HIh9GefwTUADFg2YDG8ILyp1a2HcMMw9kBO1oPXLktjyzLe8vy2Ad1NuUK\n\nJPMpL1/o5nQ6yzYCNkPQjjDiI8Qb20xyTD6HvG2cE+ffPfn/zwF2wGBcfBQX4L+CJC9wfsV4+49qFL9Bp0ui+61HthmIrdaU9i60WcLKo75tm3hXYOy20fjiMxH8Nejo7QY91X3mXba7jd1u8NcDcl3H5mFQRIhtqJ335EhjlMISy0C/o5PUCxVgDR1gOO9s7wqxZN2Mb4LLOjjT6DLtkvbTFL0t2AaF30uaX7pgBeW8It1umXDbll027ZctvO7K\n\nurlx28lX4B+XDFwp/rp45ZlZgFCkdxQbN0TdMlKiQh4vcVe8aV7LT6Vua/yZag/V1rkSAIdeP9P65YCYZypdGcQA/YQySZ1pcpMzPNLae/S1nsWdwni4ee1Z9cU2fLPbLVep4vs7r0nanXS5lc6691cev9XB5y518WudDeRvsL80uSfCvcAp9h2Gfa88JLX1wADSMUHADgBQhmkg90yGWEyD9VfEAwBgIQAQAUBzgqF4tz6GJVQ/1rgPwbcRFYXb\n\nB9AUIL/aF4LelA4fIBscIj7B//6IfsYML4UGVIiBMfiPiKM6di+E+MfCPjIMj8+W0v0fxP6n0j4e41uMQRP+H5h8R8GZkv9UdnyT4yCAvG3wKvn0z4ig2w5ns3hnxz6gBY+MgYv8b9M959U/OfGQeEls+PyXFHTIvlX8z80e6eX82vmX4j7eAdK78uV6HZT8Z86/gcNqoeUE0eKYg4Q4IGVGwxsqO+cQ4IbVBvKkYVbSgRgNgAYG+9NACAEzjoES\n\nUN+y/9A3PgeyLwjBs+wwJAbSynsJ8J/iAUIBAAEdDRN5G4xAD4GwBgIm+cDwQLM9n5IA5YeM5wd0JAlIDKBgwAACh6zUBeATEJv43/cO9AAAlIGE3jKAhIREMkbX9wAN+5grfkf7wDH/h4u/4f5X7bHoSAv84nAT8oemWt4pN4ckRuELZtrd7NAxf275FaeLkk9/zz0UN3r+9Yl9/imteIcSpN7xw/dgKBAgGqBilu9cAPPwX+3+7/Z3ia6oIQEY\n\nAtwA/+XodrLKG0ukA/+BBNXoy468PoC2+FQDJZZmu6Gsjjk+cH/4AB6nr1w3062mCDhAnXJRDkQQAA==\n```\n%%","source":"_posts/Excalidraw/Drawing 2024-12-17 15.07.21.excalidraw.md","raw":"---\n\nexcalidraw-plugin: parsed\ntags: [excalidraw]\n\n---\n==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'\n\n\n# Excalidraw Data\n## Text Elements\nBroker ^vpVFc8Jz\n\nConsumer ^HlcmoCYz\n\nPull Message ^iEKLY3mc\n\nProcessing ^4SqNDxs2\n\nsuccess ^i4gc31t0\n\nTrue ^6S02Vu74\n\nFalse ^thrRj5N6\n\n%%\n## Drawing\n```compressed-json\nN4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebQA2bQAOGjoghH0EDihmbgBtcDBQMBLoeHF0QOwojmVg1JLIRhZ2LjQARgAGABYAVn5S5tZOADlOMW52pKSAZk6eTt6pgchC\n\nZgARdKgEYm4AMwIwlYgSbggAIQBOegB9dcIARwA1ACUAUQBZAFVcbBYoZ7MLjHPaEfD4ADKsHqEj+bGYzGcklwUGwkgapWYUFIbAA1ggAOokdTcPiFATYvEIKEwGHoQQeDGQHF+SQccK5NCdY5sOC/NQwSadbnkiDWOoVEWNCCYbjOGbxADsyW67RmSXafUV8Xi7R4iuOgrQ8vaiR1ip4vRmMx4l0VSWOWJx+IAwmx8GxSGcAMTCv2dJkQTS/XHK\n\nFkcYhuj1eiTesTEbrEXCBijE9FoeIzbSXToKy62i2LU39UWSBCEZTSSbtS7aHhJeJJS4zXrde229WOhA7SZ9U25pbdY5h4RwACSxE5qAKjUgAEVcABBboE0gzCEEmaKmZPPaaCh7Hg3B4ABQg5IAuo7KfiIcjSHB2Qizsx73BA5phBG3sFMtkpzOjTFLOJy7BInQIA8HyEIqY57AAWnOHAnh8NyEE8STnE8YxMqUsCIGcuCkDiVDkmAAC+l7HEIc\n\nBJtsYGoO027xJ0LEzJcvS6vExxEBwuLcBwQjgjxbDYPiDEHPgRyioQEZYIRvSBns5CZBOAlCfgxzhsQT5ToJ4KFORAzAZA+EVNAWBQIGQytJM8SWscNmjOMFSKm2OpMTMQ4yRsWw9mgknSdKpwSPQcBPAAYtgSQAFJGEpYKQtC5nImiIhINezqEmmkyZVSNJ0hADKnFpwiVrpuWiry/KwEKUqlOKdL1ZAsrGuxnTaFMLbNoqJbSkaqDOFMHWqtMa\n\nrtL0lw6kk3nSk6VJRp6Pr+sKH4hiOQgRotMboNi1jMHygTZCmOUdF02hbpcbbdPElxXXaPBktKZYVlWaDdHEDYWr0vTTI9Sw9F2/moFaXQFq2w4suOk75GREALsuq7rpu267vuh7HmeVGivNt5vhVEivkR77HJ+m3ED+GRZDksOziZpQhegBLrOcADSuAABJPDFAAyIwcLJPMGM4mCSJ0ADiuGmeUhHEWwpGzpRjRXqKNF0cDnksSxlo2jdPGyfx\n\naD6ZpooemJwOBQgIKcFAEKEEYFReXWzZJD0iqLK7nSzNb2QRbg+hggN7THNsmBWRI5xZV6pOhEEskVMsoqh1Ai5EMobToMEexWY5TBQOYBCpxWGfQLygZ6NkuDx6QalGxpPKkBWskEAAKpZZyR1S0cyXJrXoLg8RKSpCC16gxuleTBNj/XorkBQbdhx3UeBrgQhQGwLzhPbFTYkIVum/HHPlpW4eMXWvSGcZScyxIvEZaKTkZ9Mly5y0zkcBMHSd\n\nIqUxtgs3E+U2MEei+xDj72CgxCAAArXAUxxas2IPEAA8usKBUlzjtByJIH4DwErggKuZOECIkQojRIGXG2ViAkjQE9TEN5qTJRfO6Eqs8ypsg5NwZqEBqrYAFHVY4jVJTHD7vKFinUli9TbM/boH0ZiGjlHMLMbYugaiSD/SaNY8qundEtWMK0AwxzEhtLaOidoQDjDsRMyZjipioemVA3QkjZnzLMPU9pegWluscF6J9uBZibGo1sPAugyIkaaB\n\nAQ05E427AxLW3RhQyNoZADa0MAJwwRiuNcG4tw7j3AeI8p5zzKy0dSfGHCJDaQ/F+Cmv5qYARVtKNWKINbMVYvMfsM19Z8XUsJU2olxKgKkuAuhREoDnFko4WoPSTbSiyMQcZEZZLKGmTxUIUA3T6ADjIHYJ42CyVPuPHGURSApzlhQMsuAGKHNmRGRcZyLlXJntKOAez/y00aIBRozUSidDIg0j5ZEwCOOcfWGYbikgeJ4F4wF/jLiBI+iEvsP9\n\n4gRLVH87GwVe6EUVEPf2I9Hm9OlNpKe9MygERoeSJWFEr7SjMmcO+1kmDDAzvmYOD8mWtDGB/BOix3bKI+scNYQCEAgICmAwVkD1g8FIAADUwGwVmDwhBszCsoHmmB4IQkuAATWwHgpKtJCE4mIciVE6ISlEjsaSEpBCmGMgnuVcpqAuE8L4V/LhgjOHCIUWI9Uk1eisS6PmfUfVSgDWcLaOI3Qcw/R4C2FsrZtwlO2stFaa0jHaRTbGeMViTpWv\n\nek4u6oLwWQuhc9Y+b1UCwvhcEnoSLwmRKBgxK6Ux2hdVmqUFJE40kgQyUjbJqM8kY0KRiuhWU7zEynhASppNqmUz/DTNAeR/mQCaaKxirTtYdI7ZAXihtp6EtKGbAZYqhnXlGQsyZyy66HsgHMy9SyVmmzWRsrZ9Fdn7KfXNY5pySIPK/aUOZdy/0hAJTM0oLz9k9oBbOMA3y4N/JWGAT5JRgVFtcfqCFniX4wuSHCyRtbQlMQbWi2cF5R2rCxRI\n\nXAKQQTD1Htc0oxKnWkrpRSxoVKjKFBMmS8yDLX7Mu4DmKJ0pH5cs/hu+JbbrSJ2Cr5YBFtxUyUgRzFuUA5wQpuASF48RWY8BeGwOcMx6D6BPJ0XYIJEq2thMaxEpqyEWtOrwG1jDCbMIs6w1kU8XV8l4bVd1AjahNW9W1MR3R1Q5mbJcINOYAH9TlPWdo2gAbzFBT9fsoaKRZSzegX0abDGhkzaYn0Oakx5uoQ4wtLiwWYdLTh8tr1T7VoI4isJK\n\nLG3ROBg2YJipepXUhqObt7zSh9qySjXJ6MClY2KUc8dZTnwVOqVU8m866n5BXRANdLSFRtOCSxTpB9uk3vA7u/pimz1HIvRMx9x3jj3uu1M27z6sSvrUO+15BynkjJOcB+W/6ns3OIL985oGAOQEg28pdZEUNwaQwhsjSGYdoeqyW7DcPmtBNa8R9rpHlYUZOFR/ulxcWqTAxPCMJK4Zsd4JSy+3Hr7kszvHRlb8WXfwE5yly3ALSON6LaHUgr5M\n\nivO0FBmkCzD7naOcIQzAPhQDeBzKBzgYAcBgLdIQHnpSgnwa59ARC7OkPNbNqklqKtJKKvQ6z9J3OBhZI6hbzqeS+bdYxYUgWJRetFCInb2hwtNk6FFmLrF5HGn1B1Pn90ZNuXtGy792Xit6Py6KYMGbqk5fMaV6xopbEVeR8W2raPSwVqa3hmtWPkWopE5iGJpIwa5mEzuiAXaYZQ97UuTJyMclo3yZjIpJQNsUInQ+KdM7k9ztqZD6cG2tsMU1\n\nrt7dXT92MdO+bCSSnv1XcWY9g9J2MARgfdv5fEB8AvoMG+nZH2wcW9GcD/7O+7u3PuaDgHEGPvQZKDD+DvyEfQ8BXnjD7ihesGGOCKdabWle6KM2mKxA8k1Gi4JO+KV+zGDurGN8NOHGdOJQPG1OFki8HOnAkwAaDo7KrO4mCckarEW4SQ5uQqfka+F2ECZwHM+A2A+gbALo2q8UlmOuhqdqLCceJuTmseY6+UuuRUNuDq7CDuwhkArq/mruHqQW\n\nQiXucoqocQ7EM0W4mWEAQc8QvQyQ9e1BoMOo0WyaCeuW+i6ahWae5hEA5yag980oOe9imotYCwaiTEehpoeh5uPilaH0nU0w3UvUVovWj0TavYaijinQYMA2NEQ2re0o6wDwc4uImASCHwkgSQewLcPA4sewnQLoY4RgbwIwVk+Og+82U4RUb4y234E+i6U+1EtEzSs+m67S+2jee6V+x6IuwykAewNsdsDsfiWYvUrEairs4WMRvWcWpQgxvs/s\n\ngclUtK7cEgboHAzAQgmQ3c0owYYQDKHQxBqxYcRc6c9KCA2cLO+c7gZxJc68JMooFcUQ1cDGX2shjc/grcax6AGxWxOxgYEysB/cksdGeKbxt6061SU8R+c8C8p8EAfx2xTAK8a8G8W8IxaAu8/Rx+h8xekw58mBRQDO5kQQRAcgjhgwHKBBNC6o5uYmXOaA6ofKFo7sguwq66lsEqZwPAbwnQygEI8ElwmR5wzAEIcApAMAuI2qUC2qY4EI+qVu\n\nEA+uJCZq5C9Cpu9i5ug+YhxUmuTGbC3mTuNUQcbuoonqXIIWg0YKbh9o4WHkv0nE9WYa3AP0nU0eehswxaP0jeFC6eeW/oVhxikYthFiCYZWNiTm1oF0HYM0Ae0w8QH0cxkAfhp8tonUmYwSKiehlB1oERaArsloRZDYcRqSw2kA2APMNwLwkgMqzAFAIwuoPABIIQ3QMqBIYwc4uEEATw8QuRrMygxAIwUuiCzAi4rBbAmAjcBI3ZyRqR6RmR2R\n\nuR+RhRxRpR5RUBIheMk6TqNRxMdRNSVMk+y6zR6sbRO2W6nRi+PRZ29BoulGMBfcYoHMCBEJu+yBekGkRJ2BaBGA4IhAFJLOgmNCSZ+BHAZBpItoiSwSjetBCmd5OJjMEAiouACAQgLoUAJ4LorMLwzAWmUALwi4MUPATwkgY4ipYhKp9mRuAh+Imp1qxut4upEhnm9uU4PmJp/C5pShnu0o3u+Y4icaP8ioU00apoIeIMiQE0Hh+ot0rYiw2hfp\n\noZlhBWwZ/pme5W9i0ZNoLs8ScKDYoFRejWpItYpoNobaXsOZmYeZnWDEXkzYMiSoxxnaUMCR04cMlZ1ZtZ9ZjZeoLZuAbZHZhm3ZvZ/Zg5w55wo545bBU5hAM5SGEAc5aRGRWROReRBRRRJRZRfeYAA+luVRL4tRs6K2DR9Sp5rRkw7Re2XsXRBsN5q+gy95BOj5hE5FYJpOSB0JTqxs35JJ9KzOYFpILEzpTQ1J4FjJIMHE7soMzlqwQunJ6+Yu\n\nZwLchAXwrgLwuIMqcAQgHMc4Oo8EkgMUm8ewVA3BBqhUVFhu6pWU9FNCLmvBbm9qrFUh7FxpfmppihHulpKhbUbkyWmonEw1EWjiBoooQcbpWs3Wj0MeDYs1Fu8e0YqagZqlRWiN2aliEZ2eTm7syW0arEmYGW2o3i+JGYn0wS0WbkcKCwMR2pNeBZCacwbYXCze7+FZVZNZdZDZTZ/lgVnZIVfZPAA5Q5I58QY5E5sV8VcMSVC5qVy5GVa52VFR\n\n+VO5DuUJ5MB5q2x50+LR66c+l5NV15L+K+J6qAXJl2JyB+169+oo92W+VtR+J+L2Z+b2F+n6Rt1+P2T+lyV+QGXtZOooEOjRKGn+cO3+m5H+gKyoOYrhQS24cKMicOzgqoCQ9YcKmo0eQaF8P+s4MO0ZDYCaXUTE38t0yZJQzg9kyQ5NTE0a1BwoeoiGv+sGk0ldnEXscaLEpoJZgKSdUl7susOYrinEMwDdOdkd4eeNOoYKLEHipdYASdMZUKH0\n\nCwPAjiDYzYI9MGs4X+kB/egqhOYoMUr5/tRKXVKBVOaBPAtOJQXGWBfVEgZJAFYQQFtktJcaYFEFHQlo4WMaAugCdBjViFkC4s4F6wXwY42q+RMAnQNwUCIwvQBIi4Lo9ATwOKZ1Spl1apjm+azmjFDCD11uT1J9XmTqHF71XF0oFpjuP11pnEyQUwURXkMirE/WYN3AYiaoQSaiehcKllZhaNFhSeex60qNuiuWGlkZ2DConUWZ5NVo1BmoehxN\n\nxlTJSW09ad7sHEUWvpdNjEOomY4WN05uLN5Zyp7N3lXNflrZ7ZfNCVoVgt4VItYtMV05s5KRyVi5aVK5mV65OVeVc2Kt1RRMD4GtpV5Z9MqwkCzMbMnM3MfMAsHAQs+gIsYsoJgKvGssJEOVFE+OM+lVF58wVoK92h3R7tvRCFe9LV1GrMR9nVk83VX519NKeEv5/GJBwFG64RbTnO3KvYejV0vUcNcFwu5TymZwIwNwbwLomwPM8QUA+ApAHMXw\n\nMUCAyg2A2AFAJ4uQaDlFtmqpDmuDt1ODtFeDhUeptuhpJDb1LuXQn1wW1D8oloMZEx0aLseoyZOhQmTi9o0WM9EKqorYI18NC0ylgjpQKe1h5M6lGNWeThTmtDSZ9kUKU05odoSjviGYWYmo8SvWvWU0PQZa1eGsGoP89YUFpZblKGPZAtQtEVUV4tLjCV0tKVS56Vq5WVG5u9uDQ+j4u5o+ex4+R5Qd2tZ5eTWsHRBth2S+7xx+t5AD56FtD29t\n\n0rttV6PRp+myLtxAH6x07tWIN+ftPtj+IG3t7tgdrNIdgKYdnLo9sGXzNot0/YMeAzidtY8SMiW4bauobaqoG9EdsGpo0jUwrKd0bsyLidmonU+NP0SoqoSoTElwvryGgK9YyQEKiwjYgNslnE4b3Q2gvWcZba1BN038GoibudyouovWjiN0MifQNo4bcQ2oU9N0HiHiU0V0Zbf+WYk9fQrs7UQRgM3diQPQHiAeHiNbYKNYnbsGbYCQUWYKXs0w\n\nAaVejQcQjYt0tdUedbWd4dSbTdSWPObraoDYeo9bgKaovu9lXQxYaiNosw07s4bpXsYKU9nsrsv9sGK9gRoK1BcKkKuYw92dm9jQ8LUKiLJdKLoNwBcQPzEesWEWjYD7IH+hz740jYwo77s9ydiZ1BwSg4CwzESHqGtYGjpo2oao24aoK9cOfQCQ9ot0fQmY7bj0RHQK6hNYU07s/0woHENHFb87KiS7uYl9QHfrs4YKyWhY6oz8hZ9YWHTiConE\n\n2ok0P839Inu7MOX7fzv06oExeh9kK7qGyoqWUwP0rs0bt0rHX7UwP7toWGNYmWJQW4CQTEbkM0iZoSbYVnSW0ajp9keh7ErJSSTnSW/70nAS7S97one7s4AbIlCoW47s24sbfOcOj0GZ2oMxzEkW3QrH50xdNn9kTD0aDkgKrrdaHrpobaeofOrH29ZG+OQJT5uAPMNT7tH53AqBjO6n2TjT9OtKLTA1XTNJvAMx79E1ANSw9Yji7zQzC1DBS1Eg\n\nCE+gIwUCY4+A2q3QLw2AygLwLocAUC+gMq2ALoIwFF+Dypuz1F11gh2D2pluzFhDBpxDDupD1zZpFDPF31fFCibpP0+YVoCobY1ogLA0cKebDr3hOYwogNfDoj5iKlyewjNh/DGe0Lmlrpubqox7lbTEaiuYaLlaehyQC7k0Go+oIl0a+ZqA01FoX0cNxjiRpQdjNLjj0Vk5DLUtbjMtLLXjCtHLuVNqBVi26txV9RgrZVqsOt22Yr1VB20oJT1t\n\nCvsrp6TVerCrdthr8yirarTtGr2yWrl+urP6t+z+SvgGRrf2ZvR+Zr5ZFrsGVrgvjds45deb1dP0bdzY5oP0idyoEW1NGicauYbarHQ0ubXQOo0bbkZH9eDb2gAemoNYrhcn8ZofUKyQG7CwW7TlO6ZdeoEPzbehvUIl5oofLYCQBTbaUWnE7r4bHU0eLiVHG7v0SQof2Hjij0E0moBHQPidubuYbsjNdo9kuYbf+hTlDHQ97bfQNHebJnEKv0Cl\n\n9kbfJHCfSouoOSWLjnYAE0vuAaCjt038rYCaofVo8fTlHEE0Swd0FoaXUlPDbncadbbaPXTvNrLvrYvu0mJ7wl+PhnYATsZsMXUTI1YkurYU/lmFYjfMlg6WG/sFyBTdt9Gi/ftjNHaBt9+O7EBdtMDTYz8/8GA5sIJzTb6g2+HUYfu5Bh7RYFQvUOHEsHj585PSmYYPmojL4dRHofze0NuDw7B5AUZ/KAU2BgHX8poO7a1sBzz5OJXY0wNyHGke\n\niPQP2j7SARfwEEcdqCofJiL7gC5ekJomYUGFB1nDxJsw2ocgYsEoE/xVBUlYJE2HJo5hHE6OXNkAO1AgC3EbSYQW/1EFz0I2EfPQkp1jZ90RqJQLTq2B07vsGwrbUPk4jaRXRhqHEFemN3PY+cawSoIHgHnzDWhAOGnS1qHR3quCHywJMUB8Da7m9mQp9KcF1wqA9dOMTTCJmcE6DnBFcDwTAC3HFhCB1gMqIwEYFxC4BOgMUDmBFCCCBgcCrTH7\n\nqFn75SDescwJsMinebhoI+2YZvnJxjSKIJGueJxCvU0Z2h86cwAPI3lTK9g4grYJsBm2mp9A2w7uOkJi3VBahi+vOQIfdwRrw9fQaiPYL0E0BBkRGZib0PEmwC8pzuhUVKBoECA3c6KQhe6qcxYpEM2KKxUoHIQ+rksW87lECH0A+AxQXQpAIQC3A5g8xcAIwVeL0BuCKp4ILwGYL4yF4BMzgfLQlrPm1hgp7Q1BQamgCtDzBxuPTekeZWix2hYK\n\n81PomL0PILo3KNvN/HbwyGWs6u4iaLPMCkxjDpg+LOHF0GVDbgxhMeDiDERbAijhQbkRjkGx6BVdMwugxoHqA6jChzK3fHSn0ATbRdNOvuGaFNAsrChOi2bc9o8zmAFgvYnHdiL9Dy5JYX+7iTUGCimL5gZR6ZGkaCmuhzAawr/FdDF1Xbj8poloJiB4lmAAd4B40QItGg+iuwxhSnVjuxBTrrCHod0W6HCgDGFoAW6iK6HpUVCsdZ2wnGPHWiEH\n\nsQAx3bR6AOG1B2g3OlY8IdqDUT6hL+1XBUDKJrDSMCaJXCRAsBcERikcKwuNEsCLquc5OufHfgHnPjp0JoGjaCu2MjaoCLQFlEStwNgy1hcwEKK6BCg37Vs0B5ovASqH4F09BwN0GQmXRGj84Qi00VUPKIrHniZ2ubcYu5xkEWg06idfQluJ9I1gFKWorMZOMbB/NLBP/ROl8w2HzA6eXvaNFZyzDdQdQdaRMnZytDhsksSQy0NqHrDxlR+742Lj\n\n53YjRZ9OyQ7rC60roMdlRIlG/pmCs7n9pxTYG6Dkjujexu6ubDfqkJXpeFdQtXYiY0GcAGioUi7Gqj9AtBeQJo8AkSef2B6jstCUAkdnV0yENdw6x+dVufkN5u1ChHtMZDr3doqsbsek9Xr+it4ms9JvtY1sfQZj71cACpdqogXa7FDOu59brpSm5Ga0hW5VXWlVQXySt6qJtS2L1UYISAIQDwDUPQHwC9AhAzgJIC6CaFfAIoMqVmFAAJB2B+hg\n\n3dkIGG9wV0NEGgzDH+0bzhptQdYe1o2CzID0sJWNbBjdDzZx182IlfUE/0J6nw20bvb+JaBjTiiawK7MUF9yrSdQLhHiK4Qvz6C3DgWqPB4YqCeEvCUaKPeHntE2KHRqYPw8yGcywYVYZCQLJihd02nPUp4O06EeQxcqDY4RlLREciNRHojMR2IoQLiPxGEjiRXLYXpUCWzU9pqNzekmNRMoCphu41ZkYxBK4+i9CHIjklyLHwlVBWfI6VrbyZ6R\n\nifkak9If63KmPQHKIlWGu2Fn7TQE+6bJ0rqFy5CSSgiQVsHozbZTVbonTW1slhmgz0foEWIHvEDy7dsbO01WQYmm37nQOIOonDkeKhRpCRBYnVdtxKmi4cA0MaX6G5H7HulLQ38KLFClBTMziZAAitrGJq6sRF6JwsrgkCK5NhIhNdOmZWP0JxjLoQggNPqE1Cz9TQOYQApNCbKcRKxiQMYa2LUT5gpJ84uSXIx6xCDyOCaVvupKFmaS9e2k7Vp9\n\nkhJmTLaWvKOcb31Y2StepvSyUfia6EQW4BQ2Eq5LQClDSQnkqGeLwXSS9Gk0vc8rLwCkK86qpTFXqbTAShTFu6ACKPpmMw8xNArMUWPECgRfANMBIKBBCHWAwBzgWUxnLiRylWlREkAmPDIhJYyY5BkAcNDaDrDTUIUbaQGjpW0LOFuA9UxMgUxkRuycyvhEmqgFrDMlfRcwffvZGlncUvqQ049pcPHbjTUuuDf0l7FmnPDXhi0sxMtIOhEQ1p2z\n\nfaWCK3KUJtpIIjaf/KKEvcpwx053PIRuawjWaEAK6SiLREYisROIvEQ8AJFEila/jYfLyw+m2VSQ38G0M/Psh0iq038RvAySBlqg5gXEJyuyX/qq8cSZMfOdTFhmQl4Z8ItwfVxRmxc6w9YXrHWihSw0F+6OPNqqBbQcRVE8lesKx1Jndjo03UK0LGj8FgBEgY0diI2Eo584FFLMyTs2AVBSi2w/qXUSUFgkCy8eiZd2XCis7cTFZ/YfpvbJUXFi\n\nW+slcLCJRCJZjlQEiQIYsCoLyM4cco44Xzn4Wksp2Ks2jvi1kFWjcw6o2eihPEXWglFEKWtGeJ4WNBN58SL+iDSEGMju6I0MFOFh9KUEvCdoLIRtkdrrJnaBvMOVfkjmGSrJ++epUfjMmJzbJd6S3iDiTnSsU51GL4OnOlYdcs57ksobnP5bQyC562XyTL3nxXlAplchqowtrnSwh5D9QCqQpYjxImREmd2CXSiI0FORIzMKegDXhIJ9AioJBMGE\n\nXDtB4IXwD4PYB5hfAng2ATYutL4L6ksst3IBVy0e78FnuEIjoFc2gUfcGog084XTN6x3yfSD8oYdaUzAxleoxGMGPWAkpY9WSO2FsBNGiFw0lK005+XNLfmQtQyewYlRj3ejKhbQXQKgVvwmltTa88fIpmMK3BeDmp1PPUIvVNByzYFJjBBTdOQX3THp6C56VgvyhvS9ywTCprkNwBPB+lkJQZXpOYU8i1sS6YVhVQ6D+TZl5co7HpLKYAMlloEM\n\n4JIFxBzg5wPMIwDzCSAUAvg8EFuDAAQDnBxYPMEIEgh4CDzzIVQGoB7lHlXRksw/TiKV3iz0iSO8YmrksK1IXsBwWg/1aUB2FfwxiwfKNZAEoZcIcV9w9oAgDTVpqCVJiVHp/NWnHRf5oIp7h8qBF3dgFby85uAt4pQioFMI0UIzyaKihlI4JNpc1UlWS0iGFOFjMMr8SjKKRlVK0PEiUmkKd5WyhONwwsqFi/68FOVnnMVXHkyI4TfVRHCgAjAX\n\nQ9y9YDMBuD4B2gmAegBzHaA8xOg2qL4IPDhzpNqMZyLJjfSAhpMkKXwZgPtjHCsxCAmRJBNgAtBfBcQkgB4IQBii4Iz1OBIiJkzIhUpshm2YuaKzaQg8bOhtbVVXJCl9db6RyiAFE3ZhcxeY/MQWMLFFgSxXVGTeWLlIUTqh4+NWbQgND5x1g5KpG0NQSTFGRrtCMaxiBCn+p+rtCSauHu8IzXprKSkAcFmpVsK5rv5+axtVZh+XvLdpgCrUmWse\n\nq/KwF/yqhtKBOkBY61rlC6RtibUdV3aPS/uPBArWdqz6IEanOUNZUtsYiPQHMKQuAmjrXSh/fhV0HoXTrGFXk0JgjMXU4Fk4UsJdegEIBvBWYPMbVDMH0B6oQNOTCDWqvyagpLQxTCuXBoWXVyFu4OAUQjPt5b1VB2Ya9qxvDbMaYB9kMcfjgqWvZqlRvThXn3S0xFMtZEIaNlvo1K1N8qrIZSBHSC8igGIDMBhAz2BQMYGcDBBkgxQbdlBi2AGX\n\nJwjoFbgZuzDDUG0i4YJVlAuAd8GgGVCBJO6YeP1DTUc4QBQQmAV2jqx3y9r2l2vTXg1tmQNFR4DAcKFFFihcE4YA2obVyHj5XQupAHH+Iwwmi58m8s2jeRdEWBsS+c0fbcJNASobatt4c/ALtv0mtKE5BrC9Zkzuz4BPwFAPonqqQo+a/NAWoLXhokAebR58SUgYY0W0U98wJUuUBRv0qJYE1dhIQnGnS13QpgEKsztrIazoteAbGwacmvoT+kuN\n\nmahaYSpzXkAVpQmnOCJp4KFrZNEmw5pNL2nC7xNduF6lWtkI1rTpySVTYXPmL0YW12msUPBGlXk4dI9TCOToxq7+zYslm3UQwDGof0HEy8hznrCnXDMZ1YylhZPiPy5NwtsvNyPMH6mK8Ha8GxaqZB+IQATwGkVAB8A5DRAeN06SgPCTOAB7wQQekPcoDD0LFbY28AhT7CgB+wA4+AcjSHEsh3EzgYgbICiVfg3FC4acEuAHGIDEB6gxwZ4lXHZA\n\n1xImLMNDbE0w0JNsNKTQMJ6CbgcBvii8CQNHvwCx6EQoe1EuvE3isBMSqAbEl0gQBHxlGZ8S0IjsgTnAV1a65gDzA3Vbqd1e6g9UepPXo7+4l60eYvU+2HitCElcHjEWIyBIaNHQCuivQsHUCjKjOjqF9Bp3M6r5rOu4Zxu42c6keqebnUtN51fyjoAurXKJr/lFrRdTmcXScxAWQHpdRpKqPLuU3Sh61J5Rtarqvzq7cA80zzPppKHdr2MiGvtW\n\ndBtKU04aj8UkC2Gs3zapEM0CwQ5tt1ObZ13k5XaujC0boItV0esNFq1Ve64tZtZ5ElpK2IzYcwolWRyrrAIpr9lrDPj/ECRlLVkIczVjUoRmSH79b+pDC/rjYKGNJdSg7Q0v231bUApKJrawsgSGrjVpq81ZautW2r7Vjq3AM6v62iQbtzqcqWyuPF84F+g4ExW9rm0091BMhkCIDp0nbaeqHGeVuZM6UtrrJFkyBEBoI0w64dCO4gzxiQrdAIpI\n\nwdYJgGYAuqQ4v5THfczP73QH9ZGoTMZzbTyHH9sLbBgDQuh9Z1QAXK6JNH3lz7qDl8u5sc3Z0/6w9fGt4WcEE0gHXlMm8TRQjF3SaCGIuhA5cyQOcUUDZ0+ImpqclvkJVzXKXZnNMk6NZBsWGCpZveaUKJMNYHFpQIhg275uTVBVawavzO7ODYrcYeQtg38HgpPu3AgiRPA4gxACIR9FpAj1+6PjokDkD8cbVDFk9NCOGonvT3LF6R2e04qXouJX\n\nEi9BcfALnox1lxq9NsWvUwFWNVRPizcfAJHr72fGgTUyARGiTH1gnJ9qInEnfFn2M6ksC+tI6MwkBwA9gi4ZQDFEwDtA4Ai4S4BQHwAcxcAEUGKOcCgRPBxYyyAo0PMcD+xOA4mkRNV19x4seo5R0PGVKoK7G150BqYBX0jUvM7od0bYQfO3DlS3F7+rowAp6Ncas1IZHnftDzWgH5i4ByXYCMk0MVjmSpA6eCJl3fdq18xhQlyuVUrG1d9ksPXK\n\nuzlEHqU+Co4laEzDHiDjv0tAORJoMOIyZhg/ZRDMOVgsBWEy1zbesgT3rH1z619e+p4Cfrv1v6/9Wk0A2XqQNSGNzYUfbhnqkd3QVZmCigABg6zC6/M9UMgjQRYICEJCChDQgYQsIOEADb+USMKxIj3Z2DF5ouBlERg2qAkFAA+BjgZU4sD4NyZ4AmYRgLcBUJ5prPAbFYoWkVi7raTKJpoTx6VjqsWVMnkNhAVs9gHbMGI76u0Js/c2zEahAa7n\n\nLcONsJ2h4KN38eNVqewZ/UosQApUNH3YhGm59ZO9jY/NDIc6+jyPAAx/KAMOmRjUxsYxqWgOTHxC8Bi5q90BW1rUDSuyZRgebVYHQzWuvAzrodzNL9dV/NibqC4SUH6RRNAGebs4FBEbQGZhhfFsuM5mlVek243rQPHIsPdMW545DJOIIktiazDhL8fnh+6FLXxrZiCeyDDEyhXCSE0sUz2ulYTKceE7CGpiF6SCxelEyZfQDl7K9Yemva8UgSsn\n\n2TnJ7k7yf5OCnhTop8U5KdxNd6e98loQIpefBknR9GJHeNSen10nK0DJndtevSMFmH1XsJ9S+skBvqP1X6n9X+v31ihD91DaMaDDJ3kanEXQMmcEdKDryaEFfKSXSQkSUDOJDOytJaHEFmcl5xfZ+acOULdGkLvRm0+niGM/zBd51OAyLvGN4XvlEB6Y0RdepzGyGCxxXedLYPrbMDWm+yXsD030WCDhmi+qDrCDAxWj+YuRusrVApnqao23zuDI\n\nEuCHsz4ykS+gaLlnm7jF5yYYC0903nvdCWiABwuDpCiHeafaq3Glqvxtj2//CNL9GSCtXvF7sZgYHLA0Faql72XSShm+QRpoyolTQr1Fq0a9jDph47RYaNUmqzVFqq1TartUOqnV+Rq7a4anBySPYbi9iC/34Felpt72joAkD5xeQz9V2wgJtrCPA7Qdxk7fLjZhlOW2THJrkzyb5MCmhTIpsUxKZcODaabBoyeeFiYirCpg2gvwf4b8TZhq2VK9\n\nUMNECEA6ebQO6ZLtZN6Q7DD4OqHUkZtqw75YqRqM0hrrkQAIIUEGCHBEQjIRUI6ETCNhDYA5WpzhG40N6zoYM2ZGZmpYBJQjTJ1MB+NczhPXeaVWmNa7ApYaLdn8DaVVVkwuFhtJ9AA81oOGghe6vTTkLfVgTRhf51YWCLo13C6WomsunJCiBxTcgYDMqbFrFFrXCtb0nYGaKz3fA25O2seSZzc0fXRqCLSP9LNyKrixN2h44s02jBi40wuEvzq6\n\nY1Zxs3gR7MSB4gEIeYE8CEBuQr1p51VU9Y2UvXrzkJW84JZxLfXneXyZGULNENVbU7modO5jN47d012DHGTC0YLvqhFDz2Spfr0RvbaUMQ0ESjGWkM1HhJa7WtCqaxsGSDDwt5rWcGcvi23LUtzy7LZ8sK23DtNhJPMCbLHHGBbsO8draZJzsf40dH+J4dVDG3ebqhnbSPYt5GGTJyD8wx3GuB3BHgrwT4D8D+BYhAQwIKm4reG3/xZKHnVo6aFe\n\n0zaAjiQErloT/bDUN+9D028dnNtxz4jEO+OTbdOp22UjCFRfWcB3t72D73QHK0UZhURoU2a9SaGJXjIeJo7UWvhfmy8jwS62/U5O7RzbCHWFg+YrYVnaZ2dXZdEmq09xvLt2m+dwxgtSNZws3VxrHpsTRWvk1vcgVzNci0Gcouaae79kwgBtZhLSs9rDEUcQGhiKOVSFJuw4wnE7F1oIUgzA5XbpusO7GiTujg+JfiQQS4ab1y+x9aaoeaJALcak\n\n7bj+O970AgzveEpFBMT6FgqeqEwZZhNJwc91l5UmZd2JUkTkyJ1EzZZIB2Xy4mJxy72fdsDmvbw5322OYDsNx/LBJv3eM7D2rwwr4+iK3vCisHzYrRjiQO0CEAjACQkgG4L0A4BIIXkEUKCOLGIAUANU+gN4DldWVP0rS3Uy0WaYkplSObiL2qRVgEqRoxZ0DlMgfOmB5ssX5prq5aZ6vWmud2a1Nb1ZiflqtpUmhu7E+Sc+mFNfpua23bIsd3Mn\n\nXdqi6tcqb9woE+TrtUPZGXMOBAOjSqX48kWkL0ZKZxPjGIFlcI5uslpp3OqDqzmQISFc4IueXOrn1zm57c7uf3Onr17Q8oOyFo0liX2iHfZkhfd3xX2ENTt4ksho1crqtXa5jc1ubgA7mVuBrwO3lZhUqJ4+nkTvtJ37A7Tw0MQ2WU/ybaMdUWaLrUsKGzCsQZ6+jDiPaMatNZ8uRBJmgW3ebF3iXpdyl3/ohbkvv9pLoa56dAVQH67iTyaxscrW\n\n+m5d/pmBe3aWNLWNNzknJzy7FD8RtdBTvXRrELaYCzjomRM6gF/Ypn3F8EhULNwafMH7dyr1mg2aHmWO1XkCdQKQBeBQJegjZI+2a7acWvqCVruZbFpeOfXb77/e++IbSUlBjj2YfDvR0Lbzj6+rEmQUgNujuxUlj9zTvG9ixJv7K0bdHBm5qrQ2pMysvHBpPhvAO1HIh9GefwTUADFg2YDG8ILyp1a2HcMMw9kBO1oPXLktjyzLe8vy2Ad1NuUK\n\nJPMpL1/o5nQ6yzYCNkPQjjDiI8Qb20xyTD6HvG2cE+ffPfn/zwF2wGBcfBQX4L+CJC9wfsV4+49qFL9Bp0ui+61HthmIrdaU9i60WcLKo75tm3hXYOy20fjiMxH8Nejo7QY91X3mXba7jd1u8NcDcl3H5mFQRIhtqJ335EhjlMISy0C/o5PUCxVgDR1gOO9s7wqxZN2Mb4LLOjjT6DLtkvbTFL0t2AaF30uaX7pgBeW8It1umXDbll027ZctvO7K\n\nurlx28lX4B+XDFwp/rp45ZlZgFCkdxQbN0TdMlKiQh4vcVe8aV7LT6Vua/yZag/V1rkSAIdeP9P65YCYZypdGcQA/YQySZ1pcpMzPNLae/S1nsWdwni4ee1Z9cU2fLPbLVep4vs7r0nanXS5lc6691cev9XB5y518WudDeRvsL80uSfCvcAp9h2Gfa88JLX1wADSMUHADgBQhmkg90yGWEyD9VfEAwBgIQAQAUBzgqF4tz6GJVQ/1rgPwbcRFYXb\n\nB9AUIL/aF4LelA4fIBscIj7B//6IfsYML4UGVIiBMfiPiKM6di+E+MfCPjIMj8+W0v0fxP6n0j4e41uMQRP+H5h8R8GZkv9UdnyT4yCAvG3wKvn0z4ig2w5ns3hnxz6gBY+MgYv8b9M959U/OfGQeEls+PyXFHTIvlX8z80e6eX82vmX4j7eAdK78uV6HZT8Z86/gcNqoeUE0eKYg4Q4IGVGwxsqO+cQ4IbVBvKkYVbSgRgNgAYG+9NACAEzjoES\n\nUN+y/9A3PgeyLwjBs+wwJAbSynsJ8J/iAUIBAAEdDRN5G4xAD4GwBgIm+cDwQLM9n5IA5YeM5wd0JAlIDKBgwAACh6zUBeATEJv43/cO9AAAlIGE3jKAhIREMkbX9wAN+5grfkf7wDH/h4u/4f5X7bHoSAv84nAT8oemWt4pN4ckRuELZtrd7NAxf275FaeLkk9/zz0UN3r+9Yl9/imteIcSpN7xw/dgKBAgGqBilu9cAPPwX+3+7/Z3ia6oIQEY\n\nAtwA/+XodrLKG0ukA/+BBNXoy468PoC2+FQDJZZmu6Gsjjk+cH/4AB6nr1w3062mCDhAnXJRDkQQAA==\n```\n%%","slug":"Excalidraw/Drawing 2024-12-17 15.07.21.excalidraw","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2025-01-05T07:01:31.935Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001na5t2bas2f99k","content":"<p>&#x3D;&#x3D;⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠&#x3D;&#x3D; You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’</p>\n<h1 id=\"Excalidraw-Data\"><a href=\"#Excalidraw-Data\" class=\"headerlink\" title=\"Excalidraw Data\"></a>Excalidraw Data</h1><h2 id=\"Text-Elements\"><a href=\"#Text-Elements\" class=\"headerlink\" title=\"Text Elements\"></a>Text Elements</h2><p>Broker ^vpVFc8Jz</p>\n<p>Consumer ^HlcmoCYz</p>\n<p>Pull Message ^iEKLY3mc</p>\n<p>Processing ^4SqNDxs2</p>\n<p>success ^i4gc31t0</p>\n<p>True ^6S02Vu74</p>\n<p>False ^thrRj5N6</p>\n<p>%%</p>\n<h2 id=\"Drawing\"><a href=\"#Drawing\" class=\"headerlink\" title=\"Drawing\"></a>Drawing</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebQA2bQAOGjoghH0EDihmbgBtcDBQMBLoeHF0QOwojmVg1JLIRhZ2LjQARgAGABYAVn5S5tZOADlOMW52pKSAZk6eTt6pgchC</span><br><span class=\"line\"></span><br><span class=\"line\">ZgARdKgEYm4AMwIwlYgSbggAIQBOegB9dcIARwA1ACUAUQBZAFVcbBYoZ7MLjHPaEfD4ADKsHqEj+bGYzGcklwUGwkgapWYUFIbAA1ggAOokdTcPiFATYvEIKEwGHoQQeDGQHF+SQccK5NCdY5sOC/NQwSadbnkiDWOoVEWNCCYbjOGbxADsyW67RmSXafUV8Xi7R4iuOgrQ8vaiR1ip4vRmMx4l0VSWOWJx+IAwmx8GxSGcAMTCv2dJkQTS/XHK</span><br><span class=\"line\"></span><br><span class=\"line\">FkcYhuj1eiTesTEbrEXCBijE9FoeIzbSXToKy62i2LU39UWSBCEZTSSbtS7aHhJeJJS4zXrde229WOhA7SZ9U25pbdY5h4RwACSxE5qAKjUgAEVcABBboE0gzCEEmaKmZPPaaCh7Hg3B4ABQg5IAuo7KfiIcjSHB2Qizsx73BA5phBG3sFMtkpzOjTFLOJy7BInQIA8HyEIqY57AAWnOHAnh8NyEE8STnE8YxMqUsCIGcuCkDiVDkmAAC+l7HEIc</span><br><span class=\"line\"></span><br><span class=\"line\">BJtsYGoO027xJ0LEzJcvS6vExxEBwuLcBwQjgjxbDYPiDEHPgRyioQEZYIRvSBns5CZBOAlCfgxzhsQT5ToJ4KFORAzAZA+EVNAWBQIGQytJM8SWscNmjOMFSKm2OpMTMQ4yRsWw9mgknSdKpwSPQcBPAAYtgSQAFJGEpYKQtC5nImiIhINezqEmmkyZVSNJ0hADKnFpwiVrpuWiry/KwEKUqlOKdL1ZAsrGuxnTaFMLbNoqJbSkaqDOFMHWqtMa</span><br><span class=\"line\"></span><br><span class=\"line\">rtL0lw6kk3nSk6VJRp6Pr+sKH4hiOQgRotMboNi1jMHygTZCmOUdF02hbpcbbdPElxXXaPBktKZYVlWaDdHEDYWr0vTTI9Sw9F2/moFaXQFq2w4suOk75GREALsuq7rpu267vuh7HmeVGivNt5vhVEivkR77HJ+m3ED+GRZDksOziZpQhegBLrOcADSuAABJPDFAAyIwcLJPMGM4mCSJ0ADiuGmeUhHEWwpGzpRjRXqKNF0cDnksSxlo2jdPGyfx</span><br><span class=\"line\"></span><br><span class=\"line\">aD6ZpooemJwOBQgIKcFAEKEEYFReXWzZJD0iqLK7nSzNb2QRbg+hggN7THNsmBWRI5xZV6pOhEEskVMsoqh1Ai5EMobToMEexWY5TBQOYBCpxWGfQLygZ6NkuDx6QalGxpPKkBWskEAAKpZZyR1S0cyXJrXoLg8RKSpCC16gxuleTBNj/XorkBQbdhx3UeBrgQhQGwLzhPbFTYkIVum/HHPlpW4eMXWvSGcZScyxIvEZaKTkZ9Mly5y0zkcBMHSd</span><br><span class=\"line\"></span><br><span class=\"line\">IqUxtgs3E+U2MEei+xDj72CgxCAAArXAUxxas2IPEAA8usKBUlzjtByJIH4DwErggKuZOECIkQojRIGXG2ViAkjQE9TEN5qTJRfO6Eqs8ypsg5NwZqEBqrYAFHVY4jVJTHD7vKFinUli9TbM/boH0ZiGjlHMLMbYugaiSD/SaNY8qundEtWMK0AwxzEhtLaOidoQDjDsRMyZjipioemVA3QkjZnzLMPU9pegWluscF6J9uBZibGo1sPAugyIkaaB</span><br><span class=\"line\"></span><br><span class=\"line\">AQ05E427AxLW3RhQyNoZADa0MAJwwRiuNcG4tw7j3AeI8p5zzKy0dSfGHCJDaQ/F+Cmv5qYARVtKNWKINbMVYvMfsM19Z8XUsJU2olxKgKkuAuhREoDnFko4WoPSTbSiyMQcZEZZLKGmTxUIUA3T6ADjIHYJ42CyVPuPHGURSApzlhQMsuAGKHNmRGRcZyLlXJntKOAez/y00aIBRozUSidDIg0j5ZEwCOOcfWGYbikgeJ4F4wF/jLiBI+iEvsP9</span><br><span class=\"line\"></span><br><span class=\"line\">4gRLVH87GwVe6EUVEPf2I9Hm9OlNpKe9MygERoeSJWFEr7SjMmcO+1kmDDAzvmYOD8mWtDGB/BOix3bKI+scNYQCEAgICmAwVkD1g8FIAADUwGwVmDwhBszCsoHmmB4IQkuAATWwHgpKtJCE4mIciVE6ISlEjsaSEpBCmGMgnuVcpqAuE8L4V/LhgjOHCIUWI9Uk1eisS6PmfUfVSgDWcLaOI3Qcw/R4C2FsrZtwlO2stFaa0jHaRTbGeMViTpWv</span><br><span class=\"line\"></span><br><span class=\"line\">ek4u6oLwWQuhc9Y+b1UCwvhcEnoSLwmRKBgxK6Ux2hdVmqUFJE40kgQyUjbJqM8kY0KRiuhWU7zEynhASppNqmUz/DTNAeR/mQCaaKxirTtYdI7ZAXihtp6EtKGbAZYqhnXlGQsyZyy66HsgHMy9SyVmmzWRsrZ9Fdn7KfXNY5pySIPK/aUOZdy/0hAJTM0oLz9k9oBbOMA3y4N/JWGAT5JRgVFtcfqCFniX4wuSHCyRtbQlMQbWi2cF5R2rCxRI</span><br><span class=\"line\"></span><br><span class=\"line\">XAKQQTD1Htc0oxKnWkrpRSxoVKjKFBMmS8yDLX7Mu4DmKJ0pH5cs/hu+JbbrSJ2Cr5YBFtxUyUgRzFuUA5wQpuASF48RWY8BeGwOcMx6D6BPJ0XYIJEq2thMaxEpqyEWtOrwG1jDCbMIs6w1kU8XV8l4bVd1AjahNW9W1MR3R1Q5mbJcINOYAH9TlPWdo2gAbzFBT9fsoaKRZSzegX0abDGhkzaYn0Oakx5uoQ4wtLiwWYdLTh8tr1T7VoI4isJK</span><br><span class=\"line\"></span><br><span class=\"line\">LG3ROBg2YJipepXUhqObt7zSh9qySjXJ6MClY2KUc8dZTnwVOqVU8m866n5BXRANdLSFRtOCSxTpB9uk3vA7u/pimz1HIvRMx9x3jj3uu1M27z6sSvrUO+15BynkjJOcB+W/6ns3OIL985oGAOQEg28pdZEUNwaQwhsjSGYdoeqyW7DcPmtBNa8R9rpHlYUZOFR/ulxcWqTAxPCMJK4Zsd4JSy+3Hr7kszvHRlb8WXfwE5yly3ALSON6LaHUgr5M</span><br><span class=\"line\"></span><br><span class=\"line\">ivO0FBmkCzD7naOcIQzAPhQDeBzKBzgYAcBgLdIQHnpSgnwa59ARC7OkPNbNqklqKtJKKvQ6z9J3OBhZI6hbzqeS+bdYxYUgWJRetFCInb2hwtNk6FFmLrF5HGn1B1Pn90ZNuXtGy792Xit6Py6KYMGbqk5fMaV6xopbEVeR8W2raPSwVqa3hmtWPkWopE5iGJpIwa5mEzuiAXaYZQ97UuTJyMclo3yZjIpJQNsUInQ+KdM7k9ztqZD6cG2tsMU1</span><br><span class=\"line\"></span><br><span class=\"line\">rt7dXT92MdO+bCSSnv1XcWY9g9J2MARgfdv5fEB8AvoMG+nZH2wcW9GcD/7O+7u3PuaDgHEGPvQZKDD+DvyEfQ8BXnjD7ihesGGOCKdabWle6KM2mKxA8k1Gi4JO+KV+zGDurGN8NOHGdOJQPG1OFki8HOnAkwAaDo7KrO4mCckarEW4SQ5uQqfka+F2ECZwHM+A2A+gbALo2q8UlmOuhqdqLCceJuTmseY6+UuuRUNuDq7CDuwhkArq/mruHqQW</span><br><span class=\"line\"></span><br><span class=\"line\">QiXucoqocQ7EM0W4mWEAQc8QvQyQ9e1BoMOo0WyaCeuW+i6ahWae5hEA5yag980oOe9imotYCwaiTEehpoeh5uPilaH0nU0w3UvUVovWj0TavYaijinQYMA2NEQ2re0o6wDwc4uImASCHwkgSQewLcPA4sewnQLoY4RgbwIwVk+Og+82U4RUb4y234E+i6U+1EtEzSs+m67S+2jee6V+x6IuwykAewNsdsDsfiWYvUrEairs4WMRvWcWpQgxvs/s</span><br><span class=\"line\"></span><br><span class=\"line\">gclUtK7cEgboHAzAQgmQ3c0owYYQDKHQxBqxYcRc6c9KCA2cLO+c7gZxJc68JMooFcUQ1cDGX2shjc/grcax6AGxWxOxgYEysB/cksdGeKbxt6061SU8R+c8C8p8EAfx2xTAK8a8G8W8IxaAu8/Rx+h8xekw58mBRQDO5kQQRAcgjhgwHKBBNC6o5uYmXOaA6ofKFo7sguwq66lsEqZwPAbwnQygEI8ElwmR5wzAEIcApAMAuI2qUC2qY4EI+qVu</span><br><span class=\"line\"></span><br><span class=\"line\">EA+uJCZq5C9Cpu9i5ug+YhxUmuTGbC3mTuNUQcbuoonqXIIWg0YKbh9o4WHkv0nE9WYa3AP0nU0eehswxaP0jeFC6eeW/oVhxikYthFiCYZWNiTm1oF0HYM0Ae0w8QH0cxkAfhp8tonUmYwSKiehlB1oERaArsloRZDYcRqSw2kA2APMNwLwkgMqzAFAIwuoPABIIQ3QMqBIYwc4uEEATw8QuRrMygxAIwUuiCzAi4rBbAmAjcBI3ZyRqR6RmR2R</span><br><span class=\"line\"></span><br><span class=\"line\">uR+RhRxRpR5RUBIheMk6TqNRxMdRNSVMk+y6zR6sbRO2W6nRi+PRZ29BoulGMBfcYoHMCBEJu+yBekGkRJ2BaBGA4IhAFJLOgmNCSZ+BHAZBpItoiSwSjetBCmd5OJjMEAiouACAQgLoUAJ4LorMLwzAWmUALwi4MUPATwkgY4ipYhKp9mRuAh+Imp1qxut4upEhnm9uU4PmJp/C5pShnu0o3u+Y4icaP8ioU00apoIeIMiQE0Hh+ot0rYiw2hfp</span><br><span class=\"line\"></span><br><span class=\"line\">oZlhBWwZ/pme5W9i0ZNoLs8ScKDYoFRejWpItYpoNobaXsOZmYeZnWDEXkzYMiSoxxnaUMCR04cMlZ1ZtZ9ZjZeoLZuAbZHZhm3ZvZ/Zg5w55wo545bBU5hAM5SGEAc5aRGRWROReRBRRRJRZRfeYAA+luVRL4tRs6K2DR9Sp5rRkw7Re2XsXRBsN5q+gy95BOj5hE5FYJpOSB0JTqxs35JJ9KzOYFpILEzpTQ1J4FjJIMHE7soMzlqwQunJ6+Yu</span><br><span class=\"line\"></span><br><span class=\"line\">ZwLchAXwrgLwuIMqcAQgHMc4Oo8EkgMUm8ewVA3BBqhUVFhu6pWU9FNCLmvBbm9qrFUh7FxpfmppihHulpKhbUbkyWmonEw1EWjiBoooQcbpWs3Wj0MeDYs1Fu8e0YqagZqlRWiN2aliEZ2eTm7syW0arEmYGW2o3i+JGYn0wS0WbkcKCwMR2pNeBZCacwbYXCze7+FZVZNZdZDZTZ/lgVnZIVfZPAA5Q5I58QY5E5sV8VcMSVC5qVy5GVa52VFR</span><br><span class=\"line\"></span><br><span class=\"line\">+VO5DuUJ5MB5q2x50+LR66c+l5NV15L+K+J6qAXJl2JyB+169+oo92W+VtR+J+L2Z+b2F+n6Rt1+P2T+lyV+QGXtZOooEOjRKGn+cO3+m5H+gKyoOYrhQS24cKMicOzgqoCQ9YcKmo0eQaF8P+s4MO0ZDYCaXUTE38t0yZJQzg9kyQ5NTE0a1BwoeoiGv+sGk0ldnEXscaLEpoJZgKSdUl7susOYrinEMwDdOdkd4eeNOoYKLEHipdYASdMZUKH0</span><br><span class=\"line\"></span><br><span class=\"line\">CwPAjiDYzYI9MGs4X+kB/egqhOYoMUr5/tRKXVKBVOaBPAtOJQXGWBfVEgZJAFYQQFtktJcaYFEFHQlo4WMaAugCdBjViFkC4s4F6wXwY42q+RMAnQNwUCIwvQBIi4Lo9ATwOKZ1Spl1apjm+azmjFDCD11uT1J9XmTqHF71XF0oFpjuP11pnEyQUwURXkMirE/WYN3AYiaoQSaiehcKllZhaNFhSeex60qNuiuWGlkZ2DConUWZ5NVo1BmoehxN</span><br><span class=\"line\"></span><br><span class=\"line\">xlTJSW09ad7sHEUWvpdNjEOomY4WN05uLN5Zyp7N3lXNflrZ7ZfNCVoVgt4VItYtMV05s5KRyVi5aVK5mV65OVeVc2Kt1RRMD4GtpV5Z9MqwkCzMbMnM3MfMAsHAQs+gIsYsoJgKvGssJEOVFE+OM+lVF58wVoK92h3R7tvRCFe9LV1GrMR9nVk83VX519NKeEv5/GJBwFG64RbTnO3KvYejV0vUcNcFwu5TymZwIwNwbwLomwPM8QUA+ApAHMXw</span><br><span class=\"line\"></span><br><span class=\"line\">MUCAyg2A2AFAJ4uQaDlFtmqpDmuDt1ODtFeDhUeptuhpJDb1LuXQn1wW1D8oloMZEx0aLseoyZOhQmTi9o0WM9EKqorYI18NC0ylgjpQKe1h5M6lGNWeThTmtDSZ9kUKU05odoSjviGYWYmo8SvWvWU0PQZa1eGsGoP89YUFpZblKGPZAtQtEVUV4tLjCV0tKVS56Vq5WVG5u9uDQ+j4u5o+ex4+R5Qd2tZ5eTWsHRBth2S+7xx+t5AD56FtD29t</span><br><span class=\"line\"></span><br><span class=\"line\">0rttV6PRp+myLtxAH6x07tWIN+ftPtj+IG3t7tgdrNIdgKYdnLo9sGXzNot0/YMeAzidtY8SMiW4bauobaqoG9EdsGpo0jUwrKd0bsyLidmonU+NP0SoqoSoTElwvryGgK9YyQEKiwjYgNslnE4b3Q2gvWcZba1BN038GoibudyouovWjiN0MifQNo4bcQ2oU9N0HiHiU0V0Zbf+WYk9fQrs7UQRgM3diQPQHiAeHiNbYKNYnbsGbYCQUWYKXs0w</span><br><span class=\"line\"></span><br><span class=\"line\">AaVejQcQjYt0tdUedbWd4dSbTdSWPObraoDYeo9bgKaovu9lXQxYaiNosw07s4bpXsYKU9nsrsv9sGK9gRoK1BcKkKuYw92dm9jQ8LUKiLJdKLoNwBcQPzEesWEWjYD7IH+hz740jYwo77s9ydiZ1BwSg4CwzESHqGtYGjpo2oao24aoK9cOfQCQ9ot0fQmY7bj0RHQK6hNYU07s/0woHENHFb87KiS7uYl9QHfrs4YKyWhY6oz8hZ9YWHTiConE</span><br><span class=\"line\"></span><br><span class=\"line\">2ok0P839Inu7MOX7fzv06oExeh9kK7qGyoqWUwP0rs0bt0rHX7UwP7toWGNYmWJQW4CQTEbkM0iZoSbYVnSW0ajp9keh7ErJSSTnSW/70nAS7S97one7s4AbIlCoW47s24sbfOcOj0GZ2oMxzEkW3QrH50xdNn9kTD0aDkgKrrdaHrpobaeofOrH29ZG+OQJT5uAPMNT7tH53AqBjO6n2TjT9OtKLTA1XTNJvAMx79E1ANSw9Yji7zQzC1DBS1Eg</span><br><span class=\"line\"></span><br><span class=\"line\">CE+gIwUCY4+A2q3QLw2AygLwLocAUC+gMq2ALoIwFF+Dypuz1F11gh2D2pluzFhDBpxDDupD1zZpFDPF31fFCibpP0+YVoCobY1ogLA0cKebDr3hOYwogNfDoj5iKlyewjNh/DGe0Lmlrpubqox7lbTEaiuYaLlaehyQC7k0Go+oIl0a+ZqA01FoX0cNxjiRpQdjNLjj0Vk5DLUtbjMtLLXjCtHLuVNqBVi26txV9RgrZVqsOt22Yr1VB20oJT1t</span><br><span class=\"line\"></span><br><span class=\"line\">Cvsrp6TVerCrdthr8yirarTtGr2yWrl+urP6t+z+SvgGRrf2ZvR+Zr5ZFrsGVrgvjds45deb1dP0bdzY5oP0idyoEW1NGicauYbarHQ0ubXQOo0bbkZH9eDb2gAemoNYrhcn8ZofUKyQG7CwW7TlO6ZdeoEPzbehvUIl5oofLYCQBTbaUWnE7r4bHU0eLiVHG7v0SQof2Hjij0E0moBHQPidubuYbsjNdo9kuYbf+hTlDHQ97bfQNHebJnEKv0Cl</span><br><span class=\"line\"></span><br><span class=\"line\">9kbfJHCfSouoOSWLjnYAE0vuAaCjt038rYCaofVo8fTlHEE0Swd0FoaXUlPDbncadbbaPXTvNrLvrYvu0mJ7wl+PhnYATsZsMXUTI1YkurYU/lmFYjfMlg6WG/sFyBTdt9Gi/ftjNHaBt9+O7EBdtMDTYz8/8GA5sIJzTb6g2+HUYfu5Bh7RYFQvUOHEsHj585PSmYYPmojL4dRHofze0NuDw7B5AUZ/KAU2BgHX8poO7a1sBzz5OJXY0wNyHGke</span><br><span class=\"line\"></span><br><span class=\"line\">iPQP2j7SARfwEEcdqCofJiL7gC5ekJomYUGFB1nDxJsw2ocgYsEoE/xVBUlYJE2HJo5hHE6OXNkAO1AgC3EbSYQW/1EFz0I2EfPQkp1jZ90RqJQLTq2B07vsGwrbUPk4jaRXRhqHEFemN3PY+cawSoIHgHnzDWhAOGnS1qHR3quCHywJMUB8Da7m9mQp9KcF1wqA9dOMTTCJmcE6DnBFcDwTAC3HFhCB1gMqIwEYFxC4BOgMUDmBFCCCBgcCrTH7</span><br><span class=\"line\"></span><br><span class=\"line\">qFn75SDescwJsMinebhoI+2YZvnJxjSKIJGueJxCvU0Z2h86cwAPI3lTK9g4grYJsBm2mp9A2w7uOkJi3VBahi+vOQIfdwRrw9fQaiPYL0E0BBkRGZib0PEmwC8pzuhUVKBoECA3c6KQhe6qcxYpEM2KKxUoHIQ+rksW87lECH0A+AxQXQpAIQC3A5g8xcAIwVeL0BuCKp4ILwGYL4yF4BMzgfLQlrPm1hgp7Q1BQamgCtDzBxuPTekeZWix2hYK</span><br><span class=\"line\"></span><br><span class=\"line\">81PomL0PILo3KNvN/HbwyGWs6u4iaLPMCkxjDpg+LOHF0GVDbgxhMeDiDERbAijhQbkRjkGx6BVdMwugxoHqA6jChzK3fHSn0ATbRdNOvuGaFNAsrChOi2bc9o8zmAFgvYnHdiL9Dy5JYX+7iTUGCimL5gZR6ZGkaCmuhzAawr/FdDF1Xbj8poloJiB4lmAAd4B40QItGg+iuwxhSnVjuxBTrrCHod0W6HCgDGFoAW6iK6HpUVCsdZ2wnGPHWiEH</span><br><span class=\"line\"></span><br><span class=\"line\">sQAx3bR6AOG1B2g3OlY8IdqDUT6hL+1XBUDKJrDSMCaJXCRAsBcERikcKwuNEsCLquc5OufHfgHnPjp0JoGjaCu2MjaoCLQFlEStwNgy1hcwEKK6BCg37Vs0B5ovASqH4F09BwN0GQmXRGj84Qi00VUPKIrHniZ2ubcYu5xkEWg06idfQluJ9I1gFKWorMZOMbB/NLBP/ROl8w2HzA6eXvaNFZyzDdQdQdaRMnZytDhsksSQy0NqHrDxlR+742Lj</span><br><span class=\"line\"></span><br><span class=\"line\">53YjRZ9OyQ7rC60roMdlRIlG/pmCs7n9pxTYG6Dkjujexu6ubDfqkJXpeFdQtXYiY0GcAGioUi7Gqj9AtBeQJo8AkSef2B6jstCUAkdnV0yENdw6x+dVufkN5u1ChHtMZDr3doqsbsek9Xr+it4ms9JvtY1sfQZj71cACpdqogXa7FDOu59brpSm5Ga0hW5VXWlVQXySt6qJtS2L1UYISAIQDwDUPQHwC9AhAzgJIC6CaFfAIoMqVmFAAJB2B+hg</span><br><span class=\"line\"></span><br><span class=\"line\">3dkIGG9wV0NEGgzDH+0bzhptQdYe1o2CzID0sJWNbBjdDzZx182IlfUE/0J6nw20bvb+JaBjTiiawK7MUF9yrSdQLhHiK4Qvz6C3DgWqPB4YqCeEvCUaKPeHntE2KHRqYPw8yGcywYVYZCQLJihd02nPUp4O06EeQxcqDY4RlLREciNRHojMR2IoQLiPxGEjiRXLYXpUCWzU9pqNzekmNRMoCphu41ZkYxBK4+i9CHIjklyLHwlVBWfI6VrbyZ6R</span><br><span class=\"line\"></span><br><span class=\"line\">ifkak9If63KmPQHKIlWGu2Fn7TQE+6bJ0rqFy5CSSgiQVsHozbZTVbonTW1slhmgz0foEWIHvEDy7dsbO01WQYmm37nQOIOonDkeKhRpCRBYnVdtxKmi4cA0MaX6G5H7HulLQ38KLFClBTMziZAAitrGJq6sRF6JwsrgkCK5NhIhNdOmZWP0JxjLoQggNPqE1Cz9TQOYQApNCbKcRKxiQMYa2LUT5gpJ84uSXIx6xCDyOCaVvupKFmaS9e2k7Vp9</span><br><span class=\"line\"></span><br><span class=\"line\">khJmTLaWvKOcb31Y2StepvSyUfia6EQW4BQ2Eq5LQClDSQnkqGeLwXSS9Gk0vc8rLwCkK86qpTFXqbTAShTFu6ACKPpmMw8xNArMUWPECgRfANMBIKBBCHWAwBzgWUxnLiRylWlREkAmPDIhJYyY5BkAcNDaDrDTUIUbaQGjpW0LOFuA9UxMgUxkRuycyvhEmqgFrDMlfRcwffvZGlncUvqQ049pcPHbjTUuuDf0l7FmnPDXhi0sxMtIOhEQ1p2z</span><br><span class=\"line\"></span><br><span class=\"line\">faWCK3KUJtpIIjaf/KKEvcpwx053PIRuawjWaEAK6SiLREYisROIvEQ8AJFEila/jYfLyw+m2VSQ38G0M/Psh0iq038RvAySBlqg5gXEJyuyX/qq8cSZMfOdTFhmQl4Z8ItwfVxRmxc6w9YXrHWihSw0F+6OPNqqBbQcRVE8lesKx1Jndjo03UK0LGj8FgBEgY0diI2Eo584FFLMyTs2AVBSi2w/qXUSUFgkCy8eiZd2XCis7cTFZ/YfpvbJUXFi</span><br><span class=\"line\"></span><br><span class=\"line\">W+slcLCJRCJZjlQEiQIYsCoLyM4cco44Xzn4Wksp2Ks2jvi1kFWjcw6o2eihPEXWglFEKWtGeJ4WNBN58SL+iDSEGMju6I0MFOFh9KUEvCdoLIRtkdrrJnaBvMOVfkjmGSrJ++epUfjMmJzbJd6S3iDiTnSsU51GL4OnOlYdcs57ksobnP5bQyC562XyTL3nxXlAplchqowtrnSwh5D9QCqQpYjxImREmd2CXSiI0FORIzMKegDXhIJ9AioJBMGE</span><br><span class=\"line\"></span><br><span class=\"line\">XDtB4IXwD4PYB5hfAng2ATYutL4L6ksst3IBVy0e78FnuEIjoFc2gUfcGog084XTN6x3yfSD8oYdaUzAxleoxGMGPWAkpY9WSO2FsBNGiFw0lK005+XNLfmQtQyewYlRj3ejKhbQXQKgVvwmltTa88fIpmMK3BeDmp1PPUIvVNByzYFJjBBTdOQX3THp6C56VgvyhvS9ywTCprkNwBPB+lkJQZXpOYU8i1sS6YVhVQ6D+TZl5co7HpLKYAMlloEM</span><br><span class=\"line\"></span><br><span class=\"line\">4JIFxBzg5wPMIwDzCSAUAvg8EFuDAAQDnBxYPMEIEgh4CDzzIVQGoB7lHlXRksw/TiKV3iz0iSO8YmrksK1IXsBwWg/1aUB2FfwxiwfKNZAEoZcIcV9w9oAgDTVpqCVJiVHp/NWnHRf5oIp7h8qBF3dgFby85uAt4pQioFMI0UIzyaKihlI4JNpc1UlWS0iGFOFjMMr8SjKKRlVK0PEiUmkKd5WyhONwwsqFi/68FOVnnMVXHkyI4TfVRHCgAjAX</span><br><span class=\"line\"></span><br><span class=\"line\">Q9y9YDMBuD4B2gmAegBzHaA8xOg2qL4IPDhzpNqMZyLJjfSAhpMkKXwZgPtjHCsxCAmRJBNgAtBfBcQkgB4IQBii4Iz1OBIiJkzIhUpshm2YuaKzaQg8bOhtbVVXJCl9db6RyiAFE3ZhcxeY/MQWMLFFgSxXVGTeWLlIUTqh4+NWbQgND5x1g5KpG0NQSTFGRrtCMaxiBCn+p+rtCSauHu8IzXprKSkAcFmpVsK5rv5+axtVZh+XvLdpgCrUmWse</span><br><span class=\"line\"></span><br><span class=\"line\">q/KwF/yqhtKBOkBY61rlC6RtibUdV3aPS/uPBArWdqz6IEanOUNZUtsYiPQHMKQuAmjrXSh/fhV0HoXTrGFXk0JgjMXU4Fk4UsJdegEIBvBWYPMbVDMH0B6oQNOTCDWqvyagpLQxTCuXBoWXVyFu4OAUQjPt5b1VB2Ya9qxvDbMaYB9kMcfjgqWvZqlRvThXn3S0xFMtZEIaNlvo1K1N8qrIZSBHSC8igGIDMBhAz2BQMYGcDBBkgxQbdlBi2AGX</span><br><span class=\"line\"></span><br><span class=\"line\">JwjoFbgZuzDDUG0i4YJVlAuAd8GgGVCBJO6YeP1DTUc4QBQQmAV2jqx3y9r2l2vTXg1tmQNFR4DAcKFFFihcE4YA2obVyHj5XQupAHH+Iwwmi58m8s2jeRdEWBsS+c0fbcJNASobatt4c/ALtv0mtKE5BrC9Zkzuz4BPwFAPonqqQo+a/NAWoLXhokAebR58SUgYY0W0U98wJUuUBRv0qJYE1dhIQnGnS13QpgEKsztrIazoteAbGwacmvoT+kuN</span><br><span class=\"line\"></span><br><span class=\"line\">mahaYSpzXkAVpQmnOCJp4KFrZNEmw5pNL2nC7xNduF6lWtkI1rTpySVTYXPmL0YW12msUPBGlXk4dI9TCOToxq7+zYslm3UQwDGof0HEy8hznrCnXDMZ1YylhZPiPy5NwtsvNyPMH6mK8Ha8GxaqZB+IQATwGkVAB8A5DRAeN06SgPCTOAB7wQQekPcoDD0LFbY28AhT7CgB+wA4+AcjSHEsh3EzgYgbICiVfg3FC4acEuAHGIDEB6gxwZ4lXHZA</span><br><span class=\"line\"></span><br><span class=\"line\">1xImLMNDbE0w0JNsNKTQMJ6CbgcBvii8CQNHvwCx6EQoe1EuvE3isBMSqAbEl0gQBHxlGZ8S0IjsgTnAV1a65gDzA3Vbqd1e6g9UepPXo7+4l60eYvU+2HitCElcHjEWIyBIaNHQCuivQsHUCjKjOjqF9Bp3M6r5rOu4Zxu42c6keqebnUtN51fyjoAurXKJr/lFrRdTmcXScxAWQHpdRpKqPLuU3Sh61J5Rtarqvzq7cA80zzPppKHdr2MiGvtW</span><br><span class=\"line\"></span><br><span class=\"line\">dBtKU04aj8UkC2Gs3zapEM0CwQ5tt1ObZ13k5XaujC0boItV0esNFq1Ve64tZtZ5ElpK2IzYcwolWRyrrAIpr9lrDPj/ECRlLVkIczVjUoRmSH79b+pDC/rjYKGNJdSg7Q0v231bUApKJrawsgSGrjVpq81ZautW2r7Vjq3AM6v62iQbtzqcqWyuPF84F+g4ExW9rm0091BMhkCIDp0nbaeqHGeVuZM6UtrrJFkyBEBoI0w64dCO4gzxiQrdAIpI</span><br><span class=\"line\"></span><br><span class=\"line\">wdYJgGYAuqQ4v5THfczP73QH9ZGoTMZzbTyHH9sLbBgDQuh9Z1QAXK6JNH3lz7qDl8u5sc3Z0/6w9fGt4WcEE0gHXlMm8TRQjF3SaCGIuhA5cyQOcUUDZ0+ImpqclvkJVzXKXZnNMk6NZBsWGCpZveaUKJMNYHFpQIhg275uTVBVawavzO7ODYrcYeQtg38HgpPu3AgiRPA4gxACIR9FpAj1+6PjokDkD8cbVDFk9NCOGonvT3LF6R2e04qXouJX</span><br><span class=\"line\"></span><br><span class=\"line\">Ei9BcfALnox1lxq9NsWvUwFWNVRPizcfAJHr72fGgTUyARGiTH1gnJ9qInEnfFn2M6ksC+tI6MwkBwA9gi4ZQDFEwDtA4Ai4S4BQHwAcxcAEUGKOcCgRPBxYyyAo0PMcD+xOA4mkRNV19x4seo5R0PGVKoK7G150BqYBX0jUvM7od0bYQfO3DlS3F7+rowAp6Ncas1IZHnftDzWgH5i4ByXYCMk0MVjmSpA6eCJl3fdq18xhQlyuVUrG1d9ksPXK</span><br><span class=\"line\"></span><br><span class=\"line\">uzlEHqU+Co4laEzDHiDjv0tAORJoMOIyZhg/ZRDMOVgsBWEy1zbesgT3rH1z619e+p4Cfrv1v6/9Wk0A2XqQNSGNzYUfbhnqkd3QVZmCigABg6zC6/M9UMgjQRYICEJCChDQgYQsIOEADb+USMKxIj3Z2DF5ouBlERg2qAkFAA+BjgZU4sD4NyZ4AmYRgLcBUJ5prPAbFYoWkVi7raTKJpoTx6VjqsWVMnkNhAVs9gHbMGI76u0Js/c2zEahAa7n</span><br><span class=\"line\"></span><br><span class=\"line\">LcONsJ2h4KN38eNVqewZ/UosQApUNH3YhGm59ZO9jY/NDIc6+jyPAAx/KAMOmRjUxsYxqWgOTHxC8Bi5q90BW1rUDSuyZRgebVYHQzWuvAzrodzNL9dV/NibqC4SUH6RRNAGebs4FBEbQGZhhfFsuM5mlVek243rQPHIsPdMW545DJOIIktiazDhL8fnh+6FLXxrZiCeyDDEyhXCSE0sUz2ulYTKceE7CGpiF6SCxelEyZfQDl7K9Yemva8UgSsn</span><br><span class=\"line\"></span><br><span class=\"line\">2TnJ7k7yf5OCnhTop8U5KdxNd6e98loQIpefBknR9GJHeNSen10nK0DJndtevSMFmH1XsJ9S+skBvqP1X6n9X+v31ihD91DaMaDDJ3kanEXQMmcEdKDryaEFfKSXSQkSUDOJDOytJaHEFmcl5xfZ+acOULdGkLvRm0+niGM/zBd51OAyLvGN4XvlEB6Y0RdepzGyGCxxXedLYPrbMDWm+yXsD030WCDhmi+qDrCDAxWj+YuRusrVApnqao23zuDI</span><br><span class=\"line\"></span><br><span class=\"line\">EuCHsz4ykS+gaLlnm7jF5yYYC0903nvdCWiABwuDpCiHeafaq3Glqvxtj2//CNL9GSCtXvF7sZgYHLA0Faql72XSShm+QRpoyolTQr1Fq0a9jDph47RYaNUmqzVFqq1TartUOqnV+Rq7a4anBySPYbi9iC/34Felpt72joAkD5xeQz9V2wgJtrCPA7Qdxk7fLjZhlOW2THJrkzyb5MCmhTIpsUxKZcODaabBoyeeFiYirCpg2gvwf4b8TZhq2VK9</span><br><span class=\"line\"></span><br><span class=\"line\">UMNECEA6ebQO6ZLtZN6Q7DD4OqHUkZtqw75YqRqM0hrrkQAIIUEGCHBEQjIRUI6ETCNhDYA5WpzhG40N6zoYM2ZGZmpYBJQjTJ1MB+NczhPXeaVWmNa7ApYaLdn8DaVVVkwuFhtJ9AA81oOGghe6vTTkLfVgTRhf51YWCLo13C6WomsunJCiBxTcgYDMqbFrFFrXCtb0nYGaKz3fA25O2seSZzc0fXRqCLSP9LNyKrixN2h44s02jBi40wuEvzq6</span><br><span class=\"line\"></span><br><span class=\"line\">Y1Zxs3gR7MSB4gEIeYE8CEBuQr1p51VU9Y2UvXrzkJW84JZxLfXneXyZGULNENVbU7modO5jN47d012DHGTC0YLvqhFDz2Spfr0RvbaUMQ0ESjGWkM1HhJa7WtCqaxsGSDDwt5rWcGcvi23LUtzy7LZ8sK23DtNhJPMCbLHHGBbsO8draZJzsf40dH+J4dVDG3ebqhnbSPYt5GGTJyD8wx3GuB3BHgrwT4D8D+BYhAQwIKm4reG3/xZKHnVo6aFe</span><br><span class=\"line\"></span><br><span class=\"line\">0zaAjiQErloT/bDUN+9D028dnNtxz4jEO+OTbdOp22UjCFRfWcB3t72D73QHK0UZhURoU2a9SaGJXjIeJo7UWvhfmy8jwS62/U5O7RzbCHWFg+YrYVnaZ2dXZdEmq09xvLt2m+dwxgtSNZws3VxrHpsTRWvk1vcgVzNci0Gcouaae79kwgBtZhLSs9rDEUcQGhiKOVSFJuw4wnE7F1oIUgzA5XbpusO7GiTujg+JfiQQS4ab1y+x9aaoeaJALcak</span><br><span class=\"line\"></span><br><span class=\"line\">7bj+O970AgzveEpFBMT6FgqeqEwZZhNJwc91l5UmZd2JUkTkyJ1EzZZIB2Xy4mJxy72fdsDmvbw5322OYDsNx/LBJv3eM7D2rwwr4+iK3vCisHzYrRjiQO0CEAjACQkgG4L0A4BIIXkEUKCOLGIAUANU+gN4DldWVP0rS3Uy0WaYkplSObiL2qRVgEqRoxZ0DlMgfOmB5ssX5prq5aZ6vWmud2a1Nb1ZiflqtpUmhu7E+Sc+mFNfpua23bIsd3Mn</span><br><span class=\"line\"></span><br><span class=\"line\">Xdqi6tcqb9woE+TrtUPZGXMOBAOjSqX48kWkL0ZKZxPjGIFlcI5uslpp3OqDqzmQISFc4IueXOrn1zm57c7uf3Onr17Q8oOyFo0liX2iHfZkhfd3xX2ENTt4ksho1crqtXa5jc1ubgA7mVuBrwO3lZhUqJ4+nkTvtJ37A7Tw0MQ2WU/ybaMdUWaLrUsKGzCsQZ6+jDiPaMatNZ8uRBJmgW3ebF3iXpdyl3/ohbkvv9pLoa56dAVQH67iTyaxscrW</span><br><span class=\"line\"></span><br><span class=\"line\">+m5d/pmBe3aWNLWNNzknJzy7FD8RtdBTvXRrELaYCzjomRM6gF/Ypn3F8EhULNwafMH7dyr1mg2aHmWO1XkCdQKQBeBQJegjZI+2a7acWvqCVruZbFpeOfXb77/e++IbSUlBjj2YfDvR0Lbzj6+rEmQUgNujuxUlj9zTvG9ixJv7K0bdHBm5qrQ2pMysvHBpPhvAO1HIh9GefwTUADFg2YDG8ILyp1a2HcMMw9kBO1oPXLktjyzLe8vy2Ad1NuUK</span><br><span class=\"line\"></span><br><span class=\"line\">JPMpL1/o5nQ6yzYCNkPQjjDiI8Qb20xyTD6HvG2cE+ffPfn/zwF2wGBcfBQX4L+CJC9wfsV4+49qFL9Bp0ui+61HthmIrdaU9i60WcLKo75tm3hXYOy20fjiMxH8Nejo7QY91X3mXba7jd1u8NcDcl3H5mFQRIhtqJ335EhjlMISy0C/o5PUCxVgDR1gOO9s7wqxZN2Mb4LLOjjT6DLtkvbTFL0t2AaF30uaX7pgBeW8It1umXDbll027ZctvO7K</span><br><span class=\"line\"></span><br><span class=\"line\">urlx28lX4B+XDFwp/rp45ZlZgFCkdxQbN0TdMlKiQh4vcVe8aV7LT6Vua/yZag/V1rkSAIdeP9P65YCYZypdGcQA/YQySZ1pcpMzPNLae/S1nsWdwni4ee1Z9cU2fLPbLVep4vs7r0nanXS5lc6691cev9XB5y518WudDeRvsL80uSfCvcAp9h2Gfa88JLX1wADSMUHADgBQhmkg90yGWEyD9VfEAwBgIQAQAUBzgqF4tz6GJVQ/1rgPwbcRFYXb</span><br><span class=\"line\"></span><br><span class=\"line\">B9AUIL/aF4LelA4fIBscIj7B//6IfsYML4UGVIiBMfiPiKM6di+E+MfCPjIMj8+W0v0fxP6n0j4e41uMQRP+H5h8R8GZkv9UdnyT4yCAvG3wKvn0z4ig2w5ns3hnxz6gBY+MgYv8b9M959U/OfGQeEls+PyXFHTIvlX8z80e6eX82vmX4j7eAdK78uV6HZT8Z86/gcNqoeUE0eKYg4Q4IGVGwxsqO+cQ4IbVBvKkYVbSgRgNgAYG+9NACAEzjoES</span><br><span class=\"line\"></span><br><span class=\"line\">UN+y/9A3PgeyLwjBs+wwJAbSynsJ8J/iAUIBAAEdDRN5G4xAD4GwBgIm+cDwQLM9n5IA5YeM5wd0JAlIDKBgwAACh6zUBeATEJv43/cO9AAAlIGE3jKAhIREMkbX9wAN+5grfkf7wDH/h4u/4f5X7bHoSAv84nAT8oemWt4pN4ckRuELZtrd7NAxf275FaeLkk9/zz0UN3r+9Yl9/imteIcSpN7xw/dgKBAgGqBilu9cAPPwX+3+7/Z3ia6oIQEY</span><br><span class=\"line\"></span><br><span class=\"line\">AtwA/+XodrLKG0ukA/+BBNXoy468PoC2+FQDJZZmu6Gsjjk+cH/4AB6nr1w3062mCDhAnXJRDkQQAA==</span><br></pre></td></tr></table></figure>\n<p>%%</p>\n","excerpt":"","more":"<p>&#x3D;&#x3D;⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠&#x3D;&#x3D; You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’</p>\n<h1 id=\"Excalidraw-Data\"><a href=\"#Excalidraw-Data\" class=\"headerlink\" title=\"Excalidraw Data\"></a>Excalidraw Data</h1><h2 id=\"Text-Elements\"><a href=\"#Text-Elements\" class=\"headerlink\" title=\"Text Elements\"></a>Text Elements</h2><p>Broker ^vpVFc8Jz</p>\n<p>Consumer ^HlcmoCYz</p>\n<p>Pull Message ^iEKLY3mc</p>\n<p>Processing ^4SqNDxs2</p>\n<p>success ^i4gc31t0</p>\n<p>True ^6S02Vu74</p>\n<p>False ^thrRj5N6</p>\n<p>%%</p>\n<h2 id=\"Drawing\"><a href=\"#Drawing\" class=\"headerlink\" title=\"Drawing\"></a>Drawing</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebQA2bQAOGjoghH0EDihmbgBtcDBQMBLoeHF0QOwojmVg1JLIRhZ2LjQARgAGABYAVn5S5tZOADlOMW52pKSAZk6eTt6pgchC</span><br><span class=\"line\"></span><br><span class=\"line\">ZgARdKgEYm4AMwIwlYgSbggAIQBOegB9dcIARwA1ACUAUQBZAFVcbBYoZ7MLjHPaEfD4ADKsHqEj+bGYzGcklwUGwkgapWYUFIbAA1ggAOokdTcPiFATYvEIKEwGHoQQeDGQHF+SQccK5NCdY5sOC/NQwSadbnkiDWOoVEWNCCYbjOGbxADsyW67RmSXafUV8Xi7R4iuOgrQ8vaiR1ip4vRmMx4l0VSWOWJx+IAwmx8GxSGcAMTCv2dJkQTS/XHK</span><br><span class=\"line\"></span><br><span class=\"line\">FkcYhuj1eiTesTEbrEXCBijE9FoeIzbSXToKy62i2LU39UWSBCEZTSSbtS7aHhJeJJS4zXrde229WOhA7SZ9U25pbdY5h4RwACSxE5qAKjUgAEVcABBboE0gzCEEmaKmZPPaaCh7Hg3B4ABQg5IAuo7KfiIcjSHB2Qizsx73BA5phBG3sFMtkpzOjTFLOJy7BInQIA8HyEIqY57AAWnOHAnh8NyEE8STnE8YxMqUsCIGcuCkDiVDkmAAC+l7HEIc</span><br><span class=\"line\"></span><br><span class=\"line\">BJtsYGoO027xJ0LEzJcvS6vExxEBwuLcBwQjgjxbDYPiDEHPgRyioQEZYIRvSBns5CZBOAlCfgxzhsQT5ToJ4KFORAzAZA+EVNAWBQIGQytJM8SWscNmjOMFSKm2OpMTMQ4yRsWw9mgknSdKpwSPQcBPAAYtgSQAFJGEpYKQtC5nImiIhINezqEmmkyZVSNJ0hADKnFpwiVrpuWiry/KwEKUqlOKdL1ZAsrGuxnTaFMLbNoqJbSkaqDOFMHWqtMa</span><br><span class=\"line\"></span><br><span class=\"line\">rtL0lw6kk3nSk6VJRp6Pr+sKH4hiOQgRotMboNi1jMHygTZCmOUdF02hbpcbbdPElxXXaPBktKZYVlWaDdHEDYWr0vTTI9Sw9F2/moFaXQFq2w4suOk75GREALsuq7rpu267vuh7HmeVGivNt5vhVEivkR77HJ+m3ED+GRZDksOziZpQhegBLrOcADSuAABJPDFAAyIwcLJPMGM4mCSJ0ADiuGmeUhHEWwpGzpRjRXqKNF0cDnksSxlo2jdPGyfx</span><br><span class=\"line\"></span><br><span class=\"line\">aD6ZpooemJwOBQgIKcFAEKEEYFReXWzZJD0iqLK7nSzNb2QRbg+hggN7THNsmBWRI5xZV6pOhEEskVMsoqh1Ai5EMobToMEexWY5TBQOYBCpxWGfQLygZ6NkuDx6QalGxpPKkBWskEAAKpZZyR1S0cyXJrXoLg8RKSpCC16gxuleTBNj/XorkBQbdhx3UeBrgQhQGwLzhPbFTYkIVum/HHPlpW4eMXWvSGcZScyxIvEZaKTkZ9Mly5y0zkcBMHSd</span><br><span class=\"line\"></span><br><span class=\"line\">IqUxtgs3E+U2MEei+xDj72CgxCAAArXAUxxas2IPEAA8usKBUlzjtByJIH4DwErggKuZOECIkQojRIGXG2ViAkjQE9TEN5qTJRfO6Eqs8ypsg5NwZqEBqrYAFHVY4jVJTHD7vKFinUli9TbM/boH0ZiGjlHMLMbYugaiSD/SaNY8qundEtWMK0AwxzEhtLaOidoQDjDsRMyZjipioemVA3QkjZnzLMPU9pegWluscF6J9uBZibGo1sPAugyIkaaB</span><br><span class=\"line\"></span><br><span class=\"line\">AQ05E427AxLW3RhQyNoZADa0MAJwwRiuNcG4tw7j3AeI8p5zzKy0dSfGHCJDaQ/F+Cmv5qYARVtKNWKINbMVYvMfsM19Z8XUsJU2olxKgKkuAuhREoDnFko4WoPSTbSiyMQcZEZZLKGmTxUIUA3T6ADjIHYJ42CyVPuPHGURSApzlhQMsuAGKHNmRGRcZyLlXJntKOAez/y00aIBRozUSidDIg0j5ZEwCOOcfWGYbikgeJ4F4wF/jLiBI+iEvsP9</span><br><span class=\"line\"></span><br><span class=\"line\">4gRLVH87GwVe6EUVEPf2I9Hm9OlNpKe9MygERoeSJWFEr7SjMmcO+1kmDDAzvmYOD8mWtDGB/BOix3bKI+scNYQCEAgICmAwVkD1g8FIAADUwGwVmDwhBszCsoHmmB4IQkuAATWwHgpKtJCE4mIciVE6ISlEjsaSEpBCmGMgnuVcpqAuE8L4V/LhgjOHCIUWI9Uk1eisS6PmfUfVSgDWcLaOI3Qcw/R4C2FsrZtwlO2stFaa0jHaRTbGeMViTpWv</span><br><span class=\"line\"></span><br><span class=\"line\">ek4u6oLwWQuhc9Y+b1UCwvhcEnoSLwmRKBgxK6Ux2hdVmqUFJE40kgQyUjbJqM8kY0KRiuhWU7zEynhASppNqmUz/DTNAeR/mQCaaKxirTtYdI7ZAXihtp6EtKGbAZYqhnXlGQsyZyy66HsgHMy9SyVmmzWRsrZ9Fdn7KfXNY5pySIPK/aUOZdy/0hAJTM0oLz9k9oBbOMA3y4N/JWGAT5JRgVFtcfqCFniX4wuSHCyRtbQlMQbWi2cF5R2rCxRI</span><br><span class=\"line\"></span><br><span class=\"line\">XAKQQTD1Htc0oxKnWkrpRSxoVKjKFBMmS8yDLX7Mu4DmKJ0pH5cs/hu+JbbrSJ2Cr5YBFtxUyUgRzFuUA5wQpuASF48RWY8BeGwOcMx6D6BPJ0XYIJEq2thMaxEpqyEWtOrwG1jDCbMIs6w1kU8XV8l4bVd1AjahNW9W1MR3R1Q5mbJcINOYAH9TlPWdo2gAbzFBT9fsoaKRZSzegX0abDGhkzaYn0Oakx5uoQ4wtLiwWYdLTh8tr1T7VoI4isJK</span><br><span class=\"line\"></span><br><span class=\"line\">LG3ROBg2YJipepXUhqObt7zSh9qySjXJ6MClY2KUc8dZTnwVOqVU8m866n5BXRANdLSFRtOCSxTpB9uk3vA7u/pimz1HIvRMx9x3jj3uu1M27z6sSvrUO+15BynkjJOcB+W/6ns3OIL985oGAOQEg28pdZEUNwaQwhsjSGYdoeqyW7DcPmtBNa8R9rpHlYUZOFR/ulxcWqTAxPCMJK4Zsd4JSy+3Hr7kszvHRlb8WXfwE5yly3ALSON6LaHUgr5M</span><br><span class=\"line\"></span><br><span class=\"line\">ivO0FBmkCzD7naOcIQzAPhQDeBzKBzgYAcBgLdIQHnpSgnwa59ARC7OkPNbNqklqKtJKKvQ6z9J3OBhZI6hbzqeS+bdYxYUgWJRetFCInb2hwtNk6FFmLrF5HGn1B1Pn90ZNuXtGy792Xit6Py6KYMGbqk5fMaV6xopbEVeR8W2raPSwVqa3hmtWPkWopE5iGJpIwa5mEzuiAXaYZQ97UuTJyMclo3yZjIpJQNsUInQ+KdM7k9ztqZD6cG2tsMU1</span><br><span class=\"line\"></span><br><span class=\"line\">rt7dXT92MdO+bCSSnv1XcWY9g9J2MARgfdv5fEB8AvoMG+nZH2wcW9GcD/7O+7u3PuaDgHEGPvQZKDD+DvyEfQ8BXnjD7ihesGGOCKdabWle6KM2mKxA8k1Gi4JO+KV+zGDurGN8NOHGdOJQPG1OFki8HOnAkwAaDo7KrO4mCckarEW4SQ5uQqfka+F2ECZwHM+A2A+gbALo2q8UlmOuhqdqLCceJuTmseY6+UuuRUNuDq7CDuwhkArq/mruHqQW</span><br><span class=\"line\"></span><br><span class=\"line\">QiXucoqocQ7EM0W4mWEAQc8QvQyQ9e1BoMOo0WyaCeuW+i6ahWae5hEA5yag980oOe9imotYCwaiTEehpoeh5uPilaH0nU0w3UvUVovWj0TavYaijinQYMA2NEQ2re0o6wDwc4uImASCHwkgSQewLcPA4sewnQLoY4RgbwIwVk+Og+82U4RUb4y234E+i6U+1EtEzSs+m67S+2jee6V+x6IuwykAewNsdsDsfiWYvUrEairs4WMRvWcWpQgxvs/s</span><br><span class=\"line\"></span><br><span class=\"line\">gclUtK7cEgboHAzAQgmQ3c0owYYQDKHQxBqxYcRc6c9KCA2cLO+c7gZxJc68JMooFcUQ1cDGX2shjc/grcax6AGxWxOxgYEysB/cksdGeKbxt6061SU8R+c8C8p8EAfx2xTAK8a8G8W8IxaAu8/Rx+h8xekw58mBRQDO5kQQRAcgjhgwHKBBNC6o5uYmXOaA6ofKFo7sguwq66lsEqZwPAbwnQygEI8ElwmR5wzAEIcApAMAuI2qUC2qY4EI+qVu</span><br><span class=\"line\"></span><br><span class=\"line\">EA+uJCZq5C9Cpu9i5ug+YhxUmuTGbC3mTuNUQcbuoonqXIIWg0YKbh9o4WHkv0nE9WYa3AP0nU0eehswxaP0jeFC6eeW/oVhxikYthFiCYZWNiTm1oF0HYM0Ae0w8QH0cxkAfhp8tonUmYwSKiehlB1oERaArsloRZDYcRqSw2kA2APMNwLwkgMqzAFAIwuoPABIIQ3QMqBIYwc4uEEATw8QuRrMygxAIwUuiCzAi4rBbAmAjcBI3ZyRqR6RmR2R</span><br><span class=\"line\"></span><br><span class=\"line\">uR+RhRxRpR5RUBIheMk6TqNRxMdRNSVMk+y6zR6sbRO2W6nRi+PRZ29BoulGMBfcYoHMCBEJu+yBekGkRJ2BaBGA4IhAFJLOgmNCSZ+BHAZBpItoiSwSjetBCmd5OJjMEAiouACAQgLoUAJ4LorMLwzAWmUALwi4MUPATwkgY4ipYhKp9mRuAh+Imp1qxut4upEhnm9uU4PmJp/C5pShnu0o3u+Y4icaP8ioU00apoIeIMiQE0Hh+ot0rYiw2hfp</span><br><span class=\"line\"></span><br><span class=\"line\">oZlhBWwZ/pme5W9i0ZNoLs8ScKDYoFRejWpItYpoNobaXsOZmYeZnWDEXkzYMiSoxxnaUMCR04cMlZ1ZtZ9ZjZeoLZuAbZHZhm3ZvZ/Zg5w55wo545bBU5hAM5SGEAc5aRGRWROReRBRRRJRZRfeYAA+luVRL4tRs6K2DR9Sp5rRkw7Re2XsXRBsN5q+gy95BOj5hE5FYJpOSB0JTqxs35JJ9KzOYFpILEzpTQ1J4FjJIMHE7soMzlqwQunJ6+Yu</span><br><span class=\"line\"></span><br><span class=\"line\">ZwLchAXwrgLwuIMqcAQgHMc4Oo8EkgMUm8ewVA3BBqhUVFhu6pWU9FNCLmvBbm9qrFUh7FxpfmppihHulpKhbUbkyWmonEw1EWjiBoooQcbpWs3Wj0MeDYs1Fu8e0YqagZqlRWiN2aliEZ2eTm7syW0arEmYGW2o3i+JGYn0wS0WbkcKCwMR2pNeBZCacwbYXCze7+FZVZNZdZDZTZ/lgVnZIVfZPAA5Q5I58QY5E5sV8VcMSVC5qVy5GVa52VFR</span><br><span class=\"line\"></span><br><span class=\"line\">+VO5DuUJ5MB5q2x50+LR66c+l5NV15L+K+J6qAXJl2JyB+169+oo92W+VtR+J+L2Z+b2F+n6Rt1+P2T+lyV+QGXtZOooEOjRKGn+cO3+m5H+gKyoOYrhQS24cKMicOzgqoCQ9YcKmo0eQaF8P+s4MO0ZDYCaXUTE38t0yZJQzg9kyQ5NTE0a1BwoeoiGv+sGk0ldnEXscaLEpoJZgKSdUl7susOYrinEMwDdOdkd4eeNOoYKLEHipdYASdMZUKH0</span><br><span class=\"line\"></span><br><span class=\"line\">CwPAjiDYzYI9MGs4X+kB/egqhOYoMUr5/tRKXVKBVOaBPAtOJQXGWBfVEgZJAFYQQFtktJcaYFEFHQlo4WMaAugCdBjViFkC4s4F6wXwY42q+RMAnQNwUCIwvQBIi4Lo9ATwOKZ1Spl1apjm+azmjFDCD11uT1J9XmTqHF71XF0oFpjuP11pnEyQUwURXkMirE/WYN3AYiaoQSaiehcKllZhaNFhSeex60qNuiuWGlkZ2DConUWZ5NVo1BmoehxN</span><br><span class=\"line\"></span><br><span class=\"line\">xlTJSW09ad7sHEUWvpdNjEOomY4WN05uLN5Zyp7N3lXNflrZ7ZfNCVoVgt4VItYtMV05s5KRyVi5aVK5mV65OVeVc2Kt1RRMD4GtpV5Z9MqwkCzMbMnM3MfMAsHAQs+gIsYsoJgKvGssJEOVFE+OM+lVF58wVoK92h3R7tvRCFe9LV1GrMR9nVk83VX519NKeEv5/GJBwFG64RbTnO3KvYejV0vUcNcFwu5TymZwIwNwbwLomwPM8QUA+ApAHMXw</span><br><span class=\"line\"></span><br><span class=\"line\">MUCAyg2A2AFAJ4uQaDlFtmqpDmuDt1ODtFeDhUeptuhpJDb1LuXQn1wW1D8oloMZEx0aLseoyZOhQmTi9o0WM9EKqorYI18NC0ylgjpQKe1h5M6lGNWeThTmtDSZ9kUKU05odoSjviGYWYmo8SvWvWU0PQZa1eGsGoP89YUFpZblKGPZAtQtEVUV4tLjCV0tKVS56Vq5WVG5u9uDQ+j4u5o+ex4+R5Qd2tZ5eTWsHRBth2S+7xx+t5AD56FtD29t</span><br><span class=\"line\"></span><br><span class=\"line\">0rttV6PRp+myLtxAH6x07tWIN+ftPtj+IG3t7tgdrNIdgKYdnLo9sGXzNot0/YMeAzidtY8SMiW4bauobaqoG9EdsGpo0jUwrKd0bsyLidmonU+NP0SoqoSoTElwvryGgK9YyQEKiwjYgNslnE4b3Q2gvWcZba1BN038GoibudyouovWjiN0MifQNo4bcQ2oU9N0HiHiU0V0Zbf+WYk9fQrs7UQRgM3diQPQHiAeHiNbYKNYnbsGbYCQUWYKXs0w</span><br><span class=\"line\"></span><br><span class=\"line\">AaVejQcQjYt0tdUedbWd4dSbTdSWPObraoDYeo9bgKaovu9lXQxYaiNosw07s4bpXsYKU9nsrsv9sGK9gRoK1BcKkKuYw92dm9jQ8LUKiLJdKLoNwBcQPzEesWEWjYD7IH+hz740jYwo77s9ydiZ1BwSg4CwzESHqGtYGjpo2oao24aoK9cOfQCQ9ot0fQmY7bj0RHQK6hNYU07s/0woHENHFb87KiS7uYl9QHfrs4YKyWhY6oz8hZ9YWHTiConE</span><br><span class=\"line\"></span><br><span class=\"line\">2ok0P839Inu7MOX7fzv06oExeh9kK7qGyoqWUwP0rs0bt0rHX7UwP7toWGNYmWJQW4CQTEbkM0iZoSbYVnSW0ajp9keh7ErJSSTnSW/70nAS7S97one7s4AbIlCoW47s24sbfOcOj0GZ2oMxzEkW3QrH50xdNn9kTD0aDkgKrrdaHrpobaeofOrH29ZG+OQJT5uAPMNT7tH53AqBjO6n2TjT9OtKLTA1XTNJvAMx79E1ANSw9Yji7zQzC1DBS1Eg</span><br><span class=\"line\"></span><br><span class=\"line\">CE+gIwUCY4+A2q3QLw2AygLwLocAUC+gMq2ALoIwFF+Dypuz1F11gh2D2pluzFhDBpxDDupD1zZpFDPF31fFCibpP0+YVoCobY1ogLA0cKebDr3hOYwogNfDoj5iKlyewjNh/DGe0Lmlrpubqox7lbTEaiuYaLlaehyQC7k0Go+oIl0a+ZqA01FoX0cNxjiRpQdjNLjj0Vk5DLUtbjMtLLXjCtHLuVNqBVi26txV9RgrZVqsOt22Yr1VB20oJT1t</span><br><span class=\"line\"></span><br><span class=\"line\">Cvsrp6TVerCrdthr8yirarTtGr2yWrl+urP6t+z+SvgGRrf2ZvR+Zr5ZFrsGVrgvjds45deb1dP0bdzY5oP0idyoEW1NGicauYbarHQ0ubXQOo0bbkZH9eDb2gAemoNYrhcn8ZofUKyQG7CwW7TlO6ZdeoEPzbehvUIl5oofLYCQBTbaUWnE7r4bHU0eLiVHG7v0SQof2Hjij0E0moBHQPidubuYbsjNdo9kuYbf+hTlDHQ97bfQNHebJnEKv0Cl</span><br><span class=\"line\"></span><br><span class=\"line\">9kbfJHCfSouoOSWLjnYAE0vuAaCjt038rYCaofVo8fTlHEE0Swd0FoaXUlPDbncadbbaPXTvNrLvrYvu0mJ7wl+PhnYATsZsMXUTI1YkurYU/lmFYjfMlg6WG/sFyBTdt9Gi/ftjNHaBt9+O7EBdtMDTYz8/8GA5sIJzTb6g2+HUYfu5Bh7RYFQvUOHEsHj585PSmYYPmojL4dRHofze0NuDw7B5AUZ/KAU2BgHX8poO7a1sBzz5OJXY0wNyHGke</span><br><span class=\"line\"></span><br><span class=\"line\">iPQP2j7SARfwEEcdqCofJiL7gC5ekJomYUGFB1nDxJsw2ocgYsEoE/xVBUlYJE2HJo5hHE6OXNkAO1AgC3EbSYQW/1EFz0I2EfPQkp1jZ90RqJQLTq2B07vsGwrbUPk4jaRXRhqHEFemN3PY+cawSoIHgHnzDWhAOGnS1qHR3quCHywJMUB8Da7m9mQp9KcF1wqA9dOMTTCJmcE6DnBFcDwTAC3HFhCB1gMqIwEYFxC4BOgMUDmBFCCCBgcCrTH7</span><br><span class=\"line\"></span><br><span class=\"line\">qFn75SDescwJsMinebhoI+2YZvnJxjSKIJGueJxCvU0Z2h86cwAPI3lTK9g4grYJsBm2mp9A2w7uOkJi3VBahi+vOQIfdwRrw9fQaiPYL0E0BBkRGZib0PEmwC8pzuhUVKBoECA3c6KQhe6qcxYpEM2KKxUoHIQ+rksW87lECH0A+AxQXQpAIQC3A5g8xcAIwVeL0BuCKp4ILwGYL4yF4BMzgfLQlrPm1hgp7Q1BQamgCtDzBxuPTekeZWix2hYK</span><br><span class=\"line\"></span><br><span class=\"line\">81PomL0PILo3KNvN/HbwyGWs6u4iaLPMCkxjDpg+LOHF0GVDbgxhMeDiDERbAijhQbkRjkGx6BVdMwugxoHqA6jChzK3fHSn0ATbRdNOvuGaFNAsrChOi2bc9o8zmAFgvYnHdiL9Dy5JYX+7iTUGCimL5gZR6ZGkaCmuhzAawr/FdDF1Xbj8poloJiB4lmAAd4B40QItGg+iuwxhSnVjuxBTrrCHod0W6HCgDGFoAW6iK6HpUVCsdZ2wnGPHWiEH</span><br><span class=\"line\"></span><br><span class=\"line\">sQAx3bR6AOG1B2g3OlY8IdqDUT6hL+1XBUDKJrDSMCaJXCRAsBcERikcKwuNEsCLquc5OufHfgHnPjp0JoGjaCu2MjaoCLQFlEStwNgy1hcwEKK6BCg37Vs0B5ovASqH4F09BwN0GQmXRGj84Qi00VUPKIrHniZ2ubcYu5xkEWg06idfQluJ9I1gFKWorMZOMbB/NLBP/ROl8w2HzA6eXvaNFZyzDdQdQdaRMnZytDhsksSQy0NqHrDxlR+742Lj</span><br><span class=\"line\"></span><br><span class=\"line\">53YjRZ9OyQ7rC60roMdlRIlG/pmCs7n9pxTYG6Dkjujexu6ubDfqkJXpeFdQtXYiY0GcAGioUi7Gqj9AtBeQJo8AkSef2B6jstCUAkdnV0yENdw6x+dVufkN5u1ChHtMZDr3doqsbsek9Xr+it4ms9JvtY1sfQZj71cACpdqogXa7FDOu59brpSm5Ga0hW5VXWlVQXySt6qJtS2L1UYISAIQDwDUPQHwC9AhAzgJIC6CaFfAIoMqVmFAAJB2B+hg</span><br><span class=\"line\"></span><br><span class=\"line\">3dkIGG9wV0NEGgzDH+0bzhptQdYe1o2CzID0sJWNbBjdDzZx182IlfUE/0J6nw20bvb+JaBjTiiawK7MUF9yrSdQLhHiK4Qvz6C3DgWqPB4YqCeEvCUaKPeHntE2KHRqYPw8yGcywYVYZCQLJihd02nPUp4O06EeQxcqDY4RlLREciNRHojMR2IoQLiPxGEjiRXLYXpUCWzU9pqNzekmNRMoCphu41ZkYxBK4+i9CHIjklyLHwlVBWfI6VrbyZ6R</span><br><span class=\"line\"></span><br><span class=\"line\">ifkak9If63KmPQHKIlWGu2Fn7TQE+6bJ0rqFy5CSSgiQVsHozbZTVbonTW1slhmgz0foEWIHvEDy7dsbO01WQYmm37nQOIOonDkeKhRpCRBYnVdtxKmi4cA0MaX6G5H7HulLQ38KLFClBTMziZAAitrGJq6sRF6JwsrgkCK5NhIhNdOmZWP0JxjLoQggNPqE1Cz9TQOYQApNCbKcRKxiQMYa2LUT5gpJ84uSXIx6xCDyOCaVvupKFmaS9e2k7Vp9</span><br><span class=\"line\"></span><br><span class=\"line\">khJmTLaWvKOcb31Y2StepvSyUfia6EQW4BQ2Eq5LQClDSQnkqGeLwXSS9Gk0vc8rLwCkK86qpTFXqbTAShTFu6ACKPpmMw8xNArMUWPECgRfANMBIKBBCHWAwBzgWUxnLiRylWlREkAmPDIhJYyY5BkAcNDaDrDTUIUbaQGjpW0LOFuA9UxMgUxkRuycyvhEmqgFrDMlfRcwffvZGlncUvqQ049pcPHbjTUuuDf0l7FmnPDXhi0sxMtIOhEQ1p2z</span><br><span class=\"line\"></span><br><span class=\"line\">faWCK3KUJtpIIjaf/KKEvcpwx053PIRuawjWaEAK6SiLREYisROIvEQ8AJFEila/jYfLyw+m2VSQ38G0M/Psh0iq038RvAySBlqg5gXEJyuyX/qq8cSZMfOdTFhmQl4Z8ItwfVxRmxc6w9YXrHWihSw0F+6OPNqqBbQcRVE8lesKx1Jndjo03UK0LGj8FgBEgY0diI2Eo584FFLMyTs2AVBSi2w/qXUSUFgkCy8eiZd2XCis7cTFZ/YfpvbJUXFi</span><br><span class=\"line\"></span><br><span class=\"line\">W+slcLCJRCJZjlQEiQIYsCoLyM4cco44Xzn4Wksp2Ks2jvi1kFWjcw6o2eihPEXWglFEKWtGeJ4WNBN58SL+iDSEGMju6I0MFOFh9KUEvCdoLIRtkdrrJnaBvMOVfkjmGSrJ++epUfjMmJzbJd6S3iDiTnSsU51GL4OnOlYdcs57ksobnP5bQyC562XyTL3nxXlAplchqowtrnSwh5D9QCqQpYjxImREmd2CXSiI0FORIzMKegDXhIJ9AioJBMGE</span><br><span class=\"line\"></span><br><span class=\"line\">XDtB4IXwD4PYB5hfAng2ATYutL4L6ksst3IBVy0e78FnuEIjoFc2gUfcGog084XTN6x3yfSD8oYdaUzAxleoxGMGPWAkpY9WSO2FsBNGiFw0lK005+XNLfmQtQyewYlRj3ejKhbQXQKgVvwmltTa88fIpmMK3BeDmp1PPUIvVNByzYFJjBBTdOQX3THp6C56VgvyhvS9ywTCprkNwBPB+lkJQZXpOYU8i1sS6YVhVQ6D+TZl5co7HpLKYAMlloEM</span><br><span class=\"line\"></span><br><span class=\"line\">4JIFxBzg5wPMIwDzCSAUAvg8EFuDAAQDnBxYPMEIEgh4CDzzIVQGoB7lHlXRksw/TiKV3iz0iSO8YmrksK1IXsBwWg/1aUB2FfwxiwfKNZAEoZcIcV9w9oAgDTVpqCVJiVHp/NWnHRf5oIp7h8qBF3dgFby85uAt4pQioFMI0UIzyaKihlI4JNpc1UlWS0iGFOFjMMr8SjKKRlVK0PEiUmkKd5WyhONwwsqFi/68FOVnnMVXHkyI4TfVRHCgAjAX</span><br><span class=\"line\"></span><br><span class=\"line\">Q9y9YDMBuD4B2gmAegBzHaA8xOg2qL4IPDhzpNqMZyLJjfSAhpMkKXwZgPtjHCsxCAmRJBNgAtBfBcQkgB4IQBii4Iz1OBIiJkzIhUpshm2YuaKzaQg8bOhtbVVXJCl9db6RyiAFE3ZhcxeY/MQWMLFFgSxXVGTeWLlIUTqh4+NWbQgND5x1g5KpG0NQSTFGRrtCMaxiBCn+p+rtCSauHu8IzXprKSkAcFmpVsK5rv5+axtVZh+XvLdpgCrUmWse</span><br><span class=\"line\"></span><br><span class=\"line\">q/KwF/yqhtKBOkBY61rlC6RtibUdV3aPS/uPBArWdqz6IEanOUNZUtsYiPQHMKQuAmjrXSh/fhV0HoXTrGFXk0JgjMXU4Fk4UsJdegEIBvBWYPMbVDMH0B6oQNOTCDWqvyagpLQxTCuXBoWXVyFu4OAUQjPt5b1VB2Ya9qxvDbMaYB9kMcfjgqWvZqlRvThXn3S0xFMtZEIaNlvo1K1N8qrIZSBHSC8igGIDMBhAz2BQMYGcDBBkgxQbdlBi2AGX</span><br><span class=\"line\"></span><br><span class=\"line\">JwjoFbgZuzDDUG0i4YJVlAuAd8GgGVCBJO6YeP1DTUc4QBQQmAV2jqx3y9r2l2vTXg1tmQNFR4DAcKFFFihcE4YA2obVyHj5XQupAHH+Iwwmi58m8s2jeRdEWBsS+c0fbcJNASobatt4c/ALtv0mtKE5BrC9Zkzuz4BPwFAPonqqQo+a/NAWoLXhokAebR58SUgYY0W0U98wJUuUBRv0qJYE1dhIQnGnS13QpgEKsztrIazoteAbGwacmvoT+kuN</span><br><span class=\"line\"></span><br><span class=\"line\">mahaYSpzXkAVpQmnOCJp4KFrZNEmw5pNL2nC7xNduF6lWtkI1rTpySVTYXPmL0YW12msUPBGlXk4dI9TCOToxq7+zYslm3UQwDGof0HEy8hznrCnXDMZ1YylhZPiPy5NwtsvNyPMH6mK8Ha8GxaqZB+IQATwGkVAB8A5DRAeN06SgPCTOAB7wQQekPcoDD0LFbY28AhT7CgB+wA4+AcjSHEsh3EzgYgbICiVfg3FC4acEuAHGIDEB6gxwZ4lXHZA</span><br><span class=\"line\"></span><br><span class=\"line\">1xImLMNDbE0w0JNsNKTQMJ6CbgcBvii8CQNHvwCx6EQoe1EuvE3isBMSqAbEl0gQBHxlGZ8S0IjsgTnAV1a65gDzA3Vbqd1e6g9UepPXo7+4l60eYvU+2HitCElcHjEWIyBIaNHQCuivQsHUCjKjOjqF9Bp3M6r5rOu4Zxu42c6keqebnUtN51fyjoAurXKJr/lFrRdTmcXScxAWQHpdRpKqPLuU3Sh61J5Rtarqvzq7cA80zzPppKHdr2MiGvtW</span><br><span class=\"line\"></span><br><span class=\"line\">dBtKU04aj8UkC2Gs3zapEM0CwQ5tt1ObZ13k5XaujC0boItV0esNFq1Ve64tZtZ5ElpK2IzYcwolWRyrrAIpr9lrDPj/ECRlLVkIczVjUoRmSH79b+pDC/rjYKGNJdSg7Q0v231bUApKJrawsgSGrjVpq81ZautW2r7Vjq3AM6v62iQbtzqcqWyuPF84F+g4ExW9rm0091BMhkCIDp0nbaeqHGeVuZM6UtrrJFkyBEBoI0w64dCO4gzxiQrdAIpI</span><br><span class=\"line\"></span><br><span class=\"line\">wdYJgGYAuqQ4v5THfczP73QH9ZGoTMZzbTyHH9sLbBgDQuh9Z1QAXK6JNH3lz7qDl8u5sc3Z0/6w9fGt4WcEE0gHXlMm8TRQjF3SaCGIuhA5cyQOcUUDZ0+ImpqclvkJVzXKXZnNMk6NZBsWGCpZveaUKJMNYHFpQIhg275uTVBVawavzO7ODYrcYeQtg38HgpPu3AgiRPA4gxACIR9FpAj1+6PjokDkD8cbVDFk9NCOGonvT3LF6R2e04qXouJX</span><br><span class=\"line\"></span><br><span class=\"line\">Ei9BcfALnox1lxq9NsWvUwFWNVRPizcfAJHr72fGgTUyARGiTH1gnJ9qInEnfFn2M6ksC+tI6MwkBwA9gi4ZQDFEwDtA4Ai4S4BQHwAcxcAEUGKOcCgRPBxYyyAo0PMcD+xOA4mkRNV19x4seo5R0PGVKoK7G150BqYBX0jUvM7od0bYQfO3DlS3F7+rowAp6Ncas1IZHnftDzWgH5i4ByXYCMk0MVjmSpA6eCJl3fdq18xhQlyuVUrG1d9ksPXK</span><br><span class=\"line\"></span><br><span class=\"line\">uzlEHqU+Co4laEzDHiDjv0tAORJoMOIyZhg/ZRDMOVgsBWEy1zbesgT3rH1z619e+p4Cfrv1v6/9Wk0A2XqQNSGNzYUfbhnqkd3QVZmCigABg6zC6/M9UMgjQRYICEJCChDQgYQsIOEADb+USMKxIj3Z2DF5ouBlERg2qAkFAA+BjgZU4sD4NyZ4AmYRgLcBUJ5prPAbFYoWkVi7raTKJpoTx6VjqsWVMnkNhAVs9gHbMGI76u0Js/c2zEahAa7n</span><br><span class=\"line\"></span><br><span class=\"line\">LcONsJ2h4KN38eNVqewZ/UosQApUNH3YhGm59ZO9jY/NDIc6+jyPAAx/KAMOmRjUxsYxqWgOTHxC8Bi5q90BW1rUDSuyZRgebVYHQzWuvAzrodzNL9dV/NibqC4SUH6RRNAGebs4FBEbQGZhhfFsuM5mlVek243rQPHIsPdMW545DJOIIktiazDhL8fnh+6FLXxrZiCeyDDEyhXCSE0sUz2ulYTKceE7CGpiF6SCxelEyZfQDl7K9Yemva8UgSsn</span><br><span class=\"line\"></span><br><span class=\"line\">2TnJ7k7yf5OCnhTop8U5KdxNd6e98loQIpefBknR9GJHeNSen10nK0DJndtevSMFmH1XsJ9S+skBvqP1X6n9X+v31ihD91DaMaDDJ3kanEXQMmcEdKDryaEFfKSXSQkSUDOJDOytJaHEFmcl5xfZ+acOULdGkLvRm0+niGM/zBd51OAyLvGN4XvlEB6Y0RdepzGyGCxxXedLYPrbMDWm+yXsD030WCDhmi+qDrCDAxWj+YuRusrVApnqao23zuDI</span><br><span class=\"line\"></span><br><span class=\"line\">EuCHsz4ykS+gaLlnm7jF5yYYC0903nvdCWiABwuDpCiHeafaq3Glqvxtj2//CNL9GSCtXvF7sZgYHLA0Faql72XSShm+QRpoyolTQr1Fq0a9jDph47RYaNUmqzVFqq1TartUOqnV+Rq7a4anBySPYbi9iC/34Felpt72joAkD5xeQz9V2wgJtrCPA7Qdxk7fLjZhlOW2THJrkzyb5MCmhTIpsUxKZcODaabBoyeeFiYirCpg2gvwf4b8TZhq2VK9</span><br><span class=\"line\"></span><br><span class=\"line\">UMNECEA6ebQO6ZLtZN6Q7DD4OqHUkZtqw75YqRqM0hrrkQAIIUEGCHBEQjIRUI6ETCNhDYA5WpzhG40N6zoYM2ZGZmpYBJQjTJ1MB+NczhPXeaVWmNa7ApYaLdn8DaVVVkwuFhtJ9AA81oOGghe6vTTkLfVgTRhf51YWCLo13C6WomsunJCiBxTcgYDMqbFrFFrXCtb0nYGaKz3fA25O2seSZzc0fXRqCLSP9LNyKrixN2h44s02jBi40wuEvzq6</span><br><span class=\"line\"></span><br><span class=\"line\">Y1Zxs3gR7MSB4gEIeYE8CEBuQr1p51VU9Y2UvXrzkJW84JZxLfXneXyZGULNENVbU7modO5jN47d012DHGTC0YLvqhFDz2Spfr0RvbaUMQ0ESjGWkM1HhJa7WtCqaxsGSDDwt5rWcGcvi23LUtzy7LZ8sK23DtNhJPMCbLHHGBbsO8draZJzsf40dH+J4dVDG3ebqhnbSPYt5GGTJyD8wx3GuB3BHgrwT4D8D+BYhAQwIKm4reG3/xZKHnVo6aFe</span><br><span class=\"line\"></span><br><span class=\"line\">0zaAjiQErloT/bDUN+9D028dnNtxz4jEO+OTbdOp22UjCFRfWcB3t72D73QHK0UZhURoU2a9SaGJXjIeJo7UWvhfmy8jwS62/U5O7RzbCHWFg+YrYVnaZ2dXZdEmq09xvLt2m+dwxgtSNZws3VxrHpsTRWvk1vcgVzNci0Gcouaae79kwgBtZhLSs9rDEUcQGhiKOVSFJuw4wnE7F1oIUgzA5XbpusO7GiTujg+JfiQQS4ab1y+x9aaoeaJALcak</span><br><span class=\"line\"></span><br><span class=\"line\">7bj+O970AgzveEpFBMT6FgqeqEwZZhNJwc91l5UmZd2JUkTkyJ1EzZZIB2Xy4mJxy72fdsDmvbw5322OYDsNx/LBJv3eM7D2rwwr4+iK3vCisHzYrRjiQO0CEAjACQkgG4L0A4BIIXkEUKCOLGIAUANU+gN4DldWVP0rS3Uy0WaYkplSObiL2qRVgEqRoxZ0DlMgfOmB5ssX5prq5aZ6vWmud2a1Nb1ZiflqtpUmhu7E+Sc+mFNfpua23bIsd3Mn</span><br><span class=\"line\"></span><br><span class=\"line\">Xdqi6tcqb9woE+TrtUPZGXMOBAOjSqX48kWkL0ZKZxPjGIFlcI5uslpp3OqDqzmQISFc4IueXOrn1zm57c7uf3Onr17Q8oOyFo0liX2iHfZkhfd3xX2ENTt4ksho1crqtXa5jc1ubgA7mVuBrwO3lZhUqJ4+nkTvtJ37A7Tw0MQ2WU/ybaMdUWaLrUsKGzCsQZ6+jDiPaMatNZ8uRBJmgW3ebF3iXpdyl3/ohbkvv9pLoa56dAVQH67iTyaxscrW</span><br><span class=\"line\"></span><br><span class=\"line\">+m5d/pmBe3aWNLWNNzknJzy7FD8RtdBTvXRrELaYCzjomRM6gF/Ypn3F8EhULNwafMH7dyr1mg2aHmWO1XkCdQKQBeBQJegjZI+2a7acWvqCVruZbFpeOfXb77/e++IbSUlBjj2YfDvR0Lbzj6+rEmQUgNujuxUlj9zTvG9ixJv7K0bdHBm5qrQ2pMysvHBpPhvAO1HIh9GefwTUADFg2YDG8ILyp1a2HcMMw9kBO1oPXLktjyzLe8vy2Ad1NuUK</span><br><span class=\"line\"></span><br><span class=\"line\">JPMpL1/o5nQ6yzYCNkPQjjDiI8Qb20xyTD6HvG2cE+ffPfn/zwF2wGBcfBQX4L+CJC9wfsV4+49qFL9Bp0ui+61HthmIrdaU9i60WcLKo75tm3hXYOy20fjiMxH8Nejo7QY91X3mXba7jd1u8NcDcl3H5mFQRIhtqJ335EhjlMISy0C/o5PUCxVgDR1gOO9s7wqxZN2Mb4LLOjjT6DLtkvbTFL0t2AaF30uaX7pgBeW8It1umXDbll027ZctvO7K</span><br><span class=\"line\"></span><br><span class=\"line\">urlx28lX4B+XDFwp/rp45ZlZgFCkdxQbN0TdMlKiQh4vcVe8aV7LT6Vua/yZag/V1rkSAIdeP9P65YCYZypdGcQA/YQySZ1pcpMzPNLae/S1nsWdwni4ee1Z9cU2fLPbLVep4vs7r0nanXS5lc6691cev9XB5y518WudDeRvsL80uSfCvcAp9h2Gfa88JLX1wADSMUHADgBQhmkg90yGWEyD9VfEAwBgIQAQAUBzgqF4tz6GJVQ/1rgPwbcRFYXb</span><br><span class=\"line\"></span><br><span class=\"line\">B9AUIL/aF4LelA4fIBscIj7B//6IfsYML4UGVIiBMfiPiKM6di+E+MfCPjIMj8+W0v0fxP6n0j4e41uMQRP+H5h8R8GZkv9UdnyT4yCAvG3wKvn0z4ig2w5ns3hnxz6gBY+MgYv8b9M959U/OfGQeEls+PyXFHTIvlX8z80e6eX82vmX4j7eAdK78uV6HZT8Z86/gcNqoeUE0eKYg4Q4IGVGwxsqO+cQ4IbVBvKkYVbSgRgNgAYG+9NACAEzjoES</span><br><span class=\"line\"></span><br><span class=\"line\">UN+y/9A3PgeyLwjBs+wwJAbSynsJ8J/iAUIBAAEdDRN5G4xAD4GwBgIm+cDwQLM9n5IA5YeM5wd0JAlIDKBgwAACh6zUBeATEJv43/cO9AAAlIGE3jKAhIREMkbX9wAN+5grfkf7wDH/h4u/4f5X7bHoSAv84nAT8oemWt4pN4ckRuELZtrd7NAxf275FaeLkk9/zz0UN3r+9Yl9/imteIcSpN7xw/dgKBAgGqBilu9cAPPwX+3+7/Z3ia6oIQEY</span><br><span class=\"line\"></span><br><span class=\"line\">AtwA/+XodrLKG0ukA/+BBNXoy468PoC2+FQDJZZmu6Gsjjk+cH/4AB6nr1w3062mCDhAnXJRDkQQAA==</span><br></pre></td></tr></table></figure>\n<p>%%</p>\n"},{"_content":"## GC是什么？\nGC（Garbage Collection）即垃圾回收，实质上就是回收垃圾内存。由于栈上的内存是有编译器分配和释放的，所以GC都是对堆上不再使用的内存进行回收，让这些内存能够再次被利用\n\n## 为什么需要GC？\n在真实业务场景中，对象个数非常多，引用关系错综复杂，如果全靠程序员手动释放内存很难避免指针悬挂错误。所以一门拥有自动识别并回收垃圾内存的语言（如Java、Python、Go）在开发效率上是远远高于没有GC机制的语言的\n\n## 常见的GC算法\n\n### 引用计数法\n\n引用计数法会为每一个对象分配一个空间（“计数器”），这个空间专门用来存储对象被引用的次数。如果有其他其他对象引用A对象，那么A对象的计数器就会+1；反之，引用A的对象删除对A的引用后，A的计数器便会-1，当计数器减至0时，该对象的内存空间就会被回收\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008887.png)\n\n\n- 优点：简单直接，回收速度快，不会出现内存耗尽或达到阈值才进行回收的现象\n- 缺点：\n\t- 需要额外空间维护对象的“引用”\n\t- 无法解决循环引用问题\n\n### 标记清除法\n\n标记清除法可以分为两步：\n- 标记对象：从根对象开始，遍历所有的对象及其子对象，并标记它们的可达状态\n- 清除对象：再一次遍历堆中中所有的对象，将没有被标记的对象删除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008711.png)\n\n\n- 优点：简单易实现，不需要额外的存储空间，适用于对象个数少的场景\n- 缺点：会造成内存碎片，导致后续创建大对象时，即使有足够的内存空间也可能无法成功创建，降低了内存的使用率\n\n### 复制法\n\n复制法将内存分为大小相等的两块区域，每一时刻只能使用其中的一块内存。当一块区域的内存被用完时，就需要把该区域还在使用的对象移动到另一块区域，同时将已使用的内存全部清除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008571.png)\n\n- 优点：不会产生内存碎片，每次都是清除整块内存\n- 缺点：内存被一分为二，利用率低，如果对象个数较多，复制对象的过程耗时长，效率低下\n\n### 标记整理法\n\n标记整理法和标记清除法类似，同样是需要两阶段完成GC操作\n- 标记阶段：从GC的根节点遍历所有的对象，把还在使用的对象标记\n- 整理阶段：所有存活的对象被移动到空闲内存的一端，按照地址顺序排列，并更新对象引用指针。最后将末端地址之外的内存空间清除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412260904789.png)\n\n\n## Go语言的GC算法\n\nGo语言的GC采用的是并发三色标记法 + 屏障技术实现的。三色标记法本质就是标记清理算法，并没有对象分代、内存整理的行为，三色标记只是对其标记阶段的一种简单描述。\n\n### 为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？\nGo语言的内存分配算法是基于TCMalloc，虽然不能像标记整理法/复制法消除内存碎片，但也能有效的降低内存碎片率。此外，Thread Cache机制使得Go在大部分分配场景下可以避免使用锁，在高并发环境下具有极佳的性能优势\n\n### 为什么不采用分代法？\n分代法的最大优势就是区分长生命周期和短生命周期的对象，从而快速回收段生命周期对象。但Go语言在编译期会做逃逸分析，可以将短生命周期的struct分配到栈上，考虑到一方面栈上的内存回收是非常快的，另一方面在Go中短生命周期对象个数并不多，所以分代法在Go中优势并不明显。相反地，分代法需要额外的屏障来维护老年代对象对新年代对象的引用关系，增加了GC负担\n\n## Go的GC\n\n### 标记清除法的瓶颈\n\n标记清除法在GC之前需要STW，即暂停这个应用程序，否则会导致错误地删除被引用的对象。但STW会给引用性能带来极大的损耗\n\n\n\n\n是什么，有什么优势，实际情况，特殊性，不适用","source":"_posts/Go/GC.md","raw":"## GC是什么？\nGC（Garbage Collection）即垃圾回收，实质上就是回收垃圾内存。由于栈上的内存是有编译器分配和释放的，所以GC都是对堆上不再使用的内存进行回收，让这些内存能够再次被利用\n\n## 为什么需要GC？\n在真实业务场景中，对象个数非常多，引用关系错综复杂，如果全靠程序员手动释放内存很难避免指针悬挂错误。所以一门拥有自动识别并回收垃圾内存的语言（如Java、Python、Go）在开发效率上是远远高于没有GC机制的语言的\n\n## 常见的GC算法\n\n### 引用计数法\n\n引用计数法会为每一个对象分配一个空间（“计数器”），这个空间专门用来存储对象被引用的次数。如果有其他其他对象引用A对象，那么A对象的计数器就会+1；反之，引用A的对象删除对A的引用后，A的计数器便会-1，当计数器减至0时，该对象的内存空间就会被回收\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008887.png)\n\n\n- 优点：简单直接，回收速度快，不会出现内存耗尽或达到阈值才进行回收的现象\n- 缺点：\n\t- 需要额外空间维护对象的“引用”\n\t- 无法解决循环引用问题\n\n### 标记清除法\n\n标记清除法可以分为两步：\n- 标记对象：从根对象开始，遍历所有的对象及其子对象，并标记它们的可达状态\n- 清除对象：再一次遍历堆中中所有的对象，将没有被标记的对象删除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008711.png)\n\n\n- 优点：简单易实现，不需要额外的存储空间，适用于对象个数少的场景\n- 缺点：会造成内存碎片，导致后续创建大对象时，即使有足够的内存空间也可能无法成功创建，降低了内存的使用率\n\n### 复制法\n\n复制法将内存分为大小相等的两块区域，每一时刻只能使用其中的一块内存。当一块区域的内存被用完时，就需要把该区域还在使用的对象移动到另一块区域，同时将已使用的内存全部清除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008571.png)\n\n- 优点：不会产生内存碎片，每次都是清除整块内存\n- 缺点：内存被一分为二，利用率低，如果对象个数较多，复制对象的过程耗时长，效率低下\n\n### 标记整理法\n\n标记整理法和标记清除法类似，同样是需要两阶段完成GC操作\n- 标记阶段：从GC的根节点遍历所有的对象，把还在使用的对象标记\n- 整理阶段：所有存活的对象被移动到空闲内存的一端，按照地址顺序排列，并更新对象引用指针。最后将末端地址之外的内存空间清除\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412260904789.png)\n\n\n## Go语言的GC算法\n\nGo语言的GC采用的是并发三色标记法 + 屏障技术实现的。三色标记法本质就是标记清理算法，并没有对象分代、内存整理的行为，三色标记只是对其标记阶段的一种简单描述。\n\n### 为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？\nGo语言的内存分配算法是基于TCMalloc，虽然不能像标记整理法/复制法消除内存碎片，但也能有效的降低内存碎片率。此外，Thread Cache机制使得Go在大部分分配场景下可以避免使用锁，在高并发环境下具有极佳的性能优势\n\n### 为什么不采用分代法？\n分代法的最大优势就是区分长生命周期和短生命周期的对象，从而快速回收段生命周期对象。但Go语言在编译期会做逃逸分析，可以将短生命周期的struct分配到栈上，考虑到一方面栈上的内存回收是非常快的，另一方面在Go中短生命周期对象个数并不多，所以分代法在Go中优势并不明显。相反地，分代法需要额外的屏障来维护老年代对象对新年代对象的引用关系，增加了GC负担\n\n## Go的GC\n\n### 标记清除法的瓶颈\n\n标记清除法在GC之前需要STW，即暂停这个应用程序，否则会导致错误地删除被引用的对象。但STW会给引用性能带来极大的损耗\n\n\n\n\n是什么，有什么优势，实际情况，特殊性，不适用","slug":"Go/GC","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6l001pa5t2g8i62d7u","content":"<h2 id=\"GC是什么？\"><a href=\"#GC是什么？\" class=\"headerlink\" title=\"GC是什么？\"></a>GC是什么？</h2><p>GC（Garbage Collection）即垃圾回收，实质上就是回收垃圾内存。由于栈上的内存是有编译器分配和释放的，所以GC都是对堆上不再使用的内存进行回收，让这些内存能够再次被利用</p>\n<h2 id=\"为什么需要GC？\"><a href=\"#为什么需要GC？\" class=\"headerlink\" title=\"为什么需要GC？\"></a>为什么需要GC？</h2><p>在真实业务场景中，对象个数非常多，引用关系错综复杂，如果全靠程序员手动释放内存很难避免指针悬挂错误。所以一门拥有自动识别并回收垃圾内存的语言（如Java、Python、Go）在开发效率上是远远高于没有GC机制的语言的</p>\n<h2 id=\"常见的GC算法\"><a href=\"#常见的GC算法\" class=\"headerlink\" title=\"常见的GC算法\"></a>常见的GC算法</h2><h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>引用计数法会为每一个对象分配一个空间（“计数器”），这个空间专门用来存储对象被引用的次数。如果有其他其他对象引用A对象，那么A对象的计数器就会+1；反之，引用A的对象删除对A的引用后，A的计数器便会-1，当计数器减至0时，该对象的内存空间就会被回收<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008887.png\" alt=\"image.png\"></p>\n<ul>\n<li>优点：简单直接，回收速度快，不会出现内存耗尽或达到阈值才进行回收的现象</li>\n<li>缺点：<ul>\n<li>需要额外空间维护对象的“引用”</li>\n<li>无法解决循环引用问题</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h3><p>标记清除法可以分为两步：</p>\n<ul>\n<li><p>标记对象：从根对象开始，遍历所有的对象及其子对象，并标记它们的可达状态</p>\n</li>\n<li><p>清除对象：再一次遍历堆中中所有的对象，将没有被标记的对象删除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008711.png\" alt=\"image.png\"></p>\n</li>\n<li><p>优点：简单易实现，不需要额外的存储空间，适用于对象个数少的场景</p>\n</li>\n<li><p>缺点：会造成内存碎片，导致后续创建大对象时，即使有足够的内存空间也可能无法成功创建，降低了内存的使用率</p>\n</li>\n</ul>\n<h3 id=\"复制法\"><a href=\"#复制法\" class=\"headerlink\" title=\"复制法\"></a>复制法</h3><p>复制法将内存分为大小相等的两块区域，每一时刻只能使用其中的一块内存。当一块区域的内存被用完时，就需要把该区域还在使用的对象移动到另一块区域，同时将已使用的内存全部清除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008571.png\" alt=\"image.png\"></p>\n<ul>\n<li>优点：不会产生内存碎片，每次都是清除整块内存</li>\n<li>缺点：内存被一分为二，利用率低，如果对象个数较多，复制对象的过程耗时长，效率低下</li>\n</ul>\n<h3 id=\"标记整理法\"><a href=\"#标记整理法\" class=\"headerlink\" title=\"标记整理法\"></a>标记整理法</h3><p>标记整理法和标记清除法类似，同样是需要两阶段完成GC操作</p>\n<ul>\n<li>标记阶段：从GC的根节点遍历所有的对象，把还在使用的对象标记</li>\n<li>整理阶段：所有存活的对象被移动到空闲内存的一端，按照地址顺序排列，并更新对象引用指针。最后将末端地址之外的内存空间清除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412260904789.png\" alt=\"image.png\"></li>\n</ul>\n<h2 id=\"Go语言的GC算法\"><a href=\"#Go语言的GC算法\" class=\"headerlink\" title=\"Go语言的GC算法\"></a>Go语言的GC算法</h2><p>Go语言的GC采用的是并发三色标记法 + 屏障技术实现的。三色标记法本质就是标记清理算法，并没有对象分代、内存整理的行为，三色标记只是对其标记阶段的一种简单描述。</p>\n<h3 id=\"为什么不需要内存整理（为什么不采用标记整理算法或复制算法-）？\"><a href=\"#为什么不需要内存整理（为什么不采用标记整理算法或复制算法-）？\" class=\"headerlink\" title=\"为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？\"></a>为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？</h3><p>Go语言的内存分配算法是基于TCMalloc，虽然不能像标记整理法&#x2F;复制法消除内存碎片，但也能有效的降低内存碎片率。此外，Thread Cache机制使得Go在大部分分配场景下可以避免使用锁，在高并发环境下具有极佳的性能优势</p>\n<h3 id=\"为什么不采用分代法？\"><a href=\"#为什么不采用分代法？\" class=\"headerlink\" title=\"为什么不采用分代法？\"></a>为什么不采用分代法？</h3><p>分代法的最大优势就是区分长生命周期和短生命周期的对象，从而快速回收段生命周期对象。但Go语言在编译期会做逃逸分析，可以将短生命周期的struct分配到栈上，考虑到一方面栈上的内存回收是非常快的，另一方面在Go中短生命周期对象个数并不多，所以分代法在Go中优势并不明显。相反地，分代法需要额外的屏障来维护老年代对象对新年代对象的引用关系，增加了GC负担</p>\n<h2 id=\"Go的GC\"><a href=\"#Go的GC\" class=\"headerlink\" title=\"Go的GC\"></a>Go的GC</h2><h3 id=\"标记清除法的瓶颈\"><a href=\"#标记清除法的瓶颈\" class=\"headerlink\" title=\"标记清除法的瓶颈\"></a>标记清除法的瓶颈</h3><p>标记清除法在GC之前需要STW，即暂停这个应用程序，否则会导致错误地删除被引用的对象。但STW会给引用性能带来极大的损耗</p>\n<p>是什么，有什么优势，实际情况，特殊性，不适用</p>\n","excerpt":"","more":"<h2 id=\"GC是什么？\"><a href=\"#GC是什么？\" class=\"headerlink\" title=\"GC是什么？\"></a>GC是什么？</h2><p>GC（Garbage Collection）即垃圾回收，实质上就是回收垃圾内存。由于栈上的内存是有编译器分配和释放的，所以GC都是对堆上不再使用的内存进行回收，让这些内存能够再次被利用</p>\n<h2 id=\"为什么需要GC？\"><a href=\"#为什么需要GC？\" class=\"headerlink\" title=\"为什么需要GC？\"></a>为什么需要GC？</h2><p>在真实业务场景中，对象个数非常多，引用关系错综复杂，如果全靠程序员手动释放内存很难避免指针悬挂错误。所以一门拥有自动识别并回收垃圾内存的语言（如Java、Python、Go）在开发效率上是远远高于没有GC机制的语言的</p>\n<h2 id=\"常见的GC算法\"><a href=\"#常见的GC算法\" class=\"headerlink\" title=\"常见的GC算法\"></a>常见的GC算法</h2><h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>引用计数法会为每一个对象分配一个空间（“计数器”），这个空间专门用来存储对象被引用的次数。如果有其他其他对象引用A对象，那么A对象的计数器就会+1；反之，引用A的对象删除对A的引用后，A的计数器便会-1，当计数器减至0时，该对象的内存空间就会被回收<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008887.png\" alt=\"image.png\"></p>\n<ul>\n<li>优点：简单直接，回收速度快，不会出现内存耗尽或达到阈值才进行回收的现象</li>\n<li>缺点：<ul>\n<li>需要额外空间维护对象的“引用”</li>\n<li>无法解决循环引用问题</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h3><p>标记清除法可以分为两步：</p>\n<ul>\n<li><p>标记对象：从根对象开始，遍历所有的对象及其子对象，并标记它们的可达状态</p>\n</li>\n<li><p>清除对象：再一次遍历堆中中所有的对象，将没有被标记的对象删除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008711.png\" alt=\"image.png\"></p>\n</li>\n<li><p>优点：简单易实现，不需要额外的存储空间，适用于对象个数少的场景</p>\n</li>\n<li><p>缺点：会造成内存碎片，导致后续创建大对象时，即使有足够的内存空间也可能无法成功创建，降低了内存的使用率</p>\n</li>\n</ul>\n<h3 id=\"复制法\"><a href=\"#复制法\" class=\"headerlink\" title=\"复制法\"></a>复制法</h3><p>复制法将内存分为大小相等的两块区域，每一时刻只能使用其中的一块内存。当一块区域的内存被用完时，就需要把该区域还在使用的对象移动到另一块区域，同时将已使用的内存全部清除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412252008571.png\" alt=\"image.png\"></p>\n<ul>\n<li>优点：不会产生内存碎片，每次都是清除整块内存</li>\n<li>缺点：内存被一分为二，利用率低，如果对象个数较多，复制对象的过程耗时长，效率低下</li>\n</ul>\n<h3 id=\"标记整理法\"><a href=\"#标记整理法\" class=\"headerlink\" title=\"标记整理法\"></a>标记整理法</h3><p>标记整理法和标记清除法类似，同样是需要两阶段完成GC操作</p>\n<ul>\n<li>标记阶段：从GC的根节点遍历所有的对象，把还在使用的对象标记</li>\n<li>整理阶段：所有存活的对象被移动到空闲内存的一端，按照地址顺序排列，并更新对象引用指针。最后将末端地址之外的内存空间清除<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412260904789.png\" alt=\"image.png\"></li>\n</ul>\n<h2 id=\"Go语言的GC算法\"><a href=\"#Go语言的GC算法\" class=\"headerlink\" title=\"Go语言的GC算法\"></a>Go语言的GC算法</h2><p>Go语言的GC采用的是并发三色标记法 + 屏障技术实现的。三色标记法本质就是标记清理算法，并没有对象分代、内存整理的行为，三色标记只是对其标记阶段的一种简单描述。</p>\n<h3 id=\"为什么不需要内存整理（为什么不采用标记整理算法或复制算法-）？\"><a href=\"#为什么不需要内存整理（为什么不采用标记整理算法或复制算法-）？\" class=\"headerlink\" title=\"为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？\"></a>为什么不需要内存整理（为什么不采用标记整理算法或复制算法 ）？</h3><p>Go语言的内存分配算法是基于TCMalloc，虽然不能像标记整理法&#x2F;复制法消除内存碎片，但也能有效的降低内存碎片率。此外，Thread Cache机制使得Go在大部分分配场景下可以避免使用锁，在高并发环境下具有极佳的性能优势</p>\n<h3 id=\"为什么不采用分代法？\"><a href=\"#为什么不采用分代法？\" class=\"headerlink\" title=\"为什么不采用分代法？\"></a>为什么不采用分代法？</h3><p>分代法的最大优势就是区分长生命周期和短生命周期的对象，从而快速回收段生命周期对象。但Go语言在编译期会做逃逸分析，可以将短生命周期的struct分配到栈上，考虑到一方面栈上的内存回收是非常快的，另一方面在Go中短生命周期对象个数并不多，所以分代法在Go中优势并不明显。相反地，分代法需要额外的屏障来维护老年代对象对新年代对象的引用关系，增加了GC负担</p>\n<h2 id=\"Go的GC\"><a href=\"#Go的GC\" class=\"headerlink\" title=\"Go的GC\"></a>Go的GC</h2><h3 id=\"标记清除法的瓶颈\"><a href=\"#标记清除法的瓶颈\" class=\"headerlink\" title=\"标记清除法的瓶颈\"></a>标记清除法的瓶颈</h3><p>标记清除法在GC之前需要STW，即暂停这个应用程序，否则会导致错误地删除被引用的对象。但STW会给引用性能带来极大的损耗</p>\n<p>是什么，有什么优势，实际情况，特殊性，不适用</p>\n"},{"description":"记录go:embed的一些使用方法","_content":"\n\n\n# embed使用\n\n## 背景\n\n对于一个Go项目，我们一般将代码编译成出来的二进制可执行文件，这个文件非常适合复制和部署。但在实际使用中，除了代码，一些**配置文件或者静态文件**也需要一同打包至二进制文件中。\n\n## 嵌入\n\n嵌入的内容时只读的，也就是说，嵌入内容在编译期就定死并且是并发安全的\n\n🌰：当前有一个txt文件，具体内容为`Hello World!`\n\n### 嵌入为字符串\n\n```go\n//go:embed hello.txt\nvar s string\n\nfunc TestEmbed(t *testing.T) {\n\tfmt.Println(s)\n}\n```\n\n### 嵌入为字节切片\n\n```go\n//go:embed hello.txt\nvar s []byte\n\nfunc TestEmbed(t *testing.T) {\n\tfmt.Println(s)\n}\n```\n\n### 嵌入为文件系统\n\n当需要一次性嵌入多个文件时，选择文件系统作为嵌入的类型有助于我们高效管理嵌入的多个文件\n\n```go\n//go:embed *.txt\n// 匹配多个文件\nvar fs embed.FS\n\nfunc TestEmbed(t *testing.T) {\n\tfb1, _ := fs.ReadFile(\"hello.txt\")\n\tfb2, _ := fs.ReadFile(\"hello2.txt\")\n\tfmt.Println(fb1)\n\tfmt.Println(fb2)\n}\n```\n\n### 几种go:embed写法\n\n```go\n//go:embed hello.txt hello2.txt\nvar fs embed.FS\n\n\n//go:embed hello.txt\n//go:embed hello2.txt\nvar fs embed.FS\n\n//go:embed p\nvar fs embed.FS // p是一个子目录\n\n//go:embed *.txt\nvar fs embed.FS // 匹配模式\n```\n\n\n\n","source":"_posts/Go/Go embed使用.md","raw":"---\ndescription: 记录go:embed的一些使用方法\ntag: Go\n---\n\n\n\n# embed使用\n\n## 背景\n\n对于一个Go项目，我们一般将代码编译成出来的二进制可执行文件，这个文件非常适合复制和部署。但在实际使用中，除了代码，一些**配置文件或者静态文件**也需要一同打包至二进制文件中。\n\n## 嵌入\n\n嵌入的内容时只读的，也就是说，嵌入内容在编译期就定死并且是并发安全的\n\n🌰：当前有一个txt文件，具体内容为`Hello World!`\n\n### 嵌入为字符串\n\n```go\n//go:embed hello.txt\nvar s string\n\nfunc TestEmbed(t *testing.T) {\n\tfmt.Println(s)\n}\n```\n\n### 嵌入为字节切片\n\n```go\n//go:embed hello.txt\nvar s []byte\n\nfunc TestEmbed(t *testing.T) {\n\tfmt.Println(s)\n}\n```\n\n### 嵌入为文件系统\n\n当需要一次性嵌入多个文件时，选择文件系统作为嵌入的类型有助于我们高效管理嵌入的多个文件\n\n```go\n//go:embed *.txt\n// 匹配多个文件\nvar fs embed.FS\n\nfunc TestEmbed(t *testing.T) {\n\tfb1, _ := fs.ReadFile(\"hello.txt\")\n\tfb2, _ := fs.ReadFile(\"hello2.txt\")\n\tfmt.Println(fb1)\n\tfmt.Println(fb2)\n}\n```\n\n### 几种go:embed写法\n\n```go\n//go:embed hello.txt hello2.txt\nvar fs embed.FS\n\n\n//go:embed hello.txt\n//go:embed hello2.txt\nvar fs embed.FS\n\n//go:embed p\nvar fs embed.FS // p是一个子目录\n\n//go:embed *.txt\nvar fs embed.FS // 匹配模式\n```\n\n\n\n","slug":"Go/Go embed使用","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m001ra5t24ban8agk","content":"<h1 id=\"embed使用\"><a href=\"#embed使用\" class=\"headerlink\" title=\"embed使用\"></a>embed使用</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>对于一个Go项目，我们一般将代码编译成出来的二进制可执行文件，这个文件非常适合复制和部署。但在实际使用中，除了代码，一些<strong>配置文件或者静态文件</strong>也需要一同打包至二进制文件中。</p>\n<h2 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h2><p>嵌入的内容时只读的，也就是说，嵌入内容在编译期就定死并且是并发安全的</p>\n<p>🌰：当前有一个txt文件，具体内容为<code>Hello World!</code></p>\n<h3 id=\"嵌入为字符串\"><a href=\"#嵌入为字符串\" class=\"headerlink\" title=\"嵌入为字符串\"></a>嵌入为字符串</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入为字节切片\"><a href=\"#嵌入为字节切片\" class=\"headerlink\" title=\"嵌入为字节切片\"></a>嵌入为字节切片</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入为文件系统\"><a href=\"#嵌入为文件系统\" class=\"headerlink\" title=\"嵌入为文件系统\"></a>嵌入为文件系统</h3><p>当需要一次性嵌入多个文件时，选择文件系统作为嵌入的类型有助于我们高效管理嵌入的多个文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed *.txt</span></span><br><span class=\"line\"><span class=\"comment\">// 匹配多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfb1, _ := fs.ReadFile(<span class=\"string\">&quot;hello.txt&quot;</span>)</span><br><span class=\"line\">\tfb2, _ := fs.ReadFile(<span class=\"string\">&quot;hello2.txt&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(fb1)</span><br><span class=\"line\">\tfmt.Println(fb2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几种go-embed写法\"><a href=\"#几种go-embed写法\" class=\"headerlink\" title=\"几种go:embed写法\"></a>几种go:embed写法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt hello2.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"comment\">//go:embed hello2.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed p</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS <span class=\"comment\">// p是一个子目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed *.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS <span class=\"comment\">// 匹配模式</span></span><br></pre></td></tr></table></figure>\n\n\n\n","excerpt":"","more":"<h1 id=\"embed使用\"><a href=\"#embed使用\" class=\"headerlink\" title=\"embed使用\"></a>embed使用</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>对于一个Go项目，我们一般将代码编译成出来的二进制可执行文件，这个文件非常适合复制和部署。但在实际使用中，除了代码，一些<strong>配置文件或者静态文件</strong>也需要一同打包至二进制文件中。</p>\n<h2 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h2><p>嵌入的内容时只读的，也就是说，嵌入内容在编译期就定死并且是并发安全的</p>\n<p>🌰：当前有一个txt文件，具体内容为<code>Hello World!</code></p>\n<h3 id=\"嵌入为字符串\"><a href=\"#嵌入为字符串\" class=\"headerlink\" title=\"嵌入为字符串\"></a>嵌入为字符串</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入为字节切片\"><a href=\"#嵌入为字节切片\" class=\"headerlink\" title=\"嵌入为字节切片\"></a>嵌入为字节切片</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入为文件系统\"><a href=\"#嵌入为文件系统\" class=\"headerlink\" title=\"嵌入为文件系统\"></a>嵌入为文件系统</h3><p>当需要一次性嵌入多个文件时，选择文件系统作为嵌入的类型有助于我们高效管理嵌入的多个文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed *.txt</span></span><br><span class=\"line\"><span class=\"comment\">// 匹配多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestEmbed</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tfb1, _ := fs.ReadFile(<span class=\"string\">&quot;hello.txt&quot;</span>)</span><br><span class=\"line\">\tfb2, _ := fs.ReadFile(<span class=\"string\">&quot;hello2.txt&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(fb1)</span><br><span class=\"line\">\tfmt.Println(fb2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几种go-embed写法\"><a href=\"#几种go-embed写法\" class=\"headerlink\" title=\"几种go:embed写法\"></a>几种go:embed写法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed hello.txt hello2.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed hello.txt</span></span><br><span class=\"line\"><span class=\"comment\">//go:embed hello2.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed p</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS <span class=\"comment\">// p是一个子目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:embed *.txt</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs embed.FS <span class=\"comment\">// 匹配模式</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"[Golang深入理解GPM模型](https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.1387.homepage.video_card.click)学习笔记\n\n协程调度器的核心作用就是将协程关联到内核线程，内核线程无需切换就能执行用户态中的不同功能，提高了并发度\n\n## GMP模型\n\nGMP模型设计布局如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412212114507.png\" style=\"zoom:80%\">\n\n- **G**：Goroutine，Go协程\n- **P**：Processor，逻辑处理器\n- **M**：Machine，系统级线程\n- **全局队列**：存放待调度的Goroutine\n- **本地队列**：存放某一个Processor即将调度的Goroutine\n\t- 一个本地队列中最多容纳256个Goroutine\n\t- 当创建一个Goroutine时，会优先将Goroutine放在本地队列中。如果没有本地队列存在空闲空间，那么新创建的Goroutine就会被放入全局队列\n- **GOMAXPROCS**：配置逻辑处理器个数的参数，决定了Goroutine的**并行**能力\n\t- 可通过环境变量`$GOMAXPROCS`设置\n\t- 或者在程序中通过`runtime.GOMAXPROCS()`来设置\n\n## 调度器的设计策略\n\n- **复用线程**：避免频繁创建、销毁线程带来巨大的开销\n\t- work stealing：当本线程无可调度的Goroutine时，就会“偷取”其他线程待执行的Goroutine来执行\n\t- hand off：当本线程运行的Goroutine发生了阻塞，就会创建/唤醒一个新的线程，新线程接管这个阻塞G的P\n- **利用并行**：通过`GOMAXPROCS`参数调节可同时工作的Processor，即最多有`GOMAXPROCS`个协程并行工作\n- **抢占**：coroutine是协作式的，只能由coroutine主动让出CPU资源。而Go调度器为了调度公平，规定每个Goroutine最多占用10msCPU时间，超过这个时间就会被强制下线\n- **全局队列**：当线程无法从别的线程中“偷取”可调度的Goroutine时，就会从全局队列中获取一个Goroutine进行执行\n\n## Go指令的调度流程\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412221837093.png)\n\n\ngo func()命令的执行流程：\n1. 创建一个Goroutine\n2. 尝试将Goroutine放入本线程绑定的P的本地队列中，如果本地队列已满，那么就把Goroutine放入全局队列中\n3. M会从P的本地队列中取出一个Goroutine执行，若本地队列为空，那就从别的MP组合或全局队列中“偷”一个Goroutine执行\n4. M循环调度不同的G\n5. 当M在执行G时发生了阻塞，runtime会把这个M和P解除关联，然后创建/唤醒一个线程，接着让这个线程取服务解除关联的P\n6. 当M调度结束后，G会尝试获取一个空闲的P，并进入该P的本地队列中，M和P重新关联。如果获取不到，那么G会被放入全局队列，M则是加入空闲线程中，进入休眠状态\n\n## Go启动周期的M0和G0\n\n**M0**：进程启动时创建的第一个线程，称为M0。M0实例会在全局变量runtime.m0中，不需要在heap中分配中间。M0负责执行一些初始化操作，接着便和普通线程无异\n**G0**：每一个线程在被创建之后，会立即创建一个Goroutine，称为G0，即每一个线程都有一个属于自己的G0。G0不指向某个具体的函数，而是专门负责调度本地队列中的G。在调度或系统调度时，会使用G0的栈空间，全局变量G0就是M0所创建的G0\n\n## GMP可视化调试\n\n```go\n\t// 创建trace.out文件\n\tf, err := os.Create(\"trace.out\")\n\tif err != nil {}\n\t// 启动trace\n\terr = trace.Start(f)\n\tif err != nil {}\n\t// do something\n\t// 这里是业务代码\n\n\t// 停止trace\n\ttrace.Stop()\n```\n运行程序后，会生成一个名为trace.out的文件，可以使用`go tool trace $filename`命令对这个文件进行可视化分析\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412221942758.png)\n\n左栏自上而下依次是：G协程信息、堆栈信息、M线程信息、P调度器信息\n\n## GMP调度场景全过程分析\n\n### G1创建G’\n\nP拥有G1，G1在运行过程中调用`go fun()`创建了G‘。考虑到局部性，优先将G2放入到该P的本地队列中\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221958378.png\" style=\"zoom:70%\">\n\n### G1执行完毕\n\nG1运行完毕后，G0切换到M上运行，G0执行调度工作（schedule函数)：从P的本地队列中取出G2，M上运行的Goroutine从G0切换至G2，并开始运行G2（execute函数）。实现线程的复用\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222006838.png)\n\n### 本地队列已满，再创建G\n\n如果当前运行的G创建了一个G，恰巧P的本地队列无法再容纳新创建的G时，需要将本地队列中**前半部分的G打乱顺序**，连同新创建的G一起放入全局队列中\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222017907.png)\n\n### 唤醒正在休眠的M\n\n在一个G创建一个新的G时，会尝试唤醒等待队列中的M。假设唤醒了M2，M2会寻找一个空闲的P进行绑定，并运行G0，执行协程的调度。如果P的本地队列为空，那么M2亟需寻找一个G来执行，此时M2就是**自旋线程**\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222026925.png)\n\n### 被唤醒的M2从全局队列中批量取G\n\n自旋线程M2会尝试从全局队列中获取G执行，获取的G的数量由`min(len(GQ)/2 + 1, len(GQ)/2)`决定，其中`len(GQ)`表示全局队列中元素个数。M2批量获取G的过程叫做”**从全局队列到本地队列的负载均衡**“。(感觉就是为了避免拉取太多的G，一是导致本线程消化不了，二是饿死别的线程）\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222048979.png)\n\n### 偷取M的G\n\n如果全局队列已经没有G了，自旋线程M2就会尝试从别的线程（M1）中偷取一批G，放入本地队列中准备调度。具体地，M2会偷取，M1本地队列中**后半部分**的G作为本线程即将执行调度的G，下图中P1的本地队列后半部分只有G8，因此G8被M2偷取执行\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222131818.png)\n\n### 自旋线程的限制\n\n最多有**GOMAXPROCS**个自旋线程，即使有再多的线程，也会因为没有空闲的P进行调度进入休眠状态\n\n### G发生调用阻塞\n\n当G8发生了调用阻塞，P2会立即和M2解绑。接下来P2会判断是否有线程处于休眠状态，如果有，就唤醒一个线程并与之绑定，否则P2会加入空闲P列表中，等待M来获取\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412240928105.png)\n\nG发生系统调用/非阻塞\n\n当G8从阻塞状态中恢复后，M2想要运行G8必须要有P的支持。那么M2会尝试重新获取P2，如果发现P2已经被绑定，就再尝试从空闲P队列中获取一个P。如果获取P失败，G8就会被放入全局队列，M2进入休眠线程队列\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412240936232.png)\n","source":"_posts/Go/GMP原理.md","raw":"[Golang深入理解GPM模型](https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.1387.homepage.video_card.click)学习笔记\n\n协程调度器的核心作用就是将协程关联到内核线程，内核线程无需切换就能执行用户态中的不同功能，提高了并发度\n\n## GMP模型\n\nGMP模型设计布局如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412212114507.png\" style=\"zoom:80%\">\n\n- **G**：Goroutine，Go协程\n- **P**：Processor，逻辑处理器\n- **M**：Machine，系统级线程\n- **全局队列**：存放待调度的Goroutine\n- **本地队列**：存放某一个Processor即将调度的Goroutine\n\t- 一个本地队列中最多容纳256个Goroutine\n\t- 当创建一个Goroutine时，会优先将Goroutine放在本地队列中。如果没有本地队列存在空闲空间，那么新创建的Goroutine就会被放入全局队列\n- **GOMAXPROCS**：配置逻辑处理器个数的参数，决定了Goroutine的**并行**能力\n\t- 可通过环境变量`$GOMAXPROCS`设置\n\t- 或者在程序中通过`runtime.GOMAXPROCS()`来设置\n\n## 调度器的设计策略\n\n- **复用线程**：避免频繁创建、销毁线程带来巨大的开销\n\t- work stealing：当本线程无可调度的Goroutine时，就会“偷取”其他线程待执行的Goroutine来执行\n\t- hand off：当本线程运行的Goroutine发生了阻塞，就会创建/唤醒一个新的线程，新线程接管这个阻塞G的P\n- **利用并行**：通过`GOMAXPROCS`参数调节可同时工作的Processor，即最多有`GOMAXPROCS`个协程并行工作\n- **抢占**：coroutine是协作式的，只能由coroutine主动让出CPU资源。而Go调度器为了调度公平，规定每个Goroutine最多占用10msCPU时间，超过这个时间就会被强制下线\n- **全局队列**：当线程无法从别的线程中“偷取”可调度的Goroutine时，就会从全局队列中获取一个Goroutine进行执行\n\n## Go指令的调度流程\n\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412221837093.png)\n\n\ngo func()命令的执行流程：\n1. 创建一个Goroutine\n2. 尝试将Goroutine放入本线程绑定的P的本地队列中，如果本地队列已满，那么就把Goroutine放入全局队列中\n3. M会从P的本地队列中取出一个Goroutine执行，若本地队列为空，那就从别的MP组合或全局队列中“偷”一个Goroutine执行\n4. M循环调度不同的G\n5. 当M在执行G时发生了阻塞，runtime会把这个M和P解除关联，然后创建/唤醒一个线程，接着让这个线程取服务解除关联的P\n6. 当M调度结束后，G会尝试获取一个空闲的P，并进入该P的本地队列中，M和P重新关联。如果获取不到，那么G会被放入全局队列，M则是加入空闲线程中，进入休眠状态\n\n## Go启动周期的M0和G0\n\n**M0**：进程启动时创建的第一个线程，称为M0。M0实例会在全局变量runtime.m0中，不需要在heap中分配中间。M0负责执行一些初始化操作，接着便和普通线程无异\n**G0**：每一个线程在被创建之后，会立即创建一个Goroutine，称为G0，即每一个线程都有一个属于自己的G0。G0不指向某个具体的函数，而是专门负责调度本地队列中的G。在调度或系统调度时，会使用G0的栈空间，全局变量G0就是M0所创建的G0\n\n## GMP可视化调试\n\n```go\n\t// 创建trace.out文件\n\tf, err := os.Create(\"trace.out\")\n\tif err != nil {}\n\t// 启动trace\n\terr = trace.Start(f)\n\tif err != nil {}\n\t// do something\n\t// 这里是业务代码\n\n\t// 停止trace\n\ttrace.Stop()\n```\n运行程序后，会生成一个名为trace.out的文件，可以使用`go tool trace $filename`命令对这个文件进行可视化分析\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412221942758.png)\n\n左栏自上而下依次是：G协程信息、堆栈信息、M线程信息、P调度器信息\n\n## GMP调度场景全过程分析\n\n### G1创建G’\n\nP拥有G1，G1在运行过程中调用`go fun()`创建了G‘。考虑到局部性，优先将G2放入到该P的本地队列中\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221958378.png\" style=\"zoom:70%\">\n\n### G1执行完毕\n\nG1运行完毕后，G0切换到M上运行，G0执行调度工作（schedule函数)：从P的本地队列中取出G2，M上运行的Goroutine从G0切换至G2，并开始运行G2（execute函数）。实现线程的复用\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222006838.png)\n\n### 本地队列已满，再创建G\n\n如果当前运行的G创建了一个G，恰巧P的本地队列无法再容纳新创建的G时，需要将本地队列中**前半部分的G打乱顺序**，连同新创建的G一起放入全局队列中\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222017907.png)\n\n### 唤醒正在休眠的M\n\n在一个G创建一个新的G时，会尝试唤醒等待队列中的M。假设唤醒了M2，M2会寻找一个空闲的P进行绑定，并运行G0，执行协程的调度。如果P的本地队列为空，那么M2亟需寻找一个G来执行，此时M2就是**自旋线程**\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222026925.png)\n\n### 被唤醒的M2从全局队列中批量取G\n\n自旋线程M2会尝试从全局队列中获取G执行，获取的G的数量由`min(len(GQ)/2 + 1, len(GQ)/2)`决定，其中`len(GQ)`表示全局队列中元素个数。M2批量获取G的过程叫做”**从全局队列到本地队列的负载均衡**“。(感觉就是为了避免拉取太多的G，一是导致本线程消化不了，二是饿死别的线程）\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222048979.png)\n\n### 偷取M的G\n\n如果全局队列已经没有G了，自旋线程M2就会尝试从别的线程（M1）中偷取一批G，放入本地队列中准备调度。具体地，M2会偷取，M1本地队列中**后半部分**的G作为本线程即将执行调度的G，下图中P1的本地队列后半部分只有G8，因此G8被M2偷取执行\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412222131818.png)\n\n### 自旋线程的限制\n\n最多有**GOMAXPROCS**个自旋线程，即使有再多的线程，也会因为没有空闲的P进行调度进入休眠状态\n\n### G发生调用阻塞\n\n当G8发生了调用阻塞，P2会立即和M2解绑。接下来P2会判断是否有线程处于休眠状态，如果有，就唤醒一个线程并与之绑定，否则P2会加入空闲P列表中，等待M来获取\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412240928105.png)\n\nG发生系统调用/非阻塞\n\n当G8从阻塞状态中恢复后，M2想要运行G8必须要有P的支持。那么M2会尝试重新获取P2，如果发现P2已经被绑定，就再尝试从空闲P队列中获取一个P。如果获取P失败，G8就会被放入全局队列，M2进入休眠线程队列\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/202412240936232.png)\n","slug":"Go/GMP原理","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m001ua5t299in93du","content":"<p><a href=\"https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.1387.homepage.video_card.click\">Golang深入理解GPM模型</a>学习笔记</p>\n<p>协程调度器的核心作用就是将协程关联到内核线程，内核线程无需切换就能执行用户态中的不同功能，提高了并发度</p>\n<h2 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h2><p>GMP模型设计布局如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412212114507.png\" style=\"zoom:80%\">\n\n<ul>\n<li><strong>G</strong>：Goroutine，Go协程</li>\n<li><strong>P</strong>：Processor，逻辑处理器</li>\n<li><strong>M</strong>：Machine，系统级线程</li>\n<li><strong>全局队列</strong>：存放待调度的Goroutine</li>\n<li><strong>本地队列</strong>：存放某一个Processor即将调度的Goroutine<ul>\n<li>一个本地队列中最多容纳256个Goroutine</li>\n<li>当创建一个Goroutine时，会优先将Goroutine放在本地队列中。如果没有本地队列存在空闲空间，那么新创建的Goroutine就会被放入全局队列</li>\n</ul>\n</li>\n<li><strong>GOMAXPROCS</strong>：配置逻辑处理器个数的参数，决定了Goroutine的<strong>并行</strong>能力<ul>\n<li>可通过环境变量<code>$GOMAXPROCS</code>设置</li>\n<li>或者在程序中通过<code>runtime.GOMAXPROCS()</code>来设置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调度器的设计策略\"><a href=\"#调度器的设计策略\" class=\"headerlink\" title=\"调度器的设计策略\"></a>调度器的设计策略</h2><ul>\n<li><strong>复用线程</strong>：避免频繁创建、销毁线程带来巨大的开销<ul>\n<li>work stealing：当本线程无可调度的Goroutine时，就会“偷取”其他线程待执行的Goroutine来执行</li>\n<li>hand off：当本线程运行的Goroutine发生了阻塞，就会创建&#x2F;唤醒一个新的线程，新线程接管这个阻塞G的P</li>\n</ul>\n</li>\n<li><strong>利用并行</strong>：通过<code>GOMAXPROCS</code>参数调节可同时工作的Processor，即最多有<code>GOMAXPROCS</code>个协程并行工作</li>\n<li><strong>抢占</strong>：coroutine是协作式的，只能由coroutine主动让出CPU资源。而Go调度器为了调度公平，规定每个Goroutine最多占用10msCPU时间，超过这个时间就会被强制下线</li>\n<li><strong>全局队列</strong>：当线程无法从别的线程中“偷取”可调度的Goroutine时，就会从全局队列中获取一个Goroutine进行执行</li>\n</ul>\n<h2 id=\"Go指令的调度流程\"><a href=\"#Go指令的调度流程\" class=\"headerlink\" title=\"Go指令的调度流程\"></a>Go指令的调度流程</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221837093.png\" alt=\"image.png\"></p>\n<p>go func()命令的执行流程：</p>\n<ol>\n<li>创建一个Goroutine</li>\n<li>尝试将Goroutine放入本线程绑定的P的本地队列中，如果本地队列已满，那么就把Goroutine放入全局队列中</li>\n<li>M会从P的本地队列中取出一个Goroutine执行，若本地队列为空，那就从别的MP组合或全局队列中“偷”一个Goroutine执行</li>\n<li>M循环调度不同的G</li>\n<li>当M在执行G时发生了阻塞，runtime会把这个M和P解除关联，然后创建&#x2F;唤醒一个线程，接着让这个线程取服务解除关联的P</li>\n<li>当M调度结束后，G会尝试获取一个空闲的P，并进入该P的本地队列中，M和P重新关联。如果获取不到，那么G会被放入全局队列，M则是加入空闲线程中，进入休眠状态</li>\n</ol>\n<h2 id=\"Go启动周期的M0和G0\"><a href=\"#Go启动周期的M0和G0\" class=\"headerlink\" title=\"Go启动周期的M0和G0\"></a>Go启动周期的M0和G0</h2><p><strong>M0</strong>：进程启动时创建的第一个线程，称为M0。M0实例会在全局变量runtime.m0中，不需要在heap中分配中间。M0负责执行一些初始化操作，接着便和普通线程无异<br><strong>G0</strong>：每一个线程在被创建之后，会立即创建一个Goroutine，称为G0，即每一个线程都有一个属于自己的G0。G0不指向某个具体的函数，而是专门负责调度本地队列中的G。在调度或系统调度时，会使用G0的栈空间，全局变量G0就是M0所创建的G0</p>\n<h2 id=\"GMP可视化调试\"><a href=\"#GMP可视化调试\" class=\"headerlink\" title=\"GMP可视化调试\"></a>GMP可视化调试</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建trace.out文件</span></span><br><span class=\"line\">f, err := os.Create(<span class=\"string\">&quot;trace.out&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 启动trace</span></span><br><span class=\"line\">err = trace.Start(f)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br><span class=\"line\"><span class=\"comment\">// 这里是业务代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 停止trace</span></span><br><span class=\"line\">trace.Stop()</span><br></pre></td></tr></table></figure>\n<p>运行程序后，会生成一个名为trace.out的文件，可以使用<code>go tool trace $filename</code>命令对这个文件进行可视化分析<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221942758.png\" alt=\"image.png\"></p>\n<p>左栏自上而下依次是：G协程信息、堆栈信息、M线程信息、P调度器信息</p>\n<h2 id=\"GMP调度场景全过程分析\"><a href=\"#GMP调度场景全过程分析\" class=\"headerlink\" title=\"GMP调度场景全过程分析\"></a>GMP调度场景全过程分析</h2><h3 id=\"G1创建G’\"><a href=\"#G1创建G’\" class=\"headerlink\" title=\"G1创建G’\"></a>G1创建G’</h3><p>P拥有G1，G1在运行过程中调用<code>go fun()</code>创建了G‘。考虑到局部性，优先将G2放入到该P的本地队列中<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221958378.png\" style=\"zoom:70%\"></p>\n<h3 id=\"G1执行完毕\"><a href=\"#G1执行完毕\" class=\"headerlink\" title=\"G1执行完毕\"></a>G1执行完毕</h3><p>G1运行完毕后，G0切换到M上运行，G0执行调度工作（schedule函数)：从P的本地队列中取出G2，M上运行的Goroutine从G0切换至G2，并开始运行G2（execute函数）。实现线程的复用<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222006838.png\" alt=\"image.png\"></p>\n<h3 id=\"本地队列已满，再创建G\"><a href=\"#本地队列已满，再创建G\" class=\"headerlink\" title=\"本地队列已满，再创建G\"></a>本地队列已满，再创建G</h3><p>如果当前运行的G创建了一个G，恰巧P的本地队列无法再容纳新创建的G时，需要将本地队列中<strong>前半部分的G打乱顺序</strong>，连同新创建的G一起放入全局队列中<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222017907.png\" alt=\"image.png\"></p>\n<h3 id=\"唤醒正在休眠的M\"><a href=\"#唤醒正在休眠的M\" class=\"headerlink\" title=\"唤醒正在休眠的M\"></a>唤醒正在休眠的M</h3><p>在一个G创建一个新的G时，会尝试唤醒等待队列中的M。假设唤醒了M2，M2会寻找一个空闲的P进行绑定，并运行G0，执行协程的调度。如果P的本地队列为空，那么M2亟需寻找一个G来执行，此时M2就是<strong>自旋线程</strong><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222026925.png\" alt=\"image.png\"></p>\n<h3 id=\"被唤醒的M2从全局队列中批量取G\"><a href=\"#被唤醒的M2从全局队列中批量取G\" class=\"headerlink\" title=\"被唤醒的M2从全局队列中批量取G\"></a>被唤醒的M2从全局队列中批量取G</h3><p>自旋线程M2会尝试从全局队列中获取G执行，获取的G的数量由<code>min(len(GQ)/2 + 1, len(GQ)/2)</code>决定，其中<code>len(GQ)</code>表示全局队列中元素个数。M2批量获取G的过程叫做”<strong>从全局队列到本地队列的负载均衡</strong>“。(感觉就是为了避免拉取太多的G，一是导致本线程消化不了，二是饿死别的线程）<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222048979.png\" alt=\"image.png\"></p>\n<h3 id=\"偷取M的G\"><a href=\"#偷取M的G\" class=\"headerlink\" title=\"偷取M的G\"></a>偷取M的G</h3><p>如果全局队列已经没有G了，自旋线程M2就会尝试从别的线程（M1）中偷取一批G，放入本地队列中准备调度。具体地，M2会偷取，M1本地队列中<strong>后半部分</strong>的G作为本线程即将执行调度的G，下图中P1的本地队列后半部分只有G8，因此G8被M2偷取执行<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222131818.png\" alt=\"image.png\"></p>\n<h3 id=\"自旋线程的限制\"><a href=\"#自旋线程的限制\" class=\"headerlink\" title=\"自旋线程的限制\"></a>自旋线程的限制</h3><p>最多有<strong>GOMAXPROCS</strong>个自旋线程，即使有再多的线程，也会因为没有空闲的P进行调度进入休眠状态</p>\n<h3 id=\"G发生调用阻塞\"><a href=\"#G发生调用阻塞\" class=\"headerlink\" title=\"G发生调用阻塞\"></a>G发生调用阻塞</h3><p>当G8发生了调用阻塞，P2会立即和M2解绑。接下来P2会判断是否有线程处于休眠状态，如果有，就唤醒一个线程并与之绑定，否则P2会加入空闲P列表中，等待M来获取<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412240928105.png\" alt=\"image.png\"></p>\n<p>G发生系统调用&#x2F;非阻塞</p>\n<p>当G8从阻塞状态中恢复后，M2想要运行G8必须要有P的支持。那么M2会尝试重新获取P2，如果发现P2已经被绑定，就再尝试从空闲P队列中获取一个P。如果获取P失败，G8就会被放入全局队列，M2进入休眠线程队列<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412240936232.png\" alt=\"image.png\"></p>\n","excerpt":"","more":"<p><a href=\"https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.1387.homepage.video_card.click\">Golang深入理解GPM模型</a>学习笔记</p>\n<p>协程调度器的核心作用就是将协程关联到内核线程，内核线程无需切换就能执行用户态中的不同功能，提高了并发度</p>\n<h2 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h2><p>GMP模型设计布局如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412212114507.png\" style=\"zoom:80%\">\n\n<ul>\n<li><strong>G</strong>：Goroutine，Go协程</li>\n<li><strong>P</strong>：Processor，逻辑处理器</li>\n<li><strong>M</strong>：Machine，系统级线程</li>\n<li><strong>全局队列</strong>：存放待调度的Goroutine</li>\n<li><strong>本地队列</strong>：存放某一个Processor即将调度的Goroutine<ul>\n<li>一个本地队列中最多容纳256个Goroutine</li>\n<li>当创建一个Goroutine时，会优先将Goroutine放在本地队列中。如果没有本地队列存在空闲空间，那么新创建的Goroutine就会被放入全局队列</li>\n</ul>\n</li>\n<li><strong>GOMAXPROCS</strong>：配置逻辑处理器个数的参数，决定了Goroutine的<strong>并行</strong>能力<ul>\n<li>可通过环境变量<code>$GOMAXPROCS</code>设置</li>\n<li>或者在程序中通过<code>runtime.GOMAXPROCS()</code>来设置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调度器的设计策略\"><a href=\"#调度器的设计策略\" class=\"headerlink\" title=\"调度器的设计策略\"></a>调度器的设计策略</h2><ul>\n<li><strong>复用线程</strong>：避免频繁创建、销毁线程带来巨大的开销<ul>\n<li>work stealing：当本线程无可调度的Goroutine时，就会“偷取”其他线程待执行的Goroutine来执行</li>\n<li>hand off：当本线程运行的Goroutine发生了阻塞，就会创建&#x2F;唤醒一个新的线程，新线程接管这个阻塞G的P</li>\n</ul>\n</li>\n<li><strong>利用并行</strong>：通过<code>GOMAXPROCS</code>参数调节可同时工作的Processor，即最多有<code>GOMAXPROCS</code>个协程并行工作</li>\n<li><strong>抢占</strong>：coroutine是协作式的，只能由coroutine主动让出CPU资源。而Go调度器为了调度公平，规定每个Goroutine最多占用10msCPU时间，超过这个时间就会被强制下线</li>\n<li><strong>全局队列</strong>：当线程无法从别的线程中“偷取”可调度的Goroutine时，就会从全局队列中获取一个Goroutine进行执行</li>\n</ul>\n<h2 id=\"Go指令的调度流程\"><a href=\"#Go指令的调度流程\" class=\"headerlink\" title=\"Go指令的调度流程\"></a>Go指令的调度流程</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221837093.png\" alt=\"image.png\"></p>\n<p>go func()命令的执行流程：</p>\n<ol>\n<li>创建一个Goroutine</li>\n<li>尝试将Goroutine放入本线程绑定的P的本地队列中，如果本地队列已满，那么就把Goroutine放入全局队列中</li>\n<li>M会从P的本地队列中取出一个Goroutine执行，若本地队列为空，那就从别的MP组合或全局队列中“偷”一个Goroutine执行</li>\n<li>M循环调度不同的G</li>\n<li>当M在执行G时发生了阻塞，runtime会把这个M和P解除关联，然后创建&#x2F;唤醒一个线程，接着让这个线程取服务解除关联的P</li>\n<li>当M调度结束后，G会尝试获取一个空闲的P，并进入该P的本地队列中，M和P重新关联。如果获取不到，那么G会被放入全局队列，M则是加入空闲线程中，进入休眠状态</li>\n</ol>\n<h2 id=\"Go启动周期的M0和G0\"><a href=\"#Go启动周期的M0和G0\" class=\"headerlink\" title=\"Go启动周期的M0和G0\"></a>Go启动周期的M0和G0</h2><p><strong>M0</strong>：进程启动时创建的第一个线程，称为M0。M0实例会在全局变量runtime.m0中，不需要在heap中分配中间。M0负责执行一些初始化操作，接着便和普通线程无异<br><strong>G0</strong>：每一个线程在被创建之后，会立即创建一个Goroutine，称为G0，即每一个线程都有一个属于自己的G0。G0不指向某个具体的函数，而是专门负责调度本地队列中的G。在调度或系统调度时，会使用G0的栈空间，全局变量G0就是M0所创建的G0</p>\n<h2 id=\"GMP可视化调试\"><a href=\"#GMP可视化调试\" class=\"headerlink\" title=\"GMP可视化调试\"></a>GMP可视化调试</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建trace.out文件</span></span><br><span class=\"line\">f, err := os.Create(<span class=\"string\">&quot;trace.out&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 启动trace</span></span><br><span class=\"line\">err = trace.Start(f)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// do something</span></span><br><span class=\"line\"><span class=\"comment\">// 这里是业务代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 停止trace</span></span><br><span class=\"line\">trace.Stop()</span><br></pre></td></tr></table></figure>\n<p>运行程序后，会生成一个名为trace.out的文件，可以使用<code>go tool trace $filename</code>命令对这个文件进行可视化分析<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221942758.png\" alt=\"image.png\"></p>\n<p>左栏自上而下依次是：G协程信息、堆栈信息、M线程信息、P调度器信息</p>\n<h2 id=\"GMP调度场景全过程分析\"><a href=\"#GMP调度场景全过程分析\" class=\"headerlink\" title=\"GMP调度场景全过程分析\"></a>GMP调度场景全过程分析</h2><h3 id=\"G1创建G’\"><a href=\"#G1创建G’\" class=\"headerlink\" title=\"G1创建G’\"></a>G1创建G’</h3><p>P拥有G1，G1在运行过程中调用<code>go fun()</code>创建了G‘。考虑到局部性，优先将G2放入到该P的本地队列中<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412221958378.png\" style=\"zoom:70%\"></p>\n<h3 id=\"G1执行完毕\"><a href=\"#G1执行完毕\" class=\"headerlink\" title=\"G1执行完毕\"></a>G1执行完毕</h3><p>G1运行完毕后，G0切换到M上运行，G0执行调度工作（schedule函数)：从P的本地队列中取出G2，M上运行的Goroutine从G0切换至G2，并开始运行G2（execute函数）。实现线程的复用<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222006838.png\" alt=\"image.png\"></p>\n<h3 id=\"本地队列已满，再创建G\"><a href=\"#本地队列已满，再创建G\" class=\"headerlink\" title=\"本地队列已满，再创建G\"></a>本地队列已满，再创建G</h3><p>如果当前运行的G创建了一个G，恰巧P的本地队列无法再容纳新创建的G时，需要将本地队列中<strong>前半部分的G打乱顺序</strong>，连同新创建的G一起放入全局队列中<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222017907.png\" alt=\"image.png\"></p>\n<h3 id=\"唤醒正在休眠的M\"><a href=\"#唤醒正在休眠的M\" class=\"headerlink\" title=\"唤醒正在休眠的M\"></a>唤醒正在休眠的M</h3><p>在一个G创建一个新的G时，会尝试唤醒等待队列中的M。假设唤醒了M2，M2会寻找一个空闲的P进行绑定，并运行G0，执行协程的调度。如果P的本地队列为空，那么M2亟需寻找一个G来执行，此时M2就是<strong>自旋线程</strong><br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222026925.png\" alt=\"image.png\"></p>\n<h3 id=\"被唤醒的M2从全局队列中批量取G\"><a href=\"#被唤醒的M2从全局队列中批量取G\" class=\"headerlink\" title=\"被唤醒的M2从全局队列中批量取G\"></a>被唤醒的M2从全局队列中批量取G</h3><p>自旋线程M2会尝试从全局队列中获取G执行，获取的G的数量由<code>min(len(GQ)/2 + 1, len(GQ)/2)</code>决定，其中<code>len(GQ)</code>表示全局队列中元素个数。M2批量获取G的过程叫做”<strong>从全局队列到本地队列的负载均衡</strong>“。(感觉就是为了避免拉取太多的G，一是导致本线程消化不了，二是饿死别的线程）<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222048979.png\" alt=\"image.png\"></p>\n<h3 id=\"偷取M的G\"><a href=\"#偷取M的G\" class=\"headerlink\" title=\"偷取M的G\"></a>偷取M的G</h3><p>如果全局队列已经没有G了，自旋线程M2就会尝试从别的线程（M1）中偷取一批G，放入本地队列中准备调度。具体地，M2会偷取，M1本地队列中<strong>后半部分</strong>的G作为本线程即将执行调度的G，下图中P1的本地队列后半部分只有G8，因此G8被M2偷取执行<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412222131818.png\" alt=\"image.png\"></p>\n<h3 id=\"自旋线程的限制\"><a href=\"#自旋线程的限制\" class=\"headerlink\" title=\"自旋线程的限制\"></a>自旋线程的限制</h3><p>最多有<strong>GOMAXPROCS</strong>个自旋线程，即使有再多的线程，也会因为没有空闲的P进行调度进入休眠状态</p>\n<h3 id=\"G发生调用阻塞\"><a href=\"#G发生调用阻塞\" class=\"headerlink\" title=\"G发生调用阻塞\"></a>G发生调用阻塞</h3><p>当G8发生了调用阻塞，P2会立即和M2解绑。接下来P2会判断是否有线程处于休眠状态，如果有，就唤醒一个线程并与之绑定，否则P2会加入空闲P列表中，等待M来获取<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412240928105.png\" alt=\"image.png\"></p>\n<p>G发生系统调用&#x2F;非阻塞</p>\n<p>当G8从阻塞状态中恢复后，M2想要运行G8必须要有P的支持。那么M2会尝试重新获取P2，如果发现P2已经被绑定，就再尝试从空闲P队列中获取一个P。如果获取P失败，G8就会被放入全局队列，M2进入休眠线程队列<br><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412240936232.png\" alt=\"image.png\"></p>\n"},{"description":"记录Go数据结构相关知识","date":"2024-12-11T16:00:00.000Z","_content":"\n\n\n# Go数据结构\n\n## string\n\nGo语言中，string可以看作是所有**8bit 字节**的集合，一个字节数组。\n\n- 字符串可以为空串，但不能为nil\n- 字符串的字面值是只读的，不可以被修改\n  - 字符串是不能被修改的，但是变量可以重新赋值\n\n在源码中也给出了string的结构：其中`str`是**指向字符串首地址的指针**、`len`表示**字符串的长度**\n\n```go\ntype stringStruct struct {\n    str unsafe.Pointer\n    len int\n}\n```\n\n🌰：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051022321.png\" alt=\"image-20241005102225290\" style=\"zoom:67%;\" />\n\n值得注意的是，**len表示字符串长度是以字节数计量的**，而非字符数。\n\n举个🌰：字符串`hello`的字节数和字符数是5，长度也是5；而字符串`hello啊`的字节数是8、字符数是6，而长度同字节数一样是8\n\n所以对包含非单字节编码的字符的字符串进行`len()`操作，可能会得到意想不到的结果\n\n### string和[]byte的互相转换\n\nstring和[]byte的转化（一般）会发生一次内存拷贝，并申请一块新的切片内存空间\n\n**[]byte转为string的大致过程：**\n\n- 申请一块新的内存空间，并记录首地址`addr`和字节长度`len`\n- 构建string对象，指针地址为`addr`，`len`字段赋值为`len`\n- 将源字节切片中的数据拷贝到刚申请的内存空间中\n\n![image-20241005103541446](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051035476.png)\n\nstring转为[]byte的大致过程：\n\n- 申请一块新的内存空间\n\n- 将string指针所指向的内存区域拷贝`len`字节到刚申请的空间中\n\n  ![image-20241005103722955](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051037987.png)\n\n⚠️：当**转化为的字符串被用于临时场景时**，string和[]byte之间的转换并**不会发生拷贝**\n\n例如：\n\n- 字符串比较：string(ss) == \"hello\"\n- 字符串拼接：\"hello\" + string(ss) + \"world\"\n- 用于查找：k, v := map[string(ss)]\n\n在上述场景中，[]byte转换的字符串只有临时作用，在后续程序中不会再次使用，所以并不会拷贝到内存，而是直接返回一个string，这个string的指针就指向字节切片的内存地址\n\n## slice\n\n在Go语言中，slice是基于数组封装出来的抽象数据结构。因此在解析slice之前，需要先认识认识golang中的数组。\n\nGo语言中的数组是一种值类型，和C语言中的指针类型不同，所以在Go中对数组进行复制、传参都是进行**值复制**操作，就和`int`、`float64`这些基本数据类型类似\n\n数组类型在golang中由**数组大小和数据类型**共同决定，验证例子如下：\n\n```go\n\tarr := [3]int{1, 2, 3}\n\tfmt.Printf(\"arr`s type is %T\", arr)\n\t//arr`s type is [3]int\n```\n\n正因为数组类型在初始时就被确定（大小和数据类型），所以在面对一些动态存储的场景时数组就有点力不从心了。\n\n**slice**就是为了解决数组在长度上不可增长的问题，基于数组实现了**变长数组**的机制\n\n### slice底层结构\n\nslice底层结构如下：\n\n```go\ntype slice struct {\n    // 底层数组指针\n    array unsafe.Pointer\n    // slice的长度\n    len int\n    // 容量\n    cap int\n}\n```\n\nslice扩容两步骤：\n\n1. 计算所需容量\n   1. 如果**新切片的长度＞旧切片的容量的两倍**，那么新切片的容量等于长度\n   2. 否则\n      1. 如果**旧切片的容量＜256**，那么新切片的容量就是原容量的两倍\n      2. 否则新切片的容量就是**1.25 * 原切片容量+3/4 * 256**\n2. 内存对齐，确定最终容量\n   1. 按照Go内存管理的级别确对齐内存，最终容量以此为准\n\n### slice问题解密\n\n- slice通过函数传递的是什么？\n\n  - 传递的是底层slice结构体的拷贝\n\n  - ```go\n    func PrintSliceStruct(s *[]int) {\n    \tss := (*reflect.SliceHeader)(unsafe.Pointer(s))\n    \tfmt.Printf(\"slice struct: %+v, slice is %v\\n\", ss, s)\n    }\n    \n    func test(s []int) {\n    \tfmt.Printf(\"slice address in main is %p\t\", &s)\n    \tPrintSliceStruct(&s)\n    }\n    \n    func main() {\n    \ts := make([]int, 5, 10)\n    \tfmt.Printf(\"slice address in main is %p\t\", &s)\n    \tPrintSliceStruct(&s)\n    \ttest(s)\n    \t/*\n    \tslice address in main is 0xc000008048\tslice struct: &{Data:824633788048 Len:5 Cap:10}, slice is &[0 0 0 0 0]\n    \tslice address in main is 0xc000008078\tslice struct: &{Data:824633788048 Len:5 Cap:10}, slice is &[0 0 0 0 0]\n    \t */\n    }\n    ```\n\n- 在函数里面改变slice，外层会受到影响吗？\n\n  - 只要修改的底层数组是同一个，那么就会受到影响\n```\n    func test1(s []int) {\n    \ts[0] = 7\n    \tfmt.Printf(\"test1 value %v\\n\", s)\n    }\n    \n    func test2(s []int) {\n    \ts = append(s, 4)\n    \tfmt.Printf(\"test2 value %v\\n\", s)\n    }\n    \n    func main() {\n    \ts := []int{1, 2, 3}\n    \tfmt.Printf(\"initial value of s: %v\\n\", s)\n    \ttest1(s) // 底层数组相同，会受到影响\n    \tfmt.Printf(\"after test1, value of s: %v\\n\", s)\n    \ttest2(s) // 底层数组发生变化，不受影响\n    \tfmt.Printf(\"after test2, value of s: %v\\n\", s)\n    \t/*\n    \tinitial value of s: [1 2 3]\n    \ttest1 value [7 2 3]\n    \tafter test1, value of s: [7 2 3]\n    \ttest2 value [7 2 3 4]\n    \tafter test2, value of s: [7 2 3]\n    \t */\n    }\n```\n## sync.map\n\n这里是sync.map","source":"_posts/Go/Golang数据结构.md","raw":"---\ndescription: 记录Go数据结构相关知识\ntags:\n  - Go\ndate: 2024-12-12\n---\n\n\n\n# Go数据结构\n\n## string\n\nGo语言中，string可以看作是所有**8bit 字节**的集合，一个字节数组。\n\n- 字符串可以为空串，但不能为nil\n- 字符串的字面值是只读的，不可以被修改\n  - 字符串是不能被修改的，但是变量可以重新赋值\n\n在源码中也给出了string的结构：其中`str`是**指向字符串首地址的指针**、`len`表示**字符串的长度**\n\n```go\ntype stringStruct struct {\n    str unsafe.Pointer\n    len int\n}\n```\n\n🌰：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051022321.png\" alt=\"image-20241005102225290\" style=\"zoom:67%;\" />\n\n值得注意的是，**len表示字符串长度是以字节数计量的**，而非字符数。\n\n举个🌰：字符串`hello`的字节数和字符数是5，长度也是5；而字符串`hello啊`的字节数是8、字符数是6，而长度同字节数一样是8\n\n所以对包含非单字节编码的字符的字符串进行`len()`操作，可能会得到意想不到的结果\n\n### string和[]byte的互相转换\n\nstring和[]byte的转化（一般）会发生一次内存拷贝，并申请一块新的切片内存空间\n\n**[]byte转为string的大致过程：**\n\n- 申请一块新的内存空间，并记录首地址`addr`和字节长度`len`\n- 构建string对象，指针地址为`addr`，`len`字段赋值为`len`\n- 将源字节切片中的数据拷贝到刚申请的内存空间中\n\n![image-20241005103541446](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051035476.png)\n\nstring转为[]byte的大致过程：\n\n- 申请一块新的内存空间\n\n- 将string指针所指向的内存区域拷贝`len`字节到刚申请的空间中\n\n  ![image-20241005103722955](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051037987.png)\n\n⚠️：当**转化为的字符串被用于临时场景时**，string和[]byte之间的转换并**不会发生拷贝**\n\n例如：\n\n- 字符串比较：string(ss) == \"hello\"\n- 字符串拼接：\"hello\" + string(ss) + \"world\"\n- 用于查找：k, v := map[string(ss)]\n\n在上述场景中，[]byte转换的字符串只有临时作用，在后续程序中不会再次使用，所以并不会拷贝到内存，而是直接返回一个string，这个string的指针就指向字节切片的内存地址\n\n## slice\n\n在Go语言中，slice是基于数组封装出来的抽象数据结构。因此在解析slice之前，需要先认识认识golang中的数组。\n\nGo语言中的数组是一种值类型，和C语言中的指针类型不同，所以在Go中对数组进行复制、传参都是进行**值复制**操作，就和`int`、`float64`这些基本数据类型类似\n\n数组类型在golang中由**数组大小和数据类型**共同决定，验证例子如下：\n\n```go\n\tarr := [3]int{1, 2, 3}\n\tfmt.Printf(\"arr`s type is %T\", arr)\n\t//arr`s type is [3]int\n```\n\n正因为数组类型在初始时就被确定（大小和数据类型），所以在面对一些动态存储的场景时数组就有点力不从心了。\n\n**slice**就是为了解决数组在长度上不可增长的问题，基于数组实现了**变长数组**的机制\n\n### slice底层结构\n\nslice底层结构如下：\n\n```go\ntype slice struct {\n    // 底层数组指针\n    array unsafe.Pointer\n    // slice的长度\n    len int\n    // 容量\n    cap int\n}\n```\n\nslice扩容两步骤：\n\n1. 计算所需容量\n   1. 如果**新切片的长度＞旧切片的容量的两倍**，那么新切片的容量等于长度\n   2. 否则\n      1. 如果**旧切片的容量＜256**，那么新切片的容量就是原容量的两倍\n      2. 否则新切片的容量就是**1.25 * 原切片容量+3/4 * 256**\n2. 内存对齐，确定最终容量\n   1. 按照Go内存管理的级别确对齐内存，最终容量以此为准\n\n### slice问题解密\n\n- slice通过函数传递的是什么？\n\n  - 传递的是底层slice结构体的拷贝\n\n  - ```go\n    func PrintSliceStruct(s *[]int) {\n    \tss := (*reflect.SliceHeader)(unsafe.Pointer(s))\n    \tfmt.Printf(\"slice struct: %+v, slice is %v\\n\", ss, s)\n    }\n    \n    func test(s []int) {\n    \tfmt.Printf(\"slice address in main is %p\t\", &s)\n    \tPrintSliceStruct(&s)\n    }\n    \n    func main() {\n    \ts := make([]int, 5, 10)\n    \tfmt.Printf(\"slice address in main is %p\t\", &s)\n    \tPrintSliceStruct(&s)\n    \ttest(s)\n    \t/*\n    \tslice address in main is 0xc000008048\tslice struct: &{Data:824633788048 Len:5 Cap:10}, slice is &[0 0 0 0 0]\n    \tslice address in main is 0xc000008078\tslice struct: &{Data:824633788048 Len:5 Cap:10}, slice is &[0 0 0 0 0]\n    \t */\n    }\n    ```\n\n- 在函数里面改变slice，外层会受到影响吗？\n\n  - 只要修改的底层数组是同一个，那么就会受到影响\n```\n    func test1(s []int) {\n    \ts[0] = 7\n    \tfmt.Printf(\"test1 value %v\\n\", s)\n    }\n    \n    func test2(s []int) {\n    \ts = append(s, 4)\n    \tfmt.Printf(\"test2 value %v\\n\", s)\n    }\n    \n    func main() {\n    \ts := []int{1, 2, 3}\n    \tfmt.Printf(\"initial value of s: %v\\n\", s)\n    \ttest1(s) // 底层数组相同，会受到影响\n    \tfmt.Printf(\"after test1, value of s: %v\\n\", s)\n    \ttest2(s) // 底层数组发生变化，不受影响\n    \tfmt.Printf(\"after test2, value of s: %v\\n\", s)\n    \t/*\n    \tinitial value of s: [1 2 3]\n    \ttest1 value [7 2 3]\n    \tafter test1, value of s: [7 2 3]\n    \ttest2 value [7 2 3 4]\n    \tafter test2, value of s: [7 2 3]\n    \t */\n    }\n```\n## sync.map\n\n这里是sync.map","slug":"Go/Golang数据结构","published":1,"updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m001wa5t217u41wql","content":"<h1 id=\"Go数据结构\"><a href=\"#Go数据结构\" class=\"headerlink\" title=\"Go数据结构\"></a>Go数据结构</h1><h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><p>Go语言中，string可以看作是所有<strong>8bit 字节</strong>的集合，一个字节数组。</p>\n<ul>\n<li>字符串可以为空串，但不能为nil</li>\n<li>字符串的字面值是只读的，不可以被修改<ul>\n<li>字符串是不能被修改的，但是变量可以重新赋值</li>\n</ul>\n</li>\n</ul>\n<p>在源码中也给出了string的结构：其中<code>str</code>是<strong>指向字符串首地址的指针</strong>、<code>len</code>表示<strong>字符串的长度</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> stringStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    str unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>🌰：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051022321.png\" alt=\"image-20241005102225290\" style=\"zoom:67%;\" />\n\n<p>值得注意的是，<strong>len表示字符串长度是以字节数计量的</strong>，而非字符数。</p>\n<p>举个🌰：字符串<code>hello</code>的字节数和字符数是5，长度也是5；而字符串<code>hello啊</code>的字节数是8、字符数是6，而长度同字节数一样是8</p>\n<p>所以对包含非单字节编码的字符的字符串进行<code>len()</code>操作，可能会得到意想不到的结果</p>\n<h3 id=\"string和-byte的互相转换\"><a href=\"#string和-byte的互相转换\" class=\"headerlink\" title=\"string和[]byte的互相转换\"></a>string和[]byte的互相转换</h3><p>string和[]byte的转化（一般）会发生一次内存拷贝，并申请一块新的切片内存空间</p>\n<p><strong>[]byte转为string的大致过程：</strong></p>\n<ul>\n<li>申请一块新的内存空间，并记录首地址<code>addr</code>和字节长度<code>len</code></li>\n<li>构建string对象，指针地址为<code>addr</code>，<code>len</code>字段赋值为<code>len</code></li>\n<li>将源字节切片中的数据拷贝到刚申请的内存空间中</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051035476.png\" alt=\"image-20241005103541446\"></p>\n<p>string转为[]byte的大致过程：</p>\n<ul>\n<li><p>申请一块新的内存空间</p>\n</li>\n<li><p>将string指针所指向的内存区域拷贝<code>len</code>字节到刚申请的空间中</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051037987.png\" alt=\"image-20241005103722955\"></p>\n</li>\n</ul>\n<p>⚠️：当<strong>转化为的字符串被用于临时场景时</strong>，string和[]byte之间的转换并<strong>不会发生拷贝</strong></p>\n<p>例如：</p>\n<ul>\n<li>字符串比较：string(ss) &#x3D;&#x3D; “hello”</li>\n<li>字符串拼接：”hello” + string(ss) + “world”</li>\n<li>用于查找：k, v :&#x3D; map[string(ss)]</li>\n</ul>\n<p>在上述场景中，[]byte转换的字符串只有临时作用，在后续程序中不会再次使用，所以并不会拷贝到内存，而是直接返回一个string，这个string的指针就指向字节切片的内存地址</p>\n<h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2><p>在Go语言中，slice是基于数组封装出来的抽象数据结构。因此在解析slice之前，需要先认识认识golang中的数组。</p>\n<p>Go语言中的数组是一种值类型，和C语言中的指针类型不同，所以在Go中对数组进行复制、传参都是进行<strong>值复制</strong>操作，就和<code>int</code>、<code>float64</code>这些基本数据类型类似</p>\n<p>数组类型在golang中由<strong>数组大小和数据类型</strong>共同决定，验证例子如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;arr`s type is %T&quot;</span>, arr)</span><br><span class=\"line\"><span class=\"comment\">//arr`s type is [3]int</span></span><br></pre></td></tr></table></figure>\n\n<p>正因为数组类型在初始时就被确定（大小和数据类型），所以在面对一些动态存储的场景时数组就有点力不从心了。</p>\n<p><strong>slice</strong>就是为了解决数组在长度上不可增长的问题，基于数组实现了<strong>变长数组</strong>的机制</p>\n<h3 id=\"slice底层结构\"><a href=\"#slice底层结构\" class=\"headerlink\" title=\"slice底层结构\"></a>slice底层结构</h3><p>slice底层结构如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> slice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 底层数组指针</span></span><br><span class=\"line\">    array unsafe.Pointer</span><br><span class=\"line\">    <span class=\"comment\">// slice的长度</span></span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 容量</span></span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>slice扩容两步骤：</p>\n<ol>\n<li>计算所需容量<ol>\n<li>如果<strong>新切片的长度＞旧切片的容量的两倍</strong>，那么新切片的容量等于长度</li>\n<li>否则<ol>\n<li>如果<strong>旧切片的容量＜256</strong>，那么新切片的容量就是原容量的两倍</li>\n<li>否则新切片的容量就是<strong>1.25 * 原切片容量+3&#x2F;4 * 256</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>内存对齐，确定最终容量<ol>\n<li>按照Go内存管理的级别确对齐内存，最终容量以此为准</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"slice问题解密\"><a href=\"#slice问题解密\" class=\"headerlink\" title=\"slice问题解密\"></a>slice问题解密</h3><ul>\n<li><p>slice通过函数传递的是什么？</p>\n<ul>\n<li><p>传递的是底层slice结构体的拷贝</p>\n</li>\n<li><pre><code class=\"go\">func PrintSliceStruct(s *[]int) &#123;\n    ss := (*reflect.SliceHeader)(unsafe.Pointer(s))\n    fmt.Printf(&quot;slice struct: %+v, slice is %v\\n&quot;, ss, s)\n&#125;\n\nfunc test(s []int) &#123;\n    fmt.Printf(&quot;slice address in main is %p\t&quot;, &amp;s)\n    PrintSliceStruct(&amp;s)\n&#125;\n\nfunc main() &#123;\n    s := make([]int, 5, 10)\n    fmt.Printf(&quot;slice address in main is %p\t&quot;, &amp;s)\n    PrintSliceStruct(&amp;s)\n    test(s)\n    /*\n    slice address in main is 0xc000008048\tslice struct: &amp;&#123;Data:824633788048 Len:5 Cap:10&#125;, slice is &amp;[0 0 0 0 0]\n    slice address in main is 0xc000008078\tslice struct: &amp;&#123;Data:824633788048 Len:5 Cap:10&#125;, slice is &amp;[0 0 0 0 0]\n     */\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 在函数里面改变slice，外层会受到影响吗？</span><br><span class=\"line\"></span><br><span class=\"line\">  - 只要修改的底层数组是同一个，那么就会受到影响</span><br></pre></td></tr></table></figure>\nfunc test1(s []int) &#123;\n    s[0] = 7\n    fmt.Printf(&quot;test1 value %v\\n&quot;, s)\n&#125;\n\nfunc test2(s []int) &#123;\n    s = append(s, 4)\n    fmt.Printf(&quot;test2 value %v\\n&quot;, s)\n&#125;\n\nfunc main() &#123;\n    s := []int&#123;1, 2, 3&#125;\n    fmt.Printf(&quot;initial value of s: %v\\n&quot;, s)\n    test1(s) // 底层数组相同，会受到影响\n    fmt.Printf(&quot;after test1, value of s: %v\\n&quot;, s)\n    test2(s) // 底层数组发生变化，不受影响\n    fmt.Printf(&quot;after test2, value of s: %v\\n&quot;, s)\n    /*\n    initial value of s: [1 2 3]\n    test1 value [7 2 3]\n    after test1, value of s: [7 2 3]\n    test2 value [7 2 3 4]\n    after test2, value of s: [7 2 3]\n     */\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>## sync.map\n\n这里是sync.map\n</code></pre>\n","excerpt":"","more":"<h1 id=\"Go数据结构\"><a href=\"#Go数据结构\" class=\"headerlink\" title=\"Go数据结构\"></a>Go数据结构</h1><h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><p>Go语言中，string可以看作是所有<strong>8bit 字节</strong>的集合，一个字节数组。</p>\n<ul>\n<li>字符串可以为空串，但不能为nil</li>\n<li>字符串的字面值是只读的，不可以被修改<ul>\n<li>字符串是不能被修改的，但是变量可以重新赋值</li>\n</ul>\n</li>\n</ul>\n<p>在源码中也给出了string的结构：其中<code>str</code>是<strong>指向字符串首地址的指针</strong>、<code>len</code>表示<strong>字符串的长度</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> stringStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    str unsafe.Pointer</span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>🌰：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051022321.png\" alt=\"image-20241005102225290\" style=\"zoom:67%;\" />\n\n<p>值得注意的是，<strong>len表示字符串长度是以字节数计量的</strong>，而非字符数。</p>\n<p>举个🌰：字符串<code>hello</code>的字节数和字符数是5，长度也是5；而字符串<code>hello啊</code>的字节数是8、字符数是6，而长度同字节数一样是8</p>\n<p>所以对包含非单字节编码的字符的字符串进行<code>len()</code>操作，可能会得到意想不到的结果</p>\n<h3 id=\"string和-byte的互相转换\"><a href=\"#string和-byte的互相转换\" class=\"headerlink\" title=\"string和[]byte的互相转换\"></a>string和[]byte的互相转换</h3><p>string和[]byte的转化（一般）会发生一次内存拷贝，并申请一块新的切片内存空间</p>\n<p><strong>[]byte转为string的大致过程：</strong></p>\n<ul>\n<li>申请一块新的内存空间，并记录首地址<code>addr</code>和字节长度<code>len</code></li>\n<li>构建string对象，指针地址为<code>addr</code>，<code>len</code>字段赋值为<code>len</code></li>\n<li>将源字节切片中的数据拷贝到刚申请的内存空间中</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051035476.png\" alt=\"image-20241005103541446\"></p>\n<p>string转为[]byte的大致过程：</p>\n<ul>\n<li><p>申请一块新的内存空间</p>\n</li>\n<li><p>将string指针所指向的内存区域拷贝<code>len</code>字节到刚申请的空间中</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051037987.png\" alt=\"image-20241005103722955\"></p>\n</li>\n</ul>\n<p>⚠️：当<strong>转化为的字符串被用于临时场景时</strong>，string和[]byte之间的转换并<strong>不会发生拷贝</strong></p>\n<p>例如：</p>\n<ul>\n<li>字符串比较：string(ss) &#x3D;&#x3D; “hello”</li>\n<li>字符串拼接：”hello” + string(ss) + “world”</li>\n<li>用于查找：k, v :&#x3D; map[string(ss)]</li>\n</ul>\n<p>在上述场景中，[]byte转换的字符串只有临时作用，在后续程序中不会再次使用，所以并不会拷贝到内存，而是直接返回一个string，这个string的指针就指向字节切片的内存地址</p>\n<h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2><p>在Go语言中，slice是基于数组封装出来的抽象数据结构。因此在解析slice之前，需要先认识认识golang中的数组。</p>\n<p>Go语言中的数组是一种值类型，和C语言中的指针类型不同，所以在Go中对数组进行复制、传参都是进行<strong>值复制</strong>操作，就和<code>int</code>、<code>float64</code>这些基本数据类型类似</p>\n<p>数组类型在golang中由<strong>数组大小和数据类型</strong>共同决定，验证例子如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;arr`s type is %T&quot;</span>, arr)</span><br><span class=\"line\"><span class=\"comment\">//arr`s type is [3]int</span></span><br></pre></td></tr></table></figure>\n\n<p>正因为数组类型在初始时就被确定（大小和数据类型），所以在面对一些动态存储的场景时数组就有点力不从心了。</p>\n<p><strong>slice</strong>就是为了解决数组在长度上不可增长的问题，基于数组实现了<strong>变长数组</strong>的机制</p>\n<h3 id=\"slice底层结构\"><a href=\"#slice底层结构\" class=\"headerlink\" title=\"slice底层结构\"></a>slice底层结构</h3><p>slice底层结构如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> slice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 底层数组指针</span></span><br><span class=\"line\">    array unsafe.Pointer</span><br><span class=\"line\">    <span class=\"comment\">// slice的长度</span></span><br><span class=\"line\">    <span class=\"built_in\">len</span> <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 容量</span></span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>slice扩容两步骤：</p>\n<ol>\n<li>计算所需容量<ol>\n<li>如果<strong>新切片的长度＞旧切片的容量的两倍</strong>，那么新切片的容量等于长度</li>\n<li>否则<ol>\n<li>如果<strong>旧切片的容量＜256</strong>，那么新切片的容量就是原容量的两倍</li>\n<li>否则新切片的容量就是<strong>1.25 * 原切片容量+3&#x2F;4 * 256</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>内存对齐，确定最终容量<ol>\n<li>按照Go内存管理的级别确对齐内存，最终容量以此为准</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"slice问题解密\"><a href=\"#slice问题解密\" class=\"headerlink\" title=\"slice问题解密\"></a>slice问题解密</h3><ul>\n<li><p>slice通过函数传递的是什么？</p>\n<ul>\n<li><p>传递的是底层slice结构体的拷贝</p>\n</li>\n<li><pre><code class=\"go\">func PrintSliceStruct(s *[]int) &#123;\n    ss := (*reflect.SliceHeader)(unsafe.Pointer(s))\n    fmt.Printf(&quot;slice struct: %+v, slice is %v\\n&quot;, ss, s)\n&#125;\n\nfunc test(s []int) &#123;\n    fmt.Printf(&quot;slice address in main is %p\t&quot;, &amp;s)\n    PrintSliceStruct(&amp;s)\n&#125;\n\nfunc main() &#123;\n    s := make([]int, 5, 10)\n    fmt.Printf(&quot;slice address in main is %p\t&quot;, &amp;s)\n    PrintSliceStruct(&amp;s)\n    test(s)\n    /*\n    slice address in main is 0xc000008048\tslice struct: &amp;&#123;Data:824633788048 Len:5 Cap:10&#125;, slice is &amp;[0 0 0 0 0]\n    slice address in main is 0xc000008078\tslice struct: &amp;&#123;Data:824633788048 Len:5 Cap:10&#125;, slice is &amp;[0 0 0 0 0]\n     */\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 在函数里面改变slice，外层会受到影响吗？</span><br><span class=\"line\"></span><br><span class=\"line\">  - 只要修改的底层数组是同一个，那么就会受到影响</span><br></pre></td></tr></table></figure>\nfunc test1(s []int) &#123;\n    s[0] = 7\n    fmt.Printf(&quot;test1 value %v\\n&quot;, s)\n&#125;\n\nfunc test2(s []int) &#123;\n    s = append(s, 4)\n    fmt.Printf(&quot;test2 value %v\\n&quot;, s)\n&#125;\n\nfunc main() &#123;\n    s := []int&#123;1, 2, 3&#125;\n    fmt.Printf(&quot;initial value of s: %v\\n&quot;, s)\n    test1(s) // 底层数组相同，会受到影响\n    fmt.Printf(&quot;after test1, value of s: %v\\n&quot;, s)\n    test2(s) // 底层数组发生变化，不受影响\n    fmt.Printf(&quot;after test2, value of s: %v\\n&quot;, s)\n    /*\n    initial value of s: [1 2 3]\n    test1 value [7 2 3]\n    after test1, value of s: [7 2 3]\n    test2 value [7 2 3 4]\n    after test2, value of s: [7 2 3]\n     */\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>## sync.map\n\n这里是sync.map\n</code></pre>\n"},{"description":"记录Go整洁开发的一些技巧","_content":"\n\n\n# Go实战笔记\n\n## chapter1\n\n`gin.H`本质是一个`map[string]interface{}`的类型别名。它主要用于灵活方便地构造JSON格式数据\n\n```go\nfunc main() {\n\tserver := gin.Default()\n\tserver.GET(\"/ping\", func(ctx *gin.Context) {\n\t\tctx.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\tserver.Run(\":8080\")\n}\n```\n\n## chapter2：配置\n\n**文件结构：**\n\n![image-20241113164141040](https://raw.githubusercontent.com/lyydsheep/pic/main/202411131641068.png)\n\n- 三个`yaml`文件分别对应不同的场景\n\n- config文件中定义读取配置所需的结构体类型\n\n```go\npackage config\n\nimport \"time\"\n\nvar (\n\tApp      appConfig\n\tDataBase dataBaseConfig\n)\n\ntype appConfig struct {\n\tEnv  string `yaml:\"env\"`\n\tName string `yaml:\"name\"`\n}\n\ntype dataBaseConfig struct {\n\tType        string        `yaml:\"type\"`\n\tDsn         string        `yaml:\"dsn\"`\n\tMaxOpen     int64         `yaml:\"max_open\"`\n\tMaxIdle     int64         `yaml:\"max_idle\"`\n\tMaxFileTime time.Duration `yaml:\"max_file_time\"`\n}\n```\n\n- bootstrap文件定义初始化配置的方法\n\n```go\n//go:embed *.yaml\nvar configs embed.FS\n\nfunc init() {\n\tfileName := os.Getenv(\"fileName\")\n\tfmt.Println(fileName)\n\tvp := viper.New()\n\tconfigFileStream, err := configs.ReadFile(\"application.\" + fileName + \".yaml\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvp.SetConfigType(\"yaml\")\n\terr = vp.ReadConfig(bytes.NewReader(configFileStream))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = vp.UnmarshalKey(\"app\", &App)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = vp.UnmarshalKey(\"database\", &DataBase)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n**将配置文件和项目一起打包**\n\n使用go:embed功能可以将静态文件嵌入Go项目中，这样在调用`go build .`命令后配置文件就会和项目一块打包编译成可执行文件了\n\n值得注意的是，只有在书写了go:embed的.go文件**同一级目录或子目录下**的静态文件才会被一起嵌入打包\n\n## chapter3：自定义和归档日志\n\n**两个重要的库**：[zap](https://github.com/uber-go/zap)、[umberjack](https://github.com/natefinch/lumberjack)\n\n### 日志相关配置准备\n\n**文件配置：**\n\n```yaml\napp:\n  env: \"dev\"\n  name: \"go-mall\"\n  log:\n    # 日志文件路径，从项目路径开始出发\n    path: \"./tmp/go-mall.log\"\n    # 文件最大体积（M）和有效期（Day）\n    max_size: 1\n    max_age: 60\n```\n\n**反序列化结构体：**\n\n```go\ntype appConfig struct {\n\t// 用mapstructure标签就有效\n\tEnv  string `mapstructure:\"env\"`\n\tName string `mapstructure:\"name\"`\n\tLog  struct {\n\t\tFilePath    string `mapstructure:\"path\"`\n\t\tFileMaxSize int    `mapstructure:\"max_size\"`\n\t\tFileMaxAge  int    `mapstructure:\"max_age\"`\n\t}\n}\n```\n\n### 初始化日志组件\n\n**目录结构：**\n\n![image-20241117150445307](https://raw.githubusercontent.com/lyydsheep/pic/main/202411171504369.png)\n\n- env.go中定义了不同环境的枚举值\n  - ![image-20241117183814150](https://raw.githubusercontent.com/lyydsheep/pic/main/202411171838214.png)\n\n- zap.go中对**全局日志变量**进行初始化：这里使用Go自带的init方法进行初始化，也可以自己封装一个Init函数，在项目中手动调用函数完成初始化操作\n  - 使用Go自带的init方法的弊端在于有的代码逻辑依赖于各个init的执行顺序，而这种初始化方法难以确保初始化顺序\n\n```go\n// zap只会当做基础Logger，所以只把该变量定义成包内访问的全局变量\nvar Logger *zap.Logger\n\nfunc init() {\n\t// 配置encoder信息\n\tcfg := zap.NewProductionEncoderConfig()\n\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder\n\tcfg.TimeKey = \"time\"\n\tcfg.MessageKey = \"msg\"\n\tencoder := zapcore.NewJSONEncoder(cfg)\n\tfileWriter := getFileLogWriter()\n\tvar cores []zapcore.Core\n\tswitch config.App.Env {\n\tcase enum.ModeTest, enum.ModeProd:\n\t\t// 测试、生产环境仅将info级别级以上日志写入文件\n\t\tcores = append(cores, zapcore.NewCore(encoder, fileWriter, zapcore.InfoLevel))\n\tcase enum.ModeDev:\n\t\t// 本地环境将所有的日志写入文件和控制台\n\t\tcores = append(cores, zapcore.NewCore(encoder, fileWriter, zapcore.DebugLevel),\n\t\t\tzapcore.NewCore(encoder, zapcore.WriteSyncer(os.Stdout), zapcore.DebugLevel))\n\tdefault:\n\t\tpanic(\"config.App.Env is invalid\")\n\t}\n\t// 类型定义实现接口\n\tcore := zapcore.NewTee(cores...)\n\tLogger = zap.New(core)\n}\n\nfunc getFileLogWriter() zapcore.WriteSyncer {\n\treturn zapcore.AddSync(&lumberjack.Logger{\n\t\tFilename:  config.App.Log.FilePath,\n\t\tMaxAge:    config.App.Log.FileMaxAge,\n\t\tMaxSize:   config.App.Log.FileMaxSize,\n\t\tCompress:  false,\n\t\tLocalTime: true,\n\t})\n}\n```\n\n","source":"_posts/Go/Go电商实战笔记.md","raw":"---\ndescription: 记录Go整洁开发的一些技巧\ntags:\n- Go\n- 项目\n---\n\n\n\n# Go实战笔记\n\n## chapter1\n\n`gin.H`本质是一个`map[string]interface{}`的类型别名。它主要用于灵活方便地构造JSON格式数据\n\n```go\nfunc main() {\n\tserver := gin.Default()\n\tserver.GET(\"/ping\", func(ctx *gin.Context) {\n\t\tctx.JSON(http.StatusOK, gin.H{\n\t\t\t\"message\": \"pong\",\n\t\t})\n\t})\n\tserver.Run(\":8080\")\n}\n```\n\n## chapter2：配置\n\n**文件结构：**\n\n![image-20241113164141040](https://raw.githubusercontent.com/lyydsheep/pic/main/202411131641068.png)\n\n- 三个`yaml`文件分别对应不同的场景\n\n- config文件中定义读取配置所需的结构体类型\n\n```go\npackage config\n\nimport \"time\"\n\nvar (\n\tApp      appConfig\n\tDataBase dataBaseConfig\n)\n\ntype appConfig struct {\n\tEnv  string `yaml:\"env\"`\n\tName string `yaml:\"name\"`\n}\n\ntype dataBaseConfig struct {\n\tType        string        `yaml:\"type\"`\n\tDsn         string        `yaml:\"dsn\"`\n\tMaxOpen     int64         `yaml:\"max_open\"`\n\tMaxIdle     int64         `yaml:\"max_idle\"`\n\tMaxFileTime time.Duration `yaml:\"max_file_time\"`\n}\n```\n\n- bootstrap文件定义初始化配置的方法\n\n```go\n//go:embed *.yaml\nvar configs embed.FS\n\nfunc init() {\n\tfileName := os.Getenv(\"fileName\")\n\tfmt.Println(fileName)\n\tvp := viper.New()\n\tconfigFileStream, err := configs.ReadFile(\"application.\" + fileName + \".yaml\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvp.SetConfigType(\"yaml\")\n\terr = vp.ReadConfig(bytes.NewReader(configFileStream))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = vp.UnmarshalKey(\"app\", &App)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = vp.UnmarshalKey(\"database\", &DataBase)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n**将配置文件和项目一起打包**\n\n使用go:embed功能可以将静态文件嵌入Go项目中，这样在调用`go build .`命令后配置文件就会和项目一块打包编译成可执行文件了\n\n值得注意的是，只有在书写了go:embed的.go文件**同一级目录或子目录下**的静态文件才会被一起嵌入打包\n\n## chapter3：自定义和归档日志\n\n**两个重要的库**：[zap](https://github.com/uber-go/zap)、[umberjack](https://github.com/natefinch/lumberjack)\n\n### 日志相关配置准备\n\n**文件配置：**\n\n```yaml\napp:\n  env: \"dev\"\n  name: \"go-mall\"\n  log:\n    # 日志文件路径，从项目路径开始出发\n    path: \"./tmp/go-mall.log\"\n    # 文件最大体积（M）和有效期（Day）\n    max_size: 1\n    max_age: 60\n```\n\n**反序列化结构体：**\n\n```go\ntype appConfig struct {\n\t// 用mapstructure标签就有效\n\tEnv  string `mapstructure:\"env\"`\n\tName string `mapstructure:\"name\"`\n\tLog  struct {\n\t\tFilePath    string `mapstructure:\"path\"`\n\t\tFileMaxSize int    `mapstructure:\"max_size\"`\n\t\tFileMaxAge  int    `mapstructure:\"max_age\"`\n\t}\n}\n```\n\n### 初始化日志组件\n\n**目录结构：**\n\n![image-20241117150445307](https://raw.githubusercontent.com/lyydsheep/pic/main/202411171504369.png)\n\n- env.go中定义了不同环境的枚举值\n  - ![image-20241117183814150](https://raw.githubusercontent.com/lyydsheep/pic/main/202411171838214.png)\n\n- zap.go中对**全局日志变量**进行初始化：这里使用Go自带的init方法进行初始化，也可以自己封装一个Init函数，在项目中手动调用函数完成初始化操作\n  - 使用Go自带的init方法的弊端在于有的代码逻辑依赖于各个init的执行顺序，而这种初始化方法难以确保初始化顺序\n\n```go\n// zap只会当做基础Logger，所以只把该变量定义成包内访问的全局变量\nvar Logger *zap.Logger\n\nfunc init() {\n\t// 配置encoder信息\n\tcfg := zap.NewProductionEncoderConfig()\n\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder\n\tcfg.TimeKey = \"time\"\n\tcfg.MessageKey = \"msg\"\n\tencoder := zapcore.NewJSONEncoder(cfg)\n\tfileWriter := getFileLogWriter()\n\tvar cores []zapcore.Core\n\tswitch config.App.Env {\n\tcase enum.ModeTest, enum.ModeProd:\n\t\t// 测试、生产环境仅将info级别级以上日志写入文件\n\t\tcores = append(cores, zapcore.NewCore(encoder, fileWriter, zapcore.InfoLevel))\n\tcase enum.ModeDev:\n\t\t// 本地环境将所有的日志写入文件和控制台\n\t\tcores = append(cores, zapcore.NewCore(encoder, fileWriter, zapcore.DebugLevel),\n\t\t\tzapcore.NewCore(encoder, zapcore.WriteSyncer(os.Stdout), zapcore.DebugLevel))\n\tdefault:\n\t\tpanic(\"config.App.Env is invalid\")\n\t}\n\t// 类型定义实现接口\n\tcore := zapcore.NewTee(cores...)\n\tLogger = zap.New(core)\n}\n\nfunc getFileLogWriter() zapcore.WriteSyncer {\n\treturn zapcore.AddSync(&lumberjack.Logger{\n\t\tFilename:  config.App.Log.FilePath,\n\t\tMaxAge:    config.App.Log.FileMaxAge,\n\t\tMaxSize:   config.App.Log.FileMaxSize,\n\t\tCompress:  false,\n\t\tLocalTime: true,\n\t})\n}\n```\n\n","slug":"Go/Go电商实战笔记","published":1,"date":"2024-12-27T11:03:15.342Z","updated":"2024-12-27T11:03:15.342Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m001za5t2ex0zfbv6","content":"<h1 id=\"Go实战笔记\"><a href=\"#Go实战笔记\" class=\"headerlink\" title=\"Go实战笔记\"></a>Go实战笔记</h1><h2 id=\"chapter1\"><a href=\"#chapter1\" class=\"headerlink\" title=\"chapter1\"></a>chapter1</h2><p><code>gin.H</code>本质是一个<code>map[string]interface&#123;&#125;</code>的类型别名。它主要用于灵活方便地构造JSON格式数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tserver := gin.Default()</span><br><span class=\"line\">\tserver.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tserver.Run(<span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"chapter2：配置\"><a href=\"#chapter2：配置\" class=\"headerlink\" title=\"chapter2：配置\"></a>chapter2：配置</h2><p><strong>文件结构：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411131641068.png\" alt=\"image-20241113164141040\"></p>\n<ul>\n<li><p>三个<code>yaml</code>文件分别对应不同的场景</p>\n</li>\n<li><p>config文件中定义读取配置所需的结构体类型</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tApp      appConfig</span><br><span class=\"line\">\tDataBase dataBaseConfig</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> appConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tEnv  <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;env&quot;`</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;name&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> dataBaseConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tType        <span class=\"type\">string</span>        <span class=\"string\">`yaml:&quot;type&quot;`</span></span><br><span class=\"line\">\tDsn         <span class=\"type\">string</span>        <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">\tMaxOpen     <span class=\"type\">int64</span>         <span class=\"string\">`yaml:&quot;max_open&quot;`</span></span><br><span class=\"line\">\tMaxIdle     <span class=\"type\">int64</span>         <span class=\"string\">`yaml:&quot;max_idle&quot;`</span></span><br><span class=\"line\">\tMaxFileTime time.Duration <span class=\"string\">`yaml:&quot;max_file_time&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>bootstrap文件定义初始化配置的方法</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed *.yaml</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> configs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfileName := os.Getenv(<span class=\"string\">&quot;fileName&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(fileName)</span><br><span class=\"line\">\tvp := viper.New()</span><br><span class=\"line\">\tconfigFileStream, err := configs.ReadFile(<span class=\"string\">&quot;application.&quot;</span> + fileName + <span class=\"string\">&quot;.yaml&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvp.SetConfigType(<span class=\"string\">&quot;yaml&quot;</span>)</span><br><span class=\"line\">\terr = vp.ReadConfig(bytes.NewReader(configFileStream))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = vp.UnmarshalKey(<span class=\"string\">&quot;app&quot;</span>, &amp;App)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = vp.UnmarshalKey(<span class=\"string\">&quot;database&quot;</span>, &amp;DataBase)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>将配置文件和项目一起打包</strong></p>\n<p>使用go:embed功能可以将静态文件嵌入Go项目中，这样在调用<code>go build .</code>命令后配置文件就会和项目一块打包编译成可执行文件了</p>\n<p>值得注意的是，只有在书写了go:embed的.go文件<strong>同一级目录或子目录下</strong>的静态文件才会被一起嵌入打包</p>\n<h2 id=\"chapter3：自定义和归档日志\"><a href=\"#chapter3：自定义和归档日志\" class=\"headerlink\" title=\"chapter3：自定义和归档日志\"></a>chapter3：自定义和归档日志</h2><p><strong>两个重要的库</strong>：<a href=\"https://github.com/uber-go/zap\">zap</a>、<a href=\"https://github.com/natefinch/lumberjack\">umberjack</a></p>\n<h3 id=\"日志相关配置准备\"><a href=\"#日志相关配置准备\" class=\"headerlink\" title=\"日志相关配置准备\"></a>日志相关配置准备</h3><p><strong>文件配置：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">app:</span></span><br><span class=\"line\">  <span class=\"attr\">env:</span> <span class=\"string\">&quot;dev&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">&quot;go-mall&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">log:</span></span><br><span class=\"line\">    <span class=\"comment\"># 日志文件路径，从项目路径开始出发</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./tmp/go-mall.log&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 文件最大体积（M）和有效期（Day）</span></span><br><span class=\"line\">    <span class=\"attr\">max_size:</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"attr\">max_age:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>反序列化结构体：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> appConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用mapstructure标签就有效</span></span><br><span class=\"line\">\tEnv  <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;env&quot;`</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;name&quot;`</span></span><br><span class=\"line\">\tLog  <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tFilePath    <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;path&quot;`</span></span><br><span class=\"line\">\t\tFileMaxSize <span class=\"type\">int</span>    <span class=\"string\">`mapstructure:&quot;max_size&quot;`</span></span><br><span class=\"line\">\t\tFileMaxAge  <span class=\"type\">int</span>    <span class=\"string\">`mapstructure:&quot;max_age&quot;`</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化日志组件\"><a href=\"#初始化日志组件\" class=\"headerlink\" title=\"初始化日志组件\"></a>初始化日志组件</h3><p><strong>目录结构：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411171504369.png\" alt=\"image-20241117150445307\"></p>\n<ul>\n<li><p>env.go中定义了不同环境的枚举值</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411171838214.png\" alt=\"image-20241117183814150\"></li>\n</ul>\n</li>\n<li><p>zap.go中对<strong>全局日志变量</strong>进行初始化：这里使用Go自带的init方法进行初始化，也可以自己封装一个Init函数，在项目中手动调用函数完成初始化操作</p>\n<ul>\n<li>使用Go自带的init方法的弊端在于有的代码逻辑依赖于各个init的执行顺序，而这种初始化方法难以确保初始化顺序</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zap只会当做基础Logger，所以只把该变量定义成包内访问的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Logger *zap.Logger</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 配置encoder信息</span></span><br><span class=\"line\">\tcfg := zap.NewProductionEncoderConfig()</span><br><span class=\"line\">\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class=\"line\">\tcfg.TimeKey = <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">\tcfg.MessageKey = <span class=\"string\">&quot;msg&quot;</span></span><br><span class=\"line\">\tencoder := zapcore.NewJSONEncoder(cfg)</span><br><span class=\"line\">\tfileWriter := getFileLogWriter()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> cores []zapcore.Core</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> config.App.Env &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> enum.ModeTest, enum.ModeProd:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 测试、生产环境仅将info级别级以上日志写入文件</span></span><br><span class=\"line\">\t\tcores = <span class=\"built_in\">append</span>(cores, zapcore.NewCore(encoder, fileWriter, zapcore.InfoLevel))</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> enum.ModeDev:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 本地环境将所有的日志写入文件和控制台</span></span><br><span class=\"line\">\t\tcores = <span class=\"built_in\">append</span>(cores, zapcore.NewCore(encoder, fileWriter, zapcore.DebugLevel),</span><br><span class=\"line\">\t\t\tzapcore.NewCore(encoder, zapcore.WriteSyncer(os.Stdout), zapcore.DebugLevel))</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;config.App.Env is invalid&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 类型定义实现接口</span></span><br><span class=\"line\">\tcore := zapcore.NewTee(cores...)</span><br><span class=\"line\">\tLogger = zap.New(core)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFileLogWriter</span><span class=\"params\">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> zapcore.AddSync(&amp;lumberjack.Logger&#123;</span><br><span class=\"line\">\t\tFilename:  config.App.Log.FilePath,</span><br><span class=\"line\">\t\tMaxAge:    config.App.Log.FileMaxAge,</span><br><span class=\"line\">\t\tMaxSize:   config.App.Log.FileMaxSize,</span><br><span class=\"line\">\t\tCompress:  <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tLocalTime: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"Go实战笔记\"><a href=\"#Go实战笔记\" class=\"headerlink\" title=\"Go实战笔记\"></a>Go实战笔记</h1><h2 id=\"chapter1\"><a href=\"#chapter1\" class=\"headerlink\" title=\"chapter1\"></a>chapter1</h2><p><code>gin.H</code>本质是一个<code>map[string]interface&#123;&#125;</code>的类型别名。它主要用于灵活方便地构造JSON格式数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tserver := gin.Default()</span><br><span class=\"line\">\tserver.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusOK, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tserver.Run(<span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"chapter2：配置\"><a href=\"#chapter2：配置\" class=\"headerlink\" title=\"chapter2：配置\"></a>chapter2：配置</h2><p><strong>文件结构：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411131641068.png\" alt=\"image-20241113164141040\"></p>\n<ul>\n<li><p>三个<code>yaml</code>文件分别对应不同的场景</p>\n</li>\n<li><p>config文件中定义读取配置所需的结构体类型</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tApp      appConfig</span><br><span class=\"line\">\tDataBase dataBaseConfig</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> appConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tEnv  <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;env&quot;`</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;name&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> dataBaseConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tType        <span class=\"type\">string</span>        <span class=\"string\">`yaml:&quot;type&quot;`</span></span><br><span class=\"line\">\tDsn         <span class=\"type\">string</span>        <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">\tMaxOpen     <span class=\"type\">int64</span>         <span class=\"string\">`yaml:&quot;max_open&quot;`</span></span><br><span class=\"line\">\tMaxIdle     <span class=\"type\">int64</span>         <span class=\"string\">`yaml:&quot;max_idle&quot;`</span></span><br><span class=\"line\">\tMaxFileTime time.Duration <span class=\"string\">`yaml:&quot;max_file_time&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>bootstrap文件定义初始化配置的方法</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go:embed *.yaml</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> configs embed.FS</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfileName := os.Getenv(<span class=\"string\">&quot;fileName&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(fileName)</span><br><span class=\"line\">\tvp := viper.New()</span><br><span class=\"line\">\tconfigFileStream, err := configs.ReadFile(<span class=\"string\">&quot;application.&quot;</span> + fileName + <span class=\"string\">&quot;.yaml&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvp.SetConfigType(<span class=\"string\">&quot;yaml&quot;</span>)</span><br><span class=\"line\">\terr = vp.ReadConfig(bytes.NewReader(configFileStream))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = vp.UnmarshalKey(<span class=\"string\">&quot;app&quot;</span>, &amp;App)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = vp.UnmarshalKey(<span class=\"string\">&quot;database&quot;</span>, &amp;DataBase)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>将配置文件和项目一起打包</strong></p>\n<p>使用go:embed功能可以将静态文件嵌入Go项目中，这样在调用<code>go build .</code>命令后配置文件就会和项目一块打包编译成可执行文件了</p>\n<p>值得注意的是，只有在书写了go:embed的.go文件<strong>同一级目录或子目录下</strong>的静态文件才会被一起嵌入打包</p>\n<h2 id=\"chapter3：自定义和归档日志\"><a href=\"#chapter3：自定义和归档日志\" class=\"headerlink\" title=\"chapter3：自定义和归档日志\"></a>chapter3：自定义和归档日志</h2><p><strong>两个重要的库</strong>：<a href=\"https://github.com/uber-go/zap\">zap</a>、<a href=\"https://github.com/natefinch/lumberjack\">umberjack</a></p>\n<h3 id=\"日志相关配置准备\"><a href=\"#日志相关配置准备\" class=\"headerlink\" title=\"日志相关配置准备\"></a>日志相关配置准备</h3><p><strong>文件配置：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">app:</span></span><br><span class=\"line\">  <span class=\"attr\">env:</span> <span class=\"string\">&quot;dev&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">&quot;go-mall&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">log:</span></span><br><span class=\"line\">    <span class=\"comment\"># 日志文件路径，从项目路径开始出发</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./tmp/go-mall.log&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 文件最大体积（M）和有效期（Day）</span></span><br><span class=\"line\">    <span class=\"attr\">max_size:</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"attr\">max_age:</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>反序列化结构体：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> appConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用mapstructure标签就有效</span></span><br><span class=\"line\">\tEnv  <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;env&quot;`</span></span><br><span class=\"line\">\tName <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;name&quot;`</span></span><br><span class=\"line\">\tLog  <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tFilePath    <span class=\"type\">string</span> <span class=\"string\">`mapstructure:&quot;path&quot;`</span></span><br><span class=\"line\">\t\tFileMaxSize <span class=\"type\">int</span>    <span class=\"string\">`mapstructure:&quot;max_size&quot;`</span></span><br><span class=\"line\">\t\tFileMaxAge  <span class=\"type\">int</span>    <span class=\"string\">`mapstructure:&quot;max_age&quot;`</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化日志组件\"><a href=\"#初始化日志组件\" class=\"headerlink\" title=\"初始化日志组件\"></a>初始化日志组件</h3><p><strong>目录结构：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411171504369.png\" alt=\"image-20241117150445307\"></p>\n<ul>\n<li><p>env.go中定义了不同环境的枚举值</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202411171838214.png\" alt=\"image-20241117183814150\"></li>\n</ul>\n</li>\n<li><p>zap.go中对<strong>全局日志变量</strong>进行初始化：这里使用Go自带的init方法进行初始化，也可以自己封装一个Init函数，在项目中手动调用函数完成初始化操作</p>\n<ul>\n<li>使用Go自带的init方法的弊端在于有的代码逻辑依赖于各个init的执行顺序，而这种初始化方法难以确保初始化顺序</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zap只会当做基础Logger，所以只把该变量定义成包内访问的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Logger *zap.Logger</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 配置encoder信息</span></span><br><span class=\"line\">\tcfg := zap.NewProductionEncoderConfig()</span><br><span class=\"line\">\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class=\"line\">\tcfg.TimeKey = <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">\tcfg.MessageKey = <span class=\"string\">&quot;msg&quot;</span></span><br><span class=\"line\">\tencoder := zapcore.NewJSONEncoder(cfg)</span><br><span class=\"line\">\tfileWriter := getFileLogWriter()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> cores []zapcore.Core</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> config.App.Env &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> enum.ModeTest, enum.ModeProd:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 测试、生产环境仅将info级别级以上日志写入文件</span></span><br><span class=\"line\">\t\tcores = <span class=\"built_in\">append</span>(cores, zapcore.NewCore(encoder, fileWriter, zapcore.InfoLevel))</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> enum.ModeDev:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 本地环境将所有的日志写入文件和控制台</span></span><br><span class=\"line\">\t\tcores = <span class=\"built_in\">append</span>(cores, zapcore.NewCore(encoder, fileWriter, zapcore.DebugLevel),</span><br><span class=\"line\">\t\t\tzapcore.NewCore(encoder, zapcore.WriteSyncer(os.Stdout), zapcore.DebugLevel))</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;config.App.Env is invalid&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 类型定义实现接口</span></span><br><span class=\"line\">\tcore := zapcore.NewTee(cores...)</span><br><span class=\"line\">\tLogger = zap.New(core)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFileLogWriter</span><span class=\"params\">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> zapcore.AddSync(&amp;lumberjack.Logger&#123;</span><br><span class=\"line\">\t\tFilename:  config.App.Log.FilePath,</span><br><span class=\"line\">\t\tMaxAge:    config.App.Log.FileMaxAge,</span><br><span class=\"line\">\t\tMaxSize:   config.App.Log.FileMaxSize,</span><br><span class=\"line\">\t\tCompress:  <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tLocalTime: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Golang之接入日志模块","publish":true,"description":"记录Go项目中接入日志模块","date":"2024-08-20T10:29:00.000Z","_content":"\n# 接入日志模块\n\n## 日志通用理论\n\n### 级别\n\n**DEBUG**：记录一些辅助排查问题的信息。一般不会在线上使用\n\n**INFO**：中性地描述发送了什么。线上一般都是用这个级别\n\n**WARN**：系统发生了一些不好但是能够容忍的事情。至少会打印这个级别的日志\n\n**ERROR**：系统发生了一些需要保持关注的事情\n\n### 什么时候打日志？打什么级别？\n\n两个原则\n\n- **如果怀疑某个地方要不要打日志，那就打上**\n- **宁滥勿缺，宁愿多打一些日志，也不要偷懒**\n\n\n\n前人的经验\n\n- **统一利用AOP机制，记录任何与第三方打交道的请求与响应**，包括数据库、缓存、RPC调用，使用**DEBUG**级别记录日志\n- **统一利用AOP机制，记录系统接收的请求与放回的响应**，使用**DEBUG**级别\n- 在开发阶段，使用**DEBUG**级别记录中间**流程中的关键结果**\n- 怀疑系统可能有问题，但是问题又不大，记录WARN\n- 任何不可能出现问题，或者表达**有人攻击系统**的地方，记录**ERROR**\n\n## 接入日志模块\n\n在Go里面，可以使用zap作为日志框架\n\n[uber-go/zap: Blazing fast, structured, leveled logging in Go. (github.com)](https://github.com/uber-go/zap)\n\n**初始化方法：**\n\n- 直接设置一个全局的logger即可\n\n```go\n\tlogger, err := zap.NewDevelopment()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tzap.ReplaceGlobals(logger)\n```\n\nzap中含有一个全局的`globalL`变量，但是这个全局变量什么功能都木有实现，也就是说，它连打印日志的功能都没有\n\n![屏幕截图 2024-09-02 193645](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939910.png)\n\n因此需要使用`NewDevelopment()`方法创建一个可以使用的`logger`并替换掉全局变量的初始值\n\n![屏幕截图 2024-09-02 193655](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939433.png)\n\n### 打印日志的基本操作——Error\n\n当出现像是系统错误时，就能打印Error级别的日志\n\n```go\n\tif err != nil {\n\t\tctx.JSON(http.StatusOK, Result{Code: 5, Msg: \"系统错误\"})\n\t\tzap.L().Error(\"vcxnq[nzvx 用户手机号码登录失败\", zap.Error(err))\n\t\treturn\n\t}\n```\n\n打印日志不仅能传入msg信息，还能够传入一些`error`、`int`之类的字段，最终打印结果形如下图：\n\n![屏幕截图 2024-09-02 194610](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021953667.png)\n\n注意几个细节：\n\n- 敏感数据（例如手机号码）不能打入日志，勉强能够接受使用debug级别打印敏感数据用于本地开发\n- msg要有足够定位bug出处的信息，例如在日志中用一段乱码唯一标识日志，这样只需要全局检索这段乱码就能找到出错的位置\n- 绝对不能把error返回给前端，暴露给用户\n\n### 打印日志的基本操作——Warn\n\n![image-20240902200117065](https://raw.githubusercontent.com/lyydsheep/pic/main/202409022001108.png)\n\n在此处打印了一个Warn日志，因为短信发送频繁是**偶尔**会发生的，**能够接受**。但要是**频繁出现Warn**，就很有可能是有人在攻击系统，那就要**告警引起注意了**\n\n###   打印日志的基本操作——Info\n\nInfo日志用于记录一些**中性信息**，例如\n\n![image-20240902203836373](https://raw.githubusercontent.com/lyydsheep/pic/main/202409022038436.png)\n\n### 打印日志的基本操作——Debug\n\nDebug日志可以用于记录和第三方交互的动作\n\n```go\nfunc (s *Service) Send(ctx context.Context, tpl string, args []sms.NameData, numbers ...string) error {\n\tzap.L().Debug(\"avnasio 即将发送短信\", zap.String(\"tpl\", tpl), zap.Any(\"args\", args))\n\terr := s.svc.Send(ctx, tpl, args, numbers...)\n\tif err != nil {\n\t\tzap.L().Debug(\"发送短信出现异常\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn err\n}\n```\n\n可以考虑使用装饰器模式扩展`Write()`方法的功能\n\n例如，自动将key为phone的字段进行数据脱敏\n\n```go\ntype MyCore struct {\n\tzapcore.Core\n}\n\nfunc (c *MyCore) Write(e zapcore.Entry, fs []zapcore.Field) error {\n\t// 装饰器模式，进行数据脱敏\n\tfor _, f := range fs {\n\t\tif f.Key == \"phone\" {\n\t\t\tnumber := f.String\n\t\t\tf.String = number[:3] + \"****\" + number[7:]\n\t\t}\n\t}\n\treturn c.Core.Write(e, fs)\n}\n```\n\n\n\n装饰器模式实现一个core，能够自动将key为phone的字段对应的值进行脱敏\n\n### 不使用包变量——保持依赖注入风格\n\n有的时候不同的业务不愿意共享同一个全局的logger，这个时候就需要在不同地方创建属于他们自己的logger\n\n一个很直接的方法就是在service层添加logger字段，为不同业务引入各自的logger，并且保持着依赖注入的风格\n\n![屏幕截图 2024-09-03 214039](https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144169.png)\n\n![](https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144084.png)\n\n还有一种更简单的依赖注入方法：**注入了，但是没有完全注入**\n\n这种做法的好处就是，为将来扩展留下了可操作的空间\n\n```go\nfunc NewUserService(repo repository.UserRepository) UserService {\n\treturn &BasicUserService{\n\t\trepo:   repo,\n        // 预留了变动的空间\n        logger: zap.L(),\n\t}\n}\n```\n\n### 抽象日志API\n\n做到这里不难发现，不管是配置模块也好，日志模块也好，我们的代码都强耦合viper框架和zap框架。这就会有潜在的风险：万一连viper和zap框架都想换掉呢？\n\n因此，我们需要定义自己logger接口，弱化对zap框架的依赖\n\n具体有三种风格\n\n- ```go\n  type Logger interface {\n  \tDebug(msg string, args...any)\n  \tInfo(msg string, args...any)\n  \tWarn(msg string, args...any)\n  \tError(msg string, args...any)\n  }\n  \n  func Example() {\n  \tvar l Logger\n  \t// 在msg中留有占位符\n  \tl.Info(\"用户未注册，用户信息为 %v\", \"ababab\")\n  }\n  ```\n\n- ```go\n  type LoggerV1 interface {\n  \tDebug(msg string, args ...Field)\n  \tInfo(msg string, args ...Field)\n  \tWarn(msg string, args ...Field)\n  \tError(msg string, args ...Field)\n  }\n  \n  type Field struct {\n  \tKey string\n  \tVal any\n  }\n  \n  func ExampleV1() {\n  \tvar l LoggerV1\n  \t// 输出的val有对应的key，和zap采用相同的模式\n  \tl.Info(\"这个msg\", Field{Key: \"这个是key\", Val: \"这个是Val\"})\n  }\n  \n  ```\n\n- ```go\n  // LoggerV2 要求args的个数是偶数，以key-val形式交替出现\n  type LoggerV2 interface {\n  \tDebug(msg string, args ...any)\n  \tInfo(msg string, args ...any)\n  \tWarn(msg string, args ...any)\n  \tError(msg string, args ...any)\n  }\n  \n  func ExampleV2() {\n  \tvar l LoggerV2\n  \tl.Info(\"这是msg\", \"key\", \"val\")\n  }\n  ```\n\n- 第一种风格**兼容性最好**\n- 第二种风格认同**参数就应该有个名字**\n- 第三种风格**如果有完善的代码评审流程的话可以考虑考虑**，不然不推荐\n\n### 适配器模式\n\n既然已经抽象出了日志接口，那么具体该如何实现呢？\n\n答案就是采用**适配器模式**\n\n所谓适配器模式，就是**将一个类型适配到另一个接口上**。例如，将A适配到B，这里的A可以是接口，也可以是一个具体的类型\n\n**典型的使用场景**\n\n- 有两个用途类似，但是细节上略有不同的接口，将一个接口适配到另一个接口上\n- 由于版本迭代，出现了两个接口，需要将一个接口适配到另一个接口上\n\n**与装饰器模式的区别**\n\n- 装饰器模式用于**扩展功能**，自始至终**都是一个接口**\n- 适配器模式**必然是两个不同的接口**\n\n### 利用Gin的middleware打印日志\n\n在handler文件中，有很多个方法，如果一一为这些方法打印日志需要花费很多时间和精力\n\n可是发现，handler中的方法都是与请求和响应有关的，那么就可以采用`AOP`机制，利用gin的middleware来统一打日志\n\n#### 使用builder模式构建中间件\n\n```go\n// 几个注意点：\n// 小心日志内容过多：URL可能很长，请求体、响应体都可能特别特别大，需要考虑是否要进行截取\n// 用户可能换用不同的日志框架，所以要有足够的灵活性\n// 考虑结合viper实现动态开关，但是要小心并发安全\nfunc (b *Builder) Build() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tstart := time.Now()\n\t\tal := AccessLog{}\n\t\tal.Method = ctx.Request.Method\n\t\tif b.allowURL && ctx.Request.URL != nil {\n\t\t\turl := ctx.Request.URL.String()\n\t\t\tif len(url) > 1024 {\n\t\t\t\turl = url[:1024]\n\t\t\t}\n\t\t\tal.URL = url\n\t\t}\n\t\tif b.allowReqBody && ctx.Request.Body != nil {\n\t\t\t// 这里忽略错误，毕竟我只是打印个日志，有错误也无所谓了\n\t\t\tdata, _ := ctx.GetRawData()\n\t\t\t// Request.Body是一个流对象，读完之后Request里面就木有了\n\t\t\t// 所以还得把数据放回Request.Body，不然后续步骤就读不到这个数据了\n\t\t\tctx.Request.Body = io.NopCloser(bytes.NewBuffer(data))\n\t\t\tbody := string(data)\n\t\t\tif len(body) > 1024 {\n\t\t\t\tal.ReqBody = body\n\t\t\t}\n\t\t}\n\t\t// defer 打日志，即使有panic也不会影响日志的输出\n\t\tdefer func() {\n\t\t\tal.Duration = time.Since(start).String()\n\t\t\t// 具体怎么打印日志，由用户决定\n\t\t\tb.logFunc(ctx, al)\n\t\t}()\n\t\t// 执行到业务代码（不是很懂）\n\t\tctx.Next()\n\t}\n}\n\ntype AccessLog struct {\n\t// 请求方法\n\tMethod string\n\t// url\n\tURL string\n\t// 请求体\n\tReqBody string\n\t// 处理时间\n\tDuration string\n\t// 响应体\n\tRespBody string\n}\n```\n\n**一个有意思的点：为什么要让用户传进来一个打日志的方法呢？**\n\n如果不传递方法，那么在实现中不管我们是用`Info()`、`Debug()`还是`Error()`都是写死在代码中的，不能灵活地应对不同的场景，例如开发环境要用`Debug()`，可能线上环境我就要用`Info()`了\n\n那么不如就让用户传进来一个方法，只为用户提供一个接口，屏蔽底层的实现，用户只需要考虑在不同环境选择使用不同的方法就行了\n\n#### 打印响应\n\n正常来说，打印响应就应该和上文中打印请求一样简单：直接从`context`里面拿请求就行\n\n不幸的是，`ctx`并没有暴露出`Response`，也就是不能直接读响应\n\n但是，`ctx`暴露出了`ResponseWriter`，这个接口是用来写响应的。那么我们可以“**偷梁换柱**”，将这个接口换成我们自己的实现：**在写响应之前将数据保留下来，这样就有了响应的具体数据**\n\n在这里我们只需要重写`WriteHeader`、`Write`、`WriteString`这三个方法，所以装饰器模式在实现的时候可以采用组合的方式\n\n- 组合 ---> 装饰部分方法\n- 非组合 ---> 装饰全部方法\n\n```go\nif b.allowRespBody {\n\t// 偷梁换柱\n\tctx.Writer = &responseWriter{\n\t\tal: &al,\n\t\tResponseWriter: ctx.Writer,\n\t}\n}\n\ntype responseWriter struct {\n\t// 这里用指针，为了能留住“偷”过来的数据\n\tal *AccessLog\n\tgin.ResponseWriter\n}\n\nfunc (r *responseWriter) WriteString(data string) (int, error) {\n\tr.al.RespBody = data\n\treturn r.ResponseWriter.WriteString(data)\n}\n\nfunc (r *responseWriter) Write(data []byte) (int, error) {\n\tr.al.RespBody = string(data)\n\treturn r.ResponseWriter.Write(data)\n}\n\nfunc (r *responseWriter) WriteHeader(statusCode int) {\n\tr.al.Status = statusCode\n\tr.ResponseWriter.WriteHeader(statusCode)\n}\n```\n\n### GORM打印日志\n\n直接上代码：\n\n```go\n// 衍生类型，有点像适配器模式\ntype gormLoggerFunc func(msg string, fields ...zap.Field)\n\n// Printf 实现单接口\nfunc (g gormLoggerFunc) Printf(msg string, fields ...interface{}) {\n\tg(msg, zap.Any(\"args\", fields))\n}\n\n\n\nfunc InitDB(l *zap.Logger) *gorm.DB {\n\ttype Config struct {\n\t\tDSN string `yaml:\"dsn\"`\n\t}\n\tvar config Config\n\tconfig.DSN = \"abab\"\n\terr := viper.UnmarshalKey(\"db\", &config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdb, err := gorm.Open(mysql.Open(config.DSN), &gorm.Config{\n\t\t// 强制类型转换\n\t\tLogger: logger.New(gormLoggerFunc(l.Debug), logger.Config{\n\t\t\t// 慢查询阈值，只有语句执行时间超过这个阈值才会打印日志\n            // 一般为50ms 100ms，一次磁盘io操作大概是10ms\n\t\t\tSlowThreshold:             time.Millisecond * 10,\n\t\t\tLogLevel:                  logger.Info,\n\t\t\tIgnoreRecordNotFoundError: true,\n\t\t\tParameterizedQueries:      true,\n\t\t}),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = dao.InitTable(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn db\n}\n\n```\n\ngorm已经为我们提供了有关日志的配置，所以我们可以直接使用配置实现打日志功能\n\n这里有个小问题，`logger.New()`方法的第一个参数要求传入`Writer`接口的实现，这个实现将会用来输出日志\n\n![image-20240907163634983](https://raw.githubusercontent.com/lyydsheep/pic/main/202409071637525.png)\n\n那么现在就是需要将我们自己实现的日志接口适配到gorm的`Writer`接口上\n\n好巧不巧，`Writer`接口只有一个方法，那么就可以用上**衍生函数+函数实现单接口**技巧，快速将我们的日志接口适配到此处\n\n这就是为什么我们的衍生函数的原类型是`func(msg string, fields...zap.Field)`，这正是`l.Debug()`方法的函数类型啊\n\n最后传入`Writer`接口的时候，利用衍生类型将`l.Debug()`强制类型转换，使其间接地实现了`Writer`接口的同时，未动我们自己的接口分毫\n\n\n\n\n\n","source":"_posts/Go/接入日志模块.md","raw":"---\ntitle: Golang之接入日志模块\npublish: true\ndescription: 记录Go项目中接入日志模块\ndate: 2024-08-20 18:29:00\ntag: \n- Go\n- 学习\n---\n\n# 接入日志模块\n\n## 日志通用理论\n\n### 级别\n\n**DEBUG**：记录一些辅助排查问题的信息。一般不会在线上使用\n\n**INFO**：中性地描述发送了什么。线上一般都是用这个级别\n\n**WARN**：系统发生了一些不好但是能够容忍的事情。至少会打印这个级别的日志\n\n**ERROR**：系统发生了一些需要保持关注的事情\n\n### 什么时候打日志？打什么级别？\n\n两个原则\n\n- **如果怀疑某个地方要不要打日志，那就打上**\n- **宁滥勿缺，宁愿多打一些日志，也不要偷懒**\n\n\n\n前人的经验\n\n- **统一利用AOP机制，记录任何与第三方打交道的请求与响应**，包括数据库、缓存、RPC调用，使用**DEBUG**级别记录日志\n- **统一利用AOP机制，记录系统接收的请求与放回的响应**，使用**DEBUG**级别\n- 在开发阶段，使用**DEBUG**级别记录中间**流程中的关键结果**\n- 怀疑系统可能有问题，但是问题又不大，记录WARN\n- 任何不可能出现问题，或者表达**有人攻击系统**的地方，记录**ERROR**\n\n## 接入日志模块\n\n在Go里面，可以使用zap作为日志框架\n\n[uber-go/zap: Blazing fast, structured, leveled logging in Go. (github.com)](https://github.com/uber-go/zap)\n\n**初始化方法：**\n\n- 直接设置一个全局的logger即可\n\n```go\n\tlogger, err := zap.NewDevelopment()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tzap.ReplaceGlobals(logger)\n```\n\nzap中含有一个全局的`globalL`变量，但是这个全局变量什么功能都木有实现，也就是说，它连打印日志的功能都没有\n\n![屏幕截图 2024-09-02 193645](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939910.png)\n\n因此需要使用`NewDevelopment()`方法创建一个可以使用的`logger`并替换掉全局变量的初始值\n\n![屏幕截图 2024-09-02 193655](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939433.png)\n\n### 打印日志的基本操作——Error\n\n当出现像是系统错误时，就能打印Error级别的日志\n\n```go\n\tif err != nil {\n\t\tctx.JSON(http.StatusOK, Result{Code: 5, Msg: \"系统错误\"})\n\t\tzap.L().Error(\"vcxnq[nzvx 用户手机号码登录失败\", zap.Error(err))\n\t\treturn\n\t}\n```\n\n打印日志不仅能传入msg信息，还能够传入一些`error`、`int`之类的字段，最终打印结果形如下图：\n\n![屏幕截图 2024-09-02 194610](https://raw.githubusercontent.com/lyydsheep/pic/main/202409021953667.png)\n\n注意几个细节：\n\n- 敏感数据（例如手机号码）不能打入日志，勉强能够接受使用debug级别打印敏感数据用于本地开发\n- msg要有足够定位bug出处的信息，例如在日志中用一段乱码唯一标识日志，这样只需要全局检索这段乱码就能找到出错的位置\n- 绝对不能把error返回给前端，暴露给用户\n\n### 打印日志的基本操作——Warn\n\n![image-20240902200117065](https://raw.githubusercontent.com/lyydsheep/pic/main/202409022001108.png)\n\n在此处打印了一个Warn日志，因为短信发送频繁是**偶尔**会发生的，**能够接受**。但要是**频繁出现Warn**，就很有可能是有人在攻击系统，那就要**告警引起注意了**\n\n###   打印日志的基本操作——Info\n\nInfo日志用于记录一些**中性信息**，例如\n\n![image-20240902203836373](https://raw.githubusercontent.com/lyydsheep/pic/main/202409022038436.png)\n\n### 打印日志的基本操作——Debug\n\nDebug日志可以用于记录和第三方交互的动作\n\n```go\nfunc (s *Service) Send(ctx context.Context, tpl string, args []sms.NameData, numbers ...string) error {\n\tzap.L().Debug(\"avnasio 即将发送短信\", zap.String(\"tpl\", tpl), zap.Any(\"args\", args))\n\terr := s.svc.Send(ctx, tpl, args, numbers...)\n\tif err != nil {\n\t\tzap.L().Debug(\"发送短信出现异常\", zap.Error(err))\n\t\treturn err\n\t}\n\treturn err\n}\n```\n\n可以考虑使用装饰器模式扩展`Write()`方法的功能\n\n例如，自动将key为phone的字段进行数据脱敏\n\n```go\ntype MyCore struct {\n\tzapcore.Core\n}\n\nfunc (c *MyCore) Write(e zapcore.Entry, fs []zapcore.Field) error {\n\t// 装饰器模式，进行数据脱敏\n\tfor _, f := range fs {\n\t\tif f.Key == \"phone\" {\n\t\t\tnumber := f.String\n\t\t\tf.String = number[:3] + \"****\" + number[7:]\n\t\t}\n\t}\n\treturn c.Core.Write(e, fs)\n}\n```\n\n\n\n装饰器模式实现一个core，能够自动将key为phone的字段对应的值进行脱敏\n\n### 不使用包变量——保持依赖注入风格\n\n有的时候不同的业务不愿意共享同一个全局的logger，这个时候就需要在不同地方创建属于他们自己的logger\n\n一个很直接的方法就是在service层添加logger字段，为不同业务引入各自的logger，并且保持着依赖注入的风格\n\n![屏幕截图 2024-09-03 214039](https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144169.png)\n\n![](https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144084.png)\n\n还有一种更简单的依赖注入方法：**注入了，但是没有完全注入**\n\n这种做法的好处就是，为将来扩展留下了可操作的空间\n\n```go\nfunc NewUserService(repo repository.UserRepository) UserService {\n\treturn &BasicUserService{\n\t\trepo:   repo,\n        // 预留了变动的空间\n        logger: zap.L(),\n\t}\n}\n```\n\n### 抽象日志API\n\n做到这里不难发现，不管是配置模块也好，日志模块也好，我们的代码都强耦合viper框架和zap框架。这就会有潜在的风险：万一连viper和zap框架都想换掉呢？\n\n因此，我们需要定义自己logger接口，弱化对zap框架的依赖\n\n具体有三种风格\n\n- ```go\n  type Logger interface {\n  \tDebug(msg string, args...any)\n  \tInfo(msg string, args...any)\n  \tWarn(msg string, args...any)\n  \tError(msg string, args...any)\n  }\n  \n  func Example() {\n  \tvar l Logger\n  \t// 在msg中留有占位符\n  \tl.Info(\"用户未注册，用户信息为 %v\", \"ababab\")\n  }\n  ```\n\n- ```go\n  type LoggerV1 interface {\n  \tDebug(msg string, args ...Field)\n  \tInfo(msg string, args ...Field)\n  \tWarn(msg string, args ...Field)\n  \tError(msg string, args ...Field)\n  }\n  \n  type Field struct {\n  \tKey string\n  \tVal any\n  }\n  \n  func ExampleV1() {\n  \tvar l LoggerV1\n  \t// 输出的val有对应的key，和zap采用相同的模式\n  \tl.Info(\"这个msg\", Field{Key: \"这个是key\", Val: \"这个是Val\"})\n  }\n  \n  ```\n\n- ```go\n  // LoggerV2 要求args的个数是偶数，以key-val形式交替出现\n  type LoggerV2 interface {\n  \tDebug(msg string, args ...any)\n  \tInfo(msg string, args ...any)\n  \tWarn(msg string, args ...any)\n  \tError(msg string, args ...any)\n  }\n  \n  func ExampleV2() {\n  \tvar l LoggerV2\n  \tl.Info(\"这是msg\", \"key\", \"val\")\n  }\n  ```\n\n- 第一种风格**兼容性最好**\n- 第二种风格认同**参数就应该有个名字**\n- 第三种风格**如果有完善的代码评审流程的话可以考虑考虑**，不然不推荐\n\n### 适配器模式\n\n既然已经抽象出了日志接口，那么具体该如何实现呢？\n\n答案就是采用**适配器模式**\n\n所谓适配器模式，就是**将一个类型适配到另一个接口上**。例如，将A适配到B，这里的A可以是接口，也可以是一个具体的类型\n\n**典型的使用场景**\n\n- 有两个用途类似，但是细节上略有不同的接口，将一个接口适配到另一个接口上\n- 由于版本迭代，出现了两个接口，需要将一个接口适配到另一个接口上\n\n**与装饰器模式的区别**\n\n- 装饰器模式用于**扩展功能**，自始至终**都是一个接口**\n- 适配器模式**必然是两个不同的接口**\n\n### 利用Gin的middleware打印日志\n\n在handler文件中，有很多个方法，如果一一为这些方法打印日志需要花费很多时间和精力\n\n可是发现，handler中的方法都是与请求和响应有关的，那么就可以采用`AOP`机制，利用gin的middleware来统一打日志\n\n#### 使用builder模式构建中间件\n\n```go\n// 几个注意点：\n// 小心日志内容过多：URL可能很长，请求体、响应体都可能特别特别大，需要考虑是否要进行截取\n// 用户可能换用不同的日志框架，所以要有足够的灵活性\n// 考虑结合viper实现动态开关，但是要小心并发安全\nfunc (b *Builder) Build() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tstart := time.Now()\n\t\tal := AccessLog{}\n\t\tal.Method = ctx.Request.Method\n\t\tif b.allowURL && ctx.Request.URL != nil {\n\t\t\turl := ctx.Request.URL.String()\n\t\t\tif len(url) > 1024 {\n\t\t\t\turl = url[:1024]\n\t\t\t}\n\t\t\tal.URL = url\n\t\t}\n\t\tif b.allowReqBody && ctx.Request.Body != nil {\n\t\t\t// 这里忽略错误，毕竟我只是打印个日志，有错误也无所谓了\n\t\t\tdata, _ := ctx.GetRawData()\n\t\t\t// Request.Body是一个流对象，读完之后Request里面就木有了\n\t\t\t// 所以还得把数据放回Request.Body，不然后续步骤就读不到这个数据了\n\t\t\tctx.Request.Body = io.NopCloser(bytes.NewBuffer(data))\n\t\t\tbody := string(data)\n\t\t\tif len(body) > 1024 {\n\t\t\t\tal.ReqBody = body\n\t\t\t}\n\t\t}\n\t\t// defer 打日志，即使有panic也不会影响日志的输出\n\t\tdefer func() {\n\t\t\tal.Duration = time.Since(start).String()\n\t\t\t// 具体怎么打印日志，由用户决定\n\t\t\tb.logFunc(ctx, al)\n\t\t}()\n\t\t// 执行到业务代码（不是很懂）\n\t\tctx.Next()\n\t}\n}\n\ntype AccessLog struct {\n\t// 请求方法\n\tMethod string\n\t// url\n\tURL string\n\t// 请求体\n\tReqBody string\n\t// 处理时间\n\tDuration string\n\t// 响应体\n\tRespBody string\n}\n```\n\n**一个有意思的点：为什么要让用户传进来一个打日志的方法呢？**\n\n如果不传递方法，那么在实现中不管我们是用`Info()`、`Debug()`还是`Error()`都是写死在代码中的，不能灵活地应对不同的场景，例如开发环境要用`Debug()`，可能线上环境我就要用`Info()`了\n\n那么不如就让用户传进来一个方法，只为用户提供一个接口，屏蔽底层的实现，用户只需要考虑在不同环境选择使用不同的方法就行了\n\n#### 打印响应\n\n正常来说，打印响应就应该和上文中打印请求一样简单：直接从`context`里面拿请求就行\n\n不幸的是，`ctx`并没有暴露出`Response`，也就是不能直接读响应\n\n但是，`ctx`暴露出了`ResponseWriter`，这个接口是用来写响应的。那么我们可以“**偷梁换柱**”，将这个接口换成我们自己的实现：**在写响应之前将数据保留下来，这样就有了响应的具体数据**\n\n在这里我们只需要重写`WriteHeader`、`Write`、`WriteString`这三个方法，所以装饰器模式在实现的时候可以采用组合的方式\n\n- 组合 ---> 装饰部分方法\n- 非组合 ---> 装饰全部方法\n\n```go\nif b.allowRespBody {\n\t// 偷梁换柱\n\tctx.Writer = &responseWriter{\n\t\tal: &al,\n\t\tResponseWriter: ctx.Writer,\n\t}\n}\n\ntype responseWriter struct {\n\t// 这里用指针，为了能留住“偷”过来的数据\n\tal *AccessLog\n\tgin.ResponseWriter\n}\n\nfunc (r *responseWriter) WriteString(data string) (int, error) {\n\tr.al.RespBody = data\n\treturn r.ResponseWriter.WriteString(data)\n}\n\nfunc (r *responseWriter) Write(data []byte) (int, error) {\n\tr.al.RespBody = string(data)\n\treturn r.ResponseWriter.Write(data)\n}\n\nfunc (r *responseWriter) WriteHeader(statusCode int) {\n\tr.al.Status = statusCode\n\tr.ResponseWriter.WriteHeader(statusCode)\n}\n```\n\n### GORM打印日志\n\n直接上代码：\n\n```go\n// 衍生类型，有点像适配器模式\ntype gormLoggerFunc func(msg string, fields ...zap.Field)\n\n// Printf 实现单接口\nfunc (g gormLoggerFunc) Printf(msg string, fields ...interface{}) {\n\tg(msg, zap.Any(\"args\", fields))\n}\n\n\n\nfunc InitDB(l *zap.Logger) *gorm.DB {\n\ttype Config struct {\n\t\tDSN string `yaml:\"dsn\"`\n\t}\n\tvar config Config\n\tconfig.DSN = \"abab\"\n\terr := viper.UnmarshalKey(\"db\", &config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdb, err := gorm.Open(mysql.Open(config.DSN), &gorm.Config{\n\t\t// 强制类型转换\n\t\tLogger: logger.New(gormLoggerFunc(l.Debug), logger.Config{\n\t\t\t// 慢查询阈值，只有语句执行时间超过这个阈值才会打印日志\n            // 一般为50ms 100ms，一次磁盘io操作大概是10ms\n\t\t\tSlowThreshold:             time.Millisecond * 10,\n\t\t\tLogLevel:                  logger.Info,\n\t\t\tIgnoreRecordNotFoundError: true,\n\t\t\tParameterizedQueries:      true,\n\t\t}),\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = dao.InitTable(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn db\n}\n\n```\n\ngorm已经为我们提供了有关日志的配置，所以我们可以直接使用配置实现打日志功能\n\n这里有个小问题，`logger.New()`方法的第一个参数要求传入`Writer`接口的实现，这个实现将会用来输出日志\n\n![image-20240907163634983](https://raw.githubusercontent.com/lyydsheep/pic/main/202409071637525.png)\n\n那么现在就是需要将我们自己实现的日志接口适配到gorm的`Writer`接口上\n\n好巧不巧，`Writer`接口只有一个方法，那么就可以用上**衍生函数+函数实现单接口**技巧，快速将我们的日志接口适配到此处\n\n这就是为什么我们的衍生函数的原类型是`func(msg string, fields...zap.Field)`，这正是`l.Debug()`方法的函数类型啊\n\n最后传入`Writer`接口的时候，利用衍生类型将`l.Debug()`强制类型转换，使其间接地实现了`Writer`接口的同时，未动我们自己的接口分毫\n\n\n\n\n\n","slug":"Go/接入日志模块","published":1,"updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m0021a5t2fa347a3p","content":"<h1 id=\"接入日志模块\"><a href=\"#接入日志模块\" class=\"headerlink\" title=\"接入日志模块\"></a>接入日志模块</h1><h2 id=\"日志通用理论\"><a href=\"#日志通用理论\" class=\"headerlink\" title=\"日志通用理论\"></a>日志通用理论</h2><h3 id=\"级别\"><a href=\"#级别\" class=\"headerlink\" title=\"级别\"></a>级别</h3><p><strong>DEBUG</strong>：记录一些辅助排查问题的信息。一般不会在线上使用</p>\n<p><strong>INFO</strong>：中性地描述发送了什么。线上一般都是用这个级别</p>\n<p><strong>WARN</strong>：系统发生了一些不好但是能够容忍的事情。至少会打印这个级别的日志</p>\n<p><strong>ERROR</strong>：系统发生了一些需要保持关注的事情</p>\n<h3 id=\"什么时候打日志？打什么级别？\"><a href=\"#什么时候打日志？打什么级别？\" class=\"headerlink\" title=\"什么时候打日志？打什么级别？\"></a>什么时候打日志？打什么级别？</h3><p>两个原则</p>\n<ul>\n<li><strong>如果怀疑某个地方要不要打日志，那就打上</strong></li>\n<li><strong>宁滥勿缺，宁愿多打一些日志，也不要偷懒</strong></li>\n</ul>\n<p>前人的经验</p>\n<ul>\n<li><strong>统一利用AOP机制，记录任何与第三方打交道的请求与响应</strong>，包括数据库、缓存、RPC调用，使用<strong>DEBUG</strong>级别记录日志</li>\n<li><strong>统一利用AOP机制，记录系统接收的请求与放回的响应</strong>，使用<strong>DEBUG</strong>级别</li>\n<li>在开发阶段，使用<strong>DEBUG</strong>级别记录中间<strong>流程中的关键结果</strong></li>\n<li>怀疑系统可能有问题，但是问题又不大，记录WARN</li>\n<li>任何不可能出现问题，或者表达<strong>有人攻击系统</strong>的地方，记录<strong>ERROR</strong></li>\n</ul>\n<h2 id=\"接入日志模块-1\"><a href=\"#接入日志模块-1\" class=\"headerlink\" title=\"接入日志模块\"></a>接入日志模块</h2><p>在Go里面，可以使用zap作为日志框架</p>\n<p><a href=\"https://github.com/uber-go/zap\">uber-go&#x2F;zap: Blazing fast, structured, leveled logging in Go. (github.com)</a></p>\n<p><strong>初始化方法：</strong></p>\n<ul>\n<li>直接设置一个全局的logger即可</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger, err := zap.NewDevelopment()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zap.ReplaceGlobals(logger)</span><br></pre></td></tr></table></figure>\n\n<p>zap中含有一个全局的<code>globalL</code>变量，但是这个全局变量什么功能都木有实现，也就是说，它连打印日志的功能都没有</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939910.png\" alt=\"屏幕截图 2024-09-02 193645\"></p>\n<p>因此需要使用<code>NewDevelopment()</code>方法创建一个可以使用的<code>logger</code>并替换掉全局变量的初始值</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939433.png\" alt=\"屏幕截图 2024-09-02 193655\"></p>\n<h3 id=\"打印日志的基本操作——Error\"><a href=\"#打印日志的基本操作——Error\" class=\"headerlink\" title=\"打印日志的基本操作——Error\"></a>打印日志的基本操作——Error</h3><p>当出现像是系统错误时，就能打印Error级别的日志</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tctx.JSON(http.StatusOK, Result&#123;Code: <span class=\"number\">5</span>, Msg: <span class=\"string\">&quot;系统错误&quot;</span>&#125;)</span><br><span class=\"line\">\tzap.L().Error(<span class=\"string\">&quot;vcxnq[nzvx 用户手机号码登录失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印日志不仅能传入msg信息，还能够传入一些<code>error</code>、<code>int</code>之类的字段，最终打印结果形如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021953667.png\" alt=\"屏幕截图 2024-09-02 194610\"></p>\n<p>注意几个细节：</p>\n<ul>\n<li>敏感数据（例如手机号码）不能打入日志，勉强能够接受使用debug级别打印敏感数据用于本地开发</li>\n<li>msg要有足够定位bug出处的信息，例如在日志中用一段乱码唯一标识日志，这样只需要全局检索这段乱码就能找到出错的位置</li>\n<li>绝对不能把error返回给前端，暴露给用户</li>\n</ul>\n<h3 id=\"打印日志的基本操作——Warn\"><a href=\"#打印日志的基本操作——Warn\" class=\"headerlink\" title=\"打印日志的基本操作——Warn\"></a>打印日志的基本操作——Warn</h3><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409022001108.png\" alt=\"image-20240902200117065\"></p>\n<p>在此处打印了一个Warn日志，因为短信发送频繁是<strong>偶尔</strong>会发生的，<strong>能够接受</strong>。但要是<strong>频繁出现Warn</strong>，就很有可能是有人在攻击系统，那就要<strong>告警引起注意了</strong></p>\n<h3 id=\"打印日志的基本操作——Info\"><a href=\"#打印日志的基本操作——Info\" class=\"headerlink\" title=\"打印日志的基本操作——Info\"></a>打印日志的基本操作——Info</h3><p>Info日志用于记录一些<strong>中性信息</strong>，例如</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409022038436.png\" alt=\"image-20240902203836373\"></p>\n<h3 id=\"打印日志的基本操作——Debug\"><a href=\"#打印日志的基本操作——Debug\" class=\"headerlink\" title=\"打印日志的基本操作——Debug\"></a>打印日志的基本操作——Debug</h3><p>Debug日志可以用于记录和第三方交互的动作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Service)</span></span> Send(ctx context.Context, tpl <span class=\"type\">string</span>, args []sms.NameData, numbers ...<span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tzap.L().Debug(<span class=\"string\">&quot;avnasio 即将发送短信&quot;</span>, zap.String(<span class=\"string\">&quot;tpl&quot;</span>, tpl), zap.Any(<span class=\"string\">&quot;args&quot;</span>, args))</span><br><span class=\"line\">\terr := s.svc.Send(ctx, tpl, args, numbers...)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tzap.L().Debug(<span class=\"string\">&quot;发送短信出现异常&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以考虑使用装饰器模式扩展<code>Write()</code>方法的功能</p>\n<p>例如，自动将key为phone的字段进行数据脱敏</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tzapcore.Core</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MyCore)</span></span> Write(e zapcore.Entry, fs []zapcore.Field) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 装饰器模式，进行数据脱敏</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> fs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> f.Key == <span class=\"string\">&quot;phone&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tnumber := f.String</span><br><span class=\"line\">\t\t\tf.String = number[:<span class=\"number\">3</span>] + <span class=\"string\">&quot;****&quot;</span> + number[<span class=\"number\">7</span>:]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Core.Write(e, fs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>装饰器模式实现一个core，能够自动将key为phone的字段对应的值进行脱敏</p>\n<h3 id=\"不使用包变量——保持依赖注入风格\"><a href=\"#不使用包变量——保持依赖注入风格\" class=\"headerlink\" title=\"不使用包变量——保持依赖注入风格\"></a>不使用包变量——保持依赖注入风格</h3><p>有的时候不同的业务不愿意共享同一个全局的logger，这个时候就需要在不同地方创建属于他们自己的logger</p>\n<p>一个很直接的方法就是在service层添加logger字段，为不同业务引入各自的logger，并且保持着依赖注入的风格</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144169.png\" alt=\"屏幕截图 2024-09-03 214039\"></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144084.png\"></p>\n<p>还有一种更简单的依赖注入方法：<strong>注入了，但是没有完全注入</strong></p>\n<p>这种做法的好处就是，为将来扩展留下了可操作的空间</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewUserService</span><span class=\"params\">(repo repository.UserRepository)</span></span> UserService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BasicUserService&#123;</span><br><span class=\"line\">\t\trepo:   repo,</span><br><span class=\"line\">        <span class=\"comment\">// 预留了变动的空间</span></span><br><span class=\"line\">        logger: zap.L(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象日志API\"><a href=\"#抽象日志API\" class=\"headerlink\" title=\"抽象日志API\"></a>抽象日志API</h3><p>做到这里不难发现，不管是配置模块也好，日志模块也好，我们的代码都强耦合viper框架和zap框架。这就会有潜在的风险：万一连viper和zap框架都想换掉呢？</p>\n<p>因此，我们需要定义自己logger接口，弱化对zap框架的依赖</p>\n<p>具体有三种风格</p>\n<ul>\n<li><pre><code class=\"go\">type Logger interface &#123;\n    Debug(msg string, args...any)\n    Info(msg string, args...any)\n    Warn(msg string, args...any)\n    Error(msg string, args...any)\n&#125;\n\nfunc Example() &#123;\n    var l Logger\n    // 在msg中留有占位符\n    l.Info(&quot;用户未注册，用户信息为 %v&quot;, &quot;ababab&quot;)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```go</span><br><span class=\"line\">  type LoggerV1 interface &#123;</span><br><span class=\"line\">  \tDebug(msg string, args ...Field)</span><br><span class=\"line\">  \tInfo(msg string, args ...Field)</span><br><span class=\"line\">  \tWarn(msg string, args ...Field)</span><br><span class=\"line\">  \tError(msg string, args ...Field)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  type Field struct &#123;</span><br><span class=\"line\">  \tKey string</span><br><span class=\"line\">  \tVal any</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  func ExampleV1() &#123;</span><br><span class=\"line\">  \tvar l LoggerV1</span><br><span class=\"line\">  \t// 输出的val有对应的key，和zap采用相同的模式</span><br><span class=\"line\">  \tl.Info(&quot;这个msg&quot;, Field&#123;Key: &quot;这个是key&quot;, Val: &quot;这个是Val&quot;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><pre><code class=\"go\">// LoggerV2 要求args的个数是偶数，以key-val形式交替出现\ntype LoggerV2 interface &#123;\n    Debug(msg string, args ...any)\n    Info(msg string, args ...any)\n    Warn(msg string, args ...any)\n    Error(msg string, args ...any)\n&#125;\n\nfunc ExampleV2() &#123;\n    var l LoggerV2\n    l.Info(&quot;这是msg&quot;, &quot;key&quot;, &quot;val&quot;)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 第一种风格**兼容性最好**</span><br><span class=\"line\">- 第二种风格认同**参数就应该有个名字**</span><br><span class=\"line\">- 第三种风格**如果有完善的代码评审流程的话可以考虑考虑**，不然不推荐</span><br><span class=\"line\"></span><br><span class=\"line\">### 适配器模式</span><br><span class=\"line\"></span><br><span class=\"line\">既然已经抽象出了日志接口，那么具体该如何实现呢？</span><br><span class=\"line\"></span><br><span class=\"line\">答案就是采用**适配器模式**</span><br><span class=\"line\"></span><br><span class=\"line\">所谓适配器模式，就是**将一个类型适配到另一个接口上**。例如，将A适配到B，这里的A可以是接口，也可以是一个具体的类型</span><br><span class=\"line\"></span><br><span class=\"line\">**典型的使用场景**</span><br><span class=\"line\"></span><br><span class=\"line\">- 有两个用途类似，但是细节上略有不同的接口，将一个接口适配到另一个接口上</span><br><span class=\"line\">- 由于版本迭代，出现了两个接口，需要将一个接口适配到另一个接口上</span><br><span class=\"line\"></span><br><span class=\"line\">**与装饰器模式的区别**</span><br><span class=\"line\"></span><br><span class=\"line\">- 装饰器模式用于**扩展功能**，自始至终**都是一个接口**</span><br><span class=\"line\">- 适配器模式**必然是两个不同的接口**</span><br><span class=\"line\"></span><br><span class=\"line\">### 利用Gin的middleware打印日志</span><br><span class=\"line\"></span><br><span class=\"line\">在handler文件中，有很多个方法，如果一一为这些方法打印日志需要花费很多时间和精力</span><br><span class=\"line\"></span><br><span class=\"line\">可是发现，handler中的方法都是与请求和响应有关的，那么就可以采用`AOP`机制，利用gin的middleware来统一打日志</span><br><span class=\"line\"></span><br><span class=\"line\">#### 使用builder模式构建中间件</span><br><span class=\"line\"></span><br><span class=\"line\">```go</span><br><span class=\"line\">// 几个注意点：</span><br><span class=\"line\">// 小心日志内容过多：URL可能很长，请求体、响应体都可能特别特别大，需要考虑是否要进行截取</span><br><span class=\"line\">// 用户可能换用不同的日志框架，所以要有足够的灵活性</span><br><span class=\"line\">// 考虑结合viper实现动态开关，但是要小心并发安全</span><br><span class=\"line\">func (b *Builder) Build() gin.HandlerFunc &#123;</span><br><span class=\"line\">\treturn func(ctx *gin.Context) &#123;</span><br><span class=\"line\">\t\tstart := time.Now()</span><br><span class=\"line\">\t\tal := AccessLog&#123;&#125;</span><br><span class=\"line\">\t\tal.Method = ctx.Request.Method</span><br><span class=\"line\">\t\tif b.allowURL &amp;&amp; ctx.Request.URL != nil &#123;</span><br><span class=\"line\">\t\t\turl := ctx.Request.URL.String()</span><br><span class=\"line\">\t\t\tif len(url) &gt; 1024 &#123;</span><br><span class=\"line\">\t\t\t\turl = url[:1024]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tal.URL = url</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif b.allowReqBody &amp;&amp; ctx.Request.Body != nil &#123;</span><br><span class=\"line\">\t\t\t// 这里忽略错误，毕竟我只是打印个日志，有错误也无所谓了</span><br><span class=\"line\">\t\t\tdata, _ := ctx.GetRawData()</span><br><span class=\"line\">\t\t\t// Request.Body是一个流对象，读完之后Request里面就木有了</span><br><span class=\"line\">\t\t\t// 所以还得把数据放回Request.Body，不然后续步骤就读不到这个数据了</span><br><span class=\"line\">\t\t\tctx.Request.Body = io.NopCloser(bytes.NewBuffer(data))</span><br><span class=\"line\">\t\t\tbody := string(data)</span><br><span class=\"line\">\t\t\tif len(body) &gt; 1024 &#123;</span><br><span class=\"line\">\t\t\t\tal.ReqBody = body</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// defer 打日志，即使有panic也不会影响日志的输出</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tal.Duration = time.Since(start).String()</span><br><span class=\"line\">\t\t\t// 具体怎么打印日志，由用户决定</span><br><span class=\"line\">\t\t\tb.logFunc(ctx, al)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\t// 执行到业务代码（不是很懂）</span><br><span class=\"line\">\t\tctx.Next()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type AccessLog struct &#123;</span><br><span class=\"line\">\t// 请求方法</span><br><span class=\"line\">\tMethod string</span><br><span class=\"line\">\t// url</span><br><span class=\"line\">\tURL string</span><br><span class=\"line\">\t// 请求体</span><br><span class=\"line\">\tReqBody string</span><br><span class=\"line\">\t// 处理时间</span><br><span class=\"line\">\tDuration string</span><br><span class=\"line\">\t// 响应体</span><br><span class=\"line\">\tRespBody string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n<p><strong>一个有意思的点：为什么要让用户传进来一个打日志的方法呢？</strong></p>\n<p>如果不传递方法，那么在实现中不管我们是用<code>Info()</code>、<code>Debug()</code>还是<code>Error()</code>都是写死在代码中的，不能灵活地应对不同的场景，例如开发环境要用<code>Debug()</code>，可能线上环境我就要用<code>Info()</code>了</p>\n<p>那么不如就让用户传进来一个方法，只为用户提供一个接口，屏蔽底层的实现，用户只需要考虑在不同环境选择使用不同的方法就行了</p>\n<h4 id=\"打印响应\"><a href=\"#打印响应\" class=\"headerlink\" title=\"打印响应\"></a>打印响应</h4><p>正常来说，打印响应就应该和上文中打印请求一样简单：直接从<code>context</code>里面拿请求就行</p>\n<p>不幸的是，<code>ctx</code>并没有暴露出<code>Response</code>，也就是不能直接读响应</p>\n<p>但是，<code>ctx</code>暴露出了<code>ResponseWriter</code>，这个接口是用来写响应的。那么我们可以“<strong>偷梁换柱</strong>”，将这个接口换成我们自己的实现：<strong>在写响应之前将数据保留下来，这样就有了响应的具体数据</strong></p>\n<p>在这里我们只需要重写<code>WriteHeader</code>、<code>Write</code>、<code>WriteString</code>这三个方法，所以装饰器模式在实现的时候可以采用组合的方式</p>\n<ul>\n<li>组合 —&gt; 装饰部分方法</li>\n<li>非组合 —&gt; 装饰全部方法</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> b.allowRespBody &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 偷梁换柱</span></span><br><span class=\"line\">\tctx.Writer = &amp;responseWriter&#123;</span><br><span class=\"line\">\t\tal: &amp;al,</span><br><span class=\"line\">\t\tResponseWriter: ctx.Writer,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> responseWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里用指针，为了能留住“偷”过来的数据</span></span><br><span class=\"line\">\tal *AccessLog</span><br><span class=\"line\">\tgin.ResponseWriter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> WriteString(data <span class=\"type\">string</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tr.al.RespBody = data</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r.ResponseWriter.WriteString(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> Write(data []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tr.al.RespBody = <span class=\"type\">string</span>(data)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r.ResponseWriter.Write(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> WriteHeader(statusCode <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tr.al.Status = statusCode</span><br><span class=\"line\">\tr.ResponseWriter.WriteHeader(statusCode)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GORM打印日志\"><a href=\"#GORM打印日志\" class=\"headerlink\" title=\"GORM打印日志\"></a>GORM打印日志</h3><p>直接上代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 衍生类型，有点像适配器模式</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> gormLoggerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(msg <span class=\"type\">string</span>, fields ...zap.Field)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Printf 实现单接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g gormLoggerFunc)</span></span> Printf(msg <span class=\"type\">string</span>, fields ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tg(msg, zap.Any(<span class=\"string\">&quot;args&quot;</span>, fields))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitDB</span><span class=\"params\">(l *zap.Logger)</span></span> *gorm.DB &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tDSN <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> config Config</span><br><span class=\"line\">\tconfig.DSN = <span class=\"string\">&quot;abab&quot;</span></span><br><span class=\"line\">\terr := viper.UnmarshalKey(<span class=\"string\">&quot;db&quot;</span>, &amp;config)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdb, err := gorm.Open(mysql.Open(config.DSN), &amp;gorm.Config&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 强制类型转换</span></span><br><span class=\"line\">\t\tLogger: logger.New(gormLoggerFunc(l.Debug), logger.Config&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 慢查询阈值，只有语句执行时间超过这个阈值才会打印日志</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般为50ms 100ms，一次磁盘io操作大概是10ms</span></span><br><span class=\"line\">\t\t\tSlowThreshold:             time.Millisecond * <span class=\"number\">10</span>,</span><br><span class=\"line\">\t\t\tLogLevel:                  logger.Info,</span><br><span class=\"line\">\t\t\tIgnoreRecordNotFoundError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\tParameterizedQueries:      <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t&#125;),</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = dao.InitTable(db)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> db</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>gorm已经为我们提供了有关日志的配置，所以我们可以直接使用配置实现打日志功能</p>\n<p>这里有个小问题，<code>logger.New()</code>方法的第一个参数要求传入<code>Writer</code>接口的实现，这个实现将会用来输出日志</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409071637525.png\" alt=\"image-20240907163634983\"></p>\n<p>那么现在就是需要将我们自己实现的日志接口适配到gorm的<code>Writer</code>接口上</p>\n<p>好巧不巧，<code>Writer</code>接口只有一个方法，那么就可以用上<strong>衍生函数+函数实现单接口</strong>技巧，快速将我们的日志接口适配到此处</p>\n<p>这就是为什么我们的衍生函数的原类型是<code>func(msg string, fields...zap.Field)</code>，这正是<code>l.Debug()</code>方法的函数类型啊</p>\n<p>最后传入<code>Writer</code>接口的时候，利用衍生类型将<code>l.Debug()</code>强制类型转换，使其间接地实现了<code>Writer</code>接口的同时，未动我们自己的接口分毫</p>\n","excerpt":"","more":"<h1 id=\"接入日志模块\"><a href=\"#接入日志模块\" class=\"headerlink\" title=\"接入日志模块\"></a>接入日志模块</h1><h2 id=\"日志通用理论\"><a href=\"#日志通用理论\" class=\"headerlink\" title=\"日志通用理论\"></a>日志通用理论</h2><h3 id=\"级别\"><a href=\"#级别\" class=\"headerlink\" title=\"级别\"></a>级别</h3><p><strong>DEBUG</strong>：记录一些辅助排查问题的信息。一般不会在线上使用</p>\n<p><strong>INFO</strong>：中性地描述发送了什么。线上一般都是用这个级别</p>\n<p><strong>WARN</strong>：系统发生了一些不好但是能够容忍的事情。至少会打印这个级别的日志</p>\n<p><strong>ERROR</strong>：系统发生了一些需要保持关注的事情</p>\n<h3 id=\"什么时候打日志？打什么级别？\"><a href=\"#什么时候打日志？打什么级别？\" class=\"headerlink\" title=\"什么时候打日志？打什么级别？\"></a>什么时候打日志？打什么级别？</h3><p>两个原则</p>\n<ul>\n<li><strong>如果怀疑某个地方要不要打日志，那就打上</strong></li>\n<li><strong>宁滥勿缺，宁愿多打一些日志，也不要偷懒</strong></li>\n</ul>\n<p>前人的经验</p>\n<ul>\n<li><strong>统一利用AOP机制，记录任何与第三方打交道的请求与响应</strong>，包括数据库、缓存、RPC调用，使用<strong>DEBUG</strong>级别记录日志</li>\n<li><strong>统一利用AOP机制，记录系统接收的请求与放回的响应</strong>，使用<strong>DEBUG</strong>级别</li>\n<li>在开发阶段，使用<strong>DEBUG</strong>级别记录中间<strong>流程中的关键结果</strong></li>\n<li>怀疑系统可能有问题，但是问题又不大，记录WARN</li>\n<li>任何不可能出现问题，或者表达<strong>有人攻击系统</strong>的地方，记录<strong>ERROR</strong></li>\n</ul>\n<h2 id=\"接入日志模块-1\"><a href=\"#接入日志模块-1\" class=\"headerlink\" title=\"接入日志模块\"></a>接入日志模块</h2><p>在Go里面，可以使用zap作为日志框架</p>\n<p><a href=\"https://github.com/uber-go/zap\">uber-go&#x2F;zap: Blazing fast, structured, leveled logging in Go. (github.com)</a></p>\n<p><strong>初始化方法：</strong></p>\n<ul>\n<li>直接设置一个全局的logger即可</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger, err := zap.NewDevelopment()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zap.ReplaceGlobals(logger)</span><br></pre></td></tr></table></figure>\n\n<p>zap中含有一个全局的<code>globalL</code>变量，但是这个全局变量什么功能都木有实现，也就是说，它连打印日志的功能都没有</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939910.png\" alt=\"屏幕截图 2024-09-02 193645\"></p>\n<p>因此需要使用<code>NewDevelopment()</code>方法创建一个可以使用的<code>logger</code>并替换掉全局变量的初始值</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021939433.png\" alt=\"屏幕截图 2024-09-02 193655\"></p>\n<h3 id=\"打印日志的基本操作——Error\"><a href=\"#打印日志的基本操作——Error\" class=\"headerlink\" title=\"打印日志的基本操作——Error\"></a>打印日志的基本操作——Error</h3><p>当出现像是系统错误时，就能打印Error级别的日志</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tctx.JSON(http.StatusOK, Result&#123;Code: <span class=\"number\">5</span>, Msg: <span class=\"string\">&quot;系统错误&quot;</span>&#125;)</span><br><span class=\"line\">\tzap.L().Error(<span class=\"string\">&quot;vcxnq[nzvx 用户手机号码登录失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印日志不仅能传入msg信息，还能够传入一些<code>error</code>、<code>int</code>之类的字段，最终打印结果形如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409021953667.png\" alt=\"屏幕截图 2024-09-02 194610\"></p>\n<p>注意几个细节：</p>\n<ul>\n<li>敏感数据（例如手机号码）不能打入日志，勉强能够接受使用debug级别打印敏感数据用于本地开发</li>\n<li>msg要有足够定位bug出处的信息，例如在日志中用一段乱码唯一标识日志，这样只需要全局检索这段乱码就能找到出错的位置</li>\n<li>绝对不能把error返回给前端，暴露给用户</li>\n</ul>\n<h3 id=\"打印日志的基本操作——Warn\"><a href=\"#打印日志的基本操作——Warn\" class=\"headerlink\" title=\"打印日志的基本操作——Warn\"></a>打印日志的基本操作——Warn</h3><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409022001108.png\" alt=\"image-20240902200117065\"></p>\n<p>在此处打印了一个Warn日志，因为短信发送频繁是<strong>偶尔</strong>会发生的，<strong>能够接受</strong>。但要是<strong>频繁出现Warn</strong>，就很有可能是有人在攻击系统，那就要<strong>告警引起注意了</strong></p>\n<h3 id=\"打印日志的基本操作——Info\"><a href=\"#打印日志的基本操作——Info\" class=\"headerlink\" title=\"打印日志的基本操作——Info\"></a>打印日志的基本操作——Info</h3><p>Info日志用于记录一些<strong>中性信息</strong>，例如</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409022038436.png\" alt=\"image-20240902203836373\"></p>\n<h3 id=\"打印日志的基本操作——Debug\"><a href=\"#打印日志的基本操作——Debug\" class=\"headerlink\" title=\"打印日志的基本操作——Debug\"></a>打印日志的基本操作——Debug</h3><p>Debug日志可以用于记录和第三方交互的动作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Service)</span></span> Send(ctx context.Context, tpl <span class=\"type\">string</span>, args []sms.NameData, numbers ...<span class=\"type\">string</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tzap.L().Debug(<span class=\"string\">&quot;avnasio 即将发送短信&quot;</span>, zap.String(<span class=\"string\">&quot;tpl&quot;</span>, tpl), zap.Any(<span class=\"string\">&quot;args&quot;</span>, args))</span><br><span class=\"line\">\terr := s.svc.Send(ctx, tpl, args, numbers...)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tzap.L().Debug(<span class=\"string\">&quot;发送短信出现异常&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以考虑使用装饰器模式扩展<code>Write()</code>方法的功能</p>\n<p>例如，自动将key为phone的字段进行数据脱敏</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tzapcore.Core</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *MyCore)</span></span> Write(e zapcore.Entry, fs []zapcore.Field) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 装饰器模式，进行数据脱敏</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> fs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> f.Key == <span class=\"string\">&quot;phone&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tnumber := f.String</span><br><span class=\"line\">\t\t\tf.String = number[:<span class=\"number\">3</span>] + <span class=\"string\">&quot;****&quot;</span> + number[<span class=\"number\">7</span>:]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Core.Write(e, fs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>装饰器模式实现一个core，能够自动将key为phone的字段对应的值进行脱敏</p>\n<h3 id=\"不使用包变量——保持依赖注入风格\"><a href=\"#不使用包变量——保持依赖注入风格\" class=\"headerlink\" title=\"不使用包变量——保持依赖注入风格\"></a>不使用包变量——保持依赖注入风格</h3><p>有的时候不同的业务不愿意共享同一个全局的logger，这个时候就需要在不同地方创建属于他们自己的logger</p>\n<p>一个很直接的方法就是在service层添加logger字段，为不同业务引入各自的logger，并且保持着依赖注入的风格</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144169.png\" alt=\"屏幕截图 2024-09-03 214039\"></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409032144084.png\"></p>\n<p>还有一种更简单的依赖注入方法：<strong>注入了，但是没有完全注入</strong></p>\n<p>这种做法的好处就是，为将来扩展留下了可操作的空间</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewUserService</span><span class=\"params\">(repo repository.UserRepository)</span></span> UserService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BasicUserService&#123;</span><br><span class=\"line\">\t\trepo:   repo,</span><br><span class=\"line\">        <span class=\"comment\">// 预留了变动的空间</span></span><br><span class=\"line\">        logger: zap.L(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象日志API\"><a href=\"#抽象日志API\" class=\"headerlink\" title=\"抽象日志API\"></a>抽象日志API</h3><p>做到这里不难发现，不管是配置模块也好，日志模块也好，我们的代码都强耦合viper框架和zap框架。这就会有潜在的风险：万一连viper和zap框架都想换掉呢？</p>\n<p>因此，我们需要定义自己logger接口，弱化对zap框架的依赖</p>\n<p>具体有三种风格</p>\n<ul>\n<li><pre><code class=\"go\">type Logger interface &#123;\n    Debug(msg string, args...any)\n    Info(msg string, args...any)\n    Warn(msg string, args...any)\n    Error(msg string, args...any)\n&#125;\n\nfunc Example() &#123;\n    var l Logger\n    // 在msg中留有占位符\n    l.Info(&quot;用户未注册，用户信息为 %v&quot;, &quot;ababab&quot;)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```go</span><br><span class=\"line\">  type LoggerV1 interface &#123;</span><br><span class=\"line\">  \tDebug(msg string, args ...Field)</span><br><span class=\"line\">  \tInfo(msg string, args ...Field)</span><br><span class=\"line\">  \tWarn(msg string, args ...Field)</span><br><span class=\"line\">  \tError(msg string, args ...Field)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  type Field struct &#123;</span><br><span class=\"line\">  \tKey string</span><br><span class=\"line\">  \tVal any</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  func ExampleV1() &#123;</span><br><span class=\"line\">  \tvar l LoggerV1</span><br><span class=\"line\">  \t// 输出的val有对应的key，和zap采用相同的模式</span><br><span class=\"line\">  \tl.Info(&quot;这个msg&quot;, Field&#123;Key: &quot;这个是key&quot;, Val: &quot;这个是Val&quot;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><pre><code class=\"go\">// LoggerV2 要求args的个数是偶数，以key-val形式交替出现\ntype LoggerV2 interface &#123;\n    Debug(msg string, args ...any)\n    Info(msg string, args ...any)\n    Warn(msg string, args ...any)\n    Error(msg string, args ...any)\n&#125;\n\nfunc ExampleV2() &#123;\n    var l LoggerV2\n    l.Info(&quot;这是msg&quot;, &quot;key&quot;, &quot;val&quot;)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 第一种风格**兼容性最好**</span><br><span class=\"line\">- 第二种风格认同**参数就应该有个名字**</span><br><span class=\"line\">- 第三种风格**如果有完善的代码评审流程的话可以考虑考虑**，不然不推荐</span><br><span class=\"line\"></span><br><span class=\"line\">### 适配器模式</span><br><span class=\"line\"></span><br><span class=\"line\">既然已经抽象出了日志接口，那么具体该如何实现呢？</span><br><span class=\"line\"></span><br><span class=\"line\">答案就是采用**适配器模式**</span><br><span class=\"line\"></span><br><span class=\"line\">所谓适配器模式，就是**将一个类型适配到另一个接口上**。例如，将A适配到B，这里的A可以是接口，也可以是一个具体的类型</span><br><span class=\"line\"></span><br><span class=\"line\">**典型的使用场景**</span><br><span class=\"line\"></span><br><span class=\"line\">- 有两个用途类似，但是细节上略有不同的接口，将一个接口适配到另一个接口上</span><br><span class=\"line\">- 由于版本迭代，出现了两个接口，需要将一个接口适配到另一个接口上</span><br><span class=\"line\"></span><br><span class=\"line\">**与装饰器模式的区别**</span><br><span class=\"line\"></span><br><span class=\"line\">- 装饰器模式用于**扩展功能**，自始至终**都是一个接口**</span><br><span class=\"line\">- 适配器模式**必然是两个不同的接口**</span><br><span class=\"line\"></span><br><span class=\"line\">### 利用Gin的middleware打印日志</span><br><span class=\"line\"></span><br><span class=\"line\">在handler文件中，有很多个方法，如果一一为这些方法打印日志需要花费很多时间和精力</span><br><span class=\"line\"></span><br><span class=\"line\">可是发现，handler中的方法都是与请求和响应有关的，那么就可以采用`AOP`机制，利用gin的middleware来统一打日志</span><br><span class=\"line\"></span><br><span class=\"line\">#### 使用builder模式构建中间件</span><br><span class=\"line\"></span><br><span class=\"line\">```go</span><br><span class=\"line\">// 几个注意点：</span><br><span class=\"line\">// 小心日志内容过多：URL可能很长，请求体、响应体都可能特别特别大，需要考虑是否要进行截取</span><br><span class=\"line\">// 用户可能换用不同的日志框架，所以要有足够的灵活性</span><br><span class=\"line\">// 考虑结合viper实现动态开关，但是要小心并发安全</span><br><span class=\"line\">func (b *Builder) Build() gin.HandlerFunc &#123;</span><br><span class=\"line\">\treturn func(ctx *gin.Context) &#123;</span><br><span class=\"line\">\t\tstart := time.Now()</span><br><span class=\"line\">\t\tal := AccessLog&#123;&#125;</span><br><span class=\"line\">\t\tal.Method = ctx.Request.Method</span><br><span class=\"line\">\t\tif b.allowURL &amp;&amp; ctx.Request.URL != nil &#123;</span><br><span class=\"line\">\t\t\turl := ctx.Request.URL.String()</span><br><span class=\"line\">\t\t\tif len(url) &gt; 1024 &#123;</span><br><span class=\"line\">\t\t\t\turl = url[:1024]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tal.URL = url</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif b.allowReqBody &amp;&amp; ctx.Request.Body != nil &#123;</span><br><span class=\"line\">\t\t\t// 这里忽略错误，毕竟我只是打印个日志，有错误也无所谓了</span><br><span class=\"line\">\t\t\tdata, _ := ctx.GetRawData()</span><br><span class=\"line\">\t\t\t// Request.Body是一个流对象，读完之后Request里面就木有了</span><br><span class=\"line\">\t\t\t// 所以还得把数据放回Request.Body，不然后续步骤就读不到这个数据了</span><br><span class=\"line\">\t\t\tctx.Request.Body = io.NopCloser(bytes.NewBuffer(data))</span><br><span class=\"line\">\t\t\tbody := string(data)</span><br><span class=\"line\">\t\t\tif len(body) &gt; 1024 &#123;</span><br><span class=\"line\">\t\t\t\tal.ReqBody = body</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// defer 打日志，即使有panic也不会影响日志的输出</span><br><span class=\"line\">\t\tdefer func() &#123;</span><br><span class=\"line\">\t\t\tal.Duration = time.Since(start).String()</span><br><span class=\"line\">\t\t\t// 具体怎么打印日志，由用户决定</span><br><span class=\"line\">\t\t\tb.logFunc(ctx, al)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\t// 执行到业务代码（不是很懂）</span><br><span class=\"line\">\t\tctx.Next()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type AccessLog struct &#123;</span><br><span class=\"line\">\t// 请求方法</span><br><span class=\"line\">\tMethod string</span><br><span class=\"line\">\t// url</span><br><span class=\"line\">\tURL string</span><br><span class=\"line\">\t// 请求体</span><br><span class=\"line\">\tReqBody string</span><br><span class=\"line\">\t// 处理时间</span><br><span class=\"line\">\tDuration string</span><br><span class=\"line\">\t// 响应体</span><br><span class=\"line\">\tRespBody string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n<p><strong>一个有意思的点：为什么要让用户传进来一个打日志的方法呢？</strong></p>\n<p>如果不传递方法，那么在实现中不管我们是用<code>Info()</code>、<code>Debug()</code>还是<code>Error()</code>都是写死在代码中的，不能灵活地应对不同的场景，例如开发环境要用<code>Debug()</code>，可能线上环境我就要用<code>Info()</code>了</p>\n<p>那么不如就让用户传进来一个方法，只为用户提供一个接口，屏蔽底层的实现，用户只需要考虑在不同环境选择使用不同的方法就行了</p>\n<h4 id=\"打印响应\"><a href=\"#打印响应\" class=\"headerlink\" title=\"打印响应\"></a>打印响应</h4><p>正常来说，打印响应就应该和上文中打印请求一样简单：直接从<code>context</code>里面拿请求就行</p>\n<p>不幸的是，<code>ctx</code>并没有暴露出<code>Response</code>，也就是不能直接读响应</p>\n<p>但是，<code>ctx</code>暴露出了<code>ResponseWriter</code>，这个接口是用来写响应的。那么我们可以“<strong>偷梁换柱</strong>”，将这个接口换成我们自己的实现：<strong>在写响应之前将数据保留下来，这样就有了响应的具体数据</strong></p>\n<p>在这里我们只需要重写<code>WriteHeader</code>、<code>Write</code>、<code>WriteString</code>这三个方法，所以装饰器模式在实现的时候可以采用组合的方式</p>\n<ul>\n<li>组合 —&gt; 装饰部分方法</li>\n<li>非组合 —&gt; 装饰全部方法</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> b.allowRespBody &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 偷梁换柱</span></span><br><span class=\"line\">\tctx.Writer = &amp;responseWriter&#123;</span><br><span class=\"line\">\t\tal: &amp;al,</span><br><span class=\"line\">\t\tResponseWriter: ctx.Writer,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> responseWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里用指针，为了能留住“偷”过来的数据</span></span><br><span class=\"line\">\tal *AccessLog</span><br><span class=\"line\">\tgin.ResponseWriter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> WriteString(data <span class=\"type\">string</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tr.al.RespBody = data</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r.ResponseWriter.WriteString(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> Write(data []<span class=\"type\">byte</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tr.al.RespBody = <span class=\"type\">string</span>(data)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r.ResponseWriter.Write(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *responseWriter)</span></span> WriteHeader(statusCode <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tr.al.Status = statusCode</span><br><span class=\"line\">\tr.ResponseWriter.WriteHeader(statusCode)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GORM打印日志\"><a href=\"#GORM打印日志\" class=\"headerlink\" title=\"GORM打印日志\"></a>GORM打印日志</h3><p>直接上代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 衍生类型，有点像适配器模式</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> gormLoggerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(msg <span class=\"type\">string</span>, fields ...zap.Field)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Printf 实现单接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g gormLoggerFunc)</span></span> Printf(msg <span class=\"type\">string</span>, fields ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tg(msg, zap.Any(<span class=\"string\">&quot;args&quot;</span>, fields))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitDB</span><span class=\"params\">(l *zap.Logger)</span></span> *gorm.DB &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tDSN <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> config Config</span><br><span class=\"line\">\tconfig.DSN = <span class=\"string\">&quot;abab&quot;</span></span><br><span class=\"line\">\terr := viper.UnmarshalKey(<span class=\"string\">&quot;db&quot;</span>, &amp;config)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdb, err := gorm.Open(mysql.Open(config.DSN), &amp;gorm.Config&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 强制类型转换</span></span><br><span class=\"line\">\t\tLogger: logger.New(gormLoggerFunc(l.Debug), logger.Config&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 慢查询阈值，只有语句执行时间超过这个阈值才会打印日志</span></span><br><span class=\"line\">            <span class=\"comment\">// 一般为50ms 100ms，一次磁盘io操作大概是10ms</span></span><br><span class=\"line\">\t\t\tSlowThreshold:             time.Millisecond * <span class=\"number\">10</span>,</span><br><span class=\"line\">\t\t\tLogLevel:                  logger.Info,</span><br><span class=\"line\">\t\t\tIgnoreRecordNotFoundError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\tParameterizedQueries:      <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t&#125;),</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = dao.InitTable(db)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> db</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>gorm已经为我们提供了有关日志的配置，所以我们可以直接使用配置实现打日志功能</p>\n<p>这里有个小问题，<code>logger.New()</code>方法的第一个参数要求传入<code>Writer</code>接口的实现，这个实现将会用来输出日志</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409071637525.png\" alt=\"image-20240907163634983\"></p>\n<p>那么现在就是需要将我们自己实现的日志接口适配到gorm的<code>Writer</code>接口上</p>\n<p>好巧不巧，<code>Writer</code>接口只有一个方法，那么就可以用上<strong>衍生函数+函数实现单接口</strong>技巧，快速将我们的日志接口适配到此处</p>\n<p>这就是为什么我们的衍生函数的原类型是<code>func(msg string, fields...zap.Field)</code>，这正是<code>l.Debug()</code>方法的函数类型啊</p>\n<p>最后传入<code>Writer</code>接口的时候，利用衍生类型将<code>l.Debug()</code>强制类型转换，使其间接地实现了<code>Writer</code>接口的同时，未动我们自己的接口分毫</p>\n"},{"_content":"# 榜单模型与分布式任务调度\n\n实现榜单功能主要有三个要点：\n\n1. 如何计算热点\n2. 如何保证性能\n3. 如何保证高可用\n\n一个榜单模型需要满足较强的实时性计算，允许在一定时间步长内的数据误差。丐版的实现思路就是**定时查询 + 查询数据库 + 排序选出前N个记录**\n\n使用`time.ticker`可以简便地实现定时查询子功能\n\n但是全局扫描数据库和文件排序是比较耗时的步骤，特别是当数据库中具有海量数据的时候，查询数据库的压力会特别大。\n\n![image-20241203144830478](https://raw.githubusercontent.com/lyydsheep/pic/main/202412031448530.png)\n\n一个解决思路是**异步分批查询**，将大批量的数据分而治之\n\n## 计算热点\n\n计算热点不是我们重点考虑的东西，一般都是产品经理提供计算算法，开发人员适当提出建议即可，不必过于纠结于此。计算热点算法一般会包含**用户行为、时间、权重因子**等部分，例如Hacknews算法、Reddit算法\n\n## 定时任务\n\n\n\n\n\n性能和可用性\t缺一不可\n\n针对Zset的优化手段\n\ntime.Timer\n\ntime.Ticker\n\ngo.work  go work init\n\n//go:generate mockgen\n\n引入一个job模块\n\n适配器模式或者builder模式 \t----> \t适配corn.Job接口\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412011101200.png\" alt=\"image-20241201110137143\"  />\n\n查询接口\t---->\t一个高并发且高可用的接口\n\n极致性能 ---> 必须要用本地缓存\n\n\n\n\n\n\n\n分布式定时任务：Redis分布式锁\n\n\n\n心跳机制\n","source":"_posts/Go/榜单模型与分布式任务调度.md","raw":"# 榜单模型与分布式任务调度\n\n实现榜单功能主要有三个要点：\n\n1. 如何计算热点\n2. 如何保证性能\n3. 如何保证高可用\n\n一个榜单模型需要满足较强的实时性计算，允许在一定时间步长内的数据误差。丐版的实现思路就是**定时查询 + 查询数据库 + 排序选出前N个记录**\n\n使用`time.ticker`可以简便地实现定时查询子功能\n\n但是全局扫描数据库和文件排序是比较耗时的步骤，特别是当数据库中具有海量数据的时候，查询数据库的压力会特别大。\n\n![image-20241203144830478](https://raw.githubusercontent.com/lyydsheep/pic/main/202412031448530.png)\n\n一个解决思路是**异步分批查询**，将大批量的数据分而治之\n\n## 计算热点\n\n计算热点不是我们重点考虑的东西，一般都是产品经理提供计算算法，开发人员适当提出建议即可，不必过于纠结于此。计算热点算法一般会包含**用户行为、时间、权重因子**等部分，例如Hacknews算法、Reddit算法\n\n## 定时任务\n\n\n\n\n\n性能和可用性\t缺一不可\n\n针对Zset的优化手段\n\ntime.Timer\n\ntime.Ticker\n\ngo.work  go work init\n\n//go:generate mockgen\n\n引入一个job模块\n\n适配器模式或者builder模式 \t----> \t适配corn.Job接口\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412011101200.png\" alt=\"image-20241201110137143\"  />\n\n查询接口\t---->\t一个高并发且高可用的接口\n\n极致性能 ---> 必须要用本地缓存\n\n\n\n\n\n\n\n分布式定时任务：Redis分布式锁\n\n\n\n心跳机制\n","slug":"Go/榜单模型与分布式任务调度","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m0023a5t24q264wfe","content":"<h1 id=\"榜单模型与分布式任务调度\"><a href=\"#榜单模型与分布式任务调度\" class=\"headerlink\" title=\"榜单模型与分布式任务调度\"></a>榜单模型与分布式任务调度</h1><p>实现榜单功能主要有三个要点：</p>\n<ol>\n<li>如何计算热点</li>\n<li>如何保证性能</li>\n<li>如何保证高可用</li>\n</ol>\n<p>一个榜单模型需要满足较强的实时性计算，允许在一定时间步长内的数据误差。丐版的实现思路就是<strong>定时查询 + 查询数据库 + 排序选出前N个记录</strong></p>\n<p>使用<code>time.ticker</code>可以简便地实现定时查询子功能</p>\n<p>但是全局扫描数据库和文件排序是比较耗时的步骤，特别是当数据库中具有海量数据的时候，查询数据库的压力会特别大。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412031448530.png\" alt=\"image-20241203144830478\"></p>\n<p>一个解决思路是<strong>异步分批查询</strong>，将大批量的数据分而治之</p>\n<h2 id=\"计算热点\"><a href=\"#计算热点\" class=\"headerlink\" title=\"计算热点\"></a>计算热点</h2><p>计算热点不是我们重点考虑的东西，一般都是产品经理提供计算算法，开发人员适当提出建议即可，不必过于纠结于此。计算热点算法一般会包含<strong>用户行为、时间、权重因子</strong>等部分，例如Hacknews算法、Reddit算法</p>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><p>性能和可用性\t缺一不可</p>\n<p>针对Zset的优化手段</p>\n<p>time.Timer</p>\n<p>time.Ticker</p>\n<p>go.work  go work init</p>\n<p>&#x2F;&#x2F;go:generate mockgen</p>\n<p>引入一个job模块</p>\n<p>适配器模式或者builder模式 \t—-&gt; \t适配corn.Job接口</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412011101200.png\" alt=\"image-20241201110137143\"  />\n\n<p>查询接口\t—-&gt;\t一个高并发且高可用的接口</p>\n<p>极致性能 —&gt; 必须要用本地缓存</p>\n<p>分布式定时任务：Redis分布式锁</p>\n<p>心跳机制</p>\n","excerpt":"","more":"<h1 id=\"榜单模型与分布式任务调度\"><a href=\"#榜单模型与分布式任务调度\" class=\"headerlink\" title=\"榜单模型与分布式任务调度\"></a>榜单模型与分布式任务调度</h1><p>实现榜单功能主要有三个要点：</p>\n<ol>\n<li>如何计算热点</li>\n<li>如何保证性能</li>\n<li>如何保证高可用</li>\n</ol>\n<p>一个榜单模型需要满足较强的实时性计算，允许在一定时间步长内的数据误差。丐版的实现思路就是<strong>定时查询 + 查询数据库 + 排序选出前N个记录</strong></p>\n<p>使用<code>time.ticker</code>可以简便地实现定时查询子功能</p>\n<p>但是全局扫描数据库和文件排序是比较耗时的步骤，特别是当数据库中具有海量数据的时候，查询数据库的压力会特别大。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412031448530.png\" alt=\"image-20241203144830478\"></p>\n<p>一个解决思路是<strong>异步分批查询</strong>，将大批量的数据分而治之</p>\n<h2 id=\"计算热点\"><a href=\"#计算热点\" class=\"headerlink\" title=\"计算热点\"></a>计算热点</h2><p>计算热点不是我们重点考虑的东西，一般都是产品经理提供计算算法，开发人员适当提出建议即可，不必过于纠结于此。计算热点算法一般会包含<strong>用户行为、时间、权重因子</strong>等部分，例如Hacknews算法、Reddit算法</p>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><p>性能和可用性\t缺一不可</p>\n<p>针对Zset的优化手段</p>\n<p>time.Timer</p>\n<p>time.Ticker</p>\n<p>go.work  go work init</p>\n<p>&#x2F;&#x2F;go:generate mockgen</p>\n<p>引入一个job模块</p>\n<p>适配器模式或者builder模式 \t—-&gt; \t适配corn.Job接口</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202412011101200.png\" alt=\"image-20241201110137143\"  />\n\n<p>查询接口\t—-&gt;\t一个高并发且高可用的接口</p>\n<p>极致性能 —&gt; 必须要用本地缓存</p>\n<p>分布式定时任务：Redis分布式锁</p>\n<p>心跳机制</p>\n"},{"title":"Golang之接入配置模块","publish":true,"description":"记录Go项目中接入配置模块","date":"2024-08-15T10:29:00.000Z","_content":"\n# 接入配置模块\n\n## 业务配置的通用理论：来源\n\n配置的来源有这么几类\n\n- **启动参数**：某一次运行的参数，可以在这里提供，典型的就是命令行工具\n- **环境变量**：具体实例有关的参数可以放在环境变量中\n- **本地配置文件**：当下环境所需要的通用配置\n- **远程配置中心**：与本地配置文件互相补充，除了满足启动服务的最小配置，剩下的配置都可以放在远程配置中心\n\n**优先使用配置文件，大规模服务器集群可以考虑使用远程配置中心**\n\n## 业务配置的通用理论：优先级\n\n有的时候，同一个配置项有多个来源，这个时候就需要根据优先级敲定一个唯一的来源\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457945.png)\n\n可以有下列这番排列\n\n- 命令行：毕竟是自己写的\n- 环境变量：本机电脑上的环境变量也是自己配置的\n- 配置文件：可能是同事写的，用Git同步过来了\n- 远程配置中心\n\n## 业务配置的通用理论：两次加载\n\n在使用**远程配置中心**时，一般需要有两次加载的过程\n\n- **第一次加载最基本的配置**，包括\n  - 远程配置中心的连接信息\n  - 日志相关配置\n- **第二次加载则是完全加载**\n  - 读取系统所需要的所有依赖\n  - 覆盖第一次加载的配置\n\n简单地，**第一次加载就是加载最基本功能**，**第二次加载就是完全加载并对第一次加载配置进行覆盖**\n\n## viper\n\n### 初始化viper\n\nhttps://github.com/spf13/viper\n\n首先准备好配置本地文件\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457339.png)\n\n接着使用viper**读取本地的配置文件**，具体有两种初始化viper的方法\n\n- 直接指定目标配置文件的路径\n\n  - `viper.SetConfigFile()`：加载配置文件\n\n  - `viper.ReadInConfig()`：读取配置文件内容\n\n  - ```Go\n    // 设定viper将要读取的文件\n    // viper从当前工作目录下进行定位\n    viper.SetConfigFile(\"config/dev.yaml\")\n    err := viper.ReadInConfig()\n    if err != nil {\n        panic(err)\n    }\n    ```\n\n- 分别指定目标配置文件的类型、名称、子目录\n\n  - `viper.SetConfigType()`、`viper.SetConfigName()`、`viper.AddConfigPath()`：加载配置文件\n\n  - `viper.ReadInConfig()`：读取配置文件内容\n  \n  - ```Go\n    // 设定viper将要读取的文件\n    // viper从当前工作目录下进行定位\n    viper.SetConfigType(\"yaml\")\n    viper.SetConfigName(\"dev\")\n    viper.AddConfigPath(\"config\")\n    err := viper.ReadInConfig()\n    if err != nil {\n        panic(err)\n    }\n    ```\n\n值得注意的是，不管是向viper中直接传入路径还是子目录，都是从**当前Go的工作目录开始定位的**\n\n可以在Goland IDE中查看working directory\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457921.png\" width = 600px>\n\n### 读取viper配置\n\n从viper中读取某一配置项有两种常用的方法\n\n- 直接读取某一个配置\n- 定义一个结构体，用于接收所有的配置项\n\n第二种方法比较推荐使用，我们可以在IOC中，也就是需要使用配置项的初始化的地方，定义一个内部结构体用于接收所有的配置项\n\n有两个注意点：\n\n1. **内部结构体字段要求包外能够访问（即首字母大写）**\n2. **指明将要读取的数据格式以及字段名称**\n\n```go\n\ttype Config struct {\n\t\t// 指明读取数据格式以及字段名称\n\t\t// 结构体内的字段要保证包外能访问，否则无法成功初始化\n\t\tDSN string `yaml:\"dsn\"`\n\t}\n\tvar config Config\n\t// 指定要读取的key\n\terr := viper.UnmarshalKey(\"db\", &config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n```\n\n### 设置viper默认值\n\n有的时候配置文件中缺少一些必要的配置项信息，这个时候就需要使用上viper的配置默认值。例如，如果我忘记了写DB的配置，那么就应该默认使用`localhost:3306`\n\n在viper中有两种实现默认值的方案：\n\n- 使用viper的`SetDefault()`方法\n- 利用结构体，在`UnmarshalKey()`之前设置好默认值\n  - 推荐这种，因为可以把默认值放在初始化的地方\n\n### viper动态读取配置\n\n一般而言，一个项目可能处在多个环境中，例如：开发环境、测试环境、线上环境，在不同环境中必然需要使用到不同的配置信息，那么这就会要求我们能够动态地读取配置\n\n<img src=https://raw.githubusercontent.com/lyydsheep/pic/main/202409011938249.png width=500px>\n\n我们可以在启动项目时传入一个config参数，这个config参数就是此次将读取的配置文件路径\n\n```go\n\t// 初始化配置文件路径指针，并设定默认值\n\tcfile := pflag.String(\"config\", \"config/hello.yaml\", \"配置文件路径\")\n\t// 接收config参数\n\tpflag.Parse()\n\tviper.SetConfigFile(*cfile)\n\terr := viper.ReadInConfig()\n```\n\n\n\n可以在Goland IDE中设置config参数\n\n<img src = https://raw.githubusercontent.com/lyydsheep/pic/main/202409011948441.png width=600px>\n\n### viper读取远程配置中心\n\n#### 安装etcd和etcdctl\n\n使用docker compose安装etcd\n\n![](https://raw.githubusercontent.com/lyydsheep/pic/main/202409012055638.png)\n\n**etcdctl没有安装成功，不明所以**\n\npath用于区别其他使用etcd的应用\n\n![image-20240901152107902](https://raw.githubusercontent.com/lyydsheep/pic/main/202409011521927.png)","source":"_posts/Go/接入配置模块.md","raw":"---\ntitle: Golang之接入配置模块\npublish: true\ndescription: 记录Go项目中接入配置模块\ndate: 2024-08-15 18:29:00\ntag: \n- Go\n- 学习\n---\n\n# 接入配置模块\n\n## 业务配置的通用理论：来源\n\n配置的来源有这么几类\n\n- **启动参数**：某一次运行的参数，可以在这里提供，典型的就是命令行工具\n- **环境变量**：具体实例有关的参数可以放在环境变量中\n- **本地配置文件**：当下环境所需要的通用配置\n- **远程配置中心**：与本地配置文件互相补充，除了满足启动服务的最小配置，剩下的配置都可以放在远程配置中心\n\n**优先使用配置文件，大规模服务器集群可以考虑使用远程配置中心**\n\n## 业务配置的通用理论：优先级\n\n有的时候，同一个配置项有多个来源，这个时候就需要根据优先级敲定一个唯一的来源\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457945.png)\n\n可以有下列这番排列\n\n- 命令行：毕竟是自己写的\n- 环境变量：本机电脑上的环境变量也是自己配置的\n- 配置文件：可能是同事写的，用Git同步过来了\n- 远程配置中心\n\n## 业务配置的通用理论：两次加载\n\n在使用**远程配置中心**时，一般需要有两次加载的过程\n\n- **第一次加载最基本的配置**，包括\n  - 远程配置中心的连接信息\n  - 日志相关配置\n- **第二次加载则是完全加载**\n  - 读取系统所需要的所有依赖\n  - 覆盖第一次加载的配置\n\n简单地，**第一次加载就是加载最基本功能**，**第二次加载就是完全加载并对第一次加载配置进行覆盖**\n\n## viper\n\n### 初始化viper\n\nhttps://github.com/spf13/viper\n\n首先准备好配置本地文件\n\n![img](https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457339.png)\n\n接着使用viper**读取本地的配置文件**，具体有两种初始化viper的方法\n\n- 直接指定目标配置文件的路径\n\n  - `viper.SetConfigFile()`：加载配置文件\n\n  - `viper.ReadInConfig()`：读取配置文件内容\n\n  - ```Go\n    // 设定viper将要读取的文件\n    // viper从当前工作目录下进行定位\n    viper.SetConfigFile(\"config/dev.yaml\")\n    err := viper.ReadInConfig()\n    if err != nil {\n        panic(err)\n    }\n    ```\n\n- 分别指定目标配置文件的类型、名称、子目录\n\n  - `viper.SetConfigType()`、`viper.SetConfigName()`、`viper.AddConfigPath()`：加载配置文件\n\n  - `viper.ReadInConfig()`：读取配置文件内容\n  \n  - ```Go\n    // 设定viper将要读取的文件\n    // viper从当前工作目录下进行定位\n    viper.SetConfigType(\"yaml\")\n    viper.SetConfigName(\"dev\")\n    viper.AddConfigPath(\"config\")\n    err := viper.ReadInConfig()\n    if err != nil {\n        panic(err)\n    }\n    ```\n\n值得注意的是，不管是向viper中直接传入路径还是子目录，都是从**当前Go的工作目录开始定位的**\n\n可以在Goland IDE中查看working directory\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457921.png\" width = 600px>\n\n### 读取viper配置\n\n从viper中读取某一配置项有两种常用的方法\n\n- 直接读取某一个配置\n- 定义一个结构体，用于接收所有的配置项\n\n第二种方法比较推荐使用，我们可以在IOC中，也就是需要使用配置项的初始化的地方，定义一个内部结构体用于接收所有的配置项\n\n有两个注意点：\n\n1. **内部结构体字段要求包外能够访问（即首字母大写）**\n2. **指明将要读取的数据格式以及字段名称**\n\n```go\n\ttype Config struct {\n\t\t// 指明读取数据格式以及字段名称\n\t\t// 结构体内的字段要保证包外能访问，否则无法成功初始化\n\t\tDSN string `yaml:\"dsn\"`\n\t}\n\tvar config Config\n\t// 指定要读取的key\n\terr := viper.UnmarshalKey(\"db\", &config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n```\n\n### 设置viper默认值\n\n有的时候配置文件中缺少一些必要的配置项信息，这个时候就需要使用上viper的配置默认值。例如，如果我忘记了写DB的配置，那么就应该默认使用`localhost:3306`\n\n在viper中有两种实现默认值的方案：\n\n- 使用viper的`SetDefault()`方法\n- 利用结构体，在`UnmarshalKey()`之前设置好默认值\n  - 推荐这种，因为可以把默认值放在初始化的地方\n\n### viper动态读取配置\n\n一般而言，一个项目可能处在多个环境中，例如：开发环境、测试环境、线上环境，在不同环境中必然需要使用到不同的配置信息，那么这就会要求我们能够动态地读取配置\n\n<img src=https://raw.githubusercontent.com/lyydsheep/pic/main/202409011938249.png width=500px>\n\n我们可以在启动项目时传入一个config参数，这个config参数就是此次将读取的配置文件路径\n\n```go\n\t// 初始化配置文件路径指针，并设定默认值\n\tcfile := pflag.String(\"config\", \"config/hello.yaml\", \"配置文件路径\")\n\t// 接收config参数\n\tpflag.Parse()\n\tviper.SetConfigFile(*cfile)\n\terr := viper.ReadInConfig()\n```\n\n\n\n可以在Goland IDE中设置config参数\n\n<img src = https://raw.githubusercontent.com/lyydsheep/pic/main/202409011948441.png width=600px>\n\n### viper读取远程配置中心\n\n#### 安装etcd和etcdctl\n\n使用docker compose安装etcd\n\n![](https://raw.githubusercontent.com/lyydsheep/pic/main/202409012055638.png)\n\n**etcdctl没有安装成功，不明所以**\n\npath用于区别其他使用etcd的应用\n\n![image-20240901152107902](https://raw.githubusercontent.com/lyydsheep/pic/main/202409011521927.png)","slug":"Go/接入配置模块","published":1,"updated":"2024-12-27T11:03:15.345Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6m0025a5t2bpi200c0","content":"<h1 id=\"接入配置模块\"><a href=\"#接入配置模块\" class=\"headerlink\" title=\"接入配置模块\"></a>接入配置模块</h1><h2 id=\"业务配置的通用理论：来源\"><a href=\"#业务配置的通用理论：来源\" class=\"headerlink\" title=\"业务配置的通用理论：来源\"></a>业务配置的通用理论：来源</h2><p>配置的来源有这么几类</p>\n<ul>\n<li><strong>启动参数</strong>：某一次运行的参数，可以在这里提供，典型的就是命令行工具</li>\n<li><strong>环境变量</strong>：具体实例有关的参数可以放在环境变量中</li>\n<li><strong>本地配置文件</strong>：当下环境所需要的通用配置</li>\n<li><strong>远程配置中心</strong>：与本地配置文件互相补充，除了满足启动服务的最小配置，剩下的配置都可以放在远程配置中心</li>\n</ul>\n<p><strong>优先使用配置文件，大规模服务器集群可以考虑使用远程配置中心</strong></p>\n<h2 id=\"业务配置的通用理论：优先级\"><a href=\"#业务配置的通用理论：优先级\" class=\"headerlink\" title=\"业务配置的通用理论：优先级\"></a>业务配置的通用理论：优先级</h2><p>有的时候，同一个配置项有多个来源，这个时候就需要根据优先级敲定一个唯一的来源</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457945.png\" alt=\"img\"></p>\n<p>可以有下列这番排列</p>\n<ul>\n<li>命令行：毕竟是自己写的</li>\n<li>环境变量：本机电脑上的环境变量也是自己配置的</li>\n<li>配置文件：可能是同事写的，用Git同步过来了</li>\n<li>远程配置中心</li>\n</ul>\n<h2 id=\"业务配置的通用理论：两次加载\"><a href=\"#业务配置的通用理论：两次加载\" class=\"headerlink\" title=\"业务配置的通用理论：两次加载\"></a>业务配置的通用理论：两次加载</h2><p>在使用<strong>远程配置中心</strong>时，一般需要有两次加载的过程</p>\n<ul>\n<li><strong>第一次加载最基本的配置</strong>，包括<ul>\n<li>远程配置中心的连接信息</li>\n<li>日志相关配置</li>\n</ul>\n</li>\n<li><strong>第二次加载则是完全加载</strong><ul>\n<li>读取系统所需要的所有依赖</li>\n<li>覆盖第一次加载的配置</li>\n</ul>\n</li>\n</ul>\n<p>简单地，<strong>第一次加载就是加载最基本功能</strong>，<strong>第二次加载就是完全加载并对第一次加载配置进行覆盖</strong></p>\n<h2 id=\"viper\"><a href=\"#viper\" class=\"headerlink\" title=\"viper\"></a>viper</h2><h3 id=\"初始化viper\"><a href=\"#初始化viper\" class=\"headerlink\" title=\"初始化viper\"></a>初始化viper</h3><p><a href=\"https://github.com/spf13/viper\">https://github.com/spf13/viper</a></p>\n<p>首先准备好配置本地文件</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457339.png\" alt=\"img\"></p>\n<p>接着使用viper<strong>读取本地的配置文件</strong>，具体有两种初始化viper的方法</p>\n<ul>\n<li><p>直接指定目标配置文件的路径</p>\n<ul>\n<li><p><code>viper.SetConfigFile()</code>：加载配置文件</p>\n</li>\n<li><p><code>viper.ReadInConfig()</code>：读取配置文件内容</p>\n</li>\n<li><pre><code class=\"Go\">// 设定viper将要读取的文件\n// viper从当前工作目录下进行定位\nviper.SetConfigFile(&quot;config/dev.yaml&quot;)\nerr := viper.ReadInConfig()\nif err != nil &#123;\n    panic(err)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 分别指定目标配置文件的类型、名称、子目录</span><br><span class=\"line\"></span><br><span class=\"line\">  - `viper.SetConfigType()`、`viper.SetConfigName()`、`viper.AddConfigPath()`：加载配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">  - `viper.ReadInConfig()`：读取配置文件内容</span><br><span class=\"line\">  </span><br><span class=\"line\">  - ```Go</span><br><span class=\"line\">    // 设定viper将要读取的文件</span><br><span class=\"line\">    // viper从当前工作目录下进行定位</span><br><span class=\"line\">    viper.SetConfigType(&quot;yaml&quot;)</span><br><span class=\"line\">    viper.SetConfigName(&quot;dev&quot;)</span><br><span class=\"line\">    viper.AddConfigPath(&quot;config&quot;)</span><br><span class=\"line\">    err := viper.ReadInConfig()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        panic(err)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>值得注意的是，不管是向viper中直接传入路径还是子目录，都是从<strong>当前Go的工作目录开始定位的</strong></p>\n<p>可以在Goland IDE中查看working directory</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457921.png\" width = 600px>\n\n<h3 id=\"读取viper配置\"><a href=\"#读取viper配置\" class=\"headerlink\" title=\"读取viper配置\"></a>读取viper配置</h3><p>从viper中读取某一配置项有两种常用的方法</p>\n<ul>\n<li>直接读取某一个配置</li>\n<li>定义一个结构体，用于接收所有的配置项</li>\n</ul>\n<p>第二种方法比较推荐使用，我们可以在IOC中，也就是需要使用配置项的初始化的地方，定义一个内部结构体用于接收所有的配置项</p>\n<p>有两个注意点：</p>\n<ol>\n<li><strong>内部结构体字段要求包外能够访问（即首字母大写）</strong></li>\n<li><strong>指明将要读取的数据格式以及字段名称</strong></li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 指明读取数据格式以及字段名称</span></span><br><span class=\"line\">\t<span class=\"comment\">// 结构体内的字段要保证包外能访问，否则无法成功初始化</span></span><br><span class=\"line\">\tDSN <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> config Config</span><br><span class=\"line\"><span class=\"comment\">// 指定要读取的key</span></span><br><span class=\"line\">err := viper.UnmarshalKey(<span class=\"string\">&quot;db&quot;</span>, &amp;config)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置viper默认值\"><a href=\"#设置viper默认值\" class=\"headerlink\" title=\"设置viper默认值\"></a>设置viper默认值</h3><p>有的时候配置文件中缺少一些必要的配置项信息，这个时候就需要使用上viper的配置默认值。例如，如果我忘记了写DB的配置，那么就应该默认使用<code>localhost:3306</code></p>\n<p>在viper中有两种实现默认值的方案：</p>\n<ul>\n<li>使用viper的<code>SetDefault()</code>方法</li>\n<li>利用结构体，在<code>UnmarshalKey()</code>之前设置好默认值<ul>\n<li>推荐这种，因为可以把默认值放在初始化的地方</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"viper动态读取配置\"><a href=\"#viper动态读取配置\" class=\"headerlink\" title=\"viper动态读取配置\"></a>viper动态读取配置</h3><p>一般而言，一个项目可能处在多个环境中，例如：开发环境、测试环境、线上环境，在不同环境中必然需要使用到不同的配置信息，那么这就会要求我们能够动态地读取配置</p>\n<img src=https://raw.githubusercontent.com/lyydsheep/pic/main/202409011938249.png width=500px>\n\n<p>我们可以在启动项目时传入一个config参数，这个config参数就是此次将读取的配置文件路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化配置文件路径指针，并设定默认值</span></span><br><span class=\"line\">cfile := pflag.String(<span class=\"string\">&quot;config&quot;</span>, <span class=\"string\">&quot;config/hello.yaml&quot;</span>, <span class=\"string\">&quot;配置文件路径&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 接收config参数</span></span><br><span class=\"line\">pflag.Parse()</span><br><span class=\"line\">viper.SetConfigFile(*cfile)</span><br><span class=\"line\">err := viper.ReadInConfig()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以在Goland IDE中设置config参数</p>\n<img src = https://raw.githubusercontent.com/lyydsheep/pic/main/202409011948441.png width=600px>\n\n<h3 id=\"viper读取远程配置中心\"><a href=\"#viper读取远程配置中心\" class=\"headerlink\" title=\"viper读取远程配置中心\"></a>viper读取远程配置中心</h3><h4 id=\"安装etcd和etcdctl\"><a href=\"#安装etcd和etcdctl\" class=\"headerlink\" title=\"安装etcd和etcdctl\"></a>安装etcd和etcdctl</h4><p>使用docker compose安装etcd</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409012055638.png\"></p>\n<p><strong>etcdctl没有安装成功，不明所以</strong></p>\n<p>path用于区别其他使用etcd的应用</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409011521927.png\" alt=\"image-20240901152107902\"></p>\n","excerpt":"","more":"<h1 id=\"接入配置模块\"><a href=\"#接入配置模块\" class=\"headerlink\" title=\"接入配置模块\"></a>接入配置模块</h1><h2 id=\"业务配置的通用理论：来源\"><a href=\"#业务配置的通用理论：来源\" class=\"headerlink\" title=\"业务配置的通用理论：来源\"></a>业务配置的通用理论：来源</h2><p>配置的来源有这么几类</p>\n<ul>\n<li><strong>启动参数</strong>：某一次运行的参数，可以在这里提供，典型的就是命令行工具</li>\n<li><strong>环境变量</strong>：具体实例有关的参数可以放在环境变量中</li>\n<li><strong>本地配置文件</strong>：当下环境所需要的通用配置</li>\n<li><strong>远程配置中心</strong>：与本地配置文件互相补充，除了满足启动服务的最小配置，剩下的配置都可以放在远程配置中心</li>\n</ul>\n<p><strong>优先使用配置文件，大规模服务器集群可以考虑使用远程配置中心</strong></p>\n<h2 id=\"业务配置的通用理论：优先级\"><a href=\"#业务配置的通用理论：优先级\" class=\"headerlink\" title=\"业务配置的通用理论：优先级\"></a>业务配置的通用理论：优先级</h2><p>有的时候，同一个配置项有多个来源，这个时候就需要根据优先级敲定一个唯一的来源</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457945.png\" alt=\"img\"></p>\n<p>可以有下列这番排列</p>\n<ul>\n<li>命令行：毕竟是自己写的</li>\n<li>环境变量：本机电脑上的环境变量也是自己配置的</li>\n<li>配置文件：可能是同事写的，用Git同步过来了</li>\n<li>远程配置中心</li>\n</ul>\n<h2 id=\"业务配置的通用理论：两次加载\"><a href=\"#业务配置的通用理论：两次加载\" class=\"headerlink\" title=\"业务配置的通用理论：两次加载\"></a>业务配置的通用理论：两次加载</h2><p>在使用<strong>远程配置中心</strong>时，一般需要有两次加载的过程</p>\n<ul>\n<li><strong>第一次加载最基本的配置</strong>，包括<ul>\n<li>远程配置中心的连接信息</li>\n<li>日志相关配置</li>\n</ul>\n</li>\n<li><strong>第二次加载则是完全加载</strong><ul>\n<li>读取系统所需要的所有依赖</li>\n<li>覆盖第一次加载的配置</li>\n</ul>\n</li>\n</ul>\n<p>简单地，<strong>第一次加载就是加载最基本功能</strong>，<strong>第二次加载就是完全加载并对第一次加载配置进行覆盖</strong></p>\n<h2 id=\"viper\"><a href=\"#viper\" class=\"headerlink\" title=\"viper\"></a>viper</h2><h3 id=\"初始化viper\"><a href=\"#初始化viper\" class=\"headerlink\" title=\"初始化viper\"></a>初始化viper</h3><p><a href=\"https://github.com/spf13/viper\">https://github.com/spf13/viper</a></p>\n<p>首先准备好配置本地文件</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457339.png\" alt=\"img\"></p>\n<p>接着使用viper<strong>读取本地的配置文件</strong>，具体有两种初始化viper的方法</p>\n<ul>\n<li><p>直接指定目标配置文件的路径</p>\n<ul>\n<li><p><code>viper.SetConfigFile()</code>：加载配置文件</p>\n</li>\n<li><p><code>viper.ReadInConfig()</code>：读取配置文件内容</p>\n</li>\n<li><pre><code class=\"Go\">// 设定viper将要读取的文件\n// viper从当前工作目录下进行定位\nviper.SetConfigFile(&quot;config/dev.yaml&quot;)\nerr := viper.ReadInConfig()\nif err != nil &#123;\n    panic(err)\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 分别指定目标配置文件的类型、名称、子目录</span><br><span class=\"line\"></span><br><span class=\"line\">  - `viper.SetConfigType()`、`viper.SetConfigName()`、`viper.AddConfigPath()`：加载配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">  - `viper.ReadInConfig()`：读取配置文件内容</span><br><span class=\"line\">  </span><br><span class=\"line\">  - ```Go</span><br><span class=\"line\">    // 设定viper将要读取的文件</span><br><span class=\"line\">    // viper从当前工作目录下进行定位</span><br><span class=\"line\">    viper.SetConfigType(&quot;yaml&quot;)</span><br><span class=\"line\">    viper.SetConfigName(&quot;dev&quot;)</span><br><span class=\"line\">    viper.AddConfigPath(&quot;config&quot;)</span><br><span class=\"line\">    err := viper.ReadInConfig()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        panic(err)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>值得注意的是，不管是向viper中直接传入路径还是子目录，都是从<strong>当前Go的工作目录开始定位的</strong></p>\n<p>可以在Goland IDE中查看working directory</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202408311457921.png\" width = 600px>\n\n<h3 id=\"读取viper配置\"><a href=\"#读取viper配置\" class=\"headerlink\" title=\"读取viper配置\"></a>读取viper配置</h3><p>从viper中读取某一配置项有两种常用的方法</p>\n<ul>\n<li>直接读取某一个配置</li>\n<li>定义一个结构体，用于接收所有的配置项</li>\n</ul>\n<p>第二种方法比较推荐使用，我们可以在IOC中，也就是需要使用配置项的初始化的地方，定义一个内部结构体用于接收所有的配置项</p>\n<p>有两个注意点：</p>\n<ol>\n<li><strong>内部结构体字段要求包外能够访问（即首字母大写）</strong></li>\n<li><strong>指明将要读取的数据格式以及字段名称</strong></li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 指明读取数据格式以及字段名称</span></span><br><span class=\"line\">\t<span class=\"comment\">// 结构体内的字段要保证包外能访问，否则无法成功初始化</span></span><br><span class=\"line\">\tDSN <span class=\"type\">string</span> <span class=\"string\">`yaml:&quot;dsn&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> config Config</span><br><span class=\"line\"><span class=\"comment\">// 指定要读取的key</span></span><br><span class=\"line\">err := viper.UnmarshalKey(<span class=\"string\">&quot;db&quot;</span>, &amp;config)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置viper默认值\"><a href=\"#设置viper默认值\" class=\"headerlink\" title=\"设置viper默认值\"></a>设置viper默认值</h3><p>有的时候配置文件中缺少一些必要的配置项信息，这个时候就需要使用上viper的配置默认值。例如，如果我忘记了写DB的配置，那么就应该默认使用<code>localhost:3306</code></p>\n<p>在viper中有两种实现默认值的方案：</p>\n<ul>\n<li>使用viper的<code>SetDefault()</code>方法</li>\n<li>利用结构体，在<code>UnmarshalKey()</code>之前设置好默认值<ul>\n<li>推荐这种，因为可以把默认值放在初始化的地方</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"viper动态读取配置\"><a href=\"#viper动态读取配置\" class=\"headerlink\" title=\"viper动态读取配置\"></a>viper动态读取配置</h3><p>一般而言，一个项目可能处在多个环境中，例如：开发环境、测试环境、线上环境，在不同环境中必然需要使用到不同的配置信息，那么这就会要求我们能够动态地读取配置</p>\n<img src=https://raw.githubusercontent.com/lyydsheep/pic/main/202409011938249.png width=500px>\n\n<p>我们可以在启动项目时传入一个config参数，这个config参数就是此次将读取的配置文件路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化配置文件路径指针，并设定默认值</span></span><br><span class=\"line\">cfile := pflag.String(<span class=\"string\">&quot;config&quot;</span>, <span class=\"string\">&quot;config/hello.yaml&quot;</span>, <span class=\"string\">&quot;配置文件路径&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 接收config参数</span></span><br><span class=\"line\">pflag.Parse()</span><br><span class=\"line\">viper.SetConfigFile(*cfile)</span><br><span class=\"line\">err := viper.ReadInConfig()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以在Goland IDE中设置config参数</p>\n<img src = https://raw.githubusercontent.com/lyydsheep/pic/main/202409011948441.png width=600px>\n\n<h3 id=\"viper读取远程配置中心\"><a href=\"#viper读取远程配置中心\" class=\"headerlink\" title=\"viper读取远程配置中心\"></a>viper读取远程配置中心</h3><h4 id=\"安装etcd和etcdctl\"><a href=\"#安装etcd和etcdctl\" class=\"headerlink\" title=\"安装etcd和etcdctl\"></a>安装etcd和etcdctl</h4><p>使用docker compose安装etcd</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409012055638.png\"></p>\n<p><strong>etcdctl没有安装成功，不明所以</strong></p>\n<p>path用于区别其他使用etcd的应用</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409011521927.png\" alt=\"image-20240901152107902\"></p>\n"},{"_content":"\n\n\n# 阅读、点赞、收藏\n\n## 需求分析\n\n- 阅读数量在点击文章之后就会+1，在退出文章后也不会-1\n- 点赞和收藏数既可以+1，也可以-1\n- 有时收藏的内容会放在收藏夹，取消收藏则要移除收藏夹\n\n另一方面，对于一个平台，不论是文章、视频还是评论，这些对象都会有阅读、点赞、收藏等属性字段。这也就意味着，我们提供的接口不能只限制应用于文章，而是一个**面向任何资源都能使用的阅读、点赞、收藏功能接口**\n\n更进一步地，需要分析阅读、点赞、收藏这三者之间的界限。实际可以考虑一下三个方面：\n\n- 场景\n- 性能\n- 研发\n\n## 阅读数功能设计与实现\n\n设计一个`InteractService`接口，该接口提供一个`IncReadCnt`方法，每当调用阅读接口时，就是该方法将对象的阅读数字段+1。\n\n考虑极端情况，如果是第一次对某个对象调用`IncReadCnt`方法，那么此时数据库中是没有该记录的，需要进行insert操作，而第二次、第三次调用时则是进行update操作。由此可见，`IncReadCnt`方法应该实现**upsert**操作：有记录则更新`read_cnt`字段，没有记录则插入一条记录\n\n**复习一下GORM实现upsert操作**：\n\n```go\ndao.db.WithContext(ctx).Clauses(clause.OnConflict{\n    DoUpdates: clause.Assignments(map[string]any{\n        // 直接使用 `read_cnt` = `read_cnt` + 1\n        // 保持并发安全\n        \"read_cnt\": gorm.Expr(\"read_cnt + 1\"),\n        \"utime\": time.Now().UnixMilli(),\n    }).Create(&Interactive{\n        // 略\n        ...\n    })\n})\n```\n\n在需求分析阶段，我们得出结论：应该提供一个面向任何资源的阅读、点赞、收藏功能接口。既然如此，就得有区分不同资源的字段。一种很常见的方法就是采用**biz + bizId**来唯一标识某个特定业务下的一个对象\n\n类似的设计有：\n\n- **biz + bizId**\n- **resource type + resourceId**\n- **request type + requestId**\n\n### 缓存设计\n\n在任何一个平台，阅读量、点赞、收藏都是高频访问数据。因此需要**做好缓存，防止超高的QPS压垮数据库**\n\n这里选择使用Redis的Hashes结构，一个key中同时保存`read_cnt`,`like_cnt`,`collect_cnt`字段\n\n> 为什么不是三个（广义上）Redis分别保存三个字段的属性值？🤔\n>\n> 一个原因是：阅读、点赞、收藏这三个字段经常一同出现，如果用一个key保存，那么只需要进行一次Redis查询就能拿到三个字段值\n>\n> 另一个原因是：如果使用三个Redis保存，那么为了确保读取三个Redis操作的原子性，就必须使用lua编写复杂脚本（而且性能可能会有一定损失🧐）\n\n枚举使用缓存可能发生的场景：\n\n- 没有Key\n- 有Key且有相应的字段\n- 有Key但没有相应的字段\n\n幸运地是，Redis提供了一个**HCINRBY** api（详见下图），可以有效解决后两种情况\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091421095.png\" alt=\"image-20241009142111996\" style=\"zoom: 67%;\" />\n\n对于情况一：我们就需要事先判断一下Redi中的key是否存在，如果存在就把对应的字段+1。**这是一个典型的check-do something场景，可以考虑使用lua脚本确保没有并发问题**\n\n### 注意事项\n\n⚠️：存储对象中的string类型默认对应着MySQL中的BLOB/TEXT类型，需要用`tag`明确指定`varchar`类型\n\n![image-20241011192816540](https://raw.githubusercontent.com/lyydsheep/pic/main/202410111928510.png)\n\n**先更新数据库，再更新缓存**\n\n![image-20241012151321298](https://raw.githubusercontent.com/lyydsheep/pic/main/202410121513334.png)\n\n## 点赞功能设计与实现\n\n### 需求分析\n\n点赞事实上分成两个部分：\n\n- 保留某个用户是否点赞过，并且用户可以取消点赞\n- 统计点赞数量\n\n统计点赞数量和统计阅读数量的思路是一样的，**不过需要额外记录用户是否对某个资源已经点过赞**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410130733005.png\" alt=\"image-20241012142803292\" style=\"zoom:50%;\" />\n\n### 功能实现\n\n为了简化前端代码，可以将点赞和取消点赞转发至同一个接口上，通过一个`like`字段进行区分\n\n- `true`，那么是点赞\n- `false`，那么是取消点赞\n\n并在Handler中根据`like`值，调用不同的方法\n\n#### 软删除\n\n涉及到用户可以撤销某个行为的场景（例如本处就是取消点赞），通常有两种操作数据的方式\n\n- **硬删除**：直接将数据库中的记录删除\n- **软删除**：将记录中的`status`字段设置成`2`\n  - 通常为了避免**零值问题**，人为规定`status = 1`标识记录存在，`status = 2`标识记录被删除\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121436840.png\" alt=\"image-20241012143649799\" style=\"zoom:67%;\" />\n\n相较于软删除，硬删除会产生很多**空洞**，影响MySQL性能。换句话说，**软删除的性能更好**\n\n同样地，在DAO层面，对于点赞操作，不能确定是第一次点赞还会再次点赞。因此需要采用**upsert**操作\n\n![image-20241011201326778](https://raw.githubusercontent.com/lyydsheep/pic/main/202410112013864.png)\n\n## 收藏功能设计与实现\n\n这里需要引入收藏夹的概念\n\n总体上就是两张表：\n\n- **收藏夹本体**：也就是收藏夹本身，以及其归属的用户\n- **收藏夹和资源的关联关系**\n\n![image-20241013101806634](https://raw.githubusercontent.com/lyydsheep/pic/main/202410131018715.png)\n\n收藏夹中会有多个项目，因此收藏夹和收藏夹中的内容是1：N的关系\n\n具体实现和阅读数、点赞数类似，都是要**upsert语义，以及`collect_cnt = collect_cnt + 1`** \n\n### 查询接口\n\n参考竞品：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131110917.png\" alt=\"image-20241013111021697\" style=\"zoom:50%;\" />\n\n在前端做展示一片文章、视频等资源时，需要将**资源本体、阅读数、点赞数、收藏数等**一同显示\n\n因为在实现阅读、点赞、收藏时，将这些字段视为了**一个独立的领域**，所以需要提供两个接口分别对数据和资源进行查询，并**在Web层面进行聚合**。另一种可行的方案就是将数据作为文章的子对象，那么就可以在Service层进行聚合\n\n考虑到需要进行查询多个表的操作，为了提高性能，可以使用**errgroup来并发查询数据和资源本体**\n\n具体Web层面实现如下：\n\n```go\n```\n\n\n\n```go\nfunc (h *ArticleHandler) PubDetail(ctx *gin.Context, c jwt.UserClaims, req ArticleReq) (ginx.Result, error) {\n\tuid := c.UserId\n\tvar eg errgroup.Group\n\tvar art domain.Article\n\teg.Go(func() error {\n\t\tvar err error\n\t\tart, err = h.svc.PubDetail(ctx, req.BizId)\n\t\tif err != nil {\n\t\t\th.l.Error(\"获取文章失败\", zap.Error(err))\n\t\t}\n\t\treturn err\n\t})\n\tvar intr domain.Interact\n\teg.Go(func() error {\n\t\tvar err error\n\t\tintr, err = h.interactSvc.Get(ctx, req.Biz, req.BizId, uid)\n\t\tif err != nil {\n\t\t\th.l.Error(\"获取文章数据失败\", zap.Error(err))\n\t\t}\n\t\treturn err\n\t})\n\terr := eg.Wait()\n\tif err != nil {\n\t\treturn ginx.Result{}, err\n\t}\n\tgo func() {\n\t\tvar err error\n\t\terr = h.interactSvc.IncReadCnt(ctx, req.Biz, req.BizId)\n\t\tif err != nil {\n\t\t\th.l.Error(\"增加阅读数失败\", zap.Error(err))\n\t\t}\n\t}()\n\treturn ginx.Result{\n\t\tData: ArticleVO{\n\t\t\tId:         art.Id,\n\t\t\tTitle:      art.Title,\n\t\t\tContent:    art.Content,\n\t\t\tAuthorName: art.Author.Name,\n\t\t\tReadCnt:    intr.ReadCnt,\n\t\t\tLikeCnt:    intr.LikeCnt,\n\t\t\tCollectCnt: intr.CollectCnt,\n\t\t\tLiked:      intr.Liked,\n\t\t\tCollected:  intr.Collected,\n\t\t\tCtime:      time.UnixMilli(art.Ctime).Format(time.DateTime),\n\t\t\tUtime:      time.UnixMilli(art.Utime).Format(time.DateTime),\n\t\t},\n\t}, nil\n}\n\n```\n\n\n\n⚠️：\n\n- **方法不直接修改参数，而是通过返回值间接修改参数**\n\n- 返回值的类型选择：\n\n  - 如果指针实现了接口，那就返回指针\n\n  - 如果返回值很大，避免传递引发复制，那就返回指针\n\n- 简易原则：\n\n  - 接收器永远用指针\n  - 输入输出都用结构体\n\n- 不是所有结构体都是可比较的\n\n## 功能实现小结\n\n- **大量使用事物**，保证在操作两张表时保持ACID特性\n- **大量使用Upsert语义**，因为很多情况下我们不知道表中是否有对应的数据\n- **大量使用lua脚本来保证缓存中的数据是正确的**，但是无法彻底解决缓存一致性问题\n- **在查询接口这个呢，只缓存总数数据**，并不会缓存个人是否点赞、是否收藏的数据\n- **缓存一致性虽然很重要，但不是所有的场景都必须维护**。另一方面，需要彻底解决缓存一致性问题的场景，就不应该使用缓存\n\n","source":"_posts/Go/阅读、点赞、收藏功能.md","raw":"---\ntag:\n- Go\n- 学习\n---\n\n\n\n# 阅读、点赞、收藏\n\n## 需求分析\n\n- 阅读数量在点击文章之后就会+1，在退出文章后也不会-1\n- 点赞和收藏数既可以+1，也可以-1\n- 有时收藏的内容会放在收藏夹，取消收藏则要移除收藏夹\n\n另一方面，对于一个平台，不论是文章、视频还是评论，这些对象都会有阅读、点赞、收藏等属性字段。这也就意味着，我们提供的接口不能只限制应用于文章，而是一个**面向任何资源都能使用的阅读、点赞、收藏功能接口**\n\n更进一步地，需要分析阅读、点赞、收藏这三者之间的界限。实际可以考虑一下三个方面：\n\n- 场景\n- 性能\n- 研发\n\n## 阅读数功能设计与实现\n\n设计一个`InteractService`接口，该接口提供一个`IncReadCnt`方法，每当调用阅读接口时，就是该方法将对象的阅读数字段+1。\n\n考虑极端情况，如果是第一次对某个对象调用`IncReadCnt`方法，那么此时数据库中是没有该记录的，需要进行insert操作，而第二次、第三次调用时则是进行update操作。由此可见，`IncReadCnt`方法应该实现**upsert**操作：有记录则更新`read_cnt`字段，没有记录则插入一条记录\n\n**复习一下GORM实现upsert操作**：\n\n```go\ndao.db.WithContext(ctx).Clauses(clause.OnConflict{\n    DoUpdates: clause.Assignments(map[string]any{\n        // 直接使用 `read_cnt` = `read_cnt` + 1\n        // 保持并发安全\n        \"read_cnt\": gorm.Expr(\"read_cnt + 1\"),\n        \"utime\": time.Now().UnixMilli(),\n    }).Create(&Interactive{\n        // 略\n        ...\n    })\n})\n```\n\n在需求分析阶段，我们得出结论：应该提供一个面向任何资源的阅读、点赞、收藏功能接口。既然如此，就得有区分不同资源的字段。一种很常见的方法就是采用**biz + bizId**来唯一标识某个特定业务下的一个对象\n\n类似的设计有：\n\n- **biz + bizId**\n- **resource type + resourceId**\n- **request type + requestId**\n\n### 缓存设计\n\n在任何一个平台，阅读量、点赞、收藏都是高频访问数据。因此需要**做好缓存，防止超高的QPS压垮数据库**\n\n这里选择使用Redis的Hashes结构，一个key中同时保存`read_cnt`,`like_cnt`,`collect_cnt`字段\n\n> 为什么不是三个（广义上）Redis分别保存三个字段的属性值？🤔\n>\n> 一个原因是：阅读、点赞、收藏这三个字段经常一同出现，如果用一个key保存，那么只需要进行一次Redis查询就能拿到三个字段值\n>\n> 另一个原因是：如果使用三个Redis保存，那么为了确保读取三个Redis操作的原子性，就必须使用lua编写复杂脚本（而且性能可能会有一定损失🧐）\n\n枚举使用缓存可能发生的场景：\n\n- 没有Key\n- 有Key且有相应的字段\n- 有Key但没有相应的字段\n\n幸运地是，Redis提供了一个**HCINRBY** api（详见下图），可以有效解决后两种情况\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091421095.png\" alt=\"image-20241009142111996\" style=\"zoom: 67%;\" />\n\n对于情况一：我们就需要事先判断一下Redi中的key是否存在，如果存在就把对应的字段+1。**这是一个典型的check-do something场景，可以考虑使用lua脚本确保没有并发问题**\n\n### 注意事项\n\n⚠️：存储对象中的string类型默认对应着MySQL中的BLOB/TEXT类型，需要用`tag`明确指定`varchar`类型\n\n![image-20241011192816540](https://raw.githubusercontent.com/lyydsheep/pic/main/202410111928510.png)\n\n**先更新数据库，再更新缓存**\n\n![image-20241012151321298](https://raw.githubusercontent.com/lyydsheep/pic/main/202410121513334.png)\n\n## 点赞功能设计与实现\n\n### 需求分析\n\n点赞事实上分成两个部分：\n\n- 保留某个用户是否点赞过，并且用户可以取消点赞\n- 统计点赞数量\n\n统计点赞数量和统计阅读数量的思路是一样的，**不过需要额外记录用户是否对某个资源已经点过赞**\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410130733005.png\" alt=\"image-20241012142803292\" style=\"zoom:50%;\" />\n\n### 功能实现\n\n为了简化前端代码，可以将点赞和取消点赞转发至同一个接口上，通过一个`like`字段进行区分\n\n- `true`，那么是点赞\n- `false`，那么是取消点赞\n\n并在Handler中根据`like`值，调用不同的方法\n\n#### 软删除\n\n涉及到用户可以撤销某个行为的场景（例如本处就是取消点赞），通常有两种操作数据的方式\n\n- **硬删除**：直接将数据库中的记录删除\n- **软删除**：将记录中的`status`字段设置成`2`\n  - 通常为了避免**零值问题**，人为规定`status = 1`标识记录存在，`status = 2`标识记录被删除\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121436840.png\" alt=\"image-20241012143649799\" style=\"zoom:67%;\" />\n\n相较于软删除，硬删除会产生很多**空洞**，影响MySQL性能。换句话说，**软删除的性能更好**\n\n同样地，在DAO层面，对于点赞操作，不能确定是第一次点赞还会再次点赞。因此需要采用**upsert**操作\n\n![image-20241011201326778](https://raw.githubusercontent.com/lyydsheep/pic/main/202410112013864.png)\n\n## 收藏功能设计与实现\n\n这里需要引入收藏夹的概念\n\n总体上就是两张表：\n\n- **收藏夹本体**：也就是收藏夹本身，以及其归属的用户\n- **收藏夹和资源的关联关系**\n\n![image-20241013101806634](https://raw.githubusercontent.com/lyydsheep/pic/main/202410131018715.png)\n\n收藏夹中会有多个项目，因此收藏夹和收藏夹中的内容是1：N的关系\n\n具体实现和阅读数、点赞数类似，都是要**upsert语义，以及`collect_cnt = collect_cnt + 1`** \n\n### 查询接口\n\n参考竞品：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131110917.png\" alt=\"image-20241013111021697\" style=\"zoom:50%;\" />\n\n在前端做展示一片文章、视频等资源时，需要将**资源本体、阅读数、点赞数、收藏数等**一同显示\n\n因为在实现阅读、点赞、收藏时，将这些字段视为了**一个独立的领域**，所以需要提供两个接口分别对数据和资源进行查询，并**在Web层面进行聚合**。另一种可行的方案就是将数据作为文章的子对象，那么就可以在Service层进行聚合\n\n考虑到需要进行查询多个表的操作，为了提高性能，可以使用**errgroup来并发查询数据和资源本体**\n\n具体Web层面实现如下：\n\n```go\n```\n\n\n\n```go\nfunc (h *ArticleHandler) PubDetail(ctx *gin.Context, c jwt.UserClaims, req ArticleReq) (ginx.Result, error) {\n\tuid := c.UserId\n\tvar eg errgroup.Group\n\tvar art domain.Article\n\teg.Go(func() error {\n\t\tvar err error\n\t\tart, err = h.svc.PubDetail(ctx, req.BizId)\n\t\tif err != nil {\n\t\t\th.l.Error(\"获取文章失败\", zap.Error(err))\n\t\t}\n\t\treturn err\n\t})\n\tvar intr domain.Interact\n\teg.Go(func() error {\n\t\tvar err error\n\t\tintr, err = h.interactSvc.Get(ctx, req.Biz, req.BizId, uid)\n\t\tif err != nil {\n\t\t\th.l.Error(\"获取文章数据失败\", zap.Error(err))\n\t\t}\n\t\treturn err\n\t})\n\terr := eg.Wait()\n\tif err != nil {\n\t\treturn ginx.Result{}, err\n\t}\n\tgo func() {\n\t\tvar err error\n\t\terr = h.interactSvc.IncReadCnt(ctx, req.Biz, req.BizId)\n\t\tif err != nil {\n\t\t\th.l.Error(\"增加阅读数失败\", zap.Error(err))\n\t\t}\n\t}()\n\treturn ginx.Result{\n\t\tData: ArticleVO{\n\t\t\tId:         art.Id,\n\t\t\tTitle:      art.Title,\n\t\t\tContent:    art.Content,\n\t\t\tAuthorName: art.Author.Name,\n\t\t\tReadCnt:    intr.ReadCnt,\n\t\t\tLikeCnt:    intr.LikeCnt,\n\t\t\tCollectCnt: intr.CollectCnt,\n\t\t\tLiked:      intr.Liked,\n\t\t\tCollected:  intr.Collected,\n\t\t\tCtime:      time.UnixMilli(art.Ctime).Format(time.DateTime),\n\t\t\tUtime:      time.UnixMilli(art.Utime).Format(time.DateTime),\n\t\t},\n\t}, nil\n}\n\n```\n\n\n\n⚠️：\n\n- **方法不直接修改参数，而是通过返回值间接修改参数**\n\n- 返回值的类型选择：\n\n  - 如果指针实现了接口，那就返回指针\n\n  - 如果返回值很大，避免传递引发复制，那就返回指针\n\n- 简易原则：\n\n  - 接收器永远用指针\n  - 输入输出都用结构体\n\n- 不是所有结构体都是可比较的\n\n## 功能实现小结\n\n- **大量使用事物**，保证在操作两张表时保持ACID特性\n- **大量使用Upsert语义**，因为很多情况下我们不知道表中是否有对应的数据\n- **大量使用lua脚本来保证缓存中的数据是正确的**，但是无法彻底解决缓存一致性问题\n- **在查询接口这个呢，只缓存总数数据**，并不会缓存个人是否点赞、是否收藏的数据\n- **缓存一致性虽然很重要，但不是所有的场景都必须维护**。另一方面，需要彻底解决缓存一致性问题的场景，就不应该使用缓存\n\n","slug":"Go/阅读、点赞、收藏功能","published":1,"date":"2024-12-27T11:03:15.345Z","updated":"2024-12-27T11:03:15.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n0027a5t2ak4rf36m","content":"<h1 id=\"阅读、点赞、收藏\"><a href=\"#阅读、点赞、收藏\" class=\"headerlink\" title=\"阅读、点赞、收藏\"></a>阅读、点赞、收藏</h1><h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li>阅读数量在点击文章之后就会+1，在退出文章后也不会-1</li>\n<li>点赞和收藏数既可以+1，也可以-1</li>\n<li>有时收藏的内容会放在收藏夹，取消收藏则要移除收藏夹</li>\n</ul>\n<p>另一方面，对于一个平台，不论是文章、视频还是评论，这些对象都会有阅读、点赞、收藏等属性字段。这也就意味着，我们提供的接口不能只限制应用于文章，而是一个<strong>面向任何资源都能使用的阅读、点赞、收藏功能接口</strong></p>\n<p>更进一步地，需要分析阅读、点赞、收藏这三者之间的界限。实际可以考虑一下三个方面：</p>\n<ul>\n<li>场景</li>\n<li>性能</li>\n<li>研发</li>\n</ul>\n<h2 id=\"阅读数功能设计与实现\"><a href=\"#阅读数功能设计与实现\" class=\"headerlink\" title=\"阅读数功能设计与实现\"></a>阅读数功能设计与实现</h2><p>设计一个<code>InteractService</code>接口，该接口提供一个<code>IncReadCnt</code>方法，每当调用阅读接口时，就是该方法将对象的阅读数字段+1。</p>\n<p>考虑极端情况，如果是第一次对某个对象调用<code>IncReadCnt</code>方法，那么此时数据库中是没有该记录的，需要进行insert操作，而第二次、第三次调用时则是进行update操作。由此可见，<code>IncReadCnt</code>方法应该实现<strong>upsert</strong>操作：有记录则更新<code>read_cnt</code>字段，没有记录则插入一条记录</p>\n<p><strong>复习一下GORM实现upsert操作</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dao.db.WithContext(ctx).Clauses(clause.OnConflict&#123;</span><br><span class=\"line\">    DoUpdates: clause.Assignments(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]any&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 直接使用 `read_cnt` = `read_cnt` + 1</span></span><br><span class=\"line\">        <span class=\"comment\">// 保持并发安全</span></span><br><span class=\"line\">        <span class=\"string\">&quot;read_cnt&quot;</span>: gorm.Expr(<span class=\"string\">&quot;read_cnt + 1&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;utime&quot;</span>: time.Now().UnixMilli(),</span><br><span class=\"line\">    &#125;).Create(&amp;Interactive&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 略</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在需求分析阶段，我们得出结论：应该提供一个面向任何资源的阅读、点赞、收藏功能接口。既然如此，就得有区分不同资源的字段。一种很常见的方法就是采用<strong>biz + bizId</strong>来唯一标识某个特定业务下的一个对象</p>\n<p>类似的设计有：</p>\n<ul>\n<li><strong>biz + bizId</strong></li>\n<li><strong>resource type + resourceId</strong></li>\n<li><strong>request type + requestId</strong></li>\n</ul>\n<h3 id=\"缓存设计\"><a href=\"#缓存设计\" class=\"headerlink\" title=\"缓存设计\"></a>缓存设计</h3><p>在任何一个平台，阅读量、点赞、收藏都是高频访问数据。因此需要<strong>做好缓存，防止超高的QPS压垮数据库</strong></p>\n<p>这里选择使用Redis的Hashes结构，一个key中同时保存<code>read_cnt</code>,<code>like_cnt</code>,<code>collect_cnt</code>字段</p>\n<blockquote>\n<p>为什么不是三个（广义上）Redis分别保存三个字段的属性值？🤔</p>\n<p>一个原因是：阅读、点赞、收藏这三个字段经常一同出现，如果用一个key保存，那么只需要进行一次Redis查询就能拿到三个字段值</p>\n<p>另一个原因是：如果使用三个Redis保存，那么为了确保读取三个Redis操作的原子性，就必须使用lua编写复杂脚本（而且性能可能会有一定损失🧐）</p>\n</blockquote>\n<p>枚举使用缓存可能发生的场景：</p>\n<ul>\n<li>没有Key</li>\n<li>有Key且有相应的字段</li>\n<li>有Key但没有相应的字段</li>\n</ul>\n<p>幸运地是，Redis提供了一个<strong>HCINRBY</strong> api（详见下图），可以有效解决后两种情况</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091421095.png\" alt=\"image-20241009142111996\" style=\"zoom: 67%;\" />\n\n<p>对于情况一：我们就需要事先判断一下Redi中的key是否存在，如果存在就把对应的字段+1。<strong>这是一个典型的check-do something场景，可以考虑使用lua脚本确保没有并发问题</strong></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>⚠️：存储对象中的string类型默认对应着MySQL中的BLOB&#x2F;TEXT类型，需要用<code>tag</code>明确指定<code>varchar</code>类型</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410111928510.png\" alt=\"image-20241011192816540\"></p>\n<p><strong>先更新数据库，再更新缓存</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121513334.png\" alt=\"image-20241012151321298\"></p>\n<h2 id=\"点赞功能设计与实现\"><a href=\"#点赞功能设计与实现\" class=\"headerlink\" title=\"点赞功能设计与实现\"></a>点赞功能设计与实现</h2><h3 id=\"需求分析-1\"><a href=\"#需求分析-1\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>点赞事实上分成两个部分：</p>\n<ul>\n<li>保留某个用户是否点赞过，并且用户可以取消点赞</li>\n<li>统计点赞数量</li>\n</ul>\n<p>统计点赞数量和统计阅读数量的思路是一样的，<strong>不过需要额外记录用户是否对某个资源已经点过赞</strong></p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410130733005.png\" alt=\"image-20241012142803292\" style=\"zoom:50%;\" />\n\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><p>为了简化前端代码，可以将点赞和取消点赞转发至同一个接口上，通过一个<code>like</code>字段进行区分</p>\n<ul>\n<li><code>true</code>，那么是点赞</li>\n<li><code>false</code>，那么是取消点赞</li>\n</ul>\n<p>并在Handler中根据<code>like</code>值，调用不同的方法</p>\n<h4 id=\"软删除\"><a href=\"#软删除\" class=\"headerlink\" title=\"软删除\"></a>软删除</h4><p>涉及到用户可以撤销某个行为的场景（例如本处就是取消点赞），通常有两种操作数据的方式</p>\n<ul>\n<li><strong>硬删除</strong>：直接将数据库中的记录删除</li>\n<li><strong>软删除</strong>：将记录中的<code>status</code>字段设置成<code>2</code><ul>\n<li>通常为了避免<strong>零值问题</strong>，人为规定<code>status = 1</code>标识记录存在，<code>status = 2</code>标识记录被删除</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121436840.png\" alt=\"image-20241012143649799\" style=\"zoom:67%;\" />\n\n<p>相较于软删除，硬删除会产生很多<strong>空洞</strong>，影响MySQL性能。换句话说，<strong>软删除的性能更好</strong></p>\n<p>同样地，在DAO层面，对于点赞操作，不能确定是第一次点赞还会再次点赞。因此需要采用<strong>upsert</strong>操作</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410112013864.png\" alt=\"image-20241011201326778\"></p>\n<h2 id=\"收藏功能设计与实现\"><a href=\"#收藏功能设计与实现\" class=\"headerlink\" title=\"收藏功能设计与实现\"></a>收藏功能设计与实现</h2><p>这里需要引入收藏夹的概念</p>\n<p>总体上就是两张表：</p>\n<ul>\n<li><strong>收藏夹本体</strong>：也就是收藏夹本身，以及其归属的用户</li>\n<li><strong>收藏夹和资源的关联关系</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131018715.png\" alt=\"image-20241013101806634\"></p>\n<p>收藏夹中会有多个项目，因此收藏夹和收藏夹中的内容是1：N的关系</p>\n<p>具体实现和阅读数、点赞数类似，都是要<strong>upsert语义，以及<code>collect_cnt = collect_cnt + 1</code></strong> </p>\n<h3 id=\"查询接口\"><a href=\"#查询接口\" class=\"headerlink\" title=\"查询接口\"></a>查询接口</h3><p>参考竞品：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131110917.png\" alt=\"image-20241013111021697\" style=\"zoom:50%;\" />\n\n<p>在前端做展示一片文章、视频等资源时，需要将<strong>资源本体、阅读数、点赞数、收藏数等</strong>一同显示</p>\n<p>因为在实现阅读、点赞、收藏时，将这些字段视为了<strong>一个独立的领域</strong>，所以需要提供两个接口分别对数据和资源进行查询，并<strong>在Web层面进行聚合</strong>。另一种可行的方案就是将数据作为文章的子对象，那么就可以在Service层进行聚合</p>\n<p>考虑到需要进行查询多个表的操作，为了提高性能，可以使用<strong>errgroup来并发查询数据和资源本体</strong></p>\n<p>具体Web层面实现如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *ArticleHandler)</span></span> PubDetail(ctx *gin.Context, c jwt.UserClaims, req ArticleReq) (ginx.Result, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tuid := c.UserId</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> eg errgroup.Group</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> art domain.Article</span><br><span class=\"line\">\teg.Go(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\tart, err = h.svc.PubDetail(ctx, req.BizId)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;获取文章失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> intr domain.Interact</span><br><span class=\"line\">\teg.Go(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\tintr, err = h.interactSvc.Get(ctx, req.Biz, req.BizId, uid)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;获取文章数据失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\terr := eg.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ginx.Result&#123;&#125;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\terr = h.interactSvc.IncReadCnt(ctx, req.Biz, req.BizId)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;增加阅读数失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ginx.Result&#123;</span><br><span class=\"line\">\t\tData: ArticleVO&#123;</span><br><span class=\"line\">\t\t\tId:         art.Id,</span><br><span class=\"line\">\t\t\tTitle:      art.Title,</span><br><span class=\"line\">\t\t\tContent:    art.Content,</span><br><span class=\"line\">\t\t\tAuthorName: art.Author.Name,</span><br><span class=\"line\">\t\t\tReadCnt:    intr.ReadCnt,</span><br><span class=\"line\">\t\t\tLikeCnt:    intr.LikeCnt,</span><br><span class=\"line\">\t\t\tCollectCnt: intr.CollectCnt,</span><br><span class=\"line\">\t\t\tLiked:      intr.Liked,</span><br><span class=\"line\">\t\t\tCollected:  intr.Collected,</span><br><span class=\"line\">\t\t\tCtime:      time.UnixMilli(art.Ctime).Format(time.DateTime),</span><br><span class=\"line\">\t\t\tUtime:      time.UnixMilli(art.Utime).Format(time.DateTime),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>⚠️：</p>\n<ul>\n<li><p><strong>方法不直接修改参数，而是通过返回值间接修改参数</strong></p>\n</li>\n<li><p>返回值的类型选择：</p>\n<ul>\n<li><p>如果指针实现了接口，那就返回指针</p>\n</li>\n<li><p>如果返回值很大，避免传递引发复制，那就返回指针</p>\n</li>\n</ul>\n</li>\n<li><p>简易原则：</p>\n<ul>\n<li>接收器永远用指针</li>\n<li>输入输出都用结构体</li>\n</ul>\n</li>\n<li><p>不是所有结构体都是可比较的</p>\n</li>\n</ul>\n<h2 id=\"功能实现小结\"><a href=\"#功能实现小结\" class=\"headerlink\" title=\"功能实现小结\"></a>功能实现小结</h2><ul>\n<li><strong>大量使用事物</strong>，保证在操作两张表时保持ACID特性</li>\n<li><strong>大量使用Upsert语义</strong>，因为很多情况下我们不知道表中是否有对应的数据</li>\n<li><strong>大量使用lua脚本来保证缓存中的数据是正确的</strong>，但是无法彻底解决缓存一致性问题</li>\n<li><strong>在查询接口这个呢，只缓存总数数据</strong>，并不会缓存个人是否点赞、是否收藏的数据</li>\n<li><strong>缓存一致性虽然很重要，但不是所有的场景都必须维护</strong>。另一方面，需要彻底解决缓存一致性问题的场景，就不应该使用缓存</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"阅读、点赞、收藏\"><a href=\"#阅读、点赞、收藏\" class=\"headerlink\" title=\"阅读、点赞、收藏\"></a>阅读、点赞、收藏</h1><h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li>阅读数量在点击文章之后就会+1，在退出文章后也不会-1</li>\n<li>点赞和收藏数既可以+1，也可以-1</li>\n<li>有时收藏的内容会放在收藏夹，取消收藏则要移除收藏夹</li>\n</ul>\n<p>另一方面，对于一个平台，不论是文章、视频还是评论，这些对象都会有阅读、点赞、收藏等属性字段。这也就意味着，我们提供的接口不能只限制应用于文章，而是一个<strong>面向任何资源都能使用的阅读、点赞、收藏功能接口</strong></p>\n<p>更进一步地，需要分析阅读、点赞、收藏这三者之间的界限。实际可以考虑一下三个方面：</p>\n<ul>\n<li>场景</li>\n<li>性能</li>\n<li>研发</li>\n</ul>\n<h2 id=\"阅读数功能设计与实现\"><a href=\"#阅读数功能设计与实现\" class=\"headerlink\" title=\"阅读数功能设计与实现\"></a>阅读数功能设计与实现</h2><p>设计一个<code>InteractService</code>接口，该接口提供一个<code>IncReadCnt</code>方法，每当调用阅读接口时，就是该方法将对象的阅读数字段+1。</p>\n<p>考虑极端情况，如果是第一次对某个对象调用<code>IncReadCnt</code>方法，那么此时数据库中是没有该记录的，需要进行insert操作，而第二次、第三次调用时则是进行update操作。由此可见，<code>IncReadCnt</code>方法应该实现<strong>upsert</strong>操作：有记录则更新<code>read_cnt</code>字段，没有记录则插入一条记录</p>\n<p><strong>复习一下GORM实现upsert操作</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dao.db.WithContext(ctx).Clauses(clause.OnConflict&#123;</span><br><span class=\"line\">    DoUpdates: clause.Assignments(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]any&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 直接使用 `read_cnt` = `read_cnt` + 1</span></span><br><span class=\"line\">        <span class=\"comment\">// 保持并发安全</span></span><br><span class=\"line\">        <span class=\"string\">&quot;read_cnt&quot;</span>: gorm.Expr(<span class=\"string\">&quot;read_cnt + 1&quot;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;utime&quot;</span>: time.Now().UnixMilli(),</span><br><span class=\"line\">    &#125;).Create(&amp;Interactive&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 略</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在需求分析阶段，我们得出结论：应该提供一个面向任何资源的阅读、点赞、收藏功能接口。既然如此，就得有区分不同资源的字段。一种很常见的方法就是采用<strong>biz + bizId</strong>来唯一标识某个特定业务下的一个对象</p>\n<p>类似的设计有：</p>\n<ul>\n<li><strong>biz + bizId</strong></li>\n<li><strong>resource type + resourceId</strong></li>\n<li><strong>request type + requestId</strong></li>\n</ul>\n<h3 id=\"缓存设计\"><a href=\"#缓存设计\" class=\"headerlink\" title=\"缓存设计\"></a>缓存设计</h3><p>在任何一个平台，阅读量、点赞、收藏都是高频访问数据。因此需要<strong>做好缓存，防止超高的QPS压垮数据库</strong></p>\n<p>这里选择使用Redis的Hashes结构，一个key中同时保存<code>read_cnt</code>,<code>like_cnt</code>,<code>collect_cnt</code>字段</p>\n<blockquote>\n<p>为什么不是三个（广义上）Redis分别保存三个字段的属性值？🤔</p>\n<p>一个原因是：阅读、点赞、收藏这三个字段经常一同出现，如果用一个key保存，那么只需要进行一次Redis查询就能拿到三个字段值</p>\n<p>另一个原因是：如果使用三个Redis保存，那么为了确保读取三个Redis操作的原子性，就必须使用lua编写复杂脚本（而且性能可能会有一定损失🧐）</p>\n</blockquote>\n<p>枚举使用缓存可能发生的场景：</p>\n<ul>\n<li>没有Key</li>\n<li>有Key且有相应的字段</li>\n<li>有Key但没有相应的字段</li>\n</ul>\n<p>幸运地是，Redis提供了一个<strong>HCINRBY</strong> api（详见下图），可以有效解决后两种情况</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091421095.png\" alt=\"image-20241009142111996\" style=\"zoom: 67%;\" />\n\n<p>对于情况一：我们就需要事先判断一下Redi中的key是否存在，如果存在就把对应的字段+1。<strong>这是一个典型的check-do something场景，可以考虑使用lua脚本确保没有并发问题</strong></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>⚠️：存储对象中的string类型默认对应着MySQL中的BLOB&#x2F;TEXT类型，需要用<code>tag</code>明确指定<code>varchar</code>类型</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410111928510.png\" alt=\"image-20241011192816540\"></p>\n<p><strong>先更新数据库，再更新缓存</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121513334.png\" alt=\"image-20241012151321298\"></p>\n<h2 id=\"点赞功能设计与实现\"><a href=\"#点赞功能设计与实现\" class=\"headerlink\" title=\"点赞功能设计与实现\"></a>点赞功能设计与实现</h2><h3 id=\"需求分析-1\"><a href=\"#需求分析-1\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>点赞事实上分成两个部分：</p>\n<ul>\n<li>保留某个用户是否点赞过，并且用户可以取消点赞</li>\n<li>统计点赞数量</li>\n</ul>\n<p>统计点赞数量和统计阅读数量的思路是一样的，<strong>不过需要额外记录用户是否对某个资源已经点过赞</strong></p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410130733005.png\" alt=\"image-20241012142803292\" style=\"zoom:50%;\" />\n\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><p>为了简化前端代码，可以将点赞和取消点赞转发至同一个接口上，通过一个<code>like</code>字段进行区分</p>\n<ul>\n<li><code>true</code>，那么是点赞</li>\n<li><code>false</code>，那么是取消点赞</li>\n</ul>\n<p>并在Handler中根据<code>like</code>值，调用不同的方法</p>\n<h4 id=\"软删除\"><a href=\"#软删除\" class=\"headerlink\" title=\"软删除\"></a>软删除</h4><p>涉及到用户可以撤销某个行为的场景（例如本处就是取消点赞），通常有两种操作数据的方式</p>\n<ul>\n<li><strong>硬删除</strong>：直接将数据库中的记录删除</li>\n<li><strong>软删除</strong>：将记录中的<code>status</code>字段设置成<code>2</code><ul>\n<li>通常为了避免<strong>零值问题</strong>，人为规定<code>status = 1</code>标识记录存在，<code>status = 2</code>标识记录被删除</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410121436840.png\" alt=\"image-20241012143649799\" style=\"zoom:67%;\" />\n\n<p>相较于软删除，硬删除会产生很多<strong>空洞</strong>，影响MySQL性能。换句话说，<strong>软删除的性能更好</strong></p>\n<p>同样地，在DAO层面，对于点赞操作，不能确定是第一次点赞还会再次点赞。因此需要采用<strong>upsert</strong>操作</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410112013864.png\" alt=\"image-20241011201326778\"></p>\n<h2 id=\"收藏功能设计与实现\"><a href=\"#收藏功能设计与实现\" class=\"headerlink\" title=\"收藏功能设计与实现\"></a>收藏功能设计与实现</h2><p>这里需要引入收藏夹的概念</p>\n<p>总体上就是两张表：</p>\n<ul>\n<li><strong>收藏夹本体</strong>：也就是收藏夹本身，以及其归属的用户</li>\n<li><strong>收藏夹和资源的关联关系</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131018715.png\" alt=\"image-20241013101806634\"></p>\n<p>收藏夹中会有多个项目，因此收藏夹和收藏夹中的内容是1：N的关系</p>\n<p>具体实现和阅读数、点赞数类似，都是要<strong>upsert语义，以及<code>collect_cnt = collect_cnt + 1</code></strong> </p>\n<h3 id=\"查询接口\"><a href=\"#查询接口\" class=\"headerlink\" title=\"查询接口\"></a>查询接口</h3><p>参考竞品：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410131110917.png\" alt=\"image-20241013111021697\" style=\"zoom:50%;\" />\n\n<p>在前端做展示一片文章、视频等资源时，需要将<strong>资源本体、阅读数、点赞数、收藏数等</strong>一同显示</p>\n<p>因为在实现阅读、点赞、收藏时，将这些字段视为了<strong>一个独立的领域</strong>，所以需要提供两个接口分别对数据和资源进行查询，并<strong>在Web层面进行聚合</strong>。另一种可行的方案就是将数据作为文章的子对象，那么就可以在Service层进行聚合</p>\n<p>考虑到需要进行查询多个表的操作，为了提高性能，可以使用<strong>errgroup来并发查询数据和资源本体</strong></p>\n<p>具体Web层面实现如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *ArticleHandler)</span></span> PubDetail(ctx *gin.Context, c jwt.UserClaims, req ArticleReq) (ginx.Result, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tuid := c.UserId</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> eg errgroup.Group</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> art domain.Article</span><br><span class=\"line\">\teg.Go(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\tart, err = h.svc.PubDetail(ctx, req.BizId)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;获取文章失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> intr domain.Interact</span><br><span class=\"line\">\teg.Go(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\tintr, err = h.interactSvc.Get(ctx, req.Biz, req.BizId, uid)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;获取文章数据失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\terr := eg.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ginx.Result&#123;&#125;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">\t\terr = h.interactSvc.IncReadCnt(ctx, req.Biz, req.BizId)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\th.l.Error(<span class=\"string\">&quot;增加阅读数失败&quot;</span>, zap.Error(err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ginx.Result&#123;</span><br><span class=\"line\">\t\tData: ArticleVO&#123;</span><br><span class=\"line\">\t\t\tId:         art.Id,</span><br><span class=\"line\">\t\t\tTitle:      art.Title,</span><br><span class=\"line\">\t\t\tContent:    art.Content,</span><br><span class=\"line\">\t\t\tAuthorName: art.Author.Name,</span><br><span class=\"line\">\t\t\tReadCnt:    intr.ReadCnt,</span><br><span class=\"line\">\t\t\tLikeCnt:    intr.LikeCnt,</span><br><span class=\"line\">\t\t\tCollectCnt: intr.CollectCnt,</span><br><span class=\"line\">\t\t\tLiked:      intr.Liked,</span><br><span class=\"line\">\t\t\tCollected:  intr.Collected,</span><br><span class=\"line\">\t\t\tCtime:      time.UnixMilli(art.Ctime).Format(time.DateTime),</span><br><span class=\"line\">\t\t\tUtime:      time.UnixMilli(art.Utime).Format(time.DateTime),</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>⚠️：</p>\n<ul>\n<li><p><strong>方法不直接修改参数，而是通过返回值间接修改参数</strong></p>\n</li>\n<li><p>返回值的类型选择：</p>\n<ul>\n<li><p>如果指针实现了接口，那就返回指针</p>\n</li>\n<li><p>如果返回值很大，避免传递引发复制，那就返回指针</p>\n</li>\n</ul>\n</li>\n<li><p>简易原则：</p>\n<ul>\n<li>接收器永远用指针</li>\n<li>输入输出都用结构体</li>\n</ul>\n</li>\n<li><p>不是所有结构体都是可比较的</p>\n</li>\n</ul>\n<h2 id=\"功能实现小结\"><a href=\"#功能实现小结\" class=\"headerlink\" title=\"功能实现小结\"></a>功能实现小结</h2><ul>\n<li><strong>大量使用事物</strong>，保证在操作两张表时保持ACID特性</li>\n<li><strong>大量使用Upsert语义</strong>，因为很多情况下我们不知道表中是否有对应的数据</li>\n<li><strong>大量使用lua脚本来保证缓存中的数据是正确的</strong>，但是无法彻底解决缓存一致性问题</li>\n<li><strong>在查询接口这个呢，只缓存总数数据</strong>，并不会缓存个人是否点赞、是否收藏的数据</li>\n<li><strong>缓存一致性虽然很重要，但不是所有的场景都必须维护</strong>。另一方面，需要彻底解决缓存一致性问题的场景，就不应该使用缓存</li>\n</ul>\n"},{"title":"MySQL事务学习","publish":true,"description":"记录一些有关MySQL事务的知识点","date":"2024-09-22T16:00:00.000Z","sticky":2,"_content":"\n\n\n# MySQL事务学习\n\n## 事务ACID\n\naba\n\n## 事务隔离级别\n\n[参考文章](https://xiaolincoding.com/mysql/transaction/mvcc.html)\n\n> 事务并发会 产生什么问题？\n>\n> 事务隔离级别有哪些？怎么实现的？\n>\n> 读已提交和可重复度有什么区别？\n>\n> MVCC是什么？解决了什么问题？实现原理是什么？\n>\n> 可重复读隔离级别彻底解决幻读了吗？\n\n事务的四个特性，以及InnoDB引擎的实现方式：\n\n- 原子性\n  - 通过undo log（回滚日志）来保证\n- 一致性\n  - 通过**持久性+原子性+隔离性**来保证\n- 持久性\n  - 通过redo log（重做日志）来保证\n- 隔离性\n  - 通过MVCC（多版本并发控制）或锁机制来保证\n\n### 并行的事务会有什么问题？\n\nMySQL在同时处理多个事务时，可能会出现<font color=\"blue\">**脏读、不可重复读、幻读**</font>的问题\n\n#### 脏读\n\n一个事务读取到了另一个**未提交的事务所修改的数据**，就意味着发生了脏读\n\n🌰：事务A读取并修改账户余额为`200w`，但没有立刻提交事务。在这一期间，事务B读取到账户余额为`200w`，但是呢，由于事务A还未正式提交，仍有可能发生回滚操作，如果事务A发生了回滚，那么事务B读到的数据就是一个没用的、过期的数据，这种现象就是**脏读**\n\n![image-20240921203626317](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212036399.png)\n\n#### 不可重复读\n\n在一个事务内多次读取同一个数据，如果前后两次读取结果不同，就意味着发生了**不可重复读**\n\n🌰：事务A有两次读取余额操作，好巧不巧🤪在这两次读取操作之间，事务B快速的修改了余额并进行了提交。结果就是，事务A第一次读取到的是原始数据，而第二次读取到的却是事务B修改过后的数据，两次数据不一致！这种现象就是不可重复读\n\n![image-20240921205212723](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212052763.png)\n\n#### 幻读\n\n在一个事务内多次查询符合条件的**记录数量**，如果出现前后查询结果不同，这就说明发生了**幻读**\n\n又是🌰：事务A查询完余额大于`100w`的记录数量为5条后，事务A打算歇一会😴。在事务A歇息的过程中，事务B悄悄的插入了一条余额大于`100w`的记录，导致现在共有6条记录符合查询条件。当事务A醒来再次进行查询时，就会惊讶地发现多了一条记录，~~那么它肯定会认为是自己睡觉睡出幻觉了🤪，~~这种现象就是**幻读**\n\n![image-20240921205706281](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212057315.png)\n\n### 有哪些事务的隔离级别？\n\n由前文可知，多个事务并行处理时可以会出现**脏读、不可重复读、幻读**现象，这三种现象按严重性排序如下：\n\n**`脏读 > 不可重复读 > 幻读`**\n\n针对上述三种现象出现与否，SQL标准提出了四种事务隔离级别，事务隔离级别越高，性能越差🙃，按照隔离级别从低到高一次是：\n\n- **读未提交**：指一个事务还未提交，它所做的数据变更就能被其他事务看到\n  - 可能发生脏读、不可重复读、幻读\n- **读提交**：指一个事务只有在提交后，它所做的数据变更才能被其他事务看到\n  - 可能发生不可重复读、幻读\n- **可重复读**：指一个事务执行过程中所看到的数据在事务开始时就被确定（类似于快照📷），是InnoDB引擎的默认事务隔离级别\n  - 可能发生幻读\n- **串行化**：会对记录加上读写锁，当多个事务发生读写冲突时，后访问数据的事务必须等待前一个事务完成才能继续执行\n  - 木有问题，但是性能很差🤪\n\n⚠️：**MySQL的InnoDB引擎的默认事务隔离级别是「可重复读」，但它很大程度上避免了幻读现象**，解决方案有两种：\n\n- 针对**快照读**（普通select语句），通过**MVCC方式解决幻读**。因为事务执行过程中的数据在事务开始时就已经确定了，即使在A事务执行中程B事务插入了一条数据，这也对A事务是不可见的、透明的，所以就很好的避免了幻读现象\n- 针对**当前读**（select ... for update语句），通过**next-key lock（记录锁+间隙锁）方式解决了幻读**。因为当A事务执行`select ... for update`语句时，会加上`next-key lock`，若事务B在锁的范围内插入了一条数据，那么事务B的插入语句会被阻塞，无法插入成功，所以就很好地解决了幻读问题\n\n#### 四种隔离级别的实现方式\n\n- **读未提交**\n  - 直接读就好了\n- **串行化**\n  - 加读写锁避免并行访问\n- **读提交**和**可重复读**都是通过**Read View**来实现的，区别在于创建Read View的时机\n  - 读提交在**每一个语句执行之前**都会生成一个Read View\n  - 可重复读只在启动事务时生成一个Read View，然后整个事务执行过程中都用这一个Read View\n\n🌟区分「开启事务」和「启动事务」\n\n在MySQL中有两种方式**开启事务**\n\n```sql\n# 第一种\nbegin/start transaction\n\n# 第二种\nstart transaction with consistent snapshot\n```\n\n以第一种方式开启事务不代表启动了一个事务，只有执行了第一条select语句，才是真正启动事务\n\n第二种方式在开启事务的同时也启动了事务（毕竟命令中都带有`snapshot`😂）\n\n### Read View在MVCC是如何工作的？\n\n> 两个前置知识\n>\n> - Read View中四个字段作用\n>\n> - 聚簇索引记录中两个跟事务有关的两个隐藏字段\n\nRead View实质是由**四个字段**构成的\n\n![image-20240923152532491](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231525562.png)\n\n- **m_ids**：指在创建Read View时，当前数据库中「活跃事务」的事务id，可能有多个\n  - **活跃事务**即**启动**了但是还没有提交的事务\n- **min_trx_id**：活跃事务中最小的事务id\n- **max_trx_id**：**数据库下一个将分配给事务的id**，即全局事务id的最大值+1\n- **creator_trx_id**：创建当前Read View的事务id\n\n了解完Read View中的四个字段后，再看看聚簇索引记录中的**两个隐藏字段**，🌰：\n\n![image-20240923153259596](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231532645.png)\n\n- **trx_id**：当一个事务对某条聚簇索引的数据进行改动时，就把该事务的id放入trx_id字段中\n- **roll_pointer**：当对某条聚簇索引记录进行修改时，都会把旧版本的数据记录在**undo日志**中，roll_pointer就指向每一个旧版本的数据，因此可以通过roll_pointer隐藏列找到历史记录\n\n#### MVCC\n\n在了解Read View四个字段以及聚簇索引记录的两个隐藏列后，接下来就可以弄清楚MVCC是如何控制数据快照的\n\n假设现在有一个「活跃事务」事务A，那么可以根据事务A的Read View创建时刻将其他事务划分为四类：\n\n- 事务id小于`min_trx_id`\n- 事务id大于等于`max_trx_id`\n- 事务id在`min_trx_id`和`max_trx_id`之间且位于`m_ids`中\n- 事务id在`min_trx_id`和`max_trx_id`之间且不位于`m_ids`中\n\n![image-20240923154216650](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231542692.png)\n\n- 如果记录的隐藏列`trx_id`值小于`min_trx_id`，那么这个版本的记录是在Read View创建之前完成的，所以该版本记录是对当前事务**可见的**\n- 如果`trx_id`值大于等于`max_trx_id`，说明这个版本的记录是在Read View创建之后生成的，故对于当前事务是**不可见的**\n- 如果`trx_id`值在`min_trx_id`和`max_trx_id`之间，则需要进一步判断记录的`trx_id`是否在`m_ids`列表中（即对于的事务是否是活跃事务）\n  - 是活跃事务，那么该该版本的记录对当前事务**不可见**\n  - 不是活跃事务，那么该版本的记录是**可见的**\n  - 🌰：创建了1、2、3、4这四个事务，其中事务3以迅雷不及掩耳之势提交了，那么随后启动的事务5是可以看见事务3所修改的记录版本的\n\n**这种通过「版本链」来控制并发事务不冲突地访问同一条记录的操作就叫MVCC（多版本并发控制）**\n\n","source":"_posts/MySQL/MySQL事务学习.md","raw":"---\ntitle: MySQL事务学习\npublish: true\ndescription: 记录一些有关MySQL事务的知识点\ndate: 2024-09-23 \ntag: MySQL\nsticky: 2\n---\n\n\n\n# MySQL事务学习\n\n## 事务ACID\n\naba\n\n## 事务隔离级别\n\n[参考文章](https://xiaolincoding.com/mysql/transaction/mvcc.html)\n\n> 事务并发会 产生什么问题？\n>\n> 事务隔离级别有哪些？怎么实现的？\n>\n> 读已提交和可重复度有什么区别？\n>\n> MVCC是什么？解决了什么问题？实现原理是什么？\n>\n> 可重复读隔离级别彻底解决幻读了吗？\n\n事务的四个特性，以及InnoDB引擎的实现方式：\n\n- 原子性\n  - 通过undo log（回滚日志）来保证\n- 一致性\n  - 通过**持久性+原子性+隔离性**来保证\n- 持久性\n  - 通过redo log（重做日志）来保证\n- 隔离性\n  - 通过MVCC（多版本并发控制）或锁机制来保证\n\n### 并行的事务会有什么问题？\n\nMySQL在同时处理多个事务时，可能会出现<font color=\"blue\">**脏读、不可重复读、幻读**</font>的问题\n\n#### 脏读\n\n一个事务读取到了另一个**未提交的事务所修改的数据**，就意味着发生了脏读\n\n🌰：事务A读取并修改账户余额为`200w`，但没有立刻提交事务。在这一期间，事务B读取到账户余额为`200w`，但是呢，由于事务A还未正式提交，仍有可能发生回滚操作，如果事务A发生了回滚，那么事务B读到的数据就是一个没用的、过期的数据，这种现象就是**脏读**\n\n![image-20240921203626317](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212036399.png)\n\n#### 不可重复读\n\n在一个事务内多次读取同一个数据，如果前后两次读取结果不同，就意味着发生了**不可重复读**\n\n🌰：事务A有两次读取余额操作，好巧不巧🤪在这两次读取操作之间，事务B快速的修改了余额并进行了提交。结果就是，事务A第一次读取到的是原始数据，而第二次读取到的却是事务B修改过后的数据，两次数据不一致！这种现象就是不可重复读\n\n![image-20240921205212723](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212052763.png)\n\n#### 幻读\n\n在一个事务内多次查询符合条件的**记录数量**，如果出现前后查询结果不同，这就说明发生了**幻读**\n\n又是🌰：事务A查询完余额大于`100w`的记录数量为5条后，事务A打算歇一会😴。在事务A歇息的过程中，事务B悄悄的插入了一条余额大于`100w`的记录，导致现在共有6条记录符合查询条件。当事务A醒来再次进行查询时，就会惊讶地发现多了一条记录，~~那么它肯定会认为是自己睡觉睡出幻觉了🤪，~~这种现象就是**幻读**\n\n![image-20240921205706281](https://raw.githubusercontent.com/lyydsheep/pic/main/202409212057315.png)\n\n### 有哪些事务的隔离级别？\n\n由前文可知，多个事务并行处理时可以会出现**脏读、不可重复读、幻读**现象，这三种现象按严重性排序如下：\n\n**`脏读 > 不可重复读 > 幻读`**\n\n针对上述三种现象出现与否，SQL标准提出了四种事务隔离级别，事务隔离级别越高，性能越差🙃，按照隔离级别从低到高一次是：\n\n- **读未提交**：指一个事务还未提交，它所做的数据变更就能被其他事务看到\n  - 可能发生脏读、不可重复读、幻读\n- **读提交**：指一个事务只有在提交后，它所做的数据变更才能被其他事务看到\n  - 可能发生不可重复读、幻读\n- **可重复读**：指一个事务执行过程中所看到的数据在事务开始时就被确定（类似于快照📷），是InnoDB引擎的默认事务隔离级别\n  - 可能发生幻读\n- **串行化**：会对记录加上读写锁，当多个事务发生读写冲突时，后访问数据的事务必须等待前一个事务完成才能继续执行\n  - 木有问题，但是性能很差🤪\n\n⚠️：**MySQL的InnoDB引擎的默认事务隔离级别是「可重复读」，但它很大程度上避免了幻读现象**，解决方案有两种：\n\n- 针对**快照读**（普通select语句），通过**MVCC方式解决幻读**。因为事务执行过程中的数据在事务开始时就已经确定了，即使在A事务执行中程B事务插入了一条数据，这也对A事务是不可见的、透明的，所以就很好的避免了幻读现象\n- 针对**当前读**（select ... for update语句），通过**next-key lock（记录锁+间隙锁）方式解决了幻读**。因为当A事务执行`select ... for update`语句时，会加上`next-key lock`，若事务B在锁的范围内插入了一条数据，那么事务B的插入语句会被阻塞，无法插入成功，所以就很好地解决了幻读问题\n\n#### 四种隔离级别的实现方式\n\n- **读未提交**\n  - 直接读就好了\n- **串行化**\n  - 加读写锁避免并行访问\n- **读提交**和**可重复读**都是通过**Read View**来实现的，区别在于创建Read View的时机\n  - 读提交在**每一个语句执行之前**都会生成一个Read View\n  - 可重复读只在启动事务时生成一个Read View，然后整个事务执行过程中都用这一个Read View\n\n🌟区分「开启事务」和「启动事务」\n\n在MySQL中有两种方式**开启事务**\n\n```sql\n# 第一种\nbegin/start transaction\n\n# 第二种\nstart transaction with consistent snapshot\n```\n\n以第一种方式开启事务不代表启动了一个事务，只有执行了第一条select语句，才是真正启动事务\n\n第二种方式在开启事务的同时也启动了事务（毕竟命令中都带有`snapshot`😂）\n\n### Read View在MVCC是如何工作的？\n\n> 两个前置知识\n>\n> - Read View中四个字段作用\n>\n> - 聚簇索引记录中两个跟事务有关的两个隐藏字段\n\nRead View实质是由**四个字段**构成的\n\n![image-20240923152532491](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231525562.png)\n\n- **m_ids**：指在创建Read View时，当前数据库中「活跃事务」的事务id，可能有多个\n  - **活跃事务**即**启动**了但是还没有提交的事务\n- **min_trx_id**：活跃事务中最小的事务id\n- **max_trx_id**：**数据库下一个将分配给事务的id**，即全局事务id的最大值+1\n- **creator_trx_id**：创建当前Read View的事务id\n\n了解完Read View中的四个字段后，再看看聚簇索引记录中的**两个隐藏字段**，🌰：\n\n![image-20240923153259596](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231532645.png)\n\n- **trx_id**：当一个事务对某条聚簇索引的数据进行改动时，就把该事务的id放入trx_id字段中\n- **roll_pointer**：当对某条聚簇索引记录进行修改时，都会把旧版本的数据记录在**undo日志**中，roll_pointer就指向每一个旧版本的数据，因此可以通过roll_pointer隐藏列找到历史记录\n\n#### MVCC\n\n在了解Read View四个字段以及聚簇索引记录的两个隐藏列后，接下来就可以弄清楚MVCC是如何控制数据快照的\n\n假设现在有一个「活跃事务」事务A，那么可以根据事务A的Read View创建时刻将其他事务划分为四类：\n\n- 事务id小于`min_trx_id`\n- 事务id大于等于`max_trx_id`\n- 事务id在`min_trx_id`和`max_trx_id`之间且位于`m_ids`中\n- 事务id在`min_trx_id`和`max_trx_id`之间且不位于`m_ids`中\n\n![image-20240923154216650](https://raw.githubusercontent.com/lyydsheep/pic/main/202409231542692.png)\n\n- 如果记录的隐藏列`trx_id`值小于`min_trx_id`，那么这个版本的记录是在Read View创建之前完成的，所以该版本记录是对当前事务**可见的**\n- 如果`trx_id`值大于等于`max_trx_id`，说明这个版本的记录是在Read View创建之后生成的，故对于当前事务是**不可见的**\n- 如果`trx_id`值在`min_trx_id`和`max_trx_id`之间，则需要进一步判断记录的`trx_id`是否在`m_ids`列表中（即对于的事务是否是活跃事务）\n  - 是活跃事务，那么该该版本的记录对当前事务**不可见**\n  - 不是活跃事务，那么该版本的记录是**可见的**\n  - 🌰：创建了1、2、3、4这四个事务，其中事务3以迅雷不及掩耳之势提交了，那么随后启动的事务5是可以看见事务3所修改的记录版本的\n\n**这种通过「版本链」来控制并发事务不冲突地访问同一条记录的操作就叫MVCC（多版本并发控制）**\n\n","slug":"MySQL/MySQL事务学习","published":1,"updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n0029a5t23h4se78m","content":"<h1 id=\"MySQL事务学习\"><a href=\"#MySQL事务学习\" class=\"headerlink\" title=\"MySQL事务学习\"></a>MySQL事务学习</h1><h2 id=\"事务ACID\"><a href=\"#事务ACID\" class=\"headerlink\" title=\"事务ACID\"></a>事务ACID</h2><p>aba</p>\n<h2 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h2><p><a href=\"https://xiaolincoding.com/mysql/transaction/mvcc.html\">参考文章</a></p>\n<blockquote>\n<p>事务并发会 产生什么问题？</p>\n<p>事务隔离级别有哪些？怎么实现的？</p>\n<p>读已提交和可重复度有什么区别？</p>\n<p>MVCC是什么？解决了什么问题？实现原理是什么？</p>\n<p>可重复读隔离级别彻底解决幻读了吗？</p>\n</blockquote>\n<p>事务的四个特性，以及InnoDB引擎的实现方式：</p>\n<ul>\n<li>原子性<ul>\n<li>通过undo log（回滚日志）来保证</li>\n</ul>\n</li>\n<li>一致性<ul>\n<li>通过<strong>持久性+原子性+隔离性</strong>来保证</li>\n</ul>\n</li>\n<li>持久性<ul>\n<li>通过redo log（重做日志）来保证</li>\n</ul>\n</li>\n<li>隔离性<ul>\n<li>通过MVCC（多版本并发控制）或锁机制来保证</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并行的事务会有什么问题？\"><a href=\"#并行的事务会有什么问题？\" class=\"headerlink\" title=\"并行的事务会有什么问题？\"></a>并行的事务会有什么问题？</h3><p>MySQL在同时处理多个事务时，可能会出现<font color=\"blue\"><strong>脏读、不可重复读、幻读</strong></font>的问题</p>\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p>一个事务读取到了另一个<strong>未提交的事务所修改的数据</strong>，就意味着发生了脏读</p>\n<p>🌰：事务A读取并修改账户余额为<code>200w</code>，但没有立刻提交事务。在这一期间，事务B读取到账户余额为<code>200w</code>，但是呢，由于事务A还未正式提交，仍有可能发生回滚操作，如果事务A发生了回滚，那么事务B读到的数据就是一个没用的、过期的数据，这种现象就是<strong>脏读</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212036399.png\" alt=\"image-20240921203626317\"></p>\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p>在一个事务内多次读取同一个数据，如果前后两次读取结果不同，就意味着发生了<strong>不可重复读</strong></p>\n<p>🌰：事务A有两次读取余额操作，好巧不巧🤪在这两次读取操作之间，事务B快速的修改了余额并进行了提交。结果就是，事务A第一次读取到的是原始数据，而第二次读取到的却是事务B修改过后的数据，两次数据不一致！这种现象就是不可重复读</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212052763.png\" alt=\"image-20240921205212723\"></p>\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p>在一个事务内多次查询符合条件的<strong>记录数量</strong>，如果出现前后查询结果不同，这就说明发生了<strong>幻读</strong></p>\n<p>又是🌰：事务A查询完余额大于<code>100w</code>的记录数量为5条后，事务A打算歇一会😴。在事务A歇息的过程中，事务B悄悄的插入了一条余额大于<code>100w</code>的记录，导致现在共有6条记录符合查询条件。当事务A醒来再次进行查询时，就会惊讶地发现多了一条记录，<del>那么它肯定会认为是自己睡觉睡出幻觉了🤪，</del>这种现象就是<strong>幻读</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212057315.png\" alt=\"image-20240921205706281\"></p>\n<h3 id=\"有哪些事务的隔离级别？\"><a href=\"#有哪些事务的隔离级别？\" class=\"headerlink\" title=\"有哪些事务的隔离级别？\"></a>有哪些事务的隔离级别？</h3><p>由前文可知，多个事务并行处理时可以会出现<strong>脏读、不可重复读、幻读</strong>现象，这三种现象按严重性排序如下：</p>\n<p><strong><code>脏读 &gt; 不可重复读 &gt; 幻读</code></strong></p>\n<p>针对上述三种现象出现与否，SQL标准提出了四种事务隔离级别，事务隔离级别越高，性能越差🙃，按照隔离级别从低到高一次是：</p>\n<ul>\n<li><strong>读未提交</strong>：指一个事务还未提交，它所做的数据变更就能被其他事务看到<ul>\n<li>可能发生脏读、不可重复读、幻读</li>\n</ul>\n</li>\n<li><strong>读提交</strong>：指一个事务只有在提交后，它所做的数据变更才能被其他事务看到<ul>\n<li>可能发生不可重复读、幻读</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>：指一个事务执行过程中所看到的数据在事务开始时就被确定（类似于快照📷），是InnoDB引擎的默认事务隔离级别<ul>\n<li>可能发生幻读</li>\n</ul>\n</li>\n<li><strong>串行化</strong>：会对记录加上读写锁，当多个事务发生读写冲突时，后访问数据的事务必须等待前一个事务完成才能继续执行<ul>\n<li>木有问题，但是性能很差🤪</li>\n</ul>\n</li>\n</ul>\n<p>⚠️：<strong>MySQL的InnoDB引擎的默认事务隔离级别是「可重复读」，但它很大程度上避免了幻读现象</strong>，解决方案有两种：</p>\n<ul>\n<li>针对<strong>快照读</strong>（普通select语句），通过<strong>MVCC方式解决幻读</strong>。因为事务执行过程中的数据在事务开始时就已经确定了，即使在A事务执行中程B事务插入了一条数据，这也对A事务是不可见的、透明的，所以就很好的避免了幻读现象</li>\n<li>针对<strong>当前读</strong>（select … for update语句），通过<strong>next-key lock（记录锁+间隙锁）方式解决了幻读</strong>。因为当A事务执行<code>select ... for update</code>语句时，会加上<code>next-key lock</code>，若事务B在锁的范围内插入了一条数据，那么事务B的插入语句会被阻塞，无法插入成功，所以就很好地解决了幻读问题</li>\n</ul>\n<h4 id=\"四种隔离级别的实现方式\"><a href=\"#四种隔离级别的实现方式\" class=\"headerlink\" title=\"四种隔离级别的实现方式\"></a>四种隔离级别的实现方式</h4><ul>\n<li><strong>读未提交</strong><ul>\n<li>直接读就好了</li>\n</ul>\n</li>\n<li><strong>串行化</strong><ul>\n<li>加读写锁避免并行访问</li>\n</ul>\n</li>\n<li><strong>读提交</strong>和<strong>可重复读</strong>都是通过<strong>Read View</strong>来实现的，区别在于创建Read View的时机<ul>\n<li>读提交在<strong>每一个语句执行之前</strong>都会生成一个Read View</li>\n<li>可重复读只在启动事务时生成一个Read View，然后整个事务执行过程中都用这一个Read View</li>\n</ul>\n</li>\n</ul>\n<p>🌟区分「开启事务」和「启动事务」</p>\n<p>在MySQL中有两种方式<strong>开启事务</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 第一种</span><br><span class=\"line\"><span class=\"keyword\">begin</span><span class=\"operator\">/</span><span class=\"keyword\">start</span> transaction</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二种</span><br><span class=\"line\"><span class=\"keyword\">start</span> transaction <span class=\"keyword\">with</span> consistent snapshot</span><br></pre></td></tr></table></figure>\n\n<p>以第一种方式开启事务不代表启动了一个事务，只有执行了第一条select语句，才是真正启动事务</p>\n<p>第二种方式在开启事务的同时也启动了事务（毕竟命令中都带有<code>snapshot</code>😂）</p>\n<h3 id=\"Read-View在MVCC是如何工作的？\"><a href=\"#Read-View在MVCC是如何工作的？\" class=\"headerlink\" title=\"Read View在MVCC是如何工作的？\"></a>Read View在MVCC是如何工作的？</h3><blockquote>\n<p>两个前置知识</p>\n<ul>\n<li><p>Read View中四个字段作用</p>\n</li>\n<li><p>聚簇索引记录中两个跟事务有关的两个隐藏字段</p>\n</li>\n</ul>\n</blockquote>\n<p>Read View实质是由<strong>四个字段</strong>构成的</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231525562.png\" alt=\"image-20240923152532491\"></p>\n<ul>\n<li><strong>m_ids</strong>：指在创建Read View时，当前数据库中「活跃事务」的事务id，可能有多个<ul>\n<li><strong>活跃事务</strong>即<strong>启动</strong>了但是还没有提交的事务</li>\n</ul>\n</li>\n<li><strong>min_trx_id</strong>：活跃事务中最小的事务id</li>\n<li><strong>max_trx_id</strong>：<strong>数据库下一个将分配给事务的id</strong>，即全局事务id的最大值+1</li>\n<li><strong>creator_trx_id</strong>：创建当前Read View的事务id</li>\n</ul>\n<p>了解完Read View中的四个字段后，再看看聚簇索引记录中的<strong>两个隐藏字段</strong>，🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231532645.png\" alt=\"image-20240923153259596\"></p>\n<ul>\n<li><strong>trx_id</strong>：当一个事务对某条聚簇索引的数据进行改动时，就把该事务的id放入trx_id字段中</li>\n<li><strong>roll_pointer</strong>：当对某条聚簇索引记录进行修改时，都会把旧版本的数据记录在<strong>undo日志</strong>中，roll_pointer就指向每一个旧版本的数据，因此可以通过roll_pointer隐藏列找到历史记录</li>\n</ul>\n<h4 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h4><p>在了解Read View四个字段以及聚簇索引记录的两个隐藏列后，接下来就可以弄清楚MVCC是如何控制数据快照的</p>\n<p>假设现在有一个「活跃事务」事务A，那么可以根据事务A的Read View创建时刻将其他事务划分为四类：</p>\n<ul>\n<li>事务id小于<code>min_trx_id</code></li>\n<li>事务id大于等于<code>max_trx_id</code></li>\n<li>事务id在<code>min_trx_id</code>和<code>max_trx_id</code>之间且位于<code>m_ids</code>中</li>\n<li>事务id在<code>min_trx_id</code>和<code>max_trx_id</code>之间且不位于<code>m_ids</code>中</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231542692.png\" alt=\"image-20240923154216650\"></p>\n<ul>\n<li>如果记录的隐藏列<code>trx_id</code>值小于<code>min_trx_id</code>，那么这个版本的记录是在Read View创建之前完成的，所以该版本记录是对当前事务<strong>可见的</strong></li>\n<li>如果<code>trx_id</code>值大于等于<code>max_trx_id</code>，说明这个版本的记录是在Read View创建之后生成的，故对于当前事务是<strong>不可见的</strong></li>\n<li>如果<code>trx_id</code>值在<code>min_trx_id</code>和<code>max_trx_id</code>之间，则需要进一步判断记录的<code>trx_id</code>是否在<code>m_ids</code>列表中（即对于的事务是否是活跃事务）<ul>\n<li>是活跃事务，那么该该版本的记录对当前事务<strong>不可见</strong></li>\n<li>不是活跃事务，那么该版本的记录是<strong>可见的</strong></li>\n<li>🌰：创建了1、2、3、4这四个事务，其中事务3以迅雷不及掩耳之势提交了，那么随后启动的事务5是可以看见事务3所修改的记录版本的</li>\n</ul>\n</li>\n</ul>\n<p><strong>这种通过「版本链」来控制并发事务不冲突地访问同一条记录的操作就叫MVCC（多版本并发控制）</strong></p>\n","excerpt":"","more":"<h1 id=\"MySQL事务学习\"><a href=\"#MySQL事务学习\" class=\"headerlink\" title=\"MySQL事务学习\"></a>MySQL事务学习</h1><h2 id=\"事务ACID\"><a href=\"#事务ACID\" class=\"headerlink\" title=\"事务ACID\"></a>事务ACID</h2><p>aba</p>\n<h2 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h2><p><a href=\"https://xiaolincoding.com/mysql/transaction/mvcc.html\">参考文章</a></p>\n<blockquote>\n<p>事务并发会 产生什么问题？</p>\n<p>事务隔离级别有哪些？怎么实现的？</p>\n<p>读已提交和可重复度有什么区别？</p>\n<p>MVCC是什么？解决了什么问题？实现原理是什么？</p>\n<p>可重复读隔离级别彻底解决幻读了吗？</p>\n</blockquote>\n<p>事务的四个特性，以及InnoDB引擎的实现方式：</p>\n<ul>\n<li>原子性<ul>\n<li>通过undo log（回滚日志）来保证</li>\n</ul>\n</li>\n<li>一致性<ul>\n<li>通过<strong>持久性+原子性+隔离性</strong>来保证</li>\n</ul>\n</li>\n<li>持久性<ul>\n<li>通过redo log（重做日志）来保证</li>\n</ul>\n</li>\n<li>隔离性<ul>\n<li>通过MVCC（多版本并发控制）或锁机制来保证</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并行的事务会有什么问题？\"><a href=\"#并行的事务会有什么问题？\" class=\"headerlink\" title=\"并行的事务会有什么问题？\"></a>并行的事务会有什么问题？</h3><p>MySQL在同时处理多个事务时，可能会出现<font color=\"blue\"><strong>脏读、不可重复读、幻读</strong></font>的问题</p>\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p>一个事务读取到了另一个<strong>未提交的事务所修改的数据</strong>，就意味着发生了脏读</p>\n<p>🌰：事务A读取并修改账户余额为<code>200w</code>，但没有立刻提交事务。在这一期间，事务B读取到账户余额为<code>200w</code>，但是呢，由于事务A还未正式提交，仍有可能发生回滚操作，如果事务A发生了回滚，那么事务B读到的数据就是一个没用的、过期的数据，这种现象就是<strong>脏读</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212036399.png\" alt=\"image-20240921203626317\"></p>\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p>在一个事务内多次读取同一个数据，如果前后两次读取结果不同，就意味着发生了<strong>不可重复读</strong></p>\n<p>🌰：事务A有两次读取余额操作，好巧不巧🤪在这两次读取操作之间，事务B快速的修改了余额并进行了提交。结果就是，事务A第一次读取到的是原始数据，而第二次读取到的却是事务B修改过后的数据，两次数据不一致！这种现象就是不可重复读</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212052763.png\" alt=\"image-20240921205212723\"></p>\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p>在一个事务内多次查询符合条件的<strong>记录数量</strong>，如果出现前后查询结果不同，这就说明发生了<strong>幻读</strong></p>\n<p>又是🌰：事务A查询完余额大于<code>100w</code>的记录数量为5条后，事务A打算歇一会😴。在事务A歇息的过程中，事务B悄悄的插入了一条余额大于<code>100w</code>的记录，导致现在共有6条记录符合查询条件。当事务A醒来再次进行查询时，就会惊讶地发现多了一条记录，<del>那么它肯定会认为是自己睡觉睡出幻觉了🤪，</del>这种现象就是<strong>幻读</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409212057315.png\" alt=\"image-20240921205706281\"></p>\n<h3 id=\"有哪些事务的隔离级别？\"><a href=\"#有哪些事务的隔离级别？\" class=\"headerlink\" title=\"有哪些事务的隔离级别？\"></a>有哪些事务的隔离级别？</h3><p>由前文可知，多个事务并行处理时可以会出现<strong>脏读、不可重复读、幻读</strong>现象，这三种现象按严重性排序如下：</p>\n<p><strong><code>脏读 &gt; 不可重复读 &gt; 幻读</code></strong></p>\n<p>针对上述三种现象出现与否，SQL标准提出了四种事务隔离级别，事务隔离级别越高，性能越差🙃，按照隔离级别从低到高一次是：</p>\n<ul>\n<li><strong>读未提交</strong>：指一个事务还未提交，它所做的数据变更就能被其他事务看到<ul>\n<li>可能发生脏读、不可重复读、幻读</li>\n</ul>\n</li>\n<li><strong>读提交</strong>：指一个事务只有在提交后，它所做的数据变更才能被其他事务看到<ul>\n<li>可能发生不可重复读、幻读</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>：指一个事务执行过程中所看到的数据在事务开始时就被确定（类似于快照📷），是InnoDB引擎的默认事务隔离级别<ul>\n<li>可能发生幻读</li>\n</ul>\n</li>\n<li><strong>串行化</strong>：会对记录加上读写锁，当多个事务发生读写冲突时，后访问数据的事务必须等待前一个事务完成才能继续执行<ul>\n<li>木有问题，但是性能很差🤪</li>\n</ul>\n</li>\n</ul>\n<p>⚠️：<strong>MySQL的InnoDB引擎的默认事务隔离级别是「可重复读」，但它很大程度上避免了幻读现象</strong>，解决方案有两种：</p>\n<ul>\n<li>针对<strong>快照读</strong>（普通select语句），通过<strong>MVCC方式解决幻读</strong>。因为事务执行过程中的数据在事务开始时就已经确定了，即使在A事务执行中程B事务插入了一条数据，这也对A事务是不可见的、透明的，所以就很好的避免了幻读现象</li>\n<li>针对<strong>当前读</strong>（select … for update语句），通过<strong>next-key lock（记录锁+间隙锁）方式解决了幻读</strong>。因为当A事务执行<code>select ... for update</code>语句时，会加上<code>next-key lock</code>，若事务B在锁的范围内插入了一条数据，那么事务B的插入语句会被阻塞，无法插入成功，所以就很好地解决了幻读问题</li>\n</ul>\n<h4 id=\"四种隔离级别的实现方式\"><a href=\"#四种隔离级别的实现方式\" class=\"headerlink\" title=\"四种隔离级别的实现方式\"></a>四种隔离级别的实现方式</h4><ul>\n<li><strong>读未提交</strong><ul>\n<li>直接读就好了</li>\n</ul>\n</li>\n<li><strong>串行化</strong><ul>\n<li>加读写锁避免并行访问</li>\n</ul>\n</li>\n<li><strong>读提交</strong>和<strong>可重复读</strong>都是通过<strong>Read View</strong>来实现的，区别在于创建Read View的时机<ul>\n<li>读提交在<strong>每一个语句执行之前</strong>都会生成一个Read View</li>\n<li>可重复读只在启动事务时生成一个Read View，然后整个事务执行过程中都用这一个Read View</li>\n</ul>\n</li>\n</ul>\n<p>🌟区分「开启事务」和「启动事务」</p>\n<p>在MySQL中有两种方式<strong>开启事务</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 第一种</span><br><span class=\"line\"><span class=\"keyword\">begin</span><span class=\"operator\">/</span><span class=\"keyword\">start</span> transaction</span><br><span class=\"line\"></span><br><span class=\"line\"># 第二种</span><br><span class=\"line\"><span class=\"keyword\">start</span> transaction <span class=\"keyword\">with</span> consistent snapshot</span><br></pre></td></tr></table></figure>\n\n<p>以第一种方式开启事务不代表启动了一个事务，只有执行了第一条select语句，才是真正启动事务</p>\n<p>第二种方式在开启事务的同时也启动了事务（毕竟命令中都带有<code>snapshot</code>😂）</p>\n<h3 id=\"Read-View在MVCC是如何工作的？\"><a href=\"#Read-View在MVCC是如何工作的？\" class=\"headerlink\" title=\"Read View在MVCC是如何工作的？\"></a>Read View在MVCC是如何工作的？</h3><blockquote>\n<p>两个前置知识</p>\n<ul>\n<li><p>Read View中四个字段作用</p>\n</li>\n<li><p>聚簇索引记录中两个跟事务有关的两个隐藏字段</p>\n</li>\n</ul>\n</blockquote>\n<p>Read View实质是由<strong>四个字段</strong>构成的</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231525562.png\" alt=\"image-20240923152532491\"></p>\n<ul>\n<li><strong>m_ids</strong>：指在创建Read View时，当前数据库中「活跃事务」的事务id，可能有多个<ul>\n<li><strong>活跃事务</strong>即<strong>启动</strong>了但是还没有提交的事务</li>\n</ul>\n</li>\n<li><strong>min_trx_id</strong>：活跃事务中最小的事务id</li>\n<li><strong>max_trx_id</strong>：<strong>数据库下一个将分配给事务的id</strong>，即全局事务id的最大值+1</li>\n<li><strong>creator_trx_id</strong>：创建当前Read View的事务id</li>\n</ul>\n<p>了解完Read View中的四个字段后，再看看聚簇索引记录中的<strong>两个隐藏字段</strong>，🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231532645.png\" alt=\"image-20240923153259596\"></p>\n<ul>\n<li><strong>trx_id</strong>：当一个事务对某条聚簇索引的数据进行改动时，就把该事务的id放入trx_id字段中</li>\n<li><strong>roll_pointer</strong>：当对某条聚簇索引记录进行修改时，都会把旧版本的数据记录在<strong>undo日志</strong>中，roll_pointer就指向每一个旧版本的数据，因此可以通过roll_pointer隐藏列找到历史记录</li>\n</ul>\n<h4 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h4><p>在了解Read View四个字段以及聚簇索引记录的两个隐藏列后，接下来就可以弄清楚MVCC是如何控制数据快照的</p>\n<p>假设现在有一个「活跃事务」事务A，那么可以根据事务A的Read View创建时刻将其他事务划分为四类：</p>\n<ul>\n<li>事务id小于<code>min_trx_id</code></li>\n<li>事务id大于等于<code>max_trx_id</code></li>\n<li>事务id在<code>min_trx_id</code>和<code>max_trx_id</code>之间且位于<code>m_ids</code>中</li>\n<li>事务id在<code>min_trx_id</code>和<code>max_trx_id</code>之间且不位于<code>m_ids</code>中</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409231542692.png\" alt=\"image-20240923154216650\"></p>\n<ul>\n<li>如果记录的隐藏列<code>trx_id</code>值小于<code>min_trx_id</code>，那么这个版本的记录是在Read View创建之前完成的，所以该版本记录是对当前事务<strong>可见的</strong></li>\n<li>如果<code>trx_id</code>值大于等于<code>max_trx_id</code>，说明这个版本的记录是在Read View创建之后生成的，故对于当前事务是<strong>不可见的</strong></li>\n<li>如果<code>trx_id</code>值在<code>min_trx_id</code>和<code>max_trx_id</code>之间，则需要进一步判断记录的<code>trx_id</code>是否在<code>m_ids</code>列表中（即对于的事务是否是活跃事务）<ul>\n<li>是活跃事务，那么该该版本的记录对当前事务<strong>不可见</strong></li>\n<li>不是活跃事务，那么该版本的记录是<strong>可见的</strong></li>\n<li>🌰：创建了1、2、3、4这四个事务，其中事务3以迅雷不及掩耳之势提交了，那么随后启动的事务5是可以看见事务3所修改的记录版本的</li>\n</ul>\n</li>\n</ul>\n<p><strong>这种通过「版本链」来控制并发事务不冲突地访问同一条记录的操作就叫MVCC（多版本并发控制）</strong></p>\n"},{"_content":"## 01\n- 建立连接的过程是比较复杂的，因此尽量使用长连接，避免过多的短链接\n\t- 但是长连接积累下来会导致内存占用太大，强行被系统杀死（OOM）\n\t- 解决方法：\n\t\t- 定期断开长连接\n\t\t- MySQL 5.7 及之后的版本，通过执行mysql_reset_connection重新初始化连接资源\n\n## 03\n- 尽量不要使用长事务\n\t- 长事务意味着系统中存在很老的Read-View，在事务提交前，这些Read-View都必须保留，这就会导致占用大量存储空间\n\t- 除了对回滚段的影响，长事务还占用锁资源，也可能会拖垮整个数据库\n- 总是使用`set autocommit = 1`，通过显示语句的方式来启动事务\n- 频繁使用事务的业务，可以使用`commit work and chain`\n\t- 在`autocommit = 1`，通过`begin`显示开启事务的情况下，`commit`表示提交事务，`commit work and chain`表示提交事务并开启下一个事务，省去了`begin`语句的开销\n- ![Screenshot 2025-01-17 at 22.18.29.png](https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-17%20at%2022.18.29.png)\n\n\n## 04\n- 哈希表适用于等值查询场景\n- 有序数组适用于静态存储引擎\n- 尽量使用主键查询原则\n- 自增主键\n\t- 性能\n\t- 存储空间\n\n## 05\n![Screenshot 2025-01-18 at 22.33.22.png](https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-18%20at%2022.33.22.png)\n\n## 06\n- 如果事务中需要锁多个行，把最可能造成锁冲突、最影响并发度的锁尽量往后放\n- 死锁检测要耗费大量的CPU资源\n\n## 08\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250122200502.png)\n\n## 09\n- 对于写多读少的场景，页面在写完后马上访问的概率比较小，此时change buffer的效果最好。例如：账单类、日志类系统\n","source":"_posts/MySQL/MySQL实战45讲.md","raw":"## 01\n- 建立连接的过程是比较复杂的，因此尽量使用长连接，避免过多的短链接\n\t- 但是长连接积累下来会导致内存占用太大，强行被系统杀死（OOM）\n\t- 解决方法：\n\t\t- 定期断开长连接\n\t\t- MySQL 5.7 及之后的版本，通过执行mysql_reset_connection重新初始化连接资源\n\n## 03\n- 尽量不要使用长事务\n\t- 长事务意味着系统中存在很老的Read-View，在事务提交前，这些Read-View都必须保留，这就会导致占用大量存储空间\n\t- 除了对回滚段的影响，长事务还占用锁资源，也可能会拖垮整个数据库\n- 总是使用`set autocommit = 1`，通过显示语句的方式来启动事务\n- 频繁使用事务的业务，可以使用`commit work and chain`\n\t- 在`autocommit = 1`，通过`begin`显示开启事务的情况下，`commit`表示提交事务，`commit work and chain`表示提交事务并开启下一个事务，省去了`begin`语句的开销\n- ![Screenshot 2025-01-17 at 22.18.29.png](https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-17%20at%2022.18.29.png)\n\n\n## 04\n- 哈希表适用于等值查询场景\n- 有序数组适用于静态存储引擎\n- 尽量使用主键查询原则\n- 自增主键\n\t- 性能\n\t- 存储空间\n\n## 05\n![Screenshot 2025-01-18 at 22.33.22.png](https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-18%20at%2022.33.22.png)\n\n## 06\n- 如果事务中需要锁多个行，把最可能造成锁冲突、最影响并发度的锁尽量往后放\n- 死锁检测要耗费大量的CPU资源\n\n## 08\n![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20250122200502.png)\n\n## 09\n- 对于写多读少的场景，页面在写完后马上访问的概率比较小，此时change buffer的效果最好。例如：账单类、日志类系统\n","slug":"MySQL/MySQL实战45讲","published":1,"date":"2025-01-13T14:16:31.434Z","updated":"2025-01-23T14:10:36.311Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ba5t219jh0luy","content":"<h2 id=\"01\"><a href=\"#01\" class=\"headerlink\" title=\"01\"></a>01</h2><ul>\n<li>建立连接的过程是比较复杂的，因此尽量使用长连接，避免过多的短链接<ul>\n<li>但是长连接积累下来会导致内存占用太大，强行被系统杀死（OOM）</li>\n<li>解决方法：<ul>\n<li>定期断开长连接</li>\n<li>MySQL 5.7 及之后的版本，通过执行mysql_reset_connection重新初始化连接资源</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"03\"><a href=\"#03\" class=\"headerlink\" title=\"03\"></a>03</h2><ul>\n<li>尽量不要使用长事务<ul>\n<li>长事务意味着系统中存在很老的Read-View，在事务提交前，这些Read-View都必须保留，这就会导致占用大量存储空间</li>\n<li>除了对回滚段的影响，长事务还占用锁资源，也可能会拖垮整个数据库</li>\n</ul>\n</li>\n<li>总是使用<code>set autocommit = 1</code>，通过显示语句的方式来启动事务</li>\n<li>频繁使用事务的业务，可以使用<code>commit work and chain</code><ul>\n<li>在<code>autocommit = 1</code>，通过<code>begin</code>显示开启事务的情况下，<code>commit</code>表示提交事务，<code>commit work and chain</code>表示提交事务并开启下一个事务，省去了<code>begin</code>语句的开销</li>\n</ul>\n</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-17%20at%2022.18.29.png\" alt=\"Screenshot 2025-01-17 at 22.18.29.png\"></li>\n</ul>\n<h2 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a>04</h2><ul>\n<li>哈希表适用于等值查询场景</li>\n<li>有序数组适用于静态存储引擎</li>\n<li>尽量使用主键查询原则</li>\n<li>自增主键<ul>\n<li>性能</li>\n<li>存储空间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"05\"><a href=\"#05\" class=\"headerlink\" title=\"05\"></a>05</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-18%20at%2022.33.22.png\" alt=\"Screenshot 2025-01-18 at 22.33.22.png\"></p>\n<h2 id=\"06\"><a href=\"#06\" class=\"headerlink\" title=\"06\"></a>06</h2><ul>\n<li>如果事务中需要锁多个行，把最可能造成锁冲突、最影响并发度的锁尽量往后放</li>\n<li>死锁检测要耗费大量的CPU资源</li>\n</ul>\n<h2 id=\"08\"><a href=\"#08\" class=\"headerlink\" title=\"08\"></a>08</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250122200502.png\" alt=\"image.png\"></p>\n<h2 id=\"09\"><a href=\"#09\" class=\"headerlink\" title=\"09\"></a>09</h2><ul>\n<li>对于写多读少的场景，页面在写完后马上访问的概率比较小，此时change buffer的效果最好。例如：账单类、日志类系统</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"01\"><a href=\"#01\" class=\"headerlink\" title=\"01\"></a>01</h2><ul>\n<li>建立连接的过程是比较复杂的，因此尽量使用长连接，避免过多的短链接<ul>\n<li>但是长连接积累下来会导致内存占用太大，强行被系统杀死（OOM）</li>\n<li>解决方法：<ul>\n<li>定期断开长连接</li>\n<li>MySQL 5.7 及之后的版本，通过执行mysql_reset_connection重新初始化连接资源</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"03\"><a href=\"#03\" class=\"headerlink\" title=\"03\"></a>03</h2><ul>\n<li>尽量不要使用长事务<ul>\n<li>长事务意味着系统中存在很老的Read-View，在事务提交前，这些Read-View都必须保留，这就会导致占用大量存储空间</li>\n<li>除了对回滚段的影响，长事务还占用锁资源，也可能会拖垮整个数据库</li>\n</ul>\n</li>\n<li>总是使用<code>set autocommit = 1</code>，通过显示语句的方式来启动事务</li>\n<li>频繁使用事务的业务，可以使用<code>commit work and chain</code><ul>\n<li>在<code>autocommit = 1</code>，通过<code>begin</code>显示开启事务的情况下，<code>commit</code>表示提交事务，<code>commit work and chain</code>表示提交事务并开启下一个事务，省去了<code>begin</code>语句的开销</li>\n</ul>\n</li>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-17%20at%2022.18.29.png\" alt=\"Screenshot 2025-01-17 at 22.18.29.png\"></li>\n</ul>\n<h2 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a>04</h2><ul>\n<li>哈希表适用于等值查询场景</li>\n<li>有序数组适用于静态存储引擎</li>\n<li>尽量使用主键查询原则</li>\n<li>自增主键<ul>\n<li>性能</li>\n<li>存储空间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"05\"><a href=\"#05\" class=\"headerlink\" title=\"05\"></a>05</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/Screenshot%202025-01-18%20at%2022.33.22.png\" alt=\"Screenshot 2025-01-18 at 22.33.22.png\"></p>\n<h2 id=\"06\"><a href=\"#06\" class=\"headerlink\" title=\"06\"></a>06</h2><ul>\n<li>如果事务中需要锁多个行，把最可能造成锁冲突、最影响并发度的锁尽量往后放</li>\n<li>死锁检测要耗费大量的CPU资源</li>\n</ul>\n<h2 id=\"08\"><a href=\"#08\" class=\"headerlink\" title=\"08\"></a>08</h2><p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/20250122200502.png\" alt=\"image.png\"></p>\n<h2 id=\"09\"><a href=\"#09\" class=\"headerlink\" title=\"09\"></a>09</h2><ul>\n<li>对于写多读少的场景，页面在写完后马上访问的概率比较小，此时change buffer的效果最好。例如：账单类、日志类系统</li>\n</ul>\n"},{"publish":false,"_content":"\n\n\n# 日志\n\nMySQL中的三种日志：\n\n- **undo log（回滚日志）**：是InnoDB存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚和MVCC**\n- **redo log（重做日志）**：是InnoDB存储引擎层生成的日志，实现了事务的**持久性**，主要用于**掉电等故障的恢复**\n- **binlog（归档日志）**：是Server层生成的日志，主要用于**数据备份和主从复制**\n","source":"_posts/MySQL/MySQL日志学习.md","raw":"---\npublish: false\n---\n\n\n\n# 日志\n\nMySQL中的三种日志：\n\n- **undo log（回滚日志）**：是InnoDB存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚和MVCC**\n- **redo log（重做日志）**：是InnoDB存储引擎层生成的日志，实现了事务的**持久性**，主要用于**掉电等故障的恢复**\n- **binlog（归档日志）**：是Server层生成的日志，主要用于**数据备份和主从复制**\n","slug":"MySQL/MySQL日志学习","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ea5t253yi6w1z","content":"<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h1><p>MySQL中的三种日志：</p>\n<ul>\n<li><strong>undo log（回滚日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚和MVCC</strong></li>\n<li><strong>redo log（重做日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务的<strong>持久性</strong>，主要用于<strong>掉电等故障的恢复</strong></li>\n<li><strong>binlog（归档日志）</strong>：是Server层生成的日志，主要用于<strong>数据备份和主从复制</strong></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h1><p>MySQL中的三种日志：</p>\n<ul>\n<li><strong>undo log（回滚日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚和MVCC</strong></li>\n<li><strong>redo log（重做日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务的<strong>持久性</strong>，主要用于<strong>掉电等故障的恢复</strong></li>\n<li><strong>binlog（归档日志）</strong>：是Server层生成的日志，主要用于<strong>数据备份和主从复制</strong></li>\n</ul>\n"},{"publish":true,"sticky":2,"date":"2024-09-19T10:29:00.000Z","_content":"\n# MySQL索引学习\n\n## 索引数据结构\n\n> 什么是索引？为什么索引能加快查询？\n>\n> 索引的数据结构是什么？\n>\n> B+树和B树、红黑树有什么区别？为什么使用B+树？\n\n索引是一种排好序的快速查找的数据结构。在索引上查找数据的过程可以类比在二叉搜索树上进行数据查询，可以根据数据的大小关系省略对一些数据的查询操作，从而**减少磁盘I/O的次数**，加快查询效率。\n\n索引的具体实现由**底层的存储引擎决定**，例如在InnoDB存储引擎下，索引是由B+树实现的。\n\nB树和B+树都是通过多叉树的形式，将树的高度降低，以此减少磁盘I/O的次数。但较于B树，B+树有以下优点：\n\n- B+的树**非叶子节点不存放数据只存放索引**，而B树的内节点既存数据又存索引。因此数据量相同的情况下，B+树的内节点可以存放更多的索引，这使得B+树可以比B树更“矮胖”，查询底层节点时磁盘I/O次数更少\n- B+树**有大量的冗余节点**（所有非叶子节点都是冗余节点），这些冗余节点使得B+树在插入、删除的情况下，树形变化不大，效率更高\n- B+树的叶子节点之间通过**链表相互连接**，有利于范围查询\n\n\n\n## 索引存储\n\n> 堆表和索引组织有什么区别？分别应用场景是什么？\n\n在**堆表**的组织中，**数据和索引是分开存储的**，B+树叶子节点存放的是**索引+数据的地址，地址指向堆表中的数据**。索引是排序后的数据，而堆表中的数据是无序的\n\n- 堆表中的索引**都是二级索引**，即使是主键索引也是二级索引，每次查询都要回表\n- 由于索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生变化且位置发生了改变，那么所有索引中的地址都要进行变更\n- 只支持表锁，并发性能差\n\n在**索引组织表**（聚簇索引，InnoDB存储引擎实现的数据组织方式）中，数据和索引是一起存储在B+树中的，B+树叶子节点存放的是**索引+行记录**。\n\n索引就是数据，数据就是索引\n\n- 索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快\n- 在索引组织表中，二级索引具有天然优势：若记录发生了改变，其他索引无须进行维护，除非记录的主键发生了改变\n- 支持行级锁，并发性能高\n\n## 联合索引\n\naba\n\n## 索引失效\n\n> 有哪些索引失效的场景？为什么会失效？\n\n- 对索引使用左或者左右模糊匹配\n\n  - B+树索引是按照**索引值**有序排列存储的，只能根据前缀进行匹配比较\n\n- 对索引使用函数\n\n  - 索引保存的是索引字段的原始值，而不是经过函数计算后的结果，自然不能进行索引比较\n\n- 对索引进行表达式计算\n\n  - 索引保存的是索引字段的原始值，而不是经过表达式计算后的结果，自然不能进行索引比较\n\n- 对索引隐式类型转换\n\n  - MySQL在遇到字符串和数字比较时，会先将字符串转换成数字，再进行数字比大小\n\n  - 如下两条SQL语句，第一条索引失效，第二条索引正常工作\n\n  - ```sql\n    # 先将name转换为整型数字，再进行比较\n    select * from users where name = 101010\n    # 等价于 select * from users where cast(name as signed int) = 101010\n    \n    \n    select * from users where id = '1'\n    # 等价于 select * from users where id = cast('1' as signed int)\n    ```\n\n- 联合索引非最左匹配\n\n  - 联合索引是先按照第一个索引键排序，再按照第二个索引键排序，以此类推\n\n- where子句中的or\n\n  - or前的条件列是索引列，而or后的条件列不是索引列则会导致索引失效\n\n## 索引选择\n\n> MySQL数据库中的优化器是怎么执行的？根据什么标准选择索引的？\n\n![image-20240916132934153](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161330104.png)\n\nMySQL数据库由Server层和Engine层组成：\n\n- Server层有SQL分析器、SQL优化器、SQL执行器，用于负责SQL语句的具体执行过程\n- Engine层用于存储具体的数据，例如InnoDB引擎，还有用于在内存中存储临时结果集的TempTable引擎\n\n其中SQL优化器用于分析SQL语句在使用不同索引时所需要的成本，并选择成本最小的执行计划（或全局扫描），作为SQL最优执行方案，这种优化器也叫做CBO（Cost-based optimizer）优化器\n\n在MySQL中，一条SQL的计算成本按如下公式计算：\n\n```sql\nCost = Server Cost + Engine Cost\n\t = CPU Cost + IO Cost\n```\n\n基于SQL优化器的工作原理，有如下实际案例经验：\n\n- 一般只对**高选择度的字段和字段组合**建立索引，低选择度的字段如**性别**，不创建索引\n\n- 低选择性，但是存在数据倾斜，例如优化器认为P状态有1/3，实际上P状态只有1/100，可以考虑创建索引\n\n  - 通过创建直方图，让优化器知道实际的数据分布\n\n  - ```sql\n    ANALYZE TABLE orders \n    \n    UPDATE HISTOGRAM ON o_orderstatus;\n    ```\n\n## 索引应用\n\n> 建立索引有什么优点和缺点？\n>\n> 如何正确建立索引？\n>\n> 哪些场景下适合建立索引？\n>\n> 哪些场景下不适合建立索引？\n\n可以参考[原文](https://juejin.cn/post/7149074488649318431)\n\n### 一、MySQL中各索引分析\n\n#### 1.1 为什么选自增Id作为主键？\n\n在MySQL表中，一般都是用**自增Id**作为主键，这确保了数据的唯一性，但为什么又需要**自增**性质？\n\n在InnoDB存储引擎中，主键索引以聚簇的形式**有序**存储，即索引即数据、数据即索引按照主键大小依次排列存储在磁盘上。如果使用无序的uuid作为主键，虽然uuid也能保证数据的唯一性，但是很有可能会破坏原本的树结构\n\n举个例子：\n\n灰色节点作为一条新数据，如果按照**uuid大小排列**，它应该插入在第二个位置，那么后续节点都要挪动，时间复杂度（不小于）$$O(n)$$，这就导致插入数据十分占用CPU资源。\n\n![image-20240917114122420](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171141423.png)\n\n但使用**自增Id**就不会有这个问题，新来的数据直接放到最后，因此数据表的主键值最好选用带有顺序性的值。\n\n#### 1.2 联合索引的最左匹配原则\n\n> 最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。\n\n为`id, name, age`这三个字段建立联合索引，此时一个SQL语句如下：\n\n```sql\nSELECT * FROM users WHERE name = 'lyydsheep' AND age = 1;\n```\n\n这条SQL语句是用不上联合索引的，因为查询条件中没有出现**从最左端开始的连续字段**。而下列这条SQL语句就能使用上联合索引\n\n```sql\nSELECT * FROM users WHERE id = 1 AND name = 'lyydsheep';\n```\n\n根本原因就是`id`字段是**全局有序**，而`name`、`age`字段是**局部有序**的\n\n#### 1.3 唯一索引的快慢问题\n\n唯一索引相比于普通索引的优势就在于唯一索引限定了字段值必须是唯一的，当找到一条数据后旧立马停止检索。而普通索引仍需要走完整个索引树，因为可能存在多个相同的字段值的数据。\n\n唯一索引在查询时比普通索引快上一截，但插入数据时就不同了，因为要确保数据唯一性，插入数据前要检察一遍表中是否存在相同的数据。普通索引就没有这顾虑了，因此普通索引插入数据会更快一些。\n\n### 二、建立索引的原则\n\n#### 2.1 应该遵守的原则\n\n- ①经常**频繁用作查询条件的字段**应酌情考虑为其创建索引。\n\n- ②表的**主外键或连表字段**，必须建立索引，因为能很大程度提升连表查询的性能。\n\n- ③建立索引的字段，一般值的**区分性要足够高**，这样才能提高索引的检索效率。\n\n- ④建立索引的字段，值不应该过长，如果**较长的字段要建立索引，可以选择前缀索引**。\n\n- ⑤建立**联合索引**，应当遵循**最左前缀原则**，将多个字段之间按优先级顺序组合。\n\n- ⑥经常根据**范围取值、排序、分组的字段应建立索引**，因为索引有序，能加快排序时间。\n\n- ⑦对于**唯一索引**，如果确认不会利用该字段排序，那可以将**结构改为`Hash`结构**。\n\n- ⑧尽量使用**联合索引代替单值索引**，联合索引比多个单值索引查询效率要高。\n\n#### 2.2 额外的注意点\n\n- ❶**值经常会增删改的字段**，不合适建立索引，因为每次改变后需维护索引结构。\n\n- ❷一个**字段存在大量的重复值**时，不适合建立索引，比如之前举例的性别字段。\n\n- ❸索引**不能参与计算**，因此经常**带函数查询**的字段，并不适合建立索引。\n\n- ❹一张表中的索引**数量并不是越多越好**，一般控制在`3`，最多不能超过`5`。\n\n- ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。\n\n- ❻**当表的数据较少，不应当建立索引**，因为数据量不大时，维护索引反而开销更大。\n\n- ❼索引的**字段值无序时**，不推荐建立索引，因为会造成页分裂，尤其是主键索引。\n\n## 索引常见考题\n\n参考[原文](https://xiaolincoding.com/mysql/index/index_interview.html)\n\n### 索引的分类\n\n从四个角度对索引进行分类：\n\n- 以**数据结构**分类：<font color=\"blue\">B+树索引、Hash索引、Full-text索引</font>\n- 以**物理存储**分类：<font color=\"blue\">聚簇索引、二级索引</font>\n- 以**字段特性**分类：<font color=\"blue\">主键索引、唯一索引、普通索引、前缀索引</font>\n- 以字段个数分类：<font color=\"blue\">单列索引、联合索引</font>\n\n#### 按数据结构分类\n\n不同的存储引擎所支持的索引类型不同，具体如下图\n\n![image-20240918142021754](https://raw.githubusercontent.com/lyydsheep/pic/main/202409181420334.png)\n\n#### 按物理存储分类\n\n- 聚簇索引的B+树叶子节点存放的是实际数据，包含了数据行所有字段的数据\n- 二级索引的B+树叶子节点存放的是主键值，并非实际数据。因此，如果所查询数据不二级索引叶子节点中，那么需要再进行一次**回表**操作；反之则是**索引覆盖**\n\n#### 按字段特性分类\n\n**主键索引**\n\n建立在主键之上的索引，一般在建表时创建，一张表最多只能有一个主键索引，并且主键字段不允许有`NULL`值\n\n如果没有指明主键，则系统会按照一下规则挑选并创建主键索引\n\n- 选择第一个不包含`NULL`值的**唯一列**作为主键列\n- 下下策，InnoDB自动生成一个自增的隐藏id列作为聚簇索引的索引键\n\n建表时，创建主键索引的方式如下：\n\n```sql\nCREATE TABLE table_name (\n    ...\n    PRIMARY KEY (column_name) USING BTREE\n)\n```\n\n**唯一索引**\n\n建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，但是索引键值必须唯一，允许有`NULL`值\n\n建表时，创建唯一索引的方式如下：\n\n```sql\nCREATE TABLE table_name(\n    ...\n    UNIQUE KEY(column1, column2...)\n)\n```\n\n建表后，创建唯一索引的方式如下：\n\n```sql\nCREATE UNIQUE INDEX idx_name ON table_name(column1, column2...)\n```\n\n**前缀索引**\n\n以字符类型字段的前缀为键值建立索引，主要目的是为了减少存储空间，优化查询效率，可以用在字符类型为`char`、`varchat`、`binary`、`varbinary`的列上\n\n建表时，创建前缀索引的方式如下：\n\n```sql\nCREATE TABLE table_name(\n    ...\n    INDEX(column1(length))\n)\n```\n\n建表后，创建前缀索引的方式如下 :\n\n```sql\nCREATE INDEX idx_name ON table_name (column1(length))\n```\n\n#### 按字段个数分类\n\n主要介绍联合索引的几个特点\n\n- 范围查询\n  - 联合索引的最左匹配，在遇到范围查询（>、<）时，就会停止匹配。也就是说，范围查询的字段会用到联合索引，但之后的字段不会使用联合索引\n  - 值得注意的是，对于`>=`、`<=`、`between xxx and`、`like`这类含有相等意义的范围查询，不会立刻停止匹配，即再范围查询之后的字段仍会用上联合索引，但只针对部分数据\n- 索引下推\n  - MySQL 5.6 引入索引下推优化，可以在联合索引遍历过程中，利用联合索引中未用上的查询条件对数据进行过滤，减少回表次数\n- 索引区分度\n  - 在建立联合索引时，要尽可能 把区分度大的字段放在前面，这样联合索引被SQL用到的概率更大\n- 用于排序\n  - 减少`Using filesort`的次数\n\n### 优化索引的方法\n\n- 前缀索引优化\n  - 使用前缀索引可以减小索引字段的大小，增加一个索引页中存储的数据量，有效提高索引查询的效率\n- 覆盖索引优化\n  - 将所要查询的字段建立成联合索引，在SQL查询过程中就能在二级索引B+树的叶子节点上找到所需要的全部数据，而不需要再通过聚簇索引查询获得，减少回表的操作\n- 主键索引最好是自增的\n  - 插入一条数据都是追加操作，不需要移动数据，避免了页分裂带来的性能消耗和大量的内存碎片\n  - 索引字段不宜过长，减少二级索引的存储空间\n- 索引最好设置为`NOT NULL`\n  - 索引列存在`NULL`值会加重索引选择的负担\n  - 减少物理存储空间，如果表中存在允许为`NULL`的字段，那么行格式中至少会占用1字节空间存储`NULL`值列表\n- 防止索引失效\n","source":"_posts/MySQL/MySQL索引学习.md","raw":"---\npublish: true\ntag: MySQL\nsticky: 2\ndate: 2024-09-19 18:29:00\n---\n\n# MySQL索引学习\n\n## 索引数据结构\n\n> 什么是索引？为什么索引能加快查询？\n>\n> 索引的数据结构是什么？\n>\n> B+树和B树、红黑树有什么区别？为什么使用B+树？\n\n索引是一种排好序的快速查找的数据结构。在索引上查找数据的过程可以类比在二叉搜索树上进行数据查询，可以根据数据的大小关系省略对一些数据的查询操作，从而**减少磁盘I/O的次数**，加快查询效率。\n\n索引的具体实现由**底层的存储引擎决定**，例如在InnoDB存储引擎下，索引是由B+树实现的。\n\nB树和B+树都是通过多叉树的形式，将树的高度降低，以此减少磁盘I/O的次数。但较于B树，B+树有以下优点：\n\n- B+的树**非叶子节点不存放数据只存放索引**，而B树的内节点既存数据又存索引。因此数据量相同的情况下，B+树的内节点可以存放更多的索引，这使得B+树可以比B树更“矮胖”，查询底层节点时磁盘I/O次数更少\n- B+树**有大量的冗余节点**（所有非叶子节点都是冗余节点），这些冗余节点使得B+树在插入、删除的情况下，树形变化不大，效率更高\n- B+树的叶子节点之间通过**链表相互连接**，有利于范围查询\n\n\n\n## 索引存储\n\n> 堆表和索引组织有什么区别？分别应用场景是什么？\n\n在**堆表**的组织中，**数据和索引是分开存储的**，B+树叶子节点存放的是**索引+数据的地址，地址指向堆表中的数据**。索引是排序后的数据，而堆表中的数据是无序的\n\n- 堆表中的索引**都是二级索引**，即使是主键索引也是二级索引，每次查询都要回表\n- 由于索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生变化且位置发生了改变，那么所有索引中的地址都要进行变更\n- 只支持表锁，并发性能差\n\n在**索引组织表**（聚簇索引，InnoDB存储引擎实现的数据组织方式）中，数据和索引是一起存储在B+树中的，B+树叶子节点存放的是**索引+行记录**。\n\n索引就是数据，数据就是索引\n\n- 索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快\n- 在索引组织表中，二级索引具有天然优势：若记录发生了改变，其他索引无须进行维护，除非记录的主键发生了改变\n- 支持行级锁，并发性能高\n\n## 联合索引\n\naba\n\n## 索引失效\n\n> 有哪些索引失效的场景？为什么会失效？\n\n- 对索引使用左或者左右模糊匹配\n\n  - B+树索引是按照**索引值**有序排列存储的，只能根据前缀进行匹配比较\n\n- 对索引使用函数\n\n  - 索引保存的是索引字段的原始值，而不是经过函数计算后的结果，自然不能进行索引比较\n\n- 对索引进行表达式计算\n\n  - 索引保存的是索引字段的原始值，而不是经过表达式计算后的结果，自然不能进行索引比较\n\n- 对索引隐式类型转换\n\n  - MySQL在遇到字符串和数字比较时，会先将字符串转换成数字，再进行数字比大小\n\n  - 如下两条SQL语句，第一条索引失效，第二条索引正常工作\n\n  - ```sql\n    # 先将name转换为整型数字，再进行比较\n    select * from users where name = 101010\n    # 等价于 select * from users where cast(name as signed int) = 101010\n    \n    \n    select * from users where id = '1'\n    # 等价于 select * from users where id = cast('1' as signed int)\n    ```\n\n- 联合索引非最左匹配\n\n  - 联合索引是先按照第一个索引键排序，再按照第二个索引键排序，以此类推\n\n- where子句中的or\n\n  - or前的条件列是索引列，而or后的条件列不是索引列则会导致索引失效\n\n## 索引选择\n\n> MySQL数据库中的优化器是怎么执行的？根据什么标准选择索引的？\n\n![image-20240916132934153](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161330104.png)\n\nMySQL数据库由Server层和Engine层组成：\n\n- Server层有SQL分析器、SQL优化器、SQL执行器，用于负责SQL语句的具体执行过程\n- Engine层用于存储具体的数据，例如InnoDB引擎，还有用于在内存中存储临时结果集的TempTable引擎\n\n其中SQL优化器用于分析SQL语句在使用不同索引时所需要的成本，并选择成本最小的执行计划（或全局扫描），作为SQL最优执行方案，这种优化器也叫做CBO（Cost-based optimizer）优化器\n\n在MySQL中，一条SQL的计算成本按如下公式计算：\n\n```sql\nCost = Server Cost + Engine Cost\n\t = CPU Cost + IO Cost\n```\n\n基于SQL优化器的工作原理，有如下实际案例经验：\n\n- 一般只对**高选择度的字段和字段组合**建立索引，低选择度的字段如**性别**，不创建索引\n\n- 低选择性，但是存在数据倾斜，例如优化器认为P状态有1/3，实际上P状态只有1/100，可以考虑创建索引\n\n  - 通过创建直方图，让优化器知道实际的数据分布\n\n  - ```sql\n    ANALYZE TABLE orders \n    \n    UPDATE HISTOGRAM ON o_orderstatus;\n    ```\n\n## 索引应用\n\n> 建立索引有什么优点和缺点？\n>\n> 如何正确建立索引？\n>\n> 哪些场景下适合建立索引？\n>\n> 哪些场景下不适合建立索引？\n\n可以参考[原文](https://juejin.cn/post/7149074488649318431)\n\n### 一、MySQL中各索引分析\n\n#### 1.1 为什么选自增Id作为主键？\n\n在MySQL表中，一般都是用**自增Id**作为主键，这确保了数据的唯一性，但为什么又需要**自增**性质？\n\n在InnoDB存储引擎中，主键索引以聚簇的形式**有序**存储，即索引即数据、数据即索引按照主键大小依次排列存储在磁盘上。如果使用无序的uuid作为主键，虽然uuid也能保证数据的唯一性，但是很有可能会破坏原本的树结构\n\n举个例子：\n\n灰色节点作为一条新数据，如果按照**uuid大小排列**，它应该插入在第二个位置，那么后续节点都要挪动，时间复杂度（不小于）$$O(n)$$，这就导致插入数据十分占用CPU资源。\n\n![image-20240917114122420](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171141423.png)\n\n但使用**自增Id**就不会有这个问题，新来的数据直接放到最后，因此数据表的主键值最好选用带有顺序性的值。\n\n#### 1.2 联合索引的最左匹配原则\n\n> 最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。\n\n为`id, name, age`这三个字段建立联合索引，此时一个SQL语句如下：\n\n```sql\nSELECT * FROM users WHERE name = 'lyydsheep' AND age = 1;\n```\n\n这条SQL语句是用不上联合索引的，因为查询条件中没有出现**从最左端开始的连续字段**。而下列这条SQL语句就能使用上联合索引\n\n```sql\nSELECT * FROM users WHERE id = 1 AND name = 'lyydsheep';\n```\n\n根本原因就是`id`字段是**全局有序**，而`name`、`age`字段是**局部有序**的\n\n#### 1.3 唯一索引的快慢问题\n\n唯一索引相比于普通索引的优势就在于唯一索引限定了字段值必须是唯一的，当找到一条数据后旧立马停止检索。而普通索引仍需要走完整个索引树，因为可能存在多个相同的字段值的数据。\n\n唯一索引在查询时比普通索引快上一截，但插入数据时就不同了，因为要确保数据唯一性，插入数据前要检察一遍表中是否存在相同的数据。普通索引就没有这顾虑了，因此普通索引插入数据会更快一些。\n\n### 二、建立索引的原则\n\n#### 2.1 应该遵守的原则\n\n- ①经常**频繁用作查询条件的字段**应酌情考虑为其创建索引。\n\n- ②表的**主外键或连表字段**，必须建立索引，因为能很大程度提升连表查询的性能。\n\n- ③建立索引的字段，一般值的**区分性要足够高**，这样才能提高索引的检索效率。\n\n- ④建立索引的字段，值不应该过长，如果**较长的字段要建立索引，可以选择前缀索引**。\n\n- ⑤建立**联合索引**，应当遵循**最左前缀原则**，将多个字段之间按优先级顺序组合。\n\n- ⑥经常根据**范围取值、排序、分组的字段应建立索引**，因为索引有序，能加快排序时间。\n\n- ⑦对于**唯一索引**，如果确认不会利用该字段排序，那可以将**结构改为`Hash`结构**。\n\n- ⑧尽量使用**联合索引代替单值索引**，联合索引比多个单值索引查询效率要高。\n\n#### 2.2 额外的注意点\n\n- ❶**值经常会增删改的字段**，不合适建立索引，因为每次改变后需维护索引结构。\n\n- ❷一个**字段存在大量的重复值**时，不适合建立索引，比如之前举例的性别字段。\n\n- ❸索引**不能参与计算**，因此经常**带函数查询**的字段，并不适合建立索引。\n\n- ❹一张表中的索引**数量并不是越多越好**，一般控制在`3`，最多不能超过`5`。\n\n- ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。\n\n- ❻**当表的数据较少，不应当建立索引**，因为数据量不大时，维护索引反而开销更大。\n\n- ❼索引的**字段值无序时**，不推荐建立索引，因为会造成页分裂，尤其是主键索引。\n\n## 索引常见考题\n\n参考[原文](https://xiaolincoding.com/mysql/index/index_interview.html)\n\n### 索引的分类\n\n从四个角度对索引进行分类：\n\n- 以**数据结构**分类：<font color=\"blue\">B+树索引、Hash索引、Full-text索引</font>\n- 以**物理存储**分类：<font color=\"blue\">聚簇索引、二级索引</font>\n- 以**字段特性**分类：<font color=\"blue\">主键索引、唯一索引、普通索引、前缀索引</font>\n- 以字段个数分类：<font color=\"blue\">单列索引、联合索引</font>\n\n#### 按数据结构分类\n\n不同的存储引擎所支持的索引类型不同，具体如下图\n\n![image-20240918142021754](https://raw.githubusercontent.com/lyydsheep/pic/main/202409181420334.png)\n\n#### 按物理存储分类\n\n- 聚簇索引的B+树叶子节点存放的是实际数据，包含了数据行所有字段的数据\n- 二级索引的B+树叶子节点存放的是主键值，并非实际数据。因此，如果所查询数据不二级索引叶子节点中，那么需要再进行一次**回表**操作；反之则是**索引覆盖**\n\n#### 按字段特性分类\n\n**主键索引**\n\n建立在主键之上的索引，一般在建表时创建，一张表最多只能有一个主键索引，并且主键字段不允许有`NULL`值\n\n如果没有指明主键，则系统会按照一下规则挑选并创建主键索引\n\n- 选择第一个不包含`NULL`值的**唯一列**作为主键列\n- 下下策，InnoDB自动生成一个自增的隐藏id列作为聚簇索引的索引键\n\n建表时，创建主键索引的方式如下：\n\n```sql\nCREATE TABLE table_name (\n    ...\n    PRIMARY KEY (column_name) USING BTREE\n)\n```\n\n**唯一索引**\n\n建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，但是索引键值必须唯一，允许有`NULL`值\n\n建表时，创建唯一索引的方式如下：\n\n```sql\nCREATE TABLE table_name(\n    ...\n    UNIQUE KEY(column1, column2...)\n)\n```\n\n建表后，创建唯一索引的方式如下：\n\n```sql\nCREATE UNIQUE INDEX idx_name ON table_name(column1, column2...)\n```\n\n**前缀索引**\n\n以字符类型字段的前缀为键值建立索引，主要目的是为了减少存储空间，优化查询效率，可以用在字符类型为`char`、`varchat`、`binary`、`varbinary`的列上\n\n建表时，创建前缀索引的方式如下：\n\n```sql\nCREATE TABLE table_name(\n    ...\n    INDEX(column1(length))\n)\n```\n\n建表后，创建前缀索引的方式如下 :\n\n```sql\nCREATE INDEX idx_name ON table_name (column1(length))\n```\n\n#### 按字段个数分类\n\n主要介绍联合索引的几个特点\n\n- 范围查询\n  - 联合索引的最左匹配，在遇到范围查询（>、<）时，就会停止匹配。也就是说，范围查询的字段会用到联合索引，但之后的字段不会使用联合索引\n  - 值得注意的是，对于`>=`、`<=`、`between xxx and`、`like`这类含有相等意义的范围查询，不会立刻停止匹配，即再范围查询之后的字段仍会用上联合索引，但只针对部分数据\n- 索引下推\n  - MySQL 5.6 引入索引下推优化，可以在联合索引遍历过程中，利用联合索引中未用上的查询条件对数据进行过滤，减少回表次数\n- 索引区分度\n  - 在建立联合索引时，要尽可能 把区分度大的字段放在前面，这样联合索引被SQL用到的概率更大\n- 用于排序\n  - 减少`Using filesort`的次数\n\n### 优化索引的方法\n\n- 前缀索引优化\n  - 使用前缀索引可以减小索引字段的大小，增加一个索引页中存储的数据量，有效提高索引查询的效率\n- 覆盖索引优化\n  - 将所要查询的字段建立成联合索引，在SQL查询过程中就能在二级索引B+树的叶子节点上找到所需要的全部数据，而不需要再通过聚簇索引查询获得，减少回表的操作\n- 主键索引最好是自增的\n  - 插入一条数据都是追加操作，不需要移动数据，避免了页分裂带来的性能消耗和大量的内存碎片\n  - 索引字段不宜过长，减少二级索引的存储空间\n- 索引最好设置为`NOT NULL`\n  - 索引列存在`NULL`值会加重索引选择的负担\n  - 减少物理存储空间，如果表中存在允许为`NULL`的字段，那么行格式中至少会占用1字节空间存储`NULL`值列表\n- 防止索引失效\n","slug":"MySQL/MySQL索引学习","published":1,"updated":"2024-12-27T11:03:15.343Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ga5t2h5t613uy","content":"<h1 id=\"MySQL索引学习\"><a href=\"#MySQL索引学习\" class=\"headerlink\" title=\"MySQL索引学习\"></a>MySQL索引学习</h1><h2 id=\"索引数据结构\"><a href=\"#索引数据结构\" class=\"headerlink\" title=\"索引数据结构\"></a>索引数据结构</h2><blockquote>\n<p>什么是索引？为什么索引能加快查询？</p>\n<p>索引的数据结构是什么？</p>\n<p>B+树和B树、红黑树有什么区别？为什么使用B+树？</p>\n</blockquote>\n<p>索引是一种排好序的快速查找的数据结构。在索引上查找数据的过程可以类比在二叉搜索树上进行数据查询，可以根据数据的大小关系省略对一些数据的查询操作，从而<strong>减少磁盘I&#x2F;O的次数</strong>，加快查询效率。</p>\n<p>索引的具体实现由<strong>底层的存储引擎决定</strong>，例如在InnoDB存储引擎下，索引是由B+树实现的。</p>\n<p>B树和B+树都是通过多叉树的形式，将树的高度降低，以此减少磁盘I&#x2F;O的次数。但较于B树，B+树有以下优点：</p>\n<ul>\n<li>B+的树<strong>非叶子节点不存放数据只存放索引</strong>，而B树的内节点既存数据又存索引。因此数据量相同的情况下，B+树的内节点可以存放更多的索引，这使得B+树可以比B树更“矮胖”，查询底层节点时磁盘I&#x2F;O次数更少</li>\n<li>B+树<strong>有大量的冗余节点</strong>（所有非叶子节点都是冗余节点），这些冗余节点使得B+树在插入、删除的情况下，树形变化不大，效率更高</li>\n<li>B+树的叶子节点之间通过<strong>链表相互连接</strong>，有利于范围查询</li>\n</ul>\n<h2 id=\"索引存储\"><a href=\"#索引存储\" class=\"headerlink\" title=\"索引存储\"></a>索引存储</h2><blockquote>\n<p>堆表和索引组织有什么区别？分别应用场景是什么？</p>\n</blockquote>\n<p>在<strong>堆表</strong>的组织中，<strong>数据和索引是分开存储的</strong>，B+树叶子节点存放的是<strong>索引+数据的地址，地址指向堆表中的数据</strong>。索引是排序后的数据，而堆表中的数据是无序的</p>\n<ul>\n<li>堆表中的索引<strong>都是二级索引</strong>，即使是主键索引也是二级索引，每次查询都要回表</li>\n<li>由于索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生变化且位置发生了改变，那么所有索引中的地址都要进行变更</li>\n<li>只支持表锁，并发性能差</li>\n</ul>\n<p>在<strong>索引组织表</strong>（聚簇索引，InnoDB存储引擎实现的数据组织方式）中，数据和索引是一起存储在B+树中的，B+树叶子节点存放的是<strong>索引+行记录</strong>。</p>\n<p>索引就是数据，数据就是索引</p>\n<ul>\n<li>索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>\n<li>在索引组织表中，二级索引具有天然优势：若记录发生了改变，其他索引无须进行维护，除非记录的主键发生了改变</li>\n<li>支持行级锁，并发性能高</li>\n</ul>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p>aba</p>\n<h2 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h2><blockquote>\n<p>有哪些索引失效的场景？为什么会失效？</p>\n</blockquote>\n<ul>\n<li><p>对索引使用左或者左右模糊匹配</p>\n<ul>\n<li>B+树索引是按照<strong>索引值</strong>有序排列存储的，只能根据前缀进行匹配比较</li>\n</ul>\n</li>\n<li><p>对索引使用函数</p>\n<ul>\n<li>索引保存的是索引字段的原始值，而不是经过函数计算后的结果，自然不能进行索引比较</li>\n</ul>\n</li>\n<li><p>对索引进行表达式计算</p>\n<ul>\n<li>索引保存的是索引字段的原始值，而不是经过表达式计算后的结果，自然不能进行索引比较</li>\n</ul>\n</li>\n<li><p>对索引隐式类型转换</p>\n<ul>\n<li><p>MySQL在遇到字符串和数字比较时，会先将字符串转换成数字，再进行数字比大小</p>\n</li>\n<li><p>如下两条SQL语句，第一条索引失效，第二条索引正常工作</p>\n</li>\n<li><pre><code class=\"sql\"># 先将name转换为整型数字，再进行比较\nselect * from users where name = 101010\n# 等价于 select * from users where cast(name as signed int) = 101010\n\n\nselect * from users where id = &#39;1&#39;\n# 等价于 select * from users where id = cast(&#39;1&#39; as signed int)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 联合索引非最左匹配</span><br><span class=\"line\"></span><br><span class=\"line\">  - 联合索引是先按照第一个索引键排序，再按照第二个索引键排序，以此类推</span><br><span class=\"line\"></span><br><span class=\"line\">- where子句中的or</span><br><span class=\"line\"></span><br><span class=\"line\">  - or前的条件列是索引列，而or后的条件列不是索引列则会导致索引失效</span><br><span class=\"line\"></span><br><span class=\"line\">## 索引选择</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; MySQL数据库中的优化器是怎么执行的？根据什么标准选择索引的？</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240916132934153](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161330104.png)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL数据库由Server层和Engine层组成：</span><br><span class=\"line\"></span><br><span class=\"line\">- Server层有SQL分析器、SQL优化器、SQL执行器，用于负责SQL语句的具体执行过程</span><br><span class=\"line\">- Engine层用于存储具体的数据，例如InnoDB引擎，还有用于在内存中存储临时结果集的TempTable引擎</span><br><span class=\"line\"></span><br><span class=\"line\">其中SQL优化器用于分析SQL语句在使用不同索引时所需要的成本，并选择成本最小的执行计划（或全局扫描），作为SQL最优执行方案，这种优化器也叫做CBO（Cost-based optimizer）优化器</span><br><span class=\"line\"></span><br><span class=\"line\">在MySQL中，一条SQL的计算成本按如下公式计算：</span><br><span class=\"line\"></span><br><span class=\"line\">```sql</span><br><span class=\"line\">Cost = Server Cost + Engine Cost</span><br><span class=\"line\">\t = CPU Cost + IO Cost</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>基于SQL优化器的工作原理，有如下实际案例经验：</p>\n<ul>\n<li><p>一般只对<strong>高选择度的字段和字段组合</strong>建立索引，低选择度的字段如<strong>性别</strong>，不创建索引</p>\n</li>\n<li><p>低选择性，但是存在数据倾斜，例如优化器认为P状态有1&#x2F;3，实际上P状态只有1&#x2F;100，可以考虑创建索引</p>\n<ul>\n<li><p>通过创建直方图，让优化器知道实际的数据分布</p>\n</li>\n<li><pre><code class=\"sql\">ANALYZE TABLE orders \n\nUPDATE HISTOGRAM ON o_orderstatus;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 索引应用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 建立索引有什么优点和缺点？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 如何正确建立索引？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 哪些场景下适合建立索引？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 哪些场景下不适合建立索引？</span><br><span class=\"line\"></span><br><span class=\"line\">可以参考[原文](https://juejin.cn/post/7149074488649318431)</span><br><span class=\"line\"></span><br><span class=\"line\">### 一、MySQL中各索引分析</span><br><span class=\"line\"></span><br><span class=\"line\">#### 1.1 为什么选自增Id作为主键？</span><br><span class=\"line\"></span><br><span class=\"line\">在MySQL表中，一般都是用**自增Id**作为主键，这确保了数据的唯一性，但为什么又需要**自增**性质？</span><br><span class=\"line\"></span><br><span class=\"line\">在InnoDB存储引擎中，主键索引以聚簇的形式**有序**存储，即索引即数据、数据即索引按照主键大小依次排列存储在磁盘上。如果使用无序的uuid作为主键，虽然uuid也能保证数据的唯一性，但是很有可能会破坏原本的树结构</span><br><span class=\"line\"></span><br><span class=\"line\">举个例子：</span><br><span class=\"line\"></span><br><span class=\"line\">灰色节点作为一条新数据，如果按照**uuid大小排列**，它应该插入在第二个位置，那么后续节点都要挪动，时间复杂度（不小于）$$O(n)$$，这就导致插入数据十分占用CPU资源。</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240917114122420](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171141423.png)</span><br><span class=\"line\"></span><br><span class=\"line\">但使用**自增Id**就不会有这个问题，新来的数据直接放到最后，因此数据表的主键值最好选用带有顺序性的值。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 1.2 联合索引的最左匹配原则</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">为`id, name, age`这三个字段建立联合索引，此时一个SQL语句如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```sql</span><br><span class=\"line\">SELECT * FROM users WHERE name = &#x27;lyydsheep&#x27; AND age = 1;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>这条SQL语句是用不上联合索引的，因为查询条件中没有出现<strong>从最左端开始的连续字段</strong>。而下列这条SQL语句就能使用上联合索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">AND</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;lyydsheep&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>根本原因就是<code>id</code>字段是<strong>全局有序</strong>，而<code>name</code>、<code>age</code>字段是<strong>局部有序</strong>的</p>\n<h4 id=\"1-3-唯一索引的快慢问题\"><a href=\"#1-3-唯一索引的快慢问题\" class=\"headerlink\" title=\"1.3 唯一索引的快慢问题\"></a>1.3 唯一索引的快慢问题</h4><p>唯一索引相比于普通索引的优势就在于唯一索引限定了字段值必须是唯一的，当找到一条数据后旧立马停止检索。而普通索引仍需要走完整个索引树，因为可能存在多个相同的字段值的数据。</p>\n<p>唯一索引在查询时比普通索引快上一截，但插入数据时就不同了，因为要确保数据唯一性，插入数据前要检察一遍表中是否存在相同的数据。普通索引就没有这顾虑了，因此普通索引插入数据会更快一些。</p>\n<h3 id=\"二、建立索引的原则\"><a href=\"#二、建立索引的原则\" class=\"headerlink\" title=\"二、建立索引的原则\"></a>二、建立索引的原则</h3><h4 id=\"2-1-应该遵守的原则\"><a href=\"#2-1-应该遵守的原则\" class=\"headerlink\" title=\"2.1 应该遵守的原则\"></a>2.1 应该遵守的原则</h4><ul>\n<li><p>①经常<strong>频繁用作查询条件的字段</strong>应酌情考虑为其创建索引。</p>\n</li>\n<li><p>②表的<strong>主外键或连表字段</strong>，必须建立索引，因为能很大程度提升连表查询的性能。</p>\n</li>\n<li><p>③建立索引的字段，一般值的<strong>区分性要足够高</strong>，这样才能提高索引的检索效率。</p>\n</li>\n<li><p>④建立索引的字段，值不应该过长，如果<strong>较长的字段要建立索引，可以选择前缀索引</strong>。</p>\n</li>\n<li><p>⑤建立<strong>联合索引</strong>，应当遵循<strong>最左前缀原则</strong>，将多个字段之间按优先级顺序组合。</p>\n</li>\n<li><p>⑥经常根据<strong>范围取值、排序、分组的字段应建立索引</strong>，因为索引有序，能加快排序时间。</p>\n</li>\n<li><p>⑦对于<strong>唯一索引</strong>，如果确认不会利用该字段排序，那可以将<strong>结构改为<code>Hash</code>结构</strong>。</p>\n</li>\n<li><p>⑧尽量使用<strong>联合索引代替单值索引</strong>，联合索引比多个单值索引查询效率要高。</p>\n</li>\n</ul>\n<h4 id=\"2-2-额外的注意点\"><a href=\"#2-2-额外的注意点\" class=\"headerlink\" title=\"2.2 额外的注意点\"></a>2.2 额外的注意点</h4><ul>\n<li><p>❶<strong>值经常会增删改的字段</strong>，不合适建立索引，因为每次改变后需维护索引结构。</p>\n</li>\n<li><p>❷一个<strong>字段存在大量的重复值</strong>时，不适合建立索引，比如之前举例的性别字段。</p>\n</li>\n<li><p>❸索引<strong>不能参与计算</strong>，因此经常<strong>带函数查询</strong>的字段，并不适合建立索引。</p>\n</li>\n<li><p>❹一张表中的索引<strong>数量并不是越多越好</strong>，一般控制在<code>3</code>，最多不能超过<code>5</code>。</p>\n</li>\n<li><p>❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</p>\n</li>\n<li><p>❻<strong>当表的数据较少，不应当建立索引</strong>，因为数据量不大时，维护索引反而开销更大。</p>\n</li>\n<li><p>❼索引的<strong>字段值无序时</strong>，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</p>\n</li>\n</ul>\n<h2 id=\"索引常见考题\"><a href=\"#索引常见考题\" class=\"headerlink\" title=\"索引常见考题\"></a>索引常见考题</h2><p>参考<a href=\"https://xiaolincoding.com/mysql/index/index_interview.html\">原文</a></p>\n<h3 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h3><p>从四个角度对索引进行分类：</p>\n<ul>\n<li>以<strong>数据结构</strong>分类：<font color=\"blue\">B+树索引、Hash索引、Full-text索引</font></li>\n<li>以<strong>物理存储</strong>分类：<font color=\"blue\">聚簇索引、二级索引</font></li>\n<li>以<strong>字段特性</strong>分类：<font color=\"blue\">主键索引、唯一索引、普通索引、前缀索引</font></li>\n<li>以字段个数分类：<font color=\"blue\">单列索引、联合索引</font></li>\n</ul>\n<h4 id=\"按数据结构分类\"><a href=\"#按数据结构分类\" class=\"headerlink\" title=\"按数据结构分类\"></a>按数据结构分类</h4><p>不同的存储引擎所支持的索引类型不同，具体如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409181420334.png\" alt=\"image-20240918142021754\"></p>\n<h4 id=\"按物理存储分类\"><a href=\"#按物理存储分类\" class=\"headerlink\" title=\"按物理存储分类\"></a>按物理存储分类</h4><ul>\n<li>聚簇索引的B+树叶子节点存放的是实际数据，包含了数据行所有字段的数据</li>\n<li>二级索引的B+树叶子节点存放的是主键值，并非实际数据。因此，如果所查询数据不二级索引叶子节点中，那么需要再进行一次<strong>回表</strong>操作；反之则是<strong>索引覆盖</strong></li>\n</ul>\n<h4 id=\"按字段特性分类\"><a href=\"#按字段特性分类\" class=\"headerlink\" title=\"按字段特性分类\"></a>按字段特性分类</h4><p><strong>主键索引</strong></p>\n<p>建立在主键之上的索引，一般在建表时创建，一张表最多只能有一个主键索引，并且主键字段不允许有<code>NULL</code>值</p>\n<p>如果没有指明主键，则系统会按照一下规则挑选并创建主键索引</p>\n<ul>\n<li>选择第一个不包含<code>NULL</code>值的<strong>唯一列</strong>作为主键列</li>\n<li>下下策，InnoDB自动生成一个自增的隐藏id列作为聚簇索引的索引键</li>\n</ul>\n<p>建表时，创建主键索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY KEY</span> (column_name) <span class=\"keyword\">USING</span> BTREE</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><strong>唯一索引</strong></p>\n<p>建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，但是索引键值必须唯一，允许有<code>NULL</code>值</p>\n<p>建表时，创建唯一索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name(</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY(column1, column2...)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>建表后，创建唯一索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX idx_name <span class=\"keyword\">ON</span> table_name(column1, column2...)</span><br></pre></td></tr></table></figure>\n\n<p><strong>前缀索引</strong></p>\n<p>以字符类型字段的前缀为键值建立索引，主要目的是为了减少存储空间，优化查询效率，可以用在字符类型为<code>char</code>、<code>varchat</code>、<code>binary</code>、<code>varbinary</code>的列上</p>\n<p>建表时，创建前缀索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name(</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    INDEX(column1(length))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>建表后，创建前缀索引的方式如下 :</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name <span class=\"keyword\">ON</span> table_name (column1(length))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按字段个数分类\"><a href=\"#按字段个数分类\" class=\"headerlink\" title=\"按字段个数分类\"></a>按字段个数分类</h4><p>主要介绍联合索引的几个特点</p>\n<ul>\n<li>范围查询<ul>\n<li>联合索引的最左匹配，在遇到范围查询（&gt;、&lt;）时，就会停止匹配。也就是说，范围查询的字段会用到联合索引，但之后的字段不会使用联合索引</li>\n<li>值得注意的是，对于<code>&gt;=</code>、<code>&lt;=</code>、<code>between xxx and</code>、<code>like</code>这类含有相等意义的范围查询，不会立刻停止匹配，即再范围查询之后的字段仍会用上联合索引，但只针对部分数据</li>\n</ul>\n</li>\n<li>索引下推<ul>\n<li>MySQL 5.6 引入索引下推优化，可以在联合索引遍历过程中，利用联合索引中未用上的查询条件对数据进行过滤，减少回表次数</li>\n</ul>\n</li>\n<li>索引区分度<ul>\n<li>在建立联合索引时，要尽可能 把区分度大的字段放在前面，这样联合索引被SQL用到的概率更大</li>\n</ul>\n</li>\n<li>用于排序<ul>\n<li>减少<code>Using filesort</code>的次数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化索引的方法\"><a href=\"#优化索引的方法\" class=\"headerlink\" title=\"优化索引的方法\"></a>优化索引的方法</h3><ul>\n<li>前缀索引优化<ul>\n<li>使用前缀索引可以减小索引字段的大小，增加一个索引页中存储的数据量，有效提高索引查询的效率</li>\n</ul>\n</li>\n<li>覆盖索引优化<ul>\n<li>将所要查询的字段建立成联合索引，在SQL查询过程中就能在二级索引B+树的叶子节点上找到所需要的全部数据，而不需要再通过聚簇索引查询获得，减少回表的操作</li>\n</ul>\n</li>\n<li>主键索引最好是自增的<ul>\n<li>插入一条数据都是追加操作，不需要移动数据，避免了页分裂带来的性能消耗和大量的内存碎片</li>\n<li>索引字段不宜过长，减少二级索引的存储空间</li>\n</ul>\n</li>\n<li>索引最好设置为<code>NOT NULL</code><ul>\n<li>索引列存在<code>NULL</code>值会加重索引选择的负担</li>\n<li>减少物理存储空间，如果表中存在允许为<code>NULL</code>的字段，那么行格式中至少会占用1字节空间存储<code>NULL</code>值列表</li>\n</ul>\n</li>\n<li>防止索引失效</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"MySQL索引学习\"><a href=\"#MySQL索引学习\" class=\"headerlink\" title=\"MySQL索引学习\"></a>MySQL索引学习</h1><h2 id=\"索引数据结构\"><a href=\"#索引数据结构\" class=\"headerlink\" title=\"索引数据结构\"></a>索引数据结构</h2><blockquote>\n<p>什么是索引？为什么索引能加快查询？</p>\n<p>索引的数据结构是什么？</p>\n<p>B+树和B树、红黑树有什么区别？为什么使用B+树？</p>\n</blockquote>\n<p>索引是一种排好序的快速查找的数据结构。在索引上查找数据的过程可以类比在二叉搜索树上进行数据查询，可以根据数据的大小关系省略对一些数据的查询操作，从而<strong>减少磁盘I&#x2F;O的次数</strong>，加快查询效率。</p>\n<p>索引的具体实现由<strong>底层的存储引擎决定</strong>，例如在InnoDB存储引擎下，索引是由B+树实现的。</p>\n<p>B树和B+树都是通过多叉树的形式，将树的高度降低，以此减少磁盘I&#x2F;O的次数。但较于B树，B+树有以下优点：</p>\n<ul>\n<li>B+的树<strong>非叶子节点不存放数据只存放索引</strong>，而B树的内节点既存数据又存索引。因此数据量相同的情况下，B+树的内节点可以存放更多的索引，这使得B+树可以比B树更“矮胖”，查询底层节点时磁盘I&#x2F;O次数更少</li>\n<li>B+树<strong>有大量的冗余节点</strong>（所有非叶子节点都是冗余节点），这些冗余节点使得B+树在插入、删除的情况下，树形变化不大，效率更高</li>\n<li>B+树的叶子节点之间通过<strong>链表相互连接</strong>，有利于范围查询</li>\n</ul>\n<h2 id=\"索引存储\"><a href=\"#索引存储\" class=\"headerlink\" title=\"索引存储\"></a>索引存储</h2><blockquote>\n<p>堆表和索引组织有什么区别？分别应用场景是什么？</p>\n</blockquote>\n<p>在<strong>堆表</strong>的组织中，<strong>数据和索引是分开存储的</strong>，B+树叶子节点存放的是<strong>索引+数据的地址，地址指向堆表中的数据</strong>。索引是排序后的数据，而堆表中的数据是无序的</p>\n<ul>\n<li>堆表中的索引<strong>都是二级索引</strong>，即使是主键索引也是二级索引，每次查询都要回表</li>\n<li>由于索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生变化且位置发生了改变，那么所有索引中的地址都要进行变更</li>\n<li>只支持表锁，并发性能差</li>\n</ul>\n<p>在<strong>索引组织表</strong>（聚簇索引，InnoDB存储引擎实现的数据组织方式）中，数据和索引是一起存储在B+树中的，B+树叶子节点存放的是<strong>索引+行记录</strong>。</p>\n<p>索引就是数据，数据就是索引</p>\n<ul>\n<li>索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>\n<li>在索引组织表中，二级索引具有天然优势：若记录发生了改变，其他索引无须进行维护，除非记录的主键发生了改变</li>\n<li>支持行级锁，并发性能高</li>\n</ul>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p>aba</p>\n<h2 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h2><blockquote>\n<p>有哪些索引失效的场景？为什么会失效？</p>\n</blockquote>\n<ul>\n<li><p>对索引使用左或者左右模糊匹配</p>\n<ul>\n<li>B+树索引是按照<strong>索引值</strong>有序排列存储的，只能根据前缀进行匹配比较</li>\n</ul>\n</li>\n<li><p>对索引使用函数</p>\n<ul>\n<li>索引保存的是索引字段的原始值，而不是经过函数计算后的结果，自然不能进行索引比较</li>\n</ul>\n</li>\n<li><p>对索引进行表达式计算</p>\n<ul>\n<li>索引保存的是索引字段的原始值，而不是经过表达式计算后的结果，自然不能进行索引比较</li>\n</ul>\n</li>\n<li><p>对索引隐式类型转换</p>\n<ul>\n<li><p>MySQL在遇到字符串和数字比较时，会先将字符串转换成数字，再进行数字比大小</p>\n</li>\n<li><p>如下两条SQL语句，第一条索引失效，第二条索引正常工作</p>\n</li>\n<li><pre><code class=\"sql\"># 先将name转换为整型数字，再进行比较\nselect * from users where name = 101010\n# 等价于 select * from users where cast(name as signed int) = 101010\n\n\nselect * from users where id = &#39;1&#39;\n# 等价于 select * from users where id = cast(&#39;1&#39; as signed int)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 联合索引非最左匹配</span><br><span class=\"line\"></span><br><span class=\"line\">  - 联合索引是先按照第一个索引键排序，再按照第二个索引键排序，以此类推</span><br><span class=\"line\"></span><br><span class=\"line\">- where子句中的or</span><br><span class=\"line\"></span><br><span class=\"line\">  - or前的条件列是索引列，而or后的条件列不是索引列则会导致索引失效</span><br><span class=\"line\"></span><br><span class=\"line\">## 索引选择</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; MySQL数据库中的优化器是怎么执行的？根据什么标准选择索引的？</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240916132934153](https://raw.githubusercontent.com/lyydsheep/pic/main/202409161330104.png)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL数据库由Server层和Engine层组成：</span><br><span class=\"line\"></span><br><span class=\"line\">- Server层有SQL分析器、SQL优化器、SQL执行器，用于负责SQL语句的具体执行过程</span><br><span class=\"line\">- Engine层用于存储具体的数据，例如InnoDB引擎，还有用于在内存中存储临时结果集的TempTable引擎</span><br><span class=\"line\"></span><br><span class=\"line\">其中SQL优化器用于分析SQL语句在使用不同索引时所需要的成本，并选择成本最小的执行计划（或全局扫描），作为SQL最优执行方案，这种优化器也叫做CBO（Cost-based optimizer）优化器</span><br><span class=\"line\"></span><br><span class=\"line\">在MySQL中，一条SQL的计算成本按如下公式计算：</span><br><span class=\"line\"></span><br><span class=\"line\">```sql</span><br><span class=\"line\">Cost = Server Cost + Engine Cost</span><br><span class=\"line\">\t = CPU Cost + IO Cost</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>基于SQL优化器的工作原理，有如下实际案例经验：</p>\n<ul>\n<li><p>一般只对<strong>高选择度的字段和字段组合</strong>建立索引，低选择度的字段如<strong>性别</strong>，不创建索引</p>\n</li>\n<li><p>低选择性，但是存在数据倾斜，例如优化器认为P状态有1&#x2F;3，实际上P状态只有1&#x2F;100，可以考虑创建索引</p>\n<ul>\n<li><p>通过创建直方图，让优化器知道实际的数据分布</p>\n</li>\n<li><pre><code class=\"sql\">ANALYZE TABLE orders \n\nUPDATE HISTOGRAM ON o_orderstatus;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 索引应用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 建立索引有什么优点和缺点？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 如何正确建立索引？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 哪些场景下适合建立索引？</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 哪些场景下不适合建立索引？</span><br><span class=\"line\"></span><br><span class=\"line\">可以参考[原文](https://juejin.cn/post/7149074488649318431)</span><br><span class=\"line\"></span><br><span class=\"line\">### 一、MySQL中各索引分析</span><br><span class=\"line\"></span><br><span class=\"line\">#### 1.1 为什么选自增Id作为主键？</span><br><span class=\"line\"></span><br><span class=\"line\">在MySQL表中，一般都是用**自增Id**作为主键，这确保了数据的唯一性，但为什么又需要**自增**性质？</span><br><span class=\"line\"></span><br><span class=\"line\">在InnoDB存储引擎中，主键索引以聚簇的形式**有序**存储，即索引即数据、数据即索引按照主键大小依次排列存储在磁盘上。如果使用无序的uuid作为主键，虽然uuid也能保证数据的唯一性，但是很有可能会破坏原本的树结构</span><br><span class=\"line\"></span><br><span class=\"line\">举个例子：</span><br><span class=\"line\"></span><br><span class=\"line\">灰色节点作为一条新数据，如果按照**uuid大小排列**，它应该插入在第二个位置，那么后续节点都要挪动，时间复杂度（不小于）$$O(n)$$，这就导致插入数据十分占用CPU资源。</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20240917114122420](https://raw.githubusercontent.com/lyydsheep/pic/main/202409171141423.png)</span><br><span class=\"line\"></span><br><span class=\"line\">但使用**自增Id**就不会有这个问题，新来的数据直接放到最后，因此数据表的主键值最好选用带有顺序性的值。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 1.2 联合索引的最左匹配原则</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">为`id, name, age`这三个字段建立联合索引，此时一个SQL语句如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```sql</span><br><span class=\"line\">SELECT * FROM users WHERE name = &#x27;lyydsheep&#x27; AND age = 1;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>这条SQL语句是用不上联合索引的，因为查询条件中没有出现<strong>从最左端开始的连续字段</strong>。而下列这条SQL语句就能使用上联合索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">AND</span> name <span class=\"operator\">=</span> <span class=\"string\">&#x27;lyydsheep&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>根本原因就是<code>id</code>字段是<strong>全局有序</strong>，而<code>name</code>、<code>age</code>字段是<strong>局部有序</strong>的</p>\n<h4 id=\"1-3-唯一索引的快慢问题\"><a href=\"#1-3-唯一索引的快慢问题\" class=\"headerlink\" title=\"1.3 唯一索引的快慢问题\"></a>1.3 唯一索引的快慢问题</h4><p>唯一索引相比于普通索引的优势就在于唯一索引限定了字段值必须是唯一的，当找到一条数据后旧立马停止检索。而普通索引仍需要走完整个索引树，因为可能存在多个相同的字段值的数据。</p>\n<p>唯一索引在查询时比普通索引快上一截，但插入数据时就不同了，因为要确保数据唯一性，插入数据前要检察一遍表中是否存在相同的数据。普通索引就没有这顾虑了，因此普通索引插入数据会更快一些。</p>\n<h3 id=\"二、建立索引的原则\"><a href=\"#二、建立索引的原则\" class=\"headerlink\" title=\"二、建立索引的原则\"></a>二、建立索引的原则</h3><h4 id=\"2-1-应该遵守的原则\"><a href=\"#2-1-应该遵守的原则\" class=\"headerlink\" title=\"2.1 应该遵守的原则\"></a>2.1 应该遵守的原则</h4><ul>\n<li><p>①经常<strong>频繁用作查询条件的字段</strong>应酌情考虑为其创建索引。</p>\n</li>\n<li><p>②表的<strong>主外键或连表字段</strong>，必须建立索引，因为能很大程度提升连表查询的性能。</p>\n</li>\n<li><p>③建立索引的字段，一般值的<strong>区分性要足够高</strong>，这样才能提高索引的检索效率。</p>\n</li>\n<li><p>④建立索引的字段，值不应该过长，如果<strong>较长的字段要建立索引，可以选择前缀索引</strong>。</p>\n</li>\n<li><p>⑤建立<strong>联合索引</strong>，应当遵循<strong>最左前缀原则</strong>，将多个字段之间按优先级顺序组合。</p>\n</li>\n<li><p>⑥经常根据<strong>范围取值、排序、分组的字段应建立索引</strong>，因为索引有序，能加快排序时间。</p>\n</li>\n<li><p>⑦对于<strong>唯一索引</strong>，如果确认不会利用该字段排序，那可以将<strong>结构改为<code>Hash</code>结构</strong>。</p>\n</li>\n<li><p>⑧尽量使用<strong>联合索引代替单值索引</strong>，联合索引比多个单值索引查询效率要高。</p>\n</li>\n</ul>\n<h4 id=\"2-2-额外的注意点\"><a href=\"#2-2-额外的注意点\" class=\"headerlink\" title=\"2.2 额外的注意点\"></a>2.2 额外的注意点</h4><ul>\n<li><p>❶<strong>值经常会增删改的字段</strong>，不合适建立索引，因为每次改变后需维护索引结构。</p>\n</li>\n<li><p>❷一个<strong>字段存在大量的重复值</strong>时，不适合建立索引，比如之前举例的性别字段。</p>\n</li>\n<li><p>❸索引<strong>不能参与计算</strong>，因此经常<strong>带函数查询</strong>的字段，并不适合建立索引。</p>\n</li>\n<li><p>❹一张表中的索引<strong>数量并不是越多越好</strong>，一般控制在<code>3</code>，最多不能超过<code>5</code>。</p>\n</li>\n<li><p>❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</p>\n</li>\n<li><p>❻<strong>当表的数据较少，不应当建立索引</strong>，因为数据量不大时，维护索引反而开销更大。</p>\n</li>\n<li><p>❼索引的<strong>字段值无序时</strong>，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</p>\n</li>\n</ul>\n<h2 id=\"索引常见考题\"><a href=\"#索引常见考题\" class=\"headerlink\" title=\"索引常见考题\"></a>索引常见考题</h2><p>参考<a href=\"https://xiaolincoding.com/mysql/index/index_interview.html\">原文</a></p>\n<h3 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h3><p>从四个角度对索引进行分类：</p>\n<ul>\n<li>以<strong>数据结构</strong>分类：<font color=\"blue\">B+树索引、Hash索引、Full-text索引</font></li>\n<li>以<strong>物理存储</strong>分类：<font color=\"blue\">聚簇索引、二级索引</font></li>\n<li>以<strong>字段特性</strong>分类：<font color=\"blue\">主键索引、唯一索引、普通索引、前缀索引</font></li>\n<li>以字段个数分类：<font color=\"blue\">单列索引、联合索引</font></li>\n</ul>\n<h4 id=\"按数据结构分类\"><a href=\"#按数据结构分类\" class=\"headerlink\" title=\"按数据结构分类\"></a>按数据结构分类</h4><p>不同的存储引擎所支持的索引类型不同，具体如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409181420334.png\" alt=\"image-20240918142021754\"></p>\n<h4 id=\"按物理存储分类\"><a href=\"#按物理存储分类\" class=\"headerlink\" title=\"按物理存储分类\"></a>按物理存储分类</h4><ul>\n<li>聚簇索引的B+树叶子节点存放的是实际数据，包含了数据行所有字段的数据</li>\n<li>二级索引的B+树叶子节点存放的是主键值，并非实际数据。因此，如果所查询数据不二级索引叶子节点中，那么需要再进行一次<strong>回表</strong>操作；反之则是<strong>索引覆盖</strong></li>\n</ul>\n<h4 id=\"按字段特性分类\"><a href=\"#按字段特性分类\" class=\"headerlink\" title=\"按字段特性分类\"></a>按字段特性分类</h4><p><strong>主键索引</strong></p>\n<p>建立在主键之上的索引，一般在建表时创建，一张表最多只能有一个主键索引，并且主键字段不允许有<code>NULL</code>值</p>\n<p>如果没有指明主键，则系统会按照一下规则挑选并创建主键索引</p>\n<ul>\n<li>选择第一个不包含<code>NULL</code>值的<strong>唯一列</strong>作为主键列</li>\n<li>下下策，InnoDB自动生成一个自增的隐藏id列作为聚簇索引的索引键</li>\n</ul>\n<p>建表时，创建主键索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name (</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY KEY</span> (column_name) <span class=\"keyword\">USING</span> BTREE</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><strong>唯一索引</strong></p>\n<p>建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，但是索引键值必须唯一，允许有<code>NULL</code>值</p>\n<p>建表时，创建唯一索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name(</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY(column1, column2...)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>建表后，创建唯一索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX idx_name <span class=\"keyword\">ON</span> table_name(column1, column2...)</span><br></pre></td></tr></table></figure>\n\n<p><strong>前缀索引</strong></p>\n<p>以字符类型字段的前缀为键值建立索引，主要目的是为了减少存储空间，优化查询效率，可以用在字符类型为<code>char</code>、<code>varchat</code>、<code>binary</code>、<code>varbinary</code>的列上</p>\n<p>建表时，创建前缀索引的方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> table_name(</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    INDEX(column1(length))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>建表后，创建前缀索引的方式如下 :</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_name <span class=\"keyword\">ON</span> table_name (column1(length))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按字段个数分类\"><a href=\"#按字段个数分类\" class=\"headerlink\" title=\"按字段个数分类\"></a>按字段个数分类</h4><p>主要介绍联合索引的几个特点</p>\n<ul>\n<li>范围查询<ul>\n<li>联合索引的最左匹配，在遇到范围查询（&gt;、&lt;）时，就会停止匹配。也就是说，范围查询的字段会用到联合索引，但之后的字段不会使用联合索引</li>\n<li>值得注意的是，对于<code>&gt;=</code>、<code>&lt;=</code>、<code>between xxx and</code>、<code>like</code>这类含有相等意义的范围查询，不会立刻停止匹配，即再范围查询之后的字段仍会用上联合索引，但只针对部分数据</li>\n</ul>\n</li>\n<li>索引下推<ul>\n<li>MySQL 5.6 引入索引下推优化，可以在联合索引遍历过程中，利用联合索引中未用上的查询条件对数据进行过滤，减少回表次数</li>\n</ul>\n</li>\n<li>索引区分度<ul>\n<li>在建立联合索引时，要尽可能 把区分度大的字段放在前面，这样联合索引被SQL用到的概率更大</li>\n</ul>\n</li>\n<li>用于排序<ul>\n<li>减少<code>Using filesort</code>的次数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化索引的方法\"><a href=\"#优化索引的方法\" class=\"headerlink\" title=\"优化索引的方法\"></a>优化索引的方法</h3><ul>\n<li>前缀索引优化<ul>\n<li>使用前缀索引可以减小索引字段的大小，增加一个索引页中存储的数据量，有效提高索引查询的效率</li>\n</ul>\n</li>\n<li>覆盖索引优化<ul>\n<li>将所要查询的字段建立成联合索引，在SQL查询过程中就能在二级索引B+树的叶子节点上找到所需要的全部数据，而不需要再通过聚簇索引查询获得，减少回表的操作</li>\n</ul>\n</li>\n<li>主键索引最好是自增的<ul>\n<li>插入一条数据都是追加操作，不需要移动数据，避免了页分裂带来的性能消耗和大量的内存碎片</li>\n<li>索引字段不宜过长，减少二级索引的存储空间</li>\n</ul>\n</li>\n<li>索引最好设置为<code>NOT NULL</code><ul>\n<li>索引列存在<code>NULL</code>值会加重索引选择的负担</li>\n<li>减少物理存储空间，如果表中存在允许为<code>NULL</code>的字段，那么行格式中至少会占用1字节空间存储<code>NULL</code>值列表</li>\n</ul>\n</li>\n<li>防止索引失效</li>\n</ul>\n"},{"title":"MySQL锁学习","publish":true,"description":"记录一些有关MySQL锁的知识点","date":"2024-09-26T16:00:00.000Z","_content":"\n# 锁\n\n## 锁类型\n\naba\n\n## 行级锁\n\naba\n\n## MDL锁\n\naba\n\n## 死锁\n\n> 死锁是怎么发生的？\n>\n> 发生死锁的条件有哪些？\n>\n> 怎么排查死锁问题？\n>\n> 怎么避免死锁问题？\n\n### 为什么会产生死锁\n\nInnoDB默认的事务隔离级别是**可重复读**，在可重复读事务隔离级别下多个并发的事务可能会导致幻读问题。InnoDB为了既能保证性能（不使用串行化隔离级别）又能解决幻读问题，便提出了**next-key**锁，它是记录锁和间隙锁的组合\n\n- Record key，记录锁，锁的是记录本身\n- Gap key，间隙锁，锁的是两个值的间隙，防止其他事务在这个间隙中插入新的记录，从而避免幻读现象\n\n普通的`select`语句使用MVCC机制实现可重复读，并不会对记录加锁，想要在**查询记录时对记录加锁**可以使用下列两种方式：\n\n```sql\nbegin:\n# 对读取的记录加共享锁\nselect ... lock in share mode;\ncommit; # 提交事务，释放锁\n\n\nbegin:\n# 对读取的记录加\nselect ... for update;\ncommit; #\n```\n\n> 怎么确定加锁类型的❓❓❓\n\n**行锁的释放时机是在事务提交之后，并不是执行完一条语句就会释放锁**\n\n⚠️：如果update语句中**where条件没有使用索引列**，那么就会对全表进行扫描，所有的记录都会被上行锁，记录和记录之间的间隙会被上间隙锁，也就是说，**整个表都被上锁了**😂，直到事务结束后才会释放。这就会导致其他事务停滞，造成极大的性能损失\n\n- 插入意向锁和间隙锁是冲突的，所以当其他事务持有该间隙的间隙锁时，之后在这些事务提交并释放锁之后，事务A才能拿到插入意向锁。\n- 而间隙锁和间隙锁之间时兼容的，即两个事务拿着的间隙锁所上锁的区间是允许有重叠部分的。\n\n正是因为上述两个原因，在某些情况下就会有死锁发生🌰：\n\n![image-20240926084318858](https://raw.githubusercontent.com/lyydsheep/pic/main/202409260844452.png)\n\n### 如何避免死锁\n\n死锁产生的四个必要条件：<font color='blue'>**互斥、占有并等待、非抢占、循环等待**</font>。如果系统发生了死锁，只要破环四个必要条件中的任意一个就能解除死锁\n\n在数据库层面有两种策略打破**循环等待**条件来解除死锁：\n\n- **设置事务等待锁的阈值时间**：当事务等待锁的时间超过阈值，就主动进行回滚操作，将锁释放，那么另一个事务就能继续执行了\n- **开启主动死锁检测**：当检测到发生死锁后，主动回滚死锁链条中的一个事务，让其他事务能够正常执行\n\n## 悲观锁和乐观锁\n\n### 悲观锁和乐观锁\n\n**悲观锁（Pessimistic Lock）**：悲观地认为每拿到数据的这段时间，别的线程会对数据进行修改，所以每次拿数据直接都对数据上锁，防止别的线程拿到数据。**悲观锁中的共享资源每次只给一个线程使用，其他线程则会被阻塞，直至悲观锁释放**\n\n悲观锁的并发控制实质上是采用了**先上锁再访问**的保守策略，保证了并发下数据安全处理，但是性能较差\n\n![image-20240927100026612](https://raw.githubusercontent.com/lyydsheep/pic/main/202409271000655.png)\n\n**乐观锁（Optimistic Lock）**：乐观地认为拿到数据的这段时间，别的线程不会对数据进行修改，只有在**想要更新数据时才检查数据是否被别的线程更新过**。如果更新过，则重新读取，并再次尝试更新，循环此步骤直至更新成功（或超时）\n\n![image-20240927100556216](https://raw.githubusercontent.com/lyydsheep/pic/main/202409271005257.png)\n\n乐观锁认为发生数据竞争的概率比较小，只有在更新的时候才会进行数据校验，实际上**不会上锁**，所以不会产生死锁现象\n\nCAS（compare and swap）即比较并替换\n\n- 比较：读取到一个数据值为A，在将其更新为B之前，先检查一下原值是否仍是A\n- 如果不是，则放弃更改\n- 如果是，则将数据值设置为B\n\n`compare`和`swap`两步操作是原子性的，在CPU看来就是一步操作\n\n**ABA问题**：如果某个数据初值为A，但是别的线程将其改为C后又修改成了A，此时在CAS检查过程中就误认为数据并没有被修改。这个问题就是CAS中的**ABA问题**\n\n**ABA问题的解决**：可以增加一个版本号（version）字段，每次更新操作都要对`version+1`，在CAS检查过程中不仅仅检查数据值还要检查版本号是否修改\n\n⚠️：\n\n- 乐观锁并未真正加锁，效率较高，适用于写比较少的情况，更新失败概率比较高\n- 悲观锁依赖于数据库锁，效率低，更新失败概率比较低","source":"_posts/MySQL/MySQL锁学习.md","raw":"---\ntitle: MySQL锁学习\npublish: true\ndescription: 记录一些有关MySQL锁的知识点\ndate: 2024-09-27 \ntag: MySQL\n---\n\n# 锁\n\n## 锁类型\n\naba\n\n## 行级锁\n\naba\n\n## MDL锁\n\naba\n\n## 死锁\n\n> 死锁是怎么发生的？\n>\n> 发生死锁的条件有哪些？\n>\n> 怎么排查死锁问题？\n>\n> 怎么避免死锁问题？\n\n### 为什么会产生死锁\n\nInnoDB默认的事务隔离级别是**可重复读**，在可重复读事务隔离级别下多个并发的事务可能会导致幻读问题。InnoDB为了既能保证性能（不使用串行化隔离级别）又能解决幻读问题，便提出了**next-key**锁，它是记录锁和间隙锁的组合\n\n- Record key，记录锁，锁的是记录本身\n- Gap key，间隙锁，锁的是两个值的间隙，防止其他事务在这个间隙中插入新的记录，从而避免幻读现象\n\n普通的`select`语句使用MVCC机制实现可重复读，并不会对记录加锁，想要在**查询记录时对记录加锁**可以使用下列两种方式：\n\n```sql\nbegin:\n# 对读取的记录加共享锁\nselect ... lock in share mode;\ncommit; # 提交事务，释放锁\n\n\nbegin:\n# 对读取的记录加\nselect ... for update;\ncommit; #\n```\n\n> 怎么确定加锁类型的❓❓❓\n\n**行锁的释放时机是在事务提交之后，并不是执行完一条语句就会释放锁**\n\n⚠️：如果update语句中**where条件没有使用索引列**，那么就会对全表进行扫描，所有的记录都会被上行锁，记录和记录之间的间隙会被上间隙锁，也就是说，**整个表都被上锁了**😂，直到事务结束后才会释放。这就会导致其他事务停滞，造成极大的性能损失\n\n- 插入意向锁和间隙锁是冲突的，所以当其他事务持有该间隙的间隙锁时，之后在这些事务提交并释放锁之后，事务A才能拿到插入意向锁。\n- 而间隙锁和间隙锁之间时兼容的，即两个事务拿着的间隙锁所上锁的区间是允许有重叠部分的。\n\n正是因为上述两个原因，在某些情况下就会有死锁发生🌰：\n\n![image-20240926084318858](https://raw.githubusercontent.com/lyydsheep/pic/main/202409260844452.png)\n\n### 如何避免死锁\n\n死锁产生的四个必要条件：<font color='blue'>**互斥、占有并等待、非抢占、循环等待**</font>。如果系统发生了死锁，只要破环四个必要条件中的任意一个就能解除死锁\n\n在数据库层面有两种策略打破**循环等待**条件来解除死锁：\n\n- **设置事务等待锁的阈值时间**：当事务等待锁的时间超过阈值，就主动进行回滚操作，将锁释放，那么另一个事务就能继续执行了\n- **开启主动死锁检测**：当检测到发生死锁后，主动回滚死锁链条中的一个事务，让其他事务能够正常执行\n\n## 悲观锁和乐观锁\n\n### 悲观锁和乐观锁\n\n**悲观锁（Pessimistic Lock）**：悲观地认为每拿到数据的这段时间，别的线程会对数据进行修改，所以每次拿数据直接都对数据上锁，防止别的线程拿到数据。**悲观锁中的共享资源每次只给一个线程使用，其他线程则会被阻塞，直至悲观锁释放**\n\n悲观锁的并发控制实质上是采用了**先上锁再访问**的保守策略，保证了并发下数据安全处理，但是性能较差\n\n![image-20240927100026612](https://raw.githubusercontent.com/lyydsheep/pic/main/202409271000655.png)\n\n**乐观锁（Optimistic Lock）**：乐观地认为拿到数据的这段时间，别的线程不会对数据进行修改，只有在**想要更新数据时才检查数据是否被别的线程更新过**。如果更新过，则重新读取，并再次尝试更新，循环此步骤直至更新成功（或超时）\n\n![image-20240927100556216](https://raw.githubusercontent.com/lyydsheep/pic/main/202409271005257.png)\n\n乐观锁认为发生数据竞争的概率比较小，只有在更新的时候才会进行数据校验，实际上**不会上锁**，所以不会产生死锁现象\n\nCAS（compare and swap）即比较并替换\n\n- 比较：读取到一个数据值为A，在将其更新为B之前，先检查一下原值是否仍是A\n- 如果不是，则放弃更改\n- 如果是，则将数据值设置为B\n\n`compare`和`swap`两步操作是原子性的，在CPU看来就是一步操作\n\n**ABA问题**：如果某个数据初值为A，但是别的线程将其改为C后又修改成了A，此时在CAS检查过程中就误认为数据并没有被修改。这个问题就是CAS中的**ABA问题**\n\n**ABA问题的解决**：可以增加一个版本号（version）字段，每次更新操作都要对`version+1`，在CAS检查过程中不仅仅检查数据值还要检查版本号是否修改\n\n⚠️：\n\n- 乐观锁并未真正加锁，效率较高，适用于写比较少的情况，更新失败概率比较高\n- 悲观锁依赖于数据库锁，效率低，更新失败概率比较低","slug":"MySQL/MySQL锁学习","published":1,"updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ia5t22exeelcy","content":"<h1 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h1><h2 id=\"锁类型\"><a href=\"#锁类型\" class=\"headerlink\" title=\"锁类型\"></a>锁类型</h2><p>aba</p>\n<h2 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h2><p>aba</p>\n<h2 id=\"MDL锁\"><a href=\"#MDL锁\" class=\"headerlink\" title=\"MDL锁\"></a>MDL锁</h2><p>aba</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><blockquote>\n<p>死锁是怎么发生的？</p>\n<p>发生死锁的条件有哪些？</p>\n<p>怎么排查死锁问题？</p>\n<p>怎么避免死锁问题？</p>\n</blockquote>\n<h3 id=\"为什么会产生死锁\"><a href=\"#为什么会产生死锁\" class=\"headerlink\" title=\"为什么会产生死锁\"></a>为什么会产生死锁</h3><p>InnoDB默认的事务隔离级别是<strong>可重复读</strong>，在可重复读事务隔离级别下多个并发的事务可能会导致幻读问题。InnoDB为了既能保证性能（不使用串行化隔离级别）又能解决幻读问题，便提出了<strong>next-key</strong>锁，它是记录锁和间隙锁的组合</p>\n<ul>\n<li>Record key，记录锁，锁的是记录本身</li>\n<li>Gap key，间隙锁，锁的是两个值的间隙，防止其他事务在这个间隙中插入新的记录，从而避免幻读现象</li>\n</ul>\n<p>普通的<code>select</code>语句使用MVCC机制实现可重复读，并不会对记录加锁，想要在<strong>查询记录时对记录加锁</strong>可以使用下列两种方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>:</span><br><span class=\"line\"># 对读取的记录加共享锁</span><br><span class=\"line\"><span class=\"keyword\">select</span> ... lock <span class=\"keyword\">in</span> share mode;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>; # 提交事务，释放锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>:</span><br><span class=\"line\"># 对读取的记录加</span><br><span class=\"line\"><span class=\"keyword\">select</span> ... <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>; #</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>怎么确定加锁类型的❓❓❓</p>\n</blockquote>\n<p><strong>行锁的释放时机是在事务提交之后，并不是执行完一条语句就会释放锁</strong></p>\n<p>⚠️：如果update语句中<strong>where条件没有使用索引列</strong>，那么就会对全表进行扫描，所有的记录都会被上行锁，记录和记录之间的间隙会被上间隙锁，也就是说，<strong>整个表都被上锁了</strong>😂，直到事务结束后才会释放。这就会导致其他事务停滞，造成极大的性能损失</p>\n<ul>\n<li>插入意向锁和间隙锁是冲突的，所以当其他事务持有该间隙的间隙锁时，之后在这些事务提交并释放锁之后，事务A才能拿到插入意向锁。</li>\n<li>而间隙锁和间隙锁之间时兼容的，即两个事务拿着的间隙锁所上锁的区间是允许有重叠部分的。</li>\n</ul>\n<p>正是因为上述两个原因，在某些情况下就会有死锁发生🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409260844452.png\" alt=\"image-20240926084318858\"></p>\n<h3 id=\"如何避免死锁\"><a href=\"#如何避免死锁\" class=\"headerlink\" title=\"如何避免死锁\"></a>如何避免死锁</h3><p>死锁产生的四个必要条件：<font color='blue'><strong>互斥、占有并等待、非抢占、循环等待</strong></font>。如果系统发生了死锁，只要破环四个必要条件中的任意一个就能解除死锁</p>\n<p>在数据库层面有两种策略打破<strong>循环等待</strong>条件来解除死锁：</p>\n<ul>\n<li><strong>设置事务等待锁的阈值时间</strong>：当事务等待锁的时间超过阈值，就主动进行回滚操作，将锁释放，那么另一个事务就能继续执行了</li>\n<li><strong>开启主动死锁检测</strong>：当检测到发生死锁后，主动回滚死锁链条中的一个事务，让其他事务能够正常执行</li>\n</ul>\n<h2 id=\"悲观锁和乐观锁\"><a href=\"#悲观锁和乐观锁\" class=\"headerlink\" title=\"悲观锁和乐观锁\"></a>悲观锁和乐观锁</h2><h3 id=\"悲观锁和乐观锁-1\"><a href=\"#悲观锁和乐观锁-1\" class=\"headerlink\" title=\"悲观锁和乐观锁\"></a>悲观锁和乐观锁</h3><p><strong>悲观锁（Pessimistic Lock）</strong>：悲观地认为每拿到数据的这段时间，别的线程会对数据进行修改，所以每次拿数据直接都对数据上锁，防止别的线程拿到数据。<strong>悲观锁中的共享资源每次只给一个线程使用，其他线程则会被阻塞，直至悲观锁释放</strong></p>\n<p>悲观锁的并发控制实质上是采用了<strong>先上锁再访问</strong>的保守策略，保证了并发下数据安全处理，但是性能较差</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271000655.png\" alt=\"image-20240927100026612\"></p>\n<p><strong>乐观锁（Optimistic Lock）</strong>：乐观地认为拿到数据的这段时间，别的线程不会对数据进行修改，只有在<strong>想要更新数据时才检查数据是否被别的线程更新过</strong>。如果更新过，则重新读取，并再次尝试更新，循环此步骤直至更新成功（或超时）</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271005257.png\" alt=\"image-20240927100556216\"></p>\n<p>乐观锁认为发生数据竞争的概率比较小，只有在更新的时候才会进行数据校验，实际上<strong>不会上锁</strong>，所以不会产生死锁现象</p>\n<p>CAS（compare and swap）即比较并替换</p>\n<ul>\n<li>比较：读取到一个数据值为A，在将其更新为B之前，先检查一下原值是否仍是A</li>\n<li>如果不是，则放弃更改</li>\n<li>如果是，则将数据值设置为B</li>\n</ul>\n<p><code>compare</code>和<code>swap</code>两步操作是原子性的，在CPU看来就是一步操作</p>\n<p><strong>ABA问题</strong>：如果某个数据初值为A，但是别的线程将其改为C后又修改成了A，此时在CAS检查过程中就误认为数据并没有被修改。这个问题就是CAS中的<strong>ABA问题</strong></p>\n<p><strong>ABA问题的解决</strong>：可以增加一个版本号（version）字段，每次更新操作都要对<code>version+1</code>，在CAS检查过程中不仅仅检查数据值还要检查版本号是否修改</p>\n<p>⚠️：</p>\n<ul>\n<li>乐观锁并未真正加锁，效率较高，适用于写比较少的情况，更新失败概率比较高</li>\n<li>悲观锁依赖于数据库锁，效率低，更新失败概率比较低</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h1><h2 id=\"锁类型\"><a href=\"#锁类型\" class=\"headerlink\" title=\"锁类型\"></a>锁类型</h2><p>aba</p>\n<h2 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h2><p>aba</p>\n<h2 id=\"MDL锁\"><a href=\"#MDL锁\" class=\"headerlink\" title=\"MDL锁\"></a>MDL锁</h2><p>aba</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><blockquote>\n<p>死锁是怎么发生的？</p>\n<p>发生死锁的条件有哪些？</p>\n<p>怎么排查死锁问题？</p>\n<p>怎么避免死锁问题？</p>\n</blockquote>\n<h3 id=\"为什么会产生死锁\"><a href=\"#为什么会产生死锁\" class=\"headerlink\" title=\"为什么会产生死锁\"></a>为什么会产生死锁</h3><p>InnoDB默认的事务隔离级别是<strong>可重复读</strong>，在可重复读事务隔离级别下多个并发的事务可能会导致幻读问题。InnoDB为了既能保证性能（不使用串行化隔离级别）又能解决幻读问题，便提出了<strong>next-key</strong>锁，它是记录锁和间隙锁的组合</p>\n<ul>\n<li>Record key，记录锁，锁的是记录本身</li>\n<li>Gap key，间隙锁，锁的是两个值的间隙，防止其他事务在这个间隙中插入新的记录，从而避免幻读现象</li>\n</ul>\n<p>普通的<code>select</code>语句使用MVCC机制实现可重复读，并不会对记录加锁，想要在<strong>查询记录时对记录加锁</strong>可以使用下列两种方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span>:</span><br><span class=\"line\"># 对读取的记录加共享锁</span><br><span class=\"line\"><span class=\"keyword\">select</span> ... lock <span class=\"keyword\">in</span> share mode;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>; # 提交事务，释放锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span>:</span><br><span class=\"line\"># 对读取的记录加</span><br><span class=\"line\"><span class=\"keyword\">select</span> ... <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br><span class=\"line\"><span class=\"keyword\">commit</span>; #</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>怎么确定加锁类型的❓❓❓</p>\n</blockquote>\n<p><strong>行锁的释放时机是在事务提交之后，并不是执行完一条语句就会释放锁</strong></p>\n<p>⚠️：如果update语句中<strong>where条件没有使用索引列</strong>，那么就会对全表进行扫描，所有的记录都会被上行锁，记录和记录之间的间隙会被上间隙锁，也就是说，<strong>整个表都被上锁了</strong>😂，直到事务结束后才会释放。这就会导致其他事务停滞，造成极大的性能损失</p>\n<ul>\n<li>插入意向锁和间隙锁是冲突的，所以当其他事务持有该间隙的间隙锁时，之后在这些事务提交并释放锁之后，事务A才能拿到插入意向锁。</li>\n<li>而间隙锁和间隙锁之间时兼容的，即两个事务拿着的间隙锁所上锁的区间是允许有重叠部分的。</li>\n</ul>\n<p>正是因为上述两个原因，在某些情况下就会有死锁发生🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409260844452.png\" alt=\"image-20240926084318858\"></p>\n<h3 id=\"如何避免死锁\"><a href=\"#如何避免死锁\" class=\"headerlink\" title=\"如何避免死锁\"></a>如何避免死锁</h3><p>死锁产生的四个必要条件：<font color='blue'><strong>互斥、占有并等待、非抢占、循环等待</strong></font>。如果系统发生了死锁，只要破环四个必要条件中的任意一个就能解除死锁</p>\n<p>在数据库层面有两种策略打破<strong>循环等待</strong>条件来解除死锁：</p>\n<ul>\n<li><strong>设置事务等待锁的阈值时间</strong>：当事务等待锁的时间超过阈值，就主动进行回滚操作，将锁释放，那么另一个事务就能继续执行了</li>\n<li><strong>开启主动死锁检测</strong>：当检测到发生死锁后，主动回滚死锁链条中的一个事务，让其他事务能够正常执行</li>\n</ul>\n<h2 id=\"悲观锁和乐观锁\"><a href=\"#悲观锁和乐观锁\" class=\"headerlink\" title=\"悲观锁和乐观锁\"></a>悲观锁和乐观锁</h2><h3 id=\"悲观锁和乐观锁-1\"><a href=\"#悲观锁和乐观锁-1\" class=\"headerlink\" title=\"悲观锁和乐观锁\"></a>悲观锁和乐观锁</h3><p><strong>悲观锁（Pessimistic Lock）</strong>：悲观地认为每拿到数据的这段时间，别的线程会对数据进行修改，所以每次拿数据直接都对数据上锁，防止别的线程拿到数据。<strong>悲观锁中的共享资源每次只给一个线程使用，其他线程则会被阻塞，直至悲观锁释放</strong></p>\n<p>悲观锁的并发控制实质上是采用了<strong>先上锁再访问</strong>的保守策略，保证了并发下数据安全处理，但是性能较差</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271000655.png\" alt=\"image-20240927100026612\"></p>\n<p><strong>乐观锁（Optimistic Lock）</strong>：乐观地认为拿到数据的这段时间，别的线程不会对数据进行修改，只有在<strong>想要更新数据时才检查数据是否被别的线程更新过</strong>。如果更新过，则重新读取，并再次尝试更新，循环此步骤直至更新成功（或超时）</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202409271005257.png\" alt=\"image-20240927100556216\"></p>\n<p>乐观锁认为发生数据竞争的概率比较小，只有在更新的时候才会进行数据校验，实际上<strong>不会上锁</strong>，所以不会产生死锁现象</p>\n<p>CAS（compare and swap）即比较并替换</p>\n<ul>\n<li>比较：读取到一个数据值为A，在将其更新为B之前，先检查一下原值是否仍是A</li>\n<li>如果不是，则放弃更改</li>\n<li>如果是，则将数据值设置为B</li>\n</ul>\n<p><code>compare</code>和<code>swap</code>两步操作是原子性的，在CPU看来就是一步操作</p>\n<p><strong>ABA问题</strong>：如果某个数据初值为A，但是别的线程将其改为C后又修改成了A，此时在CAS检查过程中就误认为数据并没有被修改。这个问题就是CAS中的<strong>ABA问题</strong></p>\n<p><strong>ABA问题的解决</strong>：可以增加一个版本号（version）字段，每次更新操作都要对<code>version+1</code>，在CAS检查过程中不仅仅检查数据值还要检查版本号是否修改</p>\n<p>⚠️：</p>\n<ul>\n<li>乐观锁并未真正加锁，效率较高，适用于写比较少的情况，更新失败概率比较高</li>\n<li>悲观锁依赖于数据库锁，效率低，更新失败概率比较低</li>\n</ul>\n"},{"_content":"\n- 短连接：和MySQL交互时，建立连接，用完就关闭\n- 长连接：和MySQL建立的连接在用完后不关闭，放入一个池子中，等待复用\n## 连接池常用的参数\n\n- **最大空闲连接**：表示连接池中最多能容纳多少个空闲的长连接。某个连接处理完事务后，如果连接池未满，那么该连接会被放入连接池中，否则关闭\n- **最大空闲时间**：表示一个长连接在连接池中最多存活的时间，超过这个时间，连接将会被关闭\n- **最小连接数**：连接池中兜底的连接数量，当连接池中的空闲连接少于此值时，会自动补充连接至池中。\n\t- 最小连接数必须小于等于最大空闲连接\n\n在GORM中，如果连接请求的数量大于设置的最大空闲连接数量，那么就会创建大量的短链接与MySQL进行交互。在高并发环境下会产生很多短连接，相应的需要主动断开很多短连接。断开短链接的过程中由于四次挥手**TIME_WAIT**阶段需要等待一定时间，导致端口无法及时释放，就会出现`can't assign requested address`错误\n\n**连接池的核心就是连接复用**","source":"_posts/MySQL/MySQL连接池优化.md","raw":"\n- 短连接：和MySQL交互时，建立连接，用完就关闭\n- 长连接：和MySQL建立的连接在用完后不关闭，放入一个池子中，等待复用\n## 连接池常用的参数\n\n- **最大空闲连接**：表示连接池中最多能容纳多少个空闲的长连接。某个连接处理完事务后，如果连接池未满，那么该连接会被放入连接池中，否则关闭\n- **最大空闲时间**：表示一个长连接在连接池中最多存活的时间，超过这个时间，连接将会被关闭\n- **最小连接数**：连接池中兜底的连接数量，当连接池中的空闲连接少于此值时，会自动补充连接至池中。\n\t- 最小连接数必须小于等于最大空闲连接\n\n在GORM中，如果连接请求的数量大于设置的最大空闲连接数量，那么就会创建大量的短链接与MySQL进行交互。在高并发环境下会产生很多短连接，相应的需要主动断开很多短连接。断开短链接的过程中由于四次挥手**TIME_WAIT**阶段需要等待一定时间，导致端口无法及时释放，就会出现`can't assign requested address`错误\n\n**连接池的核心就是连接复用**","slug":"MySQL/MySQL连接池优化","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ka5t2f9aldmef","content":"<ul>\n<li>短连接：和MySQL交互时，建立连接，用完就关闭</li>\n<li>长连接：和MySQL建立的连接在用完后不关闭，放入一个池子中，等待复用</li>\n</ul>\n<h2 id=\"连接池常用的参数\"><a href=\"#连接池常用的参数\" class=\"headerlink\" title=\"连接池常用的参数\"></a>连接池常用的参数</h2><ul>\n<li><strong>最大空闲连接</strong>：表示连接池中最多能容纳多少个空闲的长连接。某个连接处理完事务后，如果连接池未满，那么该连接会被放入连接池中，否则关闭</li>\n<li><strong>最大空闲时间</strong>：表示一个长连接在连接池中最多存活的时间，超过这个时间，连接将会被关闭</li>\n<li><strong>最小连接数</strong>：连接池中兜底的连接数量，当连接池中的空闲连接少于此值时，会自动补充连接至池中。<ul>\n<li>最小连接数必须小于等于最大空闲连接</li>\n</ul>\n</li>\n</ul>\n<p>在GORM中，如果连接请求的数量大于设置的最大空闲连接数量，那么就会创建大量的短链接与MySQL进行交互。在高并发环境下会产生很多短连接，相应的需要主动断开很多短连接。断开短链接的过程中由于四次挥手<strong>TIME_WAIT</strong>阶段需要等待一定时间，导致端口无法及时释放，就会出现<code>can&#39;t assign requested address</code>错误</p>\n<p><strong>连接池的核心就是连接复用</strong></p>\n","excerpt":"","more":"<ul>\n<li>短连接：和MySQL交互时，建立连接，用完就关闭</li>\n<li>长连接：和MySQL建立的连接在用完后不关闭，放入一个池子中，等待复用</li>\n</ul>\n<h2 id=\"连接池常用的参数\"><a href=\"#连接池常用的参数\" class=\"headerlink\" title=\"连接池常用的参数\"></a>连接池常用的参数</h2><ul>\n<li><strong>最大空闲连接</strong>：表示连接池中最多能容纳多少个空闲的长连接。某个连接处理完事务后，如果连接池未满，那么该连接会被放入连接池中，否则关闭</li>\n<li><strong>最大空闲时间</strong>：表示一个长连接在连接池中最多存活的时间，超过这个时间，连接将会被关闭</li>\n<li><strong>最小连接数</strong>：连接池中兜底的连接数量，当连接池中的空闲连接少于此值时，会自动补充连接至池中。<ul>\n<li>最小连接数必须小于等于最大空闲连接</li>\n</ul>\n</li>\n</ul>\n<p>在GORM中，如果连接请求的数量大于设置的最大空闲连接数量，那么就会创建大量的短链接与MySQL进行交互。在高并发环境下会产生很多短连接，相应的需要主动断开很多短连接。断开短链接的过程中由于四次挥手<strong>TIME_WAIT</strong>阶段需要等待一定时间，导致端口无法及时释放，就会出现<code>can&#39;t assign requested address</code>错误</p>\n<p><strong>连接池的核心就是连接复用</strong></p>\n"},{"title":"Redis持久化","publish":true,"description":"记录Redis持久化知识点","_content":"\n\n\n# Redis持久化\n\n> 持久化是什么？\n\nRedis中的数据是存储在内存上的，倘若发生系统奔溃或程序重启，Redis中的数据就会丢失。如果业务场景希望即使出现异常情况，Redis中的数据也不会丢失，就需要将Redis中的数据**持久化**保存到存储设备上。\n\n## Redis持久化方式\n\nRedis提供了两种持久化方式：\n\n1. RDB（Redis Database Backup）是一种保存数据快照的持久化策略。当开启RDB策略后，Redis每个一段时间就会将全局数据以**二进制**数据的形式保存在磁盘，后续通过加载RDB文件恢复数据。\n\n   <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251409010.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n\n2. AOF（Append Only File）以记录日志确保数据持久化。当开启AOF策略后，Redis会将每一条**数据更新操作**记录到日志，后续通过重放日志恢复数据\n\n   <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251412091.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n\n从两种策略的定义中很容易能看出来两种方案有一下不同点：\n\n- 体积：在同等数据量的情况下，RDB比AOF体积更小，因为RDB保存的是**二进制紧凑数据**\n- 恢复速度：RDB是快照数据，直接加载即可恢复数据，而AOF文件恢复需要重放日志，开销更大\n- 数据完整性：RDB是间隔一段时间就记录一次，相比之下，AOF文件记录每一条操作，保存的数据更加完整\n\n### RDB还是AOF？\n\n> 在Redis中，RDB是默认开启的，而AOF是默认关闭的。\n\n使用RDB还是AOF持久化策略需要依据具体场景判断：\n\n如果对数据完整性要求较高，则需要将**RDB、AOF**同时开启。此时，进行数据恢复只会采用AOF文件，因为既然开启了AOF策略那么就说明需要数据完整性更强的AOF文件，而不是可能缺少一些数据的RDB文件\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251432209.png\" alt=\"image-20241025143254030\" style=\"zoom:80%;\" />\n\n如果能够忍受几分钟的数据丢失，就可以**只开启RDB策略**。但不建议单独开启AOF策略，具体原因可参考官方的解释：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251435012.png\" alt=\"image-20241025143518646\" style=\"zoom:80%;\" />\n\n## RDB详解\n\nRDB属于数据快照持久化策略，是一种最常见、最稳定的数据持久化方案。那么如何在Redis中开启RDB持久化策略？\n\n由于Redis默认支持RDB持久化，因此我们可以在配置文件中看到如下内容\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251940149.png\" alt=\"image-20241025194036067\" style=\"zoom:80%;\" />\n\n其中`save interval changes`就代表着当一定时间间隔进行了多少次数据修改就触发RDB持久化，将数据保存到磁盘上\n\n当然，除了上述被动触发RDB持久化，Redis还提供了两条命令来支持主动持久化功能\n\n- save：Redis主线程将全局数据生成二进制文件。如果内存中的数据量庞大，那么该命令可能会导致主线程阻塞，降低系统的执行效率\n- bgsave：Redis主线程fork一个子进程，子进程执行持久化数据的操作生成一个新的rdb文件并将旧的rdb文件替换，避免了主线程阻塞\n  - 上述被动触发RDB持久化本质上就是调用了`bgsave`命令\n\n除此之外，Redis在程序关闭时会自动触发`save`命令，阻塞主线程进行数据持久化，以记录更加完全的数据。\n\n### 写时复制\n\n调用`bgsave`命令后，执行RDB持久化过程中，Redis依然可以继续处理其他命令，这都得益于**写时复制**技术\n\nRedis主线程fork子进程时，为了节省内存空间，子进程仅仅复制父进程的页表，两个进程的页表指向同一块物理内存。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022075.png\" alt=\"image-20241025202223000\" style=\"zoom:80%;\" />\n\n接着，子进程依据物理内存上的数据生成新的rdb文件。因为RDB是快照持久化策略，子进程只会保存调用`bgsave`命令那一刻的数据，所以即使生成rdb文件的过程中主进程发生了写操作，也不能影响子进程的数据。为了满足这一要求，**主进程会复制一份对应的物理内存，然后在上面进行写操作，从而不影响子进程的数据**，这就是写时复制机制。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022156.png\" alt=\"image-20241025202241119\" style=\"zoom:80%;\" />\n\n## AOF详解\n\nAOF持久化策略在Redis中是默认关闭的，需要手动开启，开启之后，Redis会将每一条更新操作记录在AOF文件。当重启时，Redis就可以通过AOF文件将所有的请求重放，恢复数据，但速度很慢。\n\n### AOF写入流程\n\nAOF文件写入流程大致分为三步：\n\n1. 将数据写入AOF缓存，实质是一个sds数据\n2. 将AOF缓存刷入磁盘缓冲区（page cache）中\n3. 刷盘\n\n![image-20241028212538059](https://raw.githubusercontent.com/lyydsheep/pic/main/202410282126394.png)\n\n### AOF重写\n\n随着用户的请求逐渐积累，AOF文件会逐渐膨胀，但是AOF文件中有效记录是少量的。这是因为，对一个key修改成千上万次，只有最后一次修改是有效的，需要真正保存在AOF文件中，而之前的修改都是无效的。所以，完全可以将AOF文件中的无效记录删除，避免AOF文件过于庞大。\n\nAOF重写过程可以概括为**一次拷贝，两处缓冲**\n\n- 一次拷贝：重写发生时，主进程会fork出一个子进程，子进程和主进程共享Redis物理内存，让**子进程将这些内存写入重写日志**\n- 两处缓冲：在重写过程中，如果有新的写入请求，会由主进程分别写入AOF缓冲和AOF重写缓冲。AOF缓冲用于保证即使此时发生宕机，原来的AOF日志也是完整的，可用于恢复。AOF重写缓冲用于保证新的AOF文件不会丢失最新的写入操作\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282135209.png\" alt=\"image-20241028213530151\" style=\"zoom:80%;\" />\n\n### AOF混合持久化\n\nAOF混合持久化是指，在AOF重写阶段，Redis将现阶段的数据状态保存为RDB状态的二进制数据，并写入AOF文件，然后再将AOF重写缓冲区中的日志数据写入到AOF文件，最后把新生成的AOF文件替换掉旧的AOF文件。\n\n此时的AOF文件既包含二进制数据，又包含日志数据，所以叫做混合持久化。\n\nAOF混合持久化通过降低AOF文件的可读性，用二进制数据记录数据状态，减少了AOF文件的体积大小。","source":"_posts/Redis/Redis持久化.md","raw":"---\ntitle: Redis持久化\npublish: true\ndescription: 记录Redis持久化知识点\n---\n\n\n\n# Redis持久化\n\n> 持久化是什么？\n\nRedis中的数据是存储在内存上的，倘若发生系统奔溃或程序重启，Redis中的数据就会丢失。如果业务场景希望即使出现异常情况，Redis中的数据也不会丢失，就需要将Redis中的数据**持久化**保存到存储设备上。\n\n## Redis持久化方式\n\nRedis提供了两种持久化方式：\n\n1. RDB（Redis Database Backup）是一种保存数据快照的持久化策略。当开启RDB策略后，Redis每个一段时间就会将全局数据以**二进制**数据的形式保存在磁盘，后续通过加载RDB文件恢复数据。\n\n   <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251409010.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n\n2. AOF（Append Only File）以记录日志确保数据持久化。当开启AOF策略后，Redis会将每一条**数据更新操作**记录到日志，后续通过重放日志恢复数据\n\n   <img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251412091.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n\n从两种策略的定义中很容易能看出来两种方案有一下不同点：\n\n- 体积：在同等数据量的情况下，RDB比AOF体积更小，因为RDB保存的是**二进制紧凑数据**\n- 恢复速度：RDB是快照数据，直接加载即可恢复数据，而AOF文件恢复需要重放日志，开销更大\n- 数据完整性：RDB是间隔一段时间就记录一次，相比之下，AOF文件记录每一条操作，保存的数据更加完整\n\n### RDB还是AOF？\n\n> 在Redis中，RDB是默认开启的，而AOF是默认关闭的。\n\n使用RDB还是AOF持久化策略需要依据具体场景判断：\n\n如果对数据完整性要求较高，则需要将**RDB、AOF**同时开启。此时，进行数据恢复只会采用AOF文件，因为既然开启了AOF策略那么就说明需要数据完整性更强的AOF文件，而不是可能缺少一些数据的RDB文件\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251432209.png\" alt=\"image-20241025143254030\" style=\"zoom:80%;\" />\n\n如果能够忍受几分钟的数据丢失，就可以**只开启RDB策略**。但不建议单独开启AOF策略，具体原因可参考官方的解释：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251435012.png\" alt=\"image-20241025143518646\" style=\"zoom:80%;\" />\n\n## RDB详解\n\nRDB属于数据快照持久化策略，是一种最常见、最稳定的数据持久化方案。那么如何在Redis中开启RDB持久化策略？\n\n由于Redis默认支持RDB持久化，因此我们可以在配置文件中看到如下内容\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251940149.png\" alt=\"image-20241025194036067\" style=\"zoom:80%;\" />\n\n其中`save interval changes`就代表着当一定时间间隔进行了多少次数据修改就触发RDB持久化，将数据保存到磁盘上\n\n当然，除了上述被动触发RDB持久化，Redis还提供了两条命令来支持主动持久化功能\n\n- save：Redis主线程将全局数据生成二进制文件。如果内存中的数据量庞大，那么该命令可能会导致主线程阻塞，降低系统的执行效率\n- bgsave：Redis主线程fork一个子进程，子进程执行持久化数据的操作生成一个新的rdb文件并将旧的rdb文件替换，避免了主线程阻塞\n  - 上述被动触发RDB持久化本质上就是调用了`bgsave`命令\n\n除此之外，Redis在程序关闭时会自动触发`save`命令，阻塞主线程进行数据持久化，以记录更加完全的数据。\n\n### 写时复制\n\n调用`bgsave`命令后，执行RDB持久化过程中，Redis依然可以继续处理其他命令，这都得益于**写时复制**技术\n\nRedis主线程fork子进程时，为了节省内存空间，子进程仅仅复制父进程的页表，两个进程的页表指向同一块物理内存。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022075.png\" alt=\"image-20241025202223000\" style=\"zoom:80%;\" />\n\n接着，子进程依据物理内存上的数据生成新的rdb文件。因为RDB是快照持久化策略，子进程只会保存调用`bgsave`命令那一刻的数据，所以即使生成rdb文件的过程中主进程发生了写操作，也不能影响子进程的数据。为了满足这一要求，**主进程会复制一份对应的物理内存，然后在上面进行写操作，从而不影响子进程的数据**，这就是写时复制机制。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022156.png\" alt=\"image-20241025202241119\" style=\"zoom:80%;\" />\n\n## AOF详解\n\nAOF持久化策略在Redis中是默认关闭的，需要手动开启，开启之后，Redis会将每一条更新操作记录在AOF文件。当重启时，Redis就可以通过AOF文件将所有的请求重放，恢复数据，但速度很慢。\n\n### AOF写入流程\n\nAOF文件写入流程大致分为三步：\n\n1. 将数据写入AOF缓存，实质是一个sds数据\n2. 将AOF缓存刷入磁盘缓冲区（page cache）中\n3. 刷盘\n\n![image-20241028212538059](https://raw.githubusercontent.com/lyydsheep/pic/main/202410282126394.png)\n\n### AOF重写\n\n随着用户的请求逐渐积累，AOF文件会逐渐膨胀，但是AOF文件中有效记录是少量的。这是因为，对一个key修改成千上万次，只有最后一次修改是有效的，需要真正保存在AOF文件中，而之前的修改都是无效的。所以，完全可以将AOF文件中的无效记录删除，避免AOF文件过于庞大。\n\nAOF重写过程可以概括为**一次拷贝，两处缓冲**\n\n- 一次拷贝：重写发生时，主进程会fork出一个子进程，子进程和主进程共享Redis物理内存，让**子进程将这些内存写入重写日志**\n- 两处缓冲：在重写过程中，如果有新的写入请求，会由主进程分别写入AOF缓冲和AOF重写缓冲。AOF缓冲用于保证即使此时发生宕机，原来的AOF日志也是完整的，可用于恢复。AOF重写缓冲用于保证新的AOF文件不会丢失最新的写入操作\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282135209.png\" alt=\"image-20241028213530151\" style=\"zoom:80%;\" />\n\n### AOF混合持久化\n\nAOF混合持久化是指，在AOF重写阶段，Redis将现阶段的数据状态保存为RDB状态的二进制数据，并写入AOF文件，然后再将AOF重写缓冲区中的日志数据写入到AOF文件，最后把新生成的AOF文件替换掉旧的AOF文件。\n\n此时的AOF文件既包含二进制数据，又包含日志数据，所以叫做混合持久化。\n\nAOF混合持久化通过降低AOF文件的可读性，用二进制数据记录数据状态，减少了AOF文件的体积大小。","slug":"Redis/Redis持久化","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002ma5t2fvuvgq7a","content":"<h1 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h1><blockquote>\n<p>持久化是什么？</p>\n</blockquote>\n<p>Redis中的数据是存储在内存上的，倘若发生系统奔溃或程序重启，Redis中的数据就会丢失。如果业务场景希望即使出现异常情况，Redis中的数据也不会丢失，就需要将Redis中的数据<strong>持久化</strong>保存到存储设备上。</p>\n<h2 id=\"Redis持久化方式\"><a href=\"#Redis持久化方式\" class=\"headerlink\" title=\"Redis持久化方式\"></a>Redis持久化方式</h2><p>Redis提供了两种持久化方式：</p>\n<ol>\n<li><p>RDB（Redis Database Backup）是一种保存数据快照的持久化策略。当开启RDB策略后，Redis每个一段时间就会将全局数据以<strong>二进制</strong>数据的形式保存在磁盘，后续通过加载RDB文件恢复数据。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251409010.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n</li>\n<li><p>AOF（Append Only File）以记录日志确保数据持久化。当开启AOF策略后，Redis会将每一条<strong>数据更新操作</strong>记录到日志，后续通过重放日志恢复数据</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251412091.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" /></li>\n</ol>\n<p>从两种策略的定义中很容易能看出来两种方案有一下不同点：</p>\n<ul>\n<li>体积：在同等数据量的情况下，RDB比AOF体积更小，因为RDB保存的是<strong>二进制紧凑数据</strong></li>\n<li>恢复速度：RDB是快照数据，直接加载即可恢复数据，而AOF文件恢复需要重放日志，开销更大</li>\n<li>数据完整性：RDB是间隔一段时间就记录一次，相比之下，AOF文件记录每一条操作，保存的数据更加完整</li>\n</ul>\n<h3 id=\"RDB还是AOF？\"><a href=\"#RDB还是AOF？\" class=\"headerlink\" title=\"RDB还是AOF？\"></a>RDB还是AOF？</h3><blockquote>\n<p>在Redis中，RDB是默认开启的，而AOF是默认关闭的。</p>\n</blockquote>\n<p>使用RDB还是AOF持久化策略需要依据具体场景判断：</p>\n<p>如果对数据完整性要求较高，则需要将<strong>RDB、AOF</strong>同时开启。此时，进行数据恢复只会采用AOF文件，因为既然开启了AOF策略那么就说明需要数据完整性更强的AOF文件，而不是可能缺少一些数据的RDB文件</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251432209.png\" alt=\"image-20241025143254030\" style=\"zoom:80%;\" />\n\n<p>如果能够忍受几分钟的数据丢失，就可以<strong>只开启RDB策略</strong>。但不建议单独开启AOF策略，具体原因可参考官方的解释：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251435012.png\" alt=\"image-20241025143518646\" style=\"zoom:80%;\" />\n\n<h2 id=\"RDB详解\"><a href=\"#RDB详解\" class=\"headerlink\" title=\"RDB详解\"></a>RDB详解</h2><p>RDB属于数据快照持久化策略，是一种最常见、最稳定的数据持久化方案。那么如何在Redis中开启RDB持久化策略？</p>\n<p>由于Redis默认支持RDB持久化，因此我们可以在配置文件中看到如下内容</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251940149.png\" alt=\"image-20241025194036067\" style=\"zoom:80%;\" />\n\n<p>其中<code>save interval changes</code>就代表着当一定时间间隔进行了多少次数据修改就触发RDB持久化，将数据保存到磁盘上</p>\n<p>当然，除了上述被动触发RDB持久化，Redis还提供了两条命令来支持主动持久化功能</p>\n<ul>\n<li>save：Redis主线程将全局数据生成二进制文件。如果内存中的数据量庞大，那么该命令可能会导致主线程阻塞，降低系统的执行效率</li>\n<li>bgsave：Redis主线程fork一个子进程，子进程执行持久化数据的操作生成一个新的rdb文件并将旧的rdb文件替换，避免了主线程阻塞<ul>\n<li>上述被动触发RDB持久化本质上就是调用了<code>bgsave</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>除此之外，Redis在程序关闭时会自动触发<code>save</code>命令，阻塞主线程进行数据持久化，以记录更加完全的数据。</p>\n<h3 id=\"写时复制\"><a href=\"#写时复制\" class=\"headerlink\" title=\"写时复制\"></a>写时复制</h3><p>调用<code>bgsave</code>命令后，执行RDB持久化过程中，Redis依然可以继续处理其他命令，这都得益于<strong>写时复制</strong>技术</p>\n<p>Redis主线程fork子进程时，为了节省内存空间，子进程仅仅复制父进程的页表，两个进程的页表指向同一块物理内存。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022075.png\" alt=\"image-20241025202223000\" style=\"zoom:80%;\" />\n\n<p>接着，子进程依据物理内存上的数据生成新的rdb文件。因为RDB是快照持久化策略，子进程只会保存调用<code>bgsave</code>命令那一刻的数据，所以即使生成rdb文件的过程中主进程发生了写操作，也不能影响子进程的数据。为了满足这一要求，<strong>主进程会复制一份对应的物理内存，然后在上面进行写操作，从而不影响子进程的数据</strong>，这就是写时复制机制。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022156.png\" alt=\"image-20241025202241119\" style=\"zoom:80%;\" />\n\n<h2 id=\"AOF详解\"><a href=\"#AOF详解\" class=\"headerlink\" title=\"AOF详解\"></a>AOF详解</h2><p>AOF持久化策略在Redis中是默认关闭的，需要手动开启，开启之后，Redis会将每一条更新操作记录在AOF文件。当重启时，Redis就可以通过AOF文件将所有的请求重放，恢复数据，但速度很慢。</p>\n<h3 id=\"AOF写入流程\"><a href=\"#AOF写入流程\" class=\"headerlink\" title=\"AOF写入流程\"></a>AOF写入流程</h3><p>AOF文件写入流程大致分为三步：</p>\n<ol>\n<li>将数据写入AOF缓存，实质是一个sds数据</li>\n<li>将AOF缓存刷入磁盘缓冲区（page cache）中</li>\n<li>刷盘</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282126394.png\" alt=\"image-20241028212538059\"></p>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>随着用户的请求逐渐积累，AOF文件会逐渐膨胀，但是AOF文件中有效记录是少量的。这是因为，对一个key修改成千上万次，只有最后一次修改是有效的，需要真正保存在AOF文件中，而之前的修改都是无效的。所以，完全可以将AOF文件中的无效记录删除，避免AOF文件过于庞大。</p>\n<p>AOF重写过程可以概括为<strong>一次拷贝，两处缓冲</strong></p>\n<ul>\n<li>一次拷贝：重写发生时，主进程会fork出一个子进程，子进程和主进程共享Redis物理内存，让<strong>子进程将这些内存写入重写日志</strong></li>\n<li>两处缓冲：在重写过程中，如果有新的写入请求，会由主进程分别写入AOF缓冲和AOF重写缓冲。AOF缓冲用于保证即使此时发生宕机，原来的AOF日志也是完整的，可用于恢复。AOF重写缓冲用于保证新的AOF文件不会丢失最新的写入操作</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282135209.png\" alt=\"image-20241028213530151\" style=\"zoom:80%;\" />\n\n<h3 id=\"AOF混合持久化\"><a href=\"#AOF混合持久化\" class=\"headerlink\" title=\"AOF混合持久化\"></a>AOF混合持久化</h3><p>AOF混合持久化是指，在AOF重写阶段，Redis将现阶段的数据状态保存为RDB状态的二进制数据，并写入AOF文件，然后再将AOF重写缓冲区中的日志数据写入到AOF文件，最后把新生成的AOF文件替换掉旧的AOF文件。</p>\n<p>此时的AOF文件既包含二进制数据，又包含日志数据，所以叫做混合持久化。</p>\n<p>AOF混合持久化通过降低AOF文件的可读性，用二进制数据记录数据状态，减少了AOF文件的体积大小。</p>\n","excerpt":"","more":"<h1 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h1><blockquote>\n<p>持久化是什么？</p>\n</blockquote>\n<p>Redis中的数据是存储在内存上的，倘若发生系统奔溃或程序重启，Redis中的数据就会丢失。如果业务场景希望即使出现异常情况，Redis中的数据也不会丢失，就需要将Redis中的数据<strong>持久化</strong>保存到存储设备上。</p>\n<h2 id=\"Redis持久化方式\"><a href=\"#Redis持久化方式\" class=\"headerlink\" title=\"Redis持久化方式\"></a>Redis持久化方式</h2><p>Redis提供了两种持久化方式：</p>\n<ol>\n<li><p>RDB（Redis Database Backup）是一种保存数据快照的持久化策略。当开启RDB策略后，Redis每个一段时间就会将全局数据以<strong>二进制</strong>数据的形式保存在磁盘，后续通过加载RDB文件恢复数据。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251409010.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" />\n</li>\n<li><p>AOF（Append Only File）以记录日志确保数据持久化。当开启AOF策略后，Redis会将每一条<strong>数据更新操作</strong>记录到日志，后续通过重放日志恢复数据</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251412091.png\" alt=\"image-20241025140840529\" style=\"zoom:80%;\" /></li>\n</ol>\n<p>从两种策略的定义中很容易能看出来两种方案有一下不同点：</p>\n<ul>\n<li>体积：在同等数据量的情况下，RDB比AOF体积更小，因为RDB保存的是<strong>二进制紧凑数据</strong></li>\n<li>恢复速度：RDB是快照数据，直接加载即可恢复数据，而AOF文件恢复需要重放日志，开销更大</li>\n<li>数据完整性：RDB是间隔一段时间就记录一次，相比之下，AOF文件记录每一条操作，保存的数据更加完整</li>\n</ul>\n<h3 id=\"RDB还是AOF？\"><a href=\"#RDB还是AOF？\" class=\"headerlink\" title=\"RDB还是AOF？\"></a>RDB还是AOF？</h3><blockquote>\n<p>在Redis中，RDB是默认开启的，而AOF是默认关闭的。</p>\n</blockquote>\n<p>使用RDB还是AOF持久化策略需要依据具体场景判断：</p>\n<p>如果对数据完整性要求较高，则需要将<strong>RDB、AOF</strong>同时开启。此时，进行数据恢复只会采用AOF文件，因为既然开启了AOF策略那么就说明需要数据完整性更强的AOF文件，而不是可能缺少一些数据的RDB文件</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251432209.png\" alt=\"image-20241025143254030\" style=\"zoom:80%;\" />\n\n<p>如果能够忍受几分钟的数据丢失，就可以<strong>只开启RDB策略</strong>。但不建议单独开启AOF策略，具体原因可参考官方的解释：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251435012.png\" alt=\"image-20241025143518646\" style=\"zoom:80%;\" />\n\n<h2 id=\"RDB详解\"><a href=\"#RDB详解\" class=\"headerlink\" title=\"RDB详解\"></a>RDB详解</h2><p>RDB属于数据快照持久化策略，是一种最常见、最稳定的数据持久化方案。那么如何在Redis中开启RDB持久化策略？</p>\n<p>由于Redis默认支持RDB持久化，因此我们可以在配置文件中看到如下内容</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410251940149.png\" alt=\"image-20241025194036067\" style=\"zoom:80%;\" />\n\n<p>其中<code>save interval changes</code>就代表着当一定时间间隔进行了多少次数据修改就触发RDB持久化，将数据保存到磁盘上</p>\n<p>当然，除了上述被动触发RDB持久化，Redis还提供了两条命令来支持主动持久化功能</p>\n<ul>\n<li>save：Redis主线程将全局数据生成二进制文件。如果内存中的数据量庞大，那么该命令可能会导致主线程阻塞，降低系统的执行效率</li>\n<li>bgsave：Redis主线程fork一个子进程，子进程执行持久化数据的操作生成一个新的rdb文件并将旧的rdb文件替换，避免了主线程阻塞<ul>\n<li>上述被动触发RDB持久化本质上就是调用了<code>bgsave</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>除此之外，Redis在程序关闭时会自动触发<code>save</code>命令，阻塞主线程进行数据持久化，以记录更加完全的数据。</p>\n<h3 id=\"写时复制\"><a href=\"#写时复制\" class=\"headerlink\" title=\"写时复制\"></a>写时复制</h3><p>调用<code>bgsave</code>命令后，执行RDB持久化过程中，Redis依然可以继续处理其他命令，这都得益于<strong>写时复制</strong>技术</p>\n<p>Redis主线程fork子进程时，为了节省内存空间，子进程仅仅复制父进程的页表，两个进程的页表指向同一块物理内存。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022075.png\" alt=\"image-20241025202223000\" style=\"zoom:80%;\" />\n\n<p>接着，子进程依据物理内存上的数据生成新的rdb文件。因为RDB是快照持久化策略，子进程只会保存调用<code>bgsave</code>命令那一刻的数据，所以即使生成rdb文件的过程中主进程发生了写操作，也不能影响子进程的数据。为了满足这一要求，<strong>主进程会复制一份对应的物理内存，然后在上面进行写操作，从而不影响子进程的数据</strong>，这就是写时复制机制。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410252022156.png\" alt=\"image-20241025202241119\" style=\"zoom:80%;\" />\n\n<h2 id=\"AOF详解\"><a href=\"#AOF详解\" class=\"headerlink\" title=\"AOF详解\"></a>AOF详解</h2><p>AOF持久化策略在Redis中是默认关闭的，需要手动开启，开启之后，Redis会将每一条更新操作记录在AOF文件。当重启时，Redis就可以通过AOF文件将所有的请求重放，恢复数据，但速度很慢。</p>\n<h3 id=\"AOF写入流程\"><a href=\"#AOF写入流程\" class=\"headerlink\" title=\"AOF写入流程\"></a>AOF写入流程</h3><p>AOF文件写入流程大致分为三步：</p>\n<ol>\n<li>将数据写入AOF缓存，实质是一个sds数据</li>\n<li>将AOF缓存刷入磁盘缓冲区（page cache）中</li>\n<li>刷盘</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282126394.png\" alt=\"image-20241028212538059\"></p>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>随着用户的请求逐渐积累，AOF文件会逐渐膨胀，但是AOF文件中有效记录是少量的。这是因为，对一个key修改成千上万次，只有最后一次修改是有效的，需要真正保存在AOF文件中，而之前的修改都是无效的。所以，完全可以将AOF文件中的无效记录删除，避免AOF文件过于庞大。</p>\n<p>AOF重写过程可以概括为<strong>一次拷贝，两处缓冲</strong></p>\n<ul>\n<li>一次拷贝：重写发生时，主进程会fork出一个子进程，子进程和主进程共享Redis物理内存，让<strong>子进程将这些内存写入重写日志</strong></li>\n<li>两处缓冲：在重写过程中，如果有新的写入请求，会由主进程分别写入AOF缓冲和AOF重写缓冲。AOF缓冲用于保证即使此时发生宕机，原来的AOF日志也是完整的，可用于恢复。AOF重写缓冲用于保证新的AOF文件不会丢失最新的写入操作</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410282135209.png\" alt=\"image-20241028213530151\" style=\"zoom:80%;\" />\n\n<h3 id=\"AOF混合持久化\"><a href=\"#AOF混合持久化\" class=\"headerlink\" title=\"AOF混合持久化\"></a>AOF混合持久化</h3><p>AOF混合持久化是指，在AOF重写阶段，Redis将现阶段的数据状态保存为RDB状态的二进制数据，并写入AOF文件，然后再将AOF重写缓冲区中的日志数据写入到AOF文件，最后把新生成的AOF文件替换掉旧的AOF文件。</p>\n<p>此时的AOF文件既包含二进制数据，又包含日志数据，所以叫做混合持久化。</p>\n<p>AOF混合持久化通过降低AOF文件的可读性，用二进制数据记录数据状态，减少了AOF文件的体积大小。</p>\n"},{"title":"Redis场景应用","publish":true,"description":"记录Redis场景应用知识点","_content":"\n# Redis场景应用\n\n## 缓存基础\n\n> Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySQL当缓存就是常见的用法。具体而言，就是将MySQL中的热点数据存储在Redis中，通常业务都满足二八原则，即80%的流量集中在20%的数据上，所以缓存是可以有效提高系统的吞吐量。\n\n### 缓存的四种模式\n\n缓存一般有四种模式：\n\n- Cache-Aside Pattern：旁路缓存\n  - 可能出现数据不一致问题\n- Read Through Pattern：读穿透缓存\n  - 对业务透明，代码简洁\n  - 缓存命中时性能较低，多一次服务间调用过程\n- Write Through Pattern：写穿透缓存\n- Write Behind Pattern：异步缓存写入模式\n  - 数据不安全，有丢失风险\n\n#### Cache-Aside Pattern\n\n旁路缓存就是指业务方将缓存当做是数据库的旁路，业务直接和缓存打交道。\n\n旁路缓存**读流程**：业务方先查看缓存中是否有目标数据，如果没有，则去数据库中查找指定数据。业务方在获取到数据的同时，将数据保存在缓存中，以备后续的查询。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301900893.png\" alt=\"image-20241030190038771\" style=\"zoom:80%;\" />\n\n旁路缓存**写流程**：业务方首先向数据库写入数据，在**写入成功之后将缓存中对于的数据删除**。这是为了避免由于更新缓存的时序差异导致的**数据不一致问题**。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301903846.png\" alt=\"image-20241030190309815\" style=\"zoom:80%;\" />\n\n#### Read Through\n\n读穿透缓存模式提供一个数据服务，业务方不再直接和缓存打交道，而是将查询请求发送给数据服务，让数据服务执行查询缓存、数据库的操作。一图蔽之：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301911313.png\" alt=\"image-20241030191116236\" style=\"zoom:80%;\" />\n\n#### Write Through\n\n写穿透缓存模式通常和读穿透模式一同使用。写穿透模式要求数据服务在接受到业务方的写请求时，**先将数据写入数据库，接着写入缓存**。\n\n![image-20241030191922522](https://raw.githubusercontent.com/lyydsheep/pic/main/202410301919593.png)\n\n由于写穿透模式要求写完数据库后马上写缓存，对缓存的及时性要求高，在高并发的环境下就可能会出现数据不一致问题。另一方面，还需要合理设置缓存中数据的过期时间，因为每一次写入操作都会增加缓存中的数据，不合理的数据过期时间可能会导致缓存中的数据急剧膨胀，占用大量内存资源。\n\n#### Write Behind\n\nWrite Behind和Write Through在执行写操作时都会对数据库和缓存操作。区别在于，**Write Behind先写缓存，再异步将数据写入数据库**。\n\nWrite Behind缓存策略采用异步写数据的方式，可以**选择在某个特定的时间点**，例如数据库负载较低时，进行写入操作，也可以**选择积累一定量的写命令**后一次性将数据写入数据库中。\n\n![image-20241030192626673](https://raw.githubusercontent.com/lyydsheep/pic/main/202410301926736.png)\n\n异步写入操作极大降低了写请求的延迟以及数据库的负载，但代价是数据安全性不够高。倘若当部分存储在内存中的数据未写入数据库时，存储服务发生了崩溃，那么数据就丢失了。\n\n## 分布式锁\n\n分布式锁就是应用在分布式场景下的锁，保证各台机器上的各个进程并发安全的操作某一资源。一个合理的分布式锁应具备如下特点：\n\n- **互斥性**：针对某一资源，同一时刻只能有一个竞争者持有锁，其他竞争者则阻塞\n- **抗死锁性（活性）**：当一个竞争者持有锁的期间，即使发生了异常导致程序退出，无法正常释放锁，也能有兜底策略将锁释放，避免发生死锁\n- **对称性**：对同一资源上锁和解锁必须是同一个竞争者\n- **可靠性**：具备一定的容灾能力\n\n### 实现\n\n从分布式锁的特点可以推测出，使用Redis实现分布式锁大致流程应该是：\n\n1. 对某一个资源尝试加锁\n2. 加锁并且标记`owner`\n3. 处理业务\n4. 检查锁的`owner`\n5. 删除锁\n\n> 为什么要标记`owner`？\n\n如果不标记锁的`owner`，可能会出现竞争者A将竞争者B的锁释放，🌰：假设A率先拿到分布式锁，接着进行业务流程。倘若此时A由于网络延迟或CPU占用率高等因素导致在**分布式锁的过期时，业务仍没有完成**。那么B以为分布式锁没有被其他竞争者占用，顺理成章地拿到了分布式锁，执行业务逻辑。不幸的是，在B执行业务过程中，A终于完成了业务，然后执行`delete`删除分布式锁的动作。但此时A删除的并非是自己，而是B的分布式锁。那么该分布式锁就失去了保证资源并发安全的意义。\n\n> 如何保证检查-删除的原子性？\n\n4、5步骤是典型的**check-do something**场景，需要保证原子性，否则会出现并发问题。\n\n要想实现Redis某些操作组合的原子性，**Lua脚本**是不二法门。Redis+Lua，可以说是专门为解决原子问题而生的。有了Lua的特性，Redis才真正在分布式锁、秒杀等场景有了用武之地，最终Redis实现分布式锁的流程如下：\n\n![image-20241027095707243](https://raw.githubusercontent.com/lyydsheep/pic/main/202410270957284.png)\n\n","source":"_posts/Redis/Redis场景应用.md","raw":"---\ntitle: Redis场景应用\npublish: true\ndescription: 记录Redis场景应用知识点\n---\n\n# Redis场景应用\n\n## 缓存基础\n\n> Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySQL当缓存就是常见的用法。具体而言，就是将MySQL中的热点数据存储在Redis中，通常业务都满足二八原则，即80%的流量集中在20%的数据上，所以缓存是可以有效提高系统的吞吐量。\n\n### 缓存的四种模式\n\n缓存一般有四种模式：\n\n- Cache-Aside Pattern：旁路缓存\n  - 可能出现数据不一致问题\n- Read Through Pattern：读穿透缓存\n  - 对业务透明，代码简洁\n  - 缓存命中时性能较低，多一次服务间调用过程\n- Write Through Pattern：写穿透缓存\n- Write Behind Pattern：异步缓存写入模式\n  - 数据不安全，有丢失风险\n\n#### Cache-Aside Pattern\n\n旁路缓存就是指业务方将缓存当做是数据库的旁路，业务直接和缓存打交道。\n\n旁路缓存**读流程**：业务方先查看缓存中是否有目标数据，如果没有，则去数据库中查找指定数据。业务方在获取到数据的同时，将数据保存在缓存中，以备后续的查询。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301900893.png\" alt=\"image-20241030190038771\" style=\"zoom:80%;\" />\n\n旁路缓存**写流程**：业务方首先向数据库写入数据，在**写入成功之后将缓存中对于的数据删除**。这是为了避免由于更新缓存的时序差异导致的**数据不一致问题**。\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301903846.png\" alt=\"image-20241030190309815\" style=\"zoom:80%;\" />\n\n#### Read Through\n\n读穿透缓存模式提供一个数据服务，业务方不再直接和缓存打交道，而是将查询请求发送给数据服务，让数据服务执行查询缓存、数据库的操作。一图蔽之：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301911313.png\" alt=\"image-20241030191116236\" style=\"zoom:80%;\" />\n\n#### Write Through\n\n写穿透缓存模式通常和读穿透模式一同使用。写穿透模式要求数据服务在接受到业务方的写请求时，**先将数据写入数据库，接着写入缓存**。\n\n![image-20241030191922522](https://raw.githubusercontent.com/lyydsheep/pic/main/202410301919593.png)\n\n由于写穿透模式要求写完数据库后马上写缓存，对缓存的及时性要求高，在高并发的环境下就可能会出现数据不一致问题。另一方面，还需要合理设置缓存中数据的过期时间，因为每一次写入操作都会增加缓存中的数据，不合理的数据过期时间可能会导致缓存中的数据急剧膨胀，占用大量内存资源。\n\n#### Write Behind\n\nWrite Behind和Write Through在执行写操作时都会对数据库和缓存操作。区别在于，**Write Behind先写缓存，再异步将数据写入数据库**。\n\nWrite Behind缓存策略采用异步写数据的方式，可以**选择在某个特定的时间点**，例如数据库负载较低时，进行写入操作，也可以**选择积累一定量的写命令**后一次性将数据写入数据库中。\n\n![image-20241030192626673](https://raw.githubusercontent.com/lyydsheep/pic/main/202410301926736.png)\n\n异步写入操作极大降低了写请求的延迟以及数据库的负载，但代价是数据安全性不够高。倘若当部分存储在内存中的数据未写入数据库时，存储服务发生了崩溃，那么数据就丢失了。\n\n## 分布式锁\n\n分布式锁就是应用在分布式场景下的锁，保证各台机器上的各个进程并发安全的操作某一资源。一个合理的分布式锁应具备如下特点：\n\n- **互斥性**：针对某一资源，同一时刻只能有一个竞争者持有锁，其他竞争者则阻塞\n- **抗死锁性（活性）**：当一个竞争者持有锁的期间，即使发生了异常导致程序退出，无法正常释放锁，也能有兜底策略将锁释放，避免发生死锁\n- **对称性**：对同一资源上锁和解锁必须是同一个竞争者\n- **可靠性**：具备一定的容灾能力\n\n### 实现\n\n从分布式锁的特点可以推测出，使用Redis实现分布式锁大致流程应该是：\n\n1. 对某一个资源尝试加锁\n2. 加锁并且标记`owner`\n3. 处理业务\n4. 检查锁的`owner`\n5. 删除锁\n\n> 为什么要标记`owner`？\n\n如果不标记锁的`owner`，可能会出现竞争者A将竞争者B的锁释放，🌰：假设A率先拿到分布式锁，接着进行业务流程。倘若此时A由于网络延迟或CPU占用率高等因素导致在**分布式锁的过期时，业务仍没有完成**。那么B以为分布式锁没有被其他竞争者占用，顺理成章地拿到了分布式锁，执行业务逻辑。不幸的是，在B执行业务过程中，A终于完成了业务，然后执行`delete`删除分布式锁的动作。但此时A删除的并非是自己，而是B的分布式锁。那么该分布式锁就失去了保证资源并发安全的意义。\n\n> 如何保证检查-删除的原子性？\n\n4、5步骤是典型的**check-do something**场景，需要保证原子性，否则会出现并发问题。\n\n要想实现Redis某些操作组合的原子性，**Lua脚本**是不二法门。Redis+Lua，可以说是专门为解决原子问题而生的。有了Lua的特性，Redis才真正在分布式锁、秒杀等场景有了用武之地，最终Redis实现分布式锁的流程如下：\n\n![image-20241027095707243](https://raw.githubusercontent.com/lyydsheep/pic/main/202410270957284.png)\n\n","slug":"Redis/Redis场景应用","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002oa5t2a4wx4k2s","content":"<h1 id=\"Redis场景应用\"><a href=\"#Redis场景应用\" class=\"headerlink\" title=\"Redis场景应用\"></a>Redis场景应用</h1><h2 id=\"缓存基础\"><a href=\"#缓存基础\" class=\"headerlink\" title=\"缓存基础\"></a>缓存基础</h2><blockquote>\n<p>Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySQL当缓存就是常见的用法。具体而言，就是将MySQL中的热点数据存储在Redis中，通常业务都满足二八原则，即80%的流量集中在20%的数据上，所以缓存是可以有效提高系统的吞吐量。</p>\n</blockquote>\n<h3 id=\"缓存的四种模式\"><a href=\"#缓存的四种模式\" class=\"headerlink\" title=\"缓存的四种模式\"></a>缓存的四种模式</h3><p>缓存一般有四种模式：</p>\n<ul>\n<li>Cache-Aside Pattern：旁路缓存<ul>\n<li>可能出现数据不一致问题</li>\n</ul>\n</li>\n<li>Read Through Pattern：读穿透缓存<ul>\n<li>对业务透明，代码简洁</li>\n<li>缓存命中时性能较低，多一次服务间调用过程</li>\n</ul>\n</li>\n<li>Write Through Pattern：写穿透缓存</li>\n<li>Write Behind Pattern：异步缓存写入模式<ul>\n<li>数据不安全，有丢失风险</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Cache-Aside-Pattern\"><a href=\"#Cache-Aside-Pattern\" class=\"headerlink\" title=\"Cache-Aside Pattern\"></a>Cache-Aside Pattern</h4><p>旁路缓存就是指业务方将缓存当做是数据库的旁路，业务直接和缓存打交道。</p>\n<p>旁路缓存<strong>读流程</strong>：业务方先查看缓存中是否有目标数据，如果没有，则去数据库中查找指定数据。业务方在获取到数据的同时，将数据保存在缓存中，以备后续的查询。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301900893.png\" alt=\"image-20241030190038771\" style=\"zoom:80%;\" />\n\n<p>旁路缓存<strong>写流程</strong>：业务方首先向数据库写入数据，在<strong>写入成功之后将缓存中对于的数据删除</strong>。这是为了避免由于更新缓存的时序差异导致的<strong>数据不一致问题</strong>。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301903846.png\" alt=\"image-20241030190309815\" style=\"zoom:80%;\" />\n\n<h4 id=\"Read-Through\"><a href=\"#Read-Through\" class=\"headerlink\" title=\"Read Through\"></a>Read Through</h4><p>读穿透缓存模式提供一个数据服务，业务方不再直接和缓存打交道，而是将查询请求发送给数据服务，让数据服务执行查询缓存、数据库的操作。一图蔽之：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301911313.png\" alt=\"image-20241030191116236\" style=\"zoom:80%;\" />\n\n<h4 id=\"Write-Through\"><a href=\"#Write-Through\" class=\"headerlink\" title=\"Write Through\"></a>Write Through</h4><p>写穿透缓存模式通常和读穿透模式一同使用。写穿透模式要求数据服务在接受到业务方的写请求时，<strong>先将数据写入数据库，接着写入缓存</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301919593.png\" alt=\"image-20241030191922522\"></p>\n<p>由于写穿透模式要求写完数据库后马上写缓存，对缓存的及时性要求高，在高并发的环境下就可能会出现数据不一致问题。另一方面，还需要合理设置缓存中数据的过期时间，因为每一次写入操作都会增加缓存中的数据，不合理的数据过期时间可能会导致缓存中的数据急剧膨胀，占用大量内存资源。</p>\n<h4 id=\"Write-Behind\"><a href=\"#Write-Behind\" class=\"headerlink\" title=\"Write Behind\"></a>Write Behind</h4><p>Write Behind和Write Through在执行写操作时都会对数据库和缓存操作。区别在于，<strong>Write Behind先写缓存，再异步将数据写入数据库</strong>。</p>\n<p>Write Behind缓存策略采用异步写数据的方式，可以<strong>选择在某个特定的时间点</strong>，例如数据库负载较低时，进行写入操作，也可以<strong>选择积累一定量的写命令</strong>后一次性将数据写入数据库中。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301926736.png\" alt=\"image-20241030192626673\"></p>\n<p>异步写入操作极大降低了写请求的延迟以及数据库的负载，但代价是数据安全性不够高。倘若当部分存储在内存中的数据未写入数据库时，存储服务发生了崩溃，那么数据就丢失了。</p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>分布式锁就是应用在分布式场景下的锁，保证各台机器上的各个进程并发安全的操作某一资源。一个合理的分布式锁应具备如下特点：</p>\n<ul>\n<li><strong>互斥性</strong>：针对某一资源，同一时刻只能有一个竞争者持有锁，其他竞争者则阻塞</li>\n<li><strong>抗死锁性（活性）</strong>：当一个竞争者持有锁的期间，即使发生了异常导致程序退出，无法正常释放锁，也能有兜底策略将锁释放，避免发生死锁</li>\n<li><strong>对称性</strong>：对同一资源上锁和解锁必须是同一个竞争者</li>\n<li><strong>可靠性</strong>：具备一定的容灾能力</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>从分布式锁的特点可以推测出，使用Redis实现分布式锁大致流程应该是：</p>\n<ol>\n<li>对某一个资源尝试加锁</li>\n<li>加锁并且标记<code>owner</code></li>\n<li>处理业务</li>\n<li>检查锁的<code>owner</code></li>\n<li>删除锁</li>\n</ol>\n<blockquote>\n<p>为什么要标记<code>owner</code>？</p>\n</blockquote>\n<p>如果不标记锁的<code>owner</code>，可能会出现竞争者A将竞争者B的锁释放，🌰：假设A率先拿到分布式锁，接着进行业务流程。倘若此时A由于网络延迟或CPU占用率高等因素导致在<strong>分布式锁的过期时，业务仍没有完成</strong>。那么B以为分布式锁没有被其他竞争者占用，顺理成章地拿到了分布式锁，执行业务逻辑。不幸的是，在B执行业务过程中，A终于完成了业务，然后执行<code>delete</code>删除分布式锁的动作。但此时A删除的并非是自己，而是B的分布式锁。那么该分布式锁就失去了保证资源并发安全的意义。</p>\n<blockquote>\n<p>如何保证检查-删除的原子性？</p>\n</blockquote>\n<p>4、5步骤是典型的<strong>check-do something</strong>场景，需要保证原子性，否则会出现并发问题。</p>\n<p>要想实现Redis某些操作组合的原子性，<strong>Lua脚本</strong>是不二法门。Redis+Lua，可以说是专门为解决原子问题而生的。有了Lua的特性，Redis才真正在分布式锁、秒杀等场景有了用武之地，最终Redis实现分布式锁的流程如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410270957284.png\" alt=\"image-20241027095707243\"></p>\n","excerpt":"","more":"<h1 id=\"Redis场景应用\"><a href=\"#Redis场景应用\" class=\"headerlink\" title=\"Redis场景应用\"></a>Redis场景应用</h1><h2 id=\"缓存基础\"><a href=\"#缓存基础\" class=\"headerlink\" title=\"缓存基础\"></a>缓存基础</h2><blockquote>\n<p>Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySQL当缓存就是常见的用法。具体而言，就是将MySQL中的热点数据存储在Redis中，通常业务都满足二八原则，即80%的流量集中在20%的数据上，所以缓存是可以有效提高系统的吞吐量。</p>\n</blockquote>\n<h3 id=\"缓存的四种模式\"><a href=\"#缓存的四种模式\" class=\"headerlink\" title=\"缓存的四种模式\"></a>缓存的四种模式</h3><p>缓存一般有四种模式：</p>\n<ul>\n<li>Cache-Aside Pattern：旁路缓存<ul>\n<li>可能出现数据不一致问题</li>\n</ul>\n</li>\n<li>Read Through Pattern：读穿透缓存<ul>\n<li>对业务透明，代码简洁</li>\n<li>缓存命中时性能较低，多一次服务间调用过程</li>\n</ul>\n</li>\n<li>Write Through Pattern：写穿透缓存</li>\n<li>Write Behind Pattern：异步缓存写入模式<ul>\n<li>数据不安全，有丢失风险</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Cache-Aside-Pattern\"><a href=\"#Cache-Aside-Pattern\" class=\"headerlink\" title=\"Cache-Aside Pattern\"></a>Cache-Aside Pattern</h4><p>旁路缓存就是指业务方将缓存当做是数据库的旁路，业务直接和缓存打交道。</p>\n<p>旁路缓存<strong>读流程</strong>：业务方先查看缓存中是否有目标数据，如果没有，则去数据库中查找指定数据。业务方在获取到数据的同时，将数据保存在缓存中，以备后续的查询。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301900893.png\" alt=\"image-20241030190038771\" style=\"zoom:80%;\" />\n\n<p>旁路缓存<strong>写流程</strong>：业务方首先向数据库写入数据，在<strong>写入成功之后将缓存中对于的数据删除</strong>。这是为了避免由于更新缓存的时序差异导致的<strong>数据不一致问题</strong>。</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301903846.png\" alt=\"image-20241030190309815\" style=\"zoom:80%;\" />\n\n<h4 id=\"Read-Through\"><a href=\"#Read-Through\" class=\"headerlink\" title=\"Read Through\"></a>Read Through</h4><p>读穿透缓存模式提供一个数据服务，业务方不再直接和缓存打交道，而是将查询请求发送给数据服务，让数据服务执行查询缓存、数据库的操作。一图蔽之：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301911313.png\" alt=\"image-20241030191116236\" style=\"zoom:80%;\" />\n\n<h4 id=\"Write-Through\"><a href=\"#Write-Through\" class=\"headerlink\" title=\"Write Through\"></a>Write Through</h4><p>写穿透缓存模式通常和读穿透模式一同使用。写穿透模式要求数据服务在接受到业务方的写请求时，<strong>先将数据写入数据库，接着写入缓存</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301919593.png\" alt=\"image-20241030191922522\"></p>\n<p>由于写穿透模式要求写完数据库后马上写缓存，对缓存的及时性要求高，在高并发的环境下就可能会出现数据不一致问题。另一方面，还需要合理设置缓存中数据的过期时间，因为每一次写入操作都会增加缓存中的数据，不合理的数据过期时间可能会导致缓存中的数据急剧膨胀，占用大量内存资源。</p>\n<h4 id=\"Write-Behind\"><a href=\"#Write-Behind\" class=\"headerlink\" title=\"Write Behind\"></a>Write Behind</h4><p>Write Behind和Write Through在执行写操作时都会对数据库和缓存操作。区别在于，<strong>Write Behind先写缓存，再异步将数据写入数据库</strong>。</p>\n<p>Write Behind缓存策略采用异步写数据的方式，可以<strong>选择在某个特定的时间点</strong>，例如数据库负载较低时，进行写入操作，也可以<strong>选择积累一定量的写命令</strong>后一次性将数据写入数据库中。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410301926736.png\" alt=\"image-20241030192626673\"></p>\n<p>异步写入操作极大降低了写请求的延迟以及数据库的负载，但代价是数据安全性不够高。倘若当部分存储在内存中的数据未写入数据库时，存储服务发生了崩溃，那么数据就丢失了。</p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>分布式锁就是应用在分布式场景下的锁，保证各台机器上的各个进程并发安全的操作某一资源。一个合理的分布式锁应具备如下特点：</p>\n<ul>\n<li><strong>互斥性</strong>：针对某一资源，同一时刻只能有一个竞争者持有锁，其他竞争者则阻塞</li>\n<li><strong>抗死锁性（活性）</strong>：当一个竞争者持有锁的期间，即使发生了异常导致程序退出，无法正常释放锁，也能有兜底策略将锁释放，避免发生死锁</li>\n<li><strong>对称性</strong>：对同一资源上锁和解锁必须是同一个竞争者</li>\n<li><strong>可靠性</strong>：具备一定的容灾能力</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>从分布式锁的特点可以推测出，使用Redis实现分布式锁大致流程应该是：</p>\n<ol>\n<li>对某一个资源尝试加锁</li>\n<li>加锁并且标记<code>owner</code></li>\n<li>处理业务</li>\n<li>检查锁的<code>owner</code></li>\n<li>删除锁</li>\n</ol>\n<blockquote>\n<p>为什么要标记<code>owner</code>？</p>\n</blockquote>\n<p>如果不标记锁的<code>owner</code>，可能会出现竞争者A将竞争者B的锁释放，🌰：假设A率先拿到分布式锁，接着进行业务流程。倘若此时A由于网络延迟或CPU占用率高等因素导致在<strong>分布式锁的过期时，业务仍没有完成</strong>。那么B以为分布式锁没有被其他竞争者占用，顺理成章地拿到了分布式锁，执行业务逻辑。不幸的是，在B执行业务过程中，A终于完成了业务，然后执行<code>delete</code>删除分布式锁的动作。但此时A删除的并非是自己，而是B的分布式锁。那么该分布式锁就失去了保证资源并发安全的意义。</p>\n<blockquote>\n<p>如何保证检查-删除的原子性？</p>\n</blockquote>\n<p>4、5步骤是典型的<strong>check-do something</strong>场景，需要保证原子性，否则会出现并发问题。</p>\n<p>要想实现Redis某些操作组合的原子性，<strong>Lua脚本</strong>是不二法门。Redis+Lua，可以说是专门为解决原子问题而生的。有了Lua的特性，Redis才真正在分布式锁、秒杀等场景有了用武之地，最终Redis实现分布式锁的流程如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410270957284.png\" alt=\"image-20241027095707243\"></p>\n"},{"title":"Redis对象","publish":true,"description":"记录Redis对象知识点","sticky":2,"_content":"\n# Redis对象\n\n## String\n\nString就是字符串，是Redis中的一个最基本数据对象，最大存储数据**512MB**\n\n### Set操作\n\n基本语法：**`set key value [expiration EX seconds | PX milliseconds] [NX|XX]`**\n\nSet操作用于在Redis中设置一个K-V对，其中几个扩展参数作用分别如下：\n\n- **EX seconds**：设置K-V对的过期时间为多少秒\n- **PX milliseconds**：设置K-V对的过期时间为多少毫秒\n- **NX**：只有当Key不存在时，命令才生效，相当于`setnx key value`\n- **XX**：只有当Key存在时，命令才生效\n\n⚠️：对一个已经存在Key进行set操作会**将原有值覆盖**，可能会导致**原有值丢失、擦除过期时间、丢失原有值类型**\n\n### 三种编码方式\n\nString对象底层采用三种不同的编码方式以高效应对各种场景\n\n- **INT编码**：用于存储long范围内的**整数**\n  - ⚠️：如果是浮点数，则不能使用INT编码。因为INT编码只能用于表示整数\n- **EMBSTR编码**：如果字符串的大小小于阈值字节，则采用此方式\n- **RAW编码**：如果字符串的大小大于阈值字节，则采用此方式\n\nEMBSTR编码和RAW编码方式在底层实现中都是由redisObject和SDS两个结构组成，区别在于**这两个结构在物理内存上是否连续（为一整体）**\n\nEMBSTR在内存中的表示：\n\n![image-20241003100407308](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004350.png)\n\nRAW在内存中的表示：\n\n![image-20241003100440097](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004128.png)\n\n#### 三种编码方式的转换关系\n\n随着对Redis的操作，String对象的编码方式可能有如下变化：\n\nINT --> RAW：当存储的内容不再是整数或大小超过long范围，则需要将INT编码转换为RAW编码\n\nEMBSTR --> RAW：由于EMBSTR编码的String对象是**只读**的，所以对一个EMBSTR进行写操作时，就会将其编码方式改为RAW。这是因为修改数据就要重新分配存储空间，而EMBSTR中redisObject和SDS是连续的，不易分配空间。并且只要进行修改操作那么就能认为这个String是易变的、不稳定的，采用RAW编码方式能够减少频繁对EMBSTR内存分配的性能损耗\n\n### SDS结构\n\n不管是EMBSTR还是RAW，都有一个SDS结构，SDS结构是为了解决C语言中字符串的尴尬处境\n\n- 计算字符串长度需要遍历，时间复杂度$$O(n)$$\n- 对字符串追加内容需要扩容操作\n- 二进制不安全\n  - 二进制安全是指公平对待每一个字符，不特殊处理任何字符\n  - C语言中字符串特殊处理`\\0`为字符串结尾\n\nSDS结构具体由一下字段组成：\n\n```C\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;\n    uint8_t alloc;\n    unsigned char flags;\n    char buf[];\n}\n```\n\n- **len**：表示字符串长度，**可以快速返回字符串长度，并且不需要`\\0`作为结尾符号**\n- **alloc**：表示分配了多少内存空间，**具有一定的预留空间，无需进行扩容操作**\n- **flags**：用于区分具体是什么类型的SDS\n  - 在Redis中SDS分为sdshdr8、sdshdr16、sdshdr32、sdshdr64\n\n## List\n\n3.2版本之前，List对象有两种编码方式\n\n- ZIPLIST\n- LINKLIST\n\n当满足以下条件时，采用ZIPLIST编码方式\n\n- 列表对象中所有存储的字符串对象长度都小于64字节\n- 列表对象中存储的对象数量不超过512个（这是LIST的限制，而不是ZIPLIST的限制）\n\n🌰：\n\n![image-20241005112548274](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051125337.png)\n\nZIPLIST中数据都是紧密排列的，在数据量小的时候可以有效节约内存；而LINKLIST顾名思义，数据是以链表形式串联起来的，在数据量大的时候采用LINKLIST编码可以加快处理性能\n\n🌰：\n\n![image-20241005112658713](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051126746.png)\n\n### QUICKLIST\n\nZIPLIST在数据较少时节约内存，LINKLIST是为了在数据较多时提高更新效率。但是ZIPLIST在数据稍多时插入数据会导致大量数据复制，占用内存空间；同样地，LINKLIST由于节点数量也异常多，也会占用不少内存\n\n基于上述问题，3.2版本就引入了QUICKLIST。QUICKLIST本质就是**ZIPLIST和LINKLIST的结合体**\n\nQUICKLIST的实现思路是，将原本LINKLIST的**单个节点存储单个数据**的模式，更换成一个**单个节点（ZIPLIST）存储多个数据**的形式\n\n![image-20241005113525108](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051135173.png)\n\n当数据较少时，QUICKLIST节点只有一个，退化成ZIPLIST\n\n当数据较多时，则同时利用了ZIPLIST和LINKLIST的优势\n\n## 压缩列表\n\n压缩列表作为List的底层数据结构，提供了紧凑型的数据存储方式，能节约内存，小数据量的时候遍历访问性能好（连续+局部性优势）\n\n### ZIPLIST整体结构\n\n在Redis代码注释中，有对ZIPLIST清晰地描述：\n\n```c\n/* The general layout of the ziplist is as follows:\n\n<zlbytes> <zltail> <zllen> <entry> <entry> <entry> ... <entry> <zlend>\n*/\n```\n\n🌰：一个具有三个节点的ZIPLIST\n\n![image-20241008161508590](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081615659.png)\n\n**zlbytes**字段表示该ZIPLIST一共占用了多少字节（包含zlbytes字段的大小）\n\n**zltail**字段表示最后一个**数据节点（entry）**距离ZIPLIST首部的偏移字节数，如果ZIPLIST为空（即木有entry），则指示**zlend**字段的偏移量\n\n> 很显然，会有如下等式：\n>\n> zlbytes = zltial + 最后一个entry大小（可能为零） + zlend大小\n\n**zllen**字段表示ZIPLIST结构中entry的个数，但由于该字段只占用2字节空间，所以最多只能表示65535个。当元素个数过多，只能通过**遍历**的方式获取元素个数\n\n**zlend**字段是一个特殊节点，标识ZIPLIST结构的结束\n\n**entry**字段表示一个数据节点，实际上也是一个结构体类型。该类型由三个字段构成，分别是\n\n```c\n<prevlen> <encoding> <entry-data>\n```\n\n### entry结构\n\n**`prevlen`**字段表示**上一个数据节点（entry）的长度**，如果长度**小于254**，那么**`prevlen`**字段占用1字节空间；如果长度**大于等于254**，那么该字段需要用5字节空间表示，并且**第一个字节为11111110**，表示这是一个5字节的`prevlen`信息，剩下的4字节用来表示长度\n\n⚠️：为什么阈值是254而不是255？这是因为255被用来特殊表示**zlend**字段，标识ZIPLIST结构的结束\n\n**`encoding`**字段是一个整形数据，其二进制编码由**内容类型**和**内容数据的字节长度**两部分组成\n\n### 连锁更新\n\n当向一个entry前面插入一个长度超过254的节点时，`prevlen`字段可能就会由1字节变成5字节，导致本entry长度增大。如果运气不是很好，将会导致下一个节点中的`prevlen`字段增加，以此类推，造成连锁反应，这就是连锁更新问题。\n\n![image-20241008185552935](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081855045.png)\n\n#### LISTPACK优化\n\n`prevlen`字段正是连锁更新的罪魁祸首，为了解决连锁更新问题，就不能再去记录上一个节点的长度，但又要保证能够实现倒序遍历（找到上一个节点的位置）\n\nRedis使用了一种巧妙的方法：删除`prevlen`字段，**新增`element-tot-len`字段记录整个节点除它（element-tot-len字段）自身之外的长度**\n\n此时节点结构就变成了：\n\n```c\n<encoding-type> <element-data> <element-top-len>\n```\n\n- encoding-type是编码类型\n- element-data是数据内容\n- element-top-len所占的每个字节的第一个bit位用于标识是否结束，0则结束，1则继续\n\n🌰：![image-20241008190334625](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081903663.png)\n\n## Set\n\nRedi中的set是一个不重复、无序的字符串集合\n\n> 如果Set底层使用INTSET编码方式，则集合是有序的\n\n### 编码方式 \n\nSet底层有两种编码方式：**INTSET、HASHTABLE**\n\n当Set中存储的都是整数并且元素个数少于512个时，则采用INTSET编码方式\n\n![image-20241009154144626](https://raw.githubusercontent.com/lyydsheep/pic/main/202410091541699.png)\n\n由上图可见，采用INTSET编码，元素排列比较紧凑，内存占用少，但查找时需要使用二分法，时间复杂度为$O(nlogn)$\n\n如果不满足INTSET编码条件，则需要使用HASHTABLE编码，HASHTABLE查询一个元素性能很高，时间复杂度为$O(1)$\n\n![image-20241009154437973](https://raw.githubusercontent.com/lyydsheep/pic/main/202410091544018.png)\n\n简单地概括：\n\n- INTSET编码适用于存储少量整数场景以节约内存空间\n- HASHTABLE编码适用于快速定位某个元素的位置\n\n## Hash\n\n// to do\n\npanic(\"implement me\")\n\n## HashTable\n\n>  HAHSTABLE是Redis中的一种底层数据结构\n\n通过HASHTABLE可以在$O(1)$时间复杂度内快速定位到Key对于的Value\n\n### 结构\n\n总所周知，Redis是用C语言实现的。HASHTABLE的C实现涉及到三个结构体：`dict`、`dictht`、`dicEntry`\n\n简单地说，`dict`封装了两个`dictht`结构，每一个`dictht`结构都有一个大小为`size`的**bucket**，bucket中存放着`dicEntry`链表。三个结构体之间的关系如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122043279.png\" alt=\"image-20241012204338184\" style=\"zoom:67%;\" />\n\n可以看到dict结构中有两个dictht结构，也就是HASHTABLE结构。dicEntry是链表结构，通过拉链法解决Hash冲突\n\n接下来，结合源码j解释每一个结构体的字段含义：\n\n```c\ntypedef struct dict{\n    dictType *type; //直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据\n    void *privdata; //私有数据，保存着dictType结构中函数的 参数\n    dictht ht[2]; //两张哈希表\n    long rehashidx; //rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一\n    int itreators;  //正在迭代的迭代器数量\n}\n```\n\n```c\n#dict结构中ht[0]、ht[1]哈希表的数据结构\ntypedef struct dictht{\n    dictEntry[] table;        //存放一个数组的地址，数组中存放哈希节点dictEntry的地址\n    unsingned long size;      //哈希表table的大小，出始大小为4\n    unsingned long  sizemask; //用于将hash值映射到table位置的索引，大小为（size-1）\n    unsingned long  used;     //记录哈希表已有节点（键值对）的数量\n}\n```\n\n```c\n#哈希表节点结构定义\ntypedef struct dictEntity{\n    void *key;//键\n    //值\n    union{\n        //“我之所以要提醒你注意这里，其实是为了说明，这种实现方法是一种节省内存的开发小技巧，非常值得学习。因为当值为整数或双精度浮点数时，由于其本身就是 64 位，就可以不用指针指向了，而是可以直接存在键值对的结构体中，这样就避免了再用一个指针，从而节省了内存空间。”\n        void *val;//自定义类型\n        uint64_t u64;//无符号整形\n        int64_t s64;//符合整形\n        double d;//浮点型\n    } v;\n    struct dictEntity *next;//发生哈希冲突时使用。指向下一个哈希表节点，形成链表\n}\n```\n\n### HashTable渐进式扩容\n\n渐进式扩容，顾名思义就是一点一点扩容容量。相比于一次性扩容大量空间，并进行大量的拷贝工作，渐进式扩容不易导致Redis在一段时间内由于进行扩容工作而无法提供其他服务，用户体验感更好。\n\n当dict满足扩容条件后，就会进行Rehash操作。Rehash操作大致分为三步：\n\n- 为**ht[1]**哈希表开辟一块空间，空间大小设定为**第一个大于2 * ht[0]的2整数次幂**。🌰：h[0] = 500，那么在进行Rehash操作时开辟的空间为$2^{\\left\\lceil log_2(2*500) \\right\\rceil} = 1024$\n\n- 迁移ht[0]数据至ht[1]：在Rehash期间，每次对字典进行增删改查操作，程序会顺带迁移当前`rehashidx`所指向的数据，并递增下标值。如果当前`rehashidx`命中了一个空位置，则会先尝试继续往后查找若干位置，如果查询无果就直接返回\n- 最终，ht[0]的数据将会全部迁移至ht[1]中。此时，需要交换ht[0]和ht[1]的指针，并将`rehash`设为-1，表示处于非Rehash状态\n  - 为什么要交换两张哈希表的指针呢？因为ht[0]代表着正在使用的哈希表\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122114045.png\" alt=\"image-20241012211414978\" style=\"zoom:80%;\" />\n\n⚠️：值得注意的是，在Rehash阶段，由于存在两张哈希表，此时进行的删除、查找、更新操作会在两个表上进行。比如查找元素时，如果ht[0]表没有找到，则会接着查询ht[1]表。但进行插入操作时，只会在ht[1]表上增添数据\n\n### 扩（缩）容时机\n\nHASHTABLE由一个变量——**负载因子**决定是否扩容（缩容）\n\n**负载因子的算法：`ht[0].used / ht[0].size`**\n\n**扩容场景：**\n\n- 负载因子大于等于1并且此时服务器没有执行BGSAVE或BGREWRITEAOF这两个命令\n- 负载因子大于5\n\n**缩容场景：**\n\n- 负载因子小于0.1并且没有BGSAVE或BGWRITEAOF命令在执行\n\n## SkipList\n\n## 跳表的结构\n\n跳表是Redis中ZSET的底层数据结构，跳表本质上就是由**链表+多级索引**组成的\n\n但Redis使用的跳表并非标准跳表，Redis中的跳表在标准跳表基础之上**允许score值重复**以及**0层节点具有向后指针**，如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141047754.png\" alt=\"image-20241014104743623\" style=\"zoom:67%;\" />\n\n其中红色框中的属于同一个节点的不同层级，跳表中节点的数量体现在0层（最底层）节点的个数\n\n结合源码，分析节点的组成：\n\n```C\n// from Redis 7.0.8\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n```\n\n- **ele**：sds结构，一个被封装过的字符串，本质上是一个char数组，用于存储数据\n- **score**：双精度浮点数类型，表示该节点的分数，决定了跳表中节点的位置次序\n- **backward**：指向上一个节点的回退指针\n- **level**：是一个zskiplistLeve结构体数组，用于表示高层索引。zskiplistLeve结构体包含了两个字段，一个是**forward**，指向同层的下一个索引；另一个是**span**，记录了距离下一个索引（节点）的步长\n\n示意图：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141101384.png\" alt=\"image-20241014110129253\" style=\"zoom:67%;\" />\n\n### 实现细节\n\n- Redis**跳表中单个节点的层数**由概率决定。每插入一个节点到0层，Redis决定该节点是否增加一层索引的**概率为25%**\n\n- 跳表将纯粹的有序单链表在插入、删除、更新操作从$O(n)$时间复杂度降低至$O(logN)$\n\n## ZSet\n\nZset也叫Sorted Set即有序集合，是按照元素的分数进行排序的集合。分数相同的情况下，按照元素的字典序进行排序\n\nZSet常用于排序集合的场景，最典型的就是**游戏排行榜**\n\n### 编码方式\n\nZSet有两种底层编码方式，一种是ZIPLIST，另一种是SKIPLIST+HASHTABLE\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141759086.png\" alt=\"image-20241014175901004\" style=\"zoom:67%;\" />\n\n如果满足下列条件，ZSet就用ZIPLIST编码方式：\n\n- 列表对象保存的所有字符串长度均小于64字节\n- 列表对象保存的元素个数少于128个\n\nZIPLIST依旧保持着它的优点，在数据量较少时，十分节约内存空间。当ZSet采用ZIPLIST编码时，底层结构如下图：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141802693.png\" alt=\"image-20241014180256647\" style=\"zoom:67%;\" />\n\n但凡上述的两个条件有一个不满足，ZSet就采用**SKIPLIST+HASHTABLE**的编码方式。其中，SKIPLIST是一个具有多级索引的有序链表，**可以实现高效的查询、插入、删除操作**。除此之外，Redis还利用HASHTABLE结构实现在$O(1)$时间复杂度下**查询到ZSet中任一成员的`score`值**\n","source":"_posts/Redis/Redis对象.md","raw":"---\ntitle: Redis对象\npublish: true\ndescription: 记录Redis对象知识点\ntag: \n- Redis\n- 数据结构\nsticky: 2\n---\n\n# Redis对象\n\n## String\n\nString就是字符串，是Redis中的一个最基本数据对象，最大存储数据**512MB**\n\n### Set操作\n\n基本语法：**`set key value [expiration EX seconds | PX milliseconds] [NX|XX]`**\n\nSet操作用于在Redis中设置一个K-V对，其中几个扩展参数作用分别如下：\n\n- **EX seconds**：设置K-V对的过期时间为多少秒\n- **PX milliseconds**：设置K-V对的过期时间为多少毫秒\n- **NX**：只有当Key不存在时，命令才生效，相当于`setnx key value`\n- **XX**：只有当Key存在时，命令才生效\n\n⚠️：对一个已经存在Key进行set操作会**将原有值覆盖**，可能会导致**原有值丢失、擦除过期时间、丢失原有值类型**\n\n### 三种编码方式\n\nString对象底层采用三种不同的编码方式以高效应对各种场景\n\n- **INT编码**：用于存储long范围内的**整数**\n  - ⚠️：如果是浮点数，则不能使用INT编码。因为INT编码只能用于表示整数\n- **EMBSTR编码**：如果字符串的大小小于阈值字节，则采用此方式\n- **RAW编码**：如果字符串的大小大于阈值字节，则采用此方式\n\nEMBSTR编码和RAW编码方式在底层实现中都是由redisObject和SDS两个结构组成，区别在于**这两个结构在物理内存上是否连续（为一整体）**\n\nEMBSTR在内存中的表示：\n\n![image-20241003100407308](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004350.png)\n\nRAW在内存中的表示：\n\n![image-20241003100440097](https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004128.png)\n\n#### 三种编码方式的转换关系\n\n随着对Redis的操作，String对象的编码方式可能有如下变化：\n\nINT --> RAW：当存储的内容不再是整数或大小超过long范围，则需要将INT编码转换为RAW编码\n\nEMBSTR --> RAW：由于EMBSTR编码的String对象是**只读**的，所以对一个EMBSTR进行写操作时，就会将其编码方式改为RAW。这是因为修改数据就要重新分配存储空间，而EMBSTR中redisObject和SDS是连续的，不易分配空间。并且只要进行修改操作那么就能认为这个String是易变的、不稳定的，采用RAW编码方式能够减少频繁对EMBSTR内存分配的性能损耗\n\n### SDS结构\n\n不管是EMBSTR还是RAW，都有一个SDS结构，SDS结构是为了解决C语言中字符串的尴尬处境\n\n- 计算字符串长度需要遍历，时间复杂度$$O(n)$$\n- 对字符串追加内容需要扩容操作\n- 二进制不安全\n  - 二进制安全是指公平对待每一个字符，不特殊处理任何字符\n  - C语言中字符串特殊处理`\\0`为字符串结尾\n\nSDS结构具体由一下字段组成：\n\n```C\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;\n    uint8_t alloc;\n    unsigned char flags;\n    char buf[];\n}\n```\n\n- **len**：表示字符串长度，**可以快速返回字符串长度，并且不需要`\\0`作为结尾符号**\n- **alloc**：表示分配了多少内存空间，**具有一定的预留空间，无需进行扩容操作**\n- **flags**：用于区分具体是什么类型的SDS\n  - 在Redis中SDS分为sdshdr8、sdshdr16、sdshdr32、sdshdr64\n\n## List\n\n3.2版本之前，List对象有两种编码方式\n\n- ZIPLIST\n- LINKLIST\n\n当满足以下条件时，采用ZIPLIST编码方式\n\n- 列表对象中所有存储的字符串对象长度都小于64字节\n- 列表对象中存储的对象数量不超过512个（这是LIST的限制，而不是ZIPLIST的限制）\n\n🌰：\n\n![image-20241005112548274](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051125337.png)\n\nZIPLIST中数据都是紧密排列的，在数据量小的时候可以有效节约内存；而LINKLIST顾名思义，数据是以链表形式串联起来的，在数据量大的时候采用LINKLIST编码可以加快处理性能\n\n🌰：\n\n![image-20241005112658713](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051126746.png)\n\n### QUICKLIST\n\nZIPLIST在数据较少时节约内存，LINKLIST是为了在数据较多时提高更新效率。但是ZIPLIST在数据稍多时插入数据会导致大量数据复制，占用内存空间；同样地，LINKLIST由于节点数量也异常多，也会占用不少内存\n\n基于上述问题，3.2版本就引入了QUICKLIST。QUICKLIST本质就是**ZIPLIST和LINKLIST的结合体**\n\nQUICKLIST的实现思路是，将原本LINKLIST的**单个节点存储单个数据**的模式，更换成一个**单个节点（ZIPLIST）存储多个数据**的形式\n\n![image-20241005113525108](https://raw.githubusercontent.com/lyydsheep/pic/main/202410051135173.png)\n\n当数据较少时，QUICKLIST节点只有一个，退化成ZIPLIST\n\n当数据较多时，则同时利用了ZIPLIST和LINKLIST的优势\n\n## 压缩列表\n\n压缩列表作为List的底层数据结构，提供了紧凑型的数据存储方式，能节约内存，小数据量的时候遍历访问性能好（连续+局部性优势）\n\n### ZIPLIST整体结构\n\n在Redis代码注释中，有对ZIPLIST清晰地描述：\n\n```c\n/* The general layout of the ziplist is as follows:\n\n<zlbytes> <zltail> <zllen> <entry> <entry> <entry> ... <entry> <zlend>\n*/\n```\n\n🌰：一个具有三个节点的ZIPLIST\n\n![image-20241008161508590](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081615659.png)\n\n**zlbytes**字段表示该ZIPLIST一共占用了多少字节（包含zlbytes字段的大小）\n\n**zltail**字段表示最后一个**数据节点（entry）**距离ZIPLIST首部的偏移字节数，如果ZIPLIST为空（即木有entry），则指示**zlend**字段的偏移量\n\n> 很显然，会有如下等式：\n>\n> zlbytes = zltial + 最后一个entry大小（可能为零） + zlend大小\n\n**zllen**字段表示ZIPLIST结构中entry的个数，但由于该字段只占用2字节空间，所以最多只能表示65535个。当元素个数过多，只能通过**遍历**的方式获取元素个数\n\n**zlend**字段是一个特殊节点，标识ZIPLIST结构的结束\n\n**entry**字段表示一个数据节点，实际上也是一个结构体类型。该类型由三个字段构成，分别是\n\n```c\n<prevlen> <encoding> <entry-data>\n```\n\n### entry结构\n\n**`prevlen`**字段表示**上一个数据节点（entry）的长度**，如果长度**小于254**，那么**`prevlen`**字段占用1字节空间；如果长度**大于等于254**，那么该字段需要用5字节空间表示，并且**第一个字节为11111110**，表示这是一个5字节的`prevlen`信息，剩下的4字节用来表示长度\n\n⚠️：为什么阈值是254而不是255？这是因为255被用来特殊表示**zlend**字段，标识ZIPLIST结构的结束\n\n**`encoding`**字段是一个整形数据，其二进制编码由**内容类型**和**内容数据的字节长度**两部分组成\n\n### 连锁更新\n\n当向一个entry前面插入一个长度超过254的节点时，`prevlen`字段可能就会由1字节变成5字节，导致本entry长度增大。如果运气不是很好，将会导致下一个节点中的`prevlen`字段增加，以此类推，造成连锁反应，这就是连锁更新问题。\n\n![image-20241008185552935](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081855045.png)\n\n#### LISTPACK优化\n\n`prevlen`字段正是连锁更新的罪魁祸首，为了解决连锁更新问题，就不能再去记录上一个节点的长度，但又要保证能够实现倒序遍历（找到上一个节点的位置）\n\nRedis使用了一种巧妙的方法：删除`prevlen`字段，**新增`element-tot-len`字段记录整个节点除它（element-tot-len字段）自身之外的长度**\n\n此时节点结构就变成了：\n\n```c\n<encoding-type> <element-data> <element-top-len>\n```\n\n- encoding-type是编码类型\n- element-data是数据内容\n- element-top-len所占的每个字节的第一个bit位用于标识是否结束，0则结束，1则继续\n\n🌰：![image-20241008190334625](https://raw.githubusercontent.com/lyydsheep/pic/main/202410081903663.png)\n\n## Set\n\nRedi中的set是一个不重复、无序的字符串集合\n\n> 如果Set底层使用INTSET编码方式，则集合是有序的\n\n### 编码方式 \n\nSet底层有两种编码方式：**INTSET、HASHTABLE**\n\n当Set中存储的都是整数并且元素个数少于512个时，则采用INTSET编码方式\n\n![image-20241009154144626](https://raw.githubusercontent.com/lyydsheep/pic/main/202410091541699.png)\n\n由上图可见，采用INTSET编码，元素排列比较紧凑，内存占用少，但查找时需要使用二分法，时间复杂度为$O(nlogn)$\n\n如果不满足INTSET编码条件，则需要使用HASHTABLE编码，HASHTABLE查询一个元素性能很高，时间复杂度为$O(1)$\n\n![image-20241009154437973](https://raw.githubusercontent.com/lyydsheep/pic/main/202410091544018.png)\n\n简单地概括：\n\n- INTSET编码适用于存储少量整数场景以节约内存空间\n- HASHTABLE编码适用于快速定位某个元素的位置\n\n## Hash\n\n// to do\n\npanic(\"implement me\")\n\n## HashTable\n\n>  HAHSTABLE是Redis中的一种底层数据结构\n\n通过HASHTABLE可以在$O(1)$时间复杂度内快速定位到Key对于的Value\n\n### 结构\n\n总所周知，Redis是用C语言实现的。HASHTABLE的C实现涉及到三个结构体：`dict`、`dictht`、`dicEntry`\n\n简单地说，`dict`封装了两个`dictht`结构，每一个`dictht`结构都有一个大小为`size`的**bucket**，bucket中存放着`dicEntry`链表。三个结构体之间的关系如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122043279.png\" alt=\"image-20241012204338184\" style=\"zoom:67%;\" />\n\n可以看到dict结构中有两个dictht结构，也就是HASHTABLE结构。dicEntry是链表结构，通过拉链法解决Hash冲突\n\n接下来，结合源码j解释每一个结构体的字段含义：\n\n```c\ntypedef struct dict{\n    dictType *type; //直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据\n    void *privdata; //私有数据，保存着dictType结构中函数的 参数\n    dictht ht[2]; //两张哈希表\n    long rehashidx; //rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一\n    int itreators;  //正在迭代的迭代器数量\n}\n```\n\n```c\n#dict结构中ht[0]、ht[1]哈希表的数据结构\ntypedef struct dictht{\n    dictEntry[] table;        //存放一个数组的地址，数组中存放哈希节点dictEntry的地址\n    unsingned long size;      //哈希表table的大小，出始大小为4\n    unsingned long  sizemask; //用于将hash值映射到table位置的索引，大小为（size-1）\n    unsingned long  used;     //记录哈希表已有节点（键值对）的数量\n}\n```\n\n```c\n#哈希表节点结构定义\ntypedef struct dictEntity{\n    void *key;//键\n    //值\n    union{\n        //“我之所以要提醒你注意这里，其实是为了说明，这种实现方法是一种节省内存的开发小技巧，非常值得学习。因为当值为整数或双精度浮点数时，由于其本身就是 64 位，就可以不用指针指向了，而是可以直接存在键值对的结构体中，这样就避免了再用一个指针，从而节省了内存空间。”\n        void *val;//自定义类型\n        uint64_t u64;//无符号整形\n        int64_t s64;//符合整形\n        double d;//浮点型\n    } v;\n    struct dictEntity *next;//发生哈希冲突时使用。指向下一个哈希表节点，形成链表\n}\n```\n\n### HashTable渐进式扩容\n\n渐进式扩容，顾名思义就是一点一点扩容容量。相比于一次性扩容大量空间，并进行大量的拷贝工作，渐进式扩容不易导致Redis在一段时间内由于进行扩容工作而无法提供其他服务，用户体验感更好。\n\n当dict满足扩容条件后，就会进行Rehash操作。Rehash操作大致分为三步：\n\n- 为**ht[1]**哈希表开辟一块空间，空间大小设定为**第一个大于2 * ht[0]的2整数次幂**。🌰：h[0] = 500，那么在进行Rehash操作时开辟的空间为$2^{\\left\\lceil log_2(2*500) \\right\\rceil} = 1024$\n\n- 迁移ht[0]数据至ht[1]：在Rehash期间，每次对字典进行增删改查操作，程序会顺带迁移当前`rehashidx`所指向的数据，并递增下标值。如果当前`rehashidx`命中了一个空位置，则会先尝试继续往后查找若干位置，如果查询无果就直接返回\n- 最终，ht[0]的数据将会全部迁移至ht[1]中。此时，需要交换ht[0]和ht[1]的指针，并将`rehash`设为-1，表示处于非Rehash状态\n  - 为什么要交换两张哈希表的指针呢？因为ht[0]代表着正在使用的哈希表\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122114045.png\" alt=\"image-20241012211414978\" style=\"zoom:80%;\" />\n\n⚠️：值得注意的是，在Rehash阶段，由于存在两张哈希表，此时进行的删除、查找、更新操作会在两个表上进行。比如查找元素时，如果ht[0]表没有找到，则会接着查询ht[1]表。但进行插入操作时，只会在ht[1]表上增添数据\n\n### 扩（缩）容时机\n\nHASHTABLE由一个变量——**负载因子**决定是否扩容（缩容）\n\n**负载因子的算法：`ht[0].used / ht[0].size`**\n\n**扩容场景：**\n\n- 负载因子大于等于1并且此时服务器没有执行BGSAVE或BGREWRITEAOF这两个命令\n- 负载因子大于5\n\n**缩容场景：**\n\n- 负载因子小于0.1并且没有BGSAVE或BGWRITEAOF命令在执行\n\n## SkipList\n\n## 跳表的结构\n\n跳表是Redis中ZSET的底层数据结构，跳表本质上就是由**链表+多级索引**组成的\n\n但Redis使用的跳表并非标准跳表，Redis中的跳表在标准跳表基础之上**允许score值重复**以及**0层节点具有向后指针**，如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141047754.png\" alt=\"image-20241014104743623\" style=\"zoom:67%;\" />\n\n其中红色框中的属于同一个节点的不同层级，跳表中节点的数量体现在0层（最底层）节点的个数\n\n结合源码，分析节点的组成：\n\n```C\n// from Redis 7.0.8\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n```\n\n- **ele**：sds结构，一个被封装过的字符串，本质上是一个char数组，用于存储数据\n- **score**：双精度浮点数类型，表示该节点的分数，决定了跳表中节点的位置次序\n- **backward**：指向上一个节点的回退指针\n- **level**：是一个zskiplistLeve结构体数组，用于表示高层索引。zskiplistLeve结构体包含了两个字段，一个是**forward**，指向同层的下一个索引；另一个是**span**，记录了距离下一个索引（节点）的步长\n\n示意图：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141101384.png\" alt=\"image-20241014110129253\" style=\"zoom:67%;\" />\n\n### 实现细节\n\n- Redis**跳表中单个节点的层数**由概率决定。每插入一个节点到0层，Redis决定该节点是否增加一层索引的**概率为25%**\n\n- 跳表将纯粹的有序单链表在插入、删除、更新操作从$O(n)$时间复杂度降低至$O(logN)$\n\n## ZSet\n\nZset也叫Sorted Set即有序集合，是按照元素的分数进行排序的集合。分数相同的情况下，按照元素的字典序进行排序\n\nZSet常用于排序集合的场景，最典型的就是**游戏排行榜**\n\n### 编码方式\n\nZSet有两种底层编码方式，一种是ZIPLIST，另一种是SKIPLIST+HASHTABLE\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141759086.png\" alt=\"image-20241014175901004\" style=\"zoom:67%;\" />\n\n如果满足下列条件，ZSet就用ZIPLIST编码方式：\n\n- 列表对象保存的所有字符串长度均小于64字节\n- 列表对象保存的元素个数少于128个\n\nZIPLIST依旧保持着它的优点，在数据量较少时，十分节约内存空间。当ZSet采用ZIPLIST编码时，底层结构如下图：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141802693.png\" alt=\"image-20241014180256647\" style=\"zoom:67%;\" />\n\n但凡上述的两个条件有一个不满足，ZSet就采用**SKIPLIST+HASHTABLE**的编码方式。其中，SKIPLIST是一个具有多级索引的有序链表，**可以实现高效的查询、插入、删除操作**。除此之外，Redis还利用HASHTABLE结构实现在$O(1)$时间复杂度下**查询到ZSet中任一成员的`score`值**\n","slug":"Redis/Redis对象","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6n002qa5t25va14by5","content":"<h1 id=\"Redis对象\"><a href=\"#Redis对象\" class=\"headerlink\" title=\"Redis对象\"></a>Redis对象</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String就是字符串，是Redis中的一个最基本数据对象，最大存储数据<strong>512MB</strong></p>\n<h3 id=\"Set操作\"><a href=\"#Set操作\" class=\"headerlink\" title=\"Set操作\"></a>Set操作</h3><p>基本语法：**<code>set key value [expiration EX seconds | PX milliseconds] [NX|XX]</code>**</p>\n<p>Set操作用于在Redis中设置一个K-V对，其中几个扩展参数作用分别如下：</p>\n<ul>\n<li><strong>EX seconds</strong>：设置K-V对的过期时间为多少秒</li>\n<li><strong>PX milliseconds</strong>：设置K-V对的过期时间为多少毫秒</li>\n<li><strong>NX</strong>：只有当Key不存在时，命令才生效，相当于<code>setnx key value</code></li>\n<li><strong>XX</strong>：只有当Key存在时，命令才生效</li>\n</ul>\n<p>⚠️：对一个已经存在Key进行set操作会<strong>将原有值覆盖</strong>，可能会导致<strong>原有值丢失、擦除过期时间、丢失原有值类型</strong></p>\n<h3 id=\"三种编码方式\"><a href=\"#三种编码方式\" class=\"headerlink\" title=\"三种编码方式\"></a>三种编码方式</h3><p>String对象底层采用三种不同的编码方式以高效应对各种场景</p>\n<ul>\n<li><strong>INT编码</strong>：用于存储long范围内的<strong>整数</strong><ul>\n<li>⚠️：如果是浮点数，则不能使用INT编码。因为INT编码只能用于表示整数</li>\n</ul>\n</li>\n<li><strong>EMBSTR编码</strong>：如果字符串的大小小于阈值字节，则采用此方式</li>\n<li><strong>RAW编码</strong>：如果字符串的大小大于阈值字节，则采用此方式</li>\n</ul>\n<p>EMBSTR编码和RAW编码方式在底层实现中都是由redisObject和SDS两个结构组成，区别在于<strong>这两个结构在物理内存上是否连续（为一整体）</strong></p>\n<p>EMBSTR在内存中的表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004350.png\" alt=\"image-20241003100407308\"></p>\n<p>RAW在内存中的表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004128.png\" alt=\"image-20241003100440097\"></p>\n<h4 id=\"三种编码方式的转换关系\"><a href=\"#三种编码方式的转换关系\" class=\"headerlink\" title=\"三种编码方式的转换关系\"></a>三种编码方式的转换关系</h4><p>随着对Redis的操作，String对象的编码方式可能有如下变化：</p>\n<p>INT –&gt; RAW：当存储的内容不再是整数或大小超过long范围，则需要将INT编码转换为RAW编码</p>\n<p>EMBSTR –&gt; RAW：由于EMBSTR编码的String对象是<strong>只读</strong>的，所以对一个EMBSTR进行写操作时，就会将其编码方式改为RAW。这是因为修改数据就要重新分配存储空间，而EMBSTR中redisObject和SDS是连续的，不易分配空间。并且只要进行修改操作那么就能认为这个String是易变的、不稳定的，采用RAW编码方式能够减少频繁对EMBSTR内存分配的性能损耗</p>\n<h3 id=\"SDS结构\"><a href=\"#SDS结构\" class=\"headerlink\" title=\"SDS结构\"></a>SDS结构</h3><p>不管是EMBSTR还是RAW，都有一个SDS结构，SDS结构是为了解决C语言中字符串的尴尬处境</p>\n<ul>\n<li>计算字符串长度需要遍历，时间复杂度$$O(n)$$</li>\n<li>对字符串追加内容需要扩容操作</li>\n<li>二进制不安全<ul>\n<li>二进制安全是指公平对待每一个字符，不特殊处理任何字符</li>\n<li>C语言中字符串特殊处理<code>\\0</code>为字符串结尾</li>\n</ul>\n</li>\n</ul>\n<p>SDS结构具体由一下字段组成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> alloc;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> flags;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>len</strong>：表示字符串长度，<strong>可以快速返回字符串长度，并且不需要<code>\\0</code>作为结尾符号</strong></li>\n<li><strong>alloc</strong>：表示分配了多少内存空间，<strong>具有一定的预留空间，无需进行扩容操作</strong></li>\n<li><strong>flags</strong>：用于区分具体是什么类型的SDS<ul>\n<li>在Redis中SDS分为sdshdr8、sdshdr16、sdshdr32、sdshdr64</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>3.2版本之前，List对象有两种编码方式</p>\n<ul>\n<li>ZIPLIST</li>\n<li>LINKLIST</li>\n</ul>\n<p>当满足以下条件时，采用ZIPLIST编码方式</p>\n<ul>\n<li>列表对象中所有存储的字符串对象长度都小于64字节</li>\n<li>列表对象中存储的对象数量不超过512个（这是LIST的限制，而不是ZIPLIST的限制）</li>\n</ul>\n<p>🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051125337.png\" alt=\"image-20241005112548274\"></p>\n<p>ZIPLIST中数据都是紧密排列的，在数据量小的时候可以有效节约内存；而LINKLIST顾名思义，数据是以链表形式串联起来的，在数据量大的时候采用LINKLIST编码可以加快处理性能</p>\n<p>🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051126746.png\" alt=\"image-20241005112658713\"></p>\n<h3 id=\"QUICKLIST\"><a href=\"#QUICKLIST\" class=\"headerlink\" title=\"QUICKLIST\"></a>QUICKLIST</h3><p>ZIPLIST在数据较少时节约内存，LINKLIST是为了在数据较多时提高更新效率。但是ZIPLIST在数据稍多时插入数据会导致大量数据复制，占用内存空间；同样地，LINKLIST由于节点数量也异常多，也会占用不少内存</p>\n<p>基于上述问题，3.2版本就引入了QUICKLIST。QUICKLIST本质就是<strong>ZIPLIST和LINKLIST的结合体</strong></p>\n<p>QUICKLIST的实现思路是，将原本LINKLIST的<strong>单个节点存储单个数据</strong>的模式，更换成一个<strong>单个节点（ZIPLIST）存储多个数据</strong>的形式</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051135173.png\" alt=\"image-20241005113525108\"></p>\n<p>当数据较少时，QUICKLIST节点只有一个，退化成ZIPLIST</p>\n<p>当数据较多时，则同时利用了ZIPLIST和LINKLIST的优势</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表作为List的底层数据结构，提供了紧凑型的数据存储方式，能节约内存，小数据量的时候遍历访问性能好（连续+局部性优势）</p>\n<h3 id=\"ZIPLIST整体结构\"><a href=\"#ZIPLIST整体结构\" class=\"headerlink\" title=\"ZIPLIST整体结构\"></a>ZIPLIST整体结构</h3><p>在Redis代码注释中，有对ZIPLIST清晰地描述：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The general layout of the ziplist is as follows:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>🌰：一个具有三个节点的ZIPLIST</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081615659.png\" alt=\"image-20241008161508590\"></p>\n<p><strong>zlbytes</strong>字段表示该ZIPLIST一共占用了多少字节（包含zlbytes字段的大小）</p>\n<p><strong>zltail</strong>字段表示最后一个<strong>数据节点（entry）</strong>距离ZIPLIST首部的偏移字节数，如果ZIPLIST为空（即木有entry），则指示<strong>zlend</strong>字段的偏移量</p>\n<blockquote>\n<p>很显然，会有如下等式：</p>\n<p>zlbytes &#x3D; zltial + 最后一个entry大小（可能为零） + zlend大小</p>\n</blockquote>\n<p><strong>zllen</strong>字段表示ZIPLIST结构中entry的个数，但由于该字段只占用2字节空间，所以最多只能表示65535个。当元素个数过多，只能通过<strong>遍历</strong>的方式获取元素个数</p>\n<p><strong>zlend</strong>字段是一个特殊节点，标识ZIPLIST结构的结束</p>\n<p><strong>entry</strong>字段表示一个数据节点，实际上也是一个结构体类型。该类型由三个字段构成，分别是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"entry结构\"><a href=\"#entry结构\" class=\"headerlink\" title=\"entry结构\"></a>entry结构</h3><p><strong><code>prevlen</code><strong>字段表示</strong>上一个数据节点（entry）的长度</strong>，如果长度<strong>小于254</strong>，那么**<code>prevlen</code><strong>字段占用1字节空间；如果长度</strong>大于等于254<strong>，那么该字段需要用5字节空间表示，并且</strong>第一个字节为11111110**，表示这是一个5字节的<code>prevlen</code>信息，剩下的4字节用来表示长度</p>\n<p>⚠️：为什么阈值是254而不是255？这是因为255被用来特殊表示<strong>zlend</strong>字段，标识ZIPLIST结构的结束</p>\n<p><strong><code>encoding</code><strong>字段是一个整形数据，其二进制编码由</strong>内容类型</strong>和<strong>内容数据的字节长度</strong>两部分组成</p>\n<h3 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h3><p>当向一个entry前面插入一个长度超过254的节点时，<code>prevlen</code>字段可能就会由1字节变成5字节，导致本entry长度增大。如果运气不是很好，将会导致下一个节点中的<code>prevlen</code>字段增加，以此类推，造成连锁反应，这就是连锁更新问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081855045.png\" alt=\"image-20241008185552935\"></p>\n<h4 id=\"LISTPACK优化\"><a href=\"#LISTPACK优化\" class=\"headerlink\" title=\"LISTPACK优化\"></a>LISTPACK优化</h4><p><code>prevlen</code>字段正是连锁更新的罪魁祸首，为了解决连锁更新问题，就不能再去记录上一个节点的长度，但又要保证能够实现倒序遍历（找到上一个节点的位置）</p>\n<p>Redis使用了一种巧妙的方法：删除<code>prevlen</code>字段，<strong>新增<code>element-tot-len</code>字段记录整个节点除它（element-tot-len字段）自身之外的长度</strong></p>\n<p>此时节点结构就变成了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;encoding-type&gt; &lt;element-data&gt; &lt;element-top-len&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>encoding-type是编码类型</li>\n<li>element-data是数据内容</li>\n<li>element-top-len所占的每个字节的第一个bit位用于标识是否结束，0则结束，1则继续</li>\n</ul>\n<p>🌰：<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081903663.png\" alt=\"image-20241008190334625\"></p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>Redi中的set是一个不重复、无序的字符串集合</p>\n<blockquote>\n<p>如果Set底层使用INTSET编码方式，则集合是有序的</p>\n</blockquote>\n<h3 id=\"编码方式\"><a href=\"#编码方式\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3><p>Set底层有两种编码方式：<strong>INTSET、HASHTABLE</strong></p>\n<p>当Set中存储的都是整数并且元素个数少于512个时，则采用INTSET编码方式</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091541699.png\" alt=\"image-20241009154144626\"></p>\n<p>由上图可见，采用INTSET编码，元素排列比较紧凑，内存占用少，但查找时需要使用二分法，时间复杂度为$O(nlogn)$</p>\n<p>如果不满足INTSET编码条件，则需要使用HASHTABLE编码，HASHTABLE查询一个元素性能很高，时间复杂度为$O(1)$</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091544018.png\" alt=\"image-20241009154437973\"></p>\n<p>简单地概括：</p>\n<ul>\n<li>INTSET编码适用于存储少量整数场景以节约内存空间</li>\n<li>HASHTABLE编码适用于快速定位某个元素的位置</li>\n</ul>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>&#x2F;&#x2F; to do</p>\n<p>panic(“implement me”)</p>\n<h2 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h2><blockquote>\n<p> HAHSTABLE是Redis中的一种底层数据结构</p>\n</blockquote>\n<p>通过HASHTABLE可以在$O(1)$时间复杂度内快速定位到Key对于的Value</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>总所周知，Redis是用C语言实现的。HASHTABLE的C实现涉及到三个结构体：<code>dict</code>、<code>dictht</code>、<code>dicEntry</code></p>\n<p>简单地说，<code>dict</code>封装了两个<code>dictht</code>结构，每一个<code>dictht</code>结构都有一个大小为<code>size</code>的<strong>bucket</strong>，bucket中存放着<code>dicEntry</code>链表。三个结构体之间的关系如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122043279.png\" alt=\"image-20241012204338184\" style=\"zoom:67%;\" />\n\n<p>可以看到dict结构中有两个dictht结构，也就是HASHTABLE结构。dicEntry是链表结构，通过拉链法解决Hash冲突</p>\n<p>接下来，结合源码j解释每一个结构体的字段含义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">    dictType *type; <span class=\"comment\">//直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *privdata; <span class=\"comment\">//私有数据，保存着dictType结构中函数的 参数</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>]; <span class=\"comment\">//两张哈希表</span></span><br><span class=\"line\">    <span class=\"type\">long</span> rehashidx; <span class=\"comment\">//rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一</span></span><br><span class=\"line\">    <span class=\"type\">int</span> itreators;  <span class=\"comment\">//正在迭代的迭代器数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#dict结构中ht[0]、ht[1]哈希表的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span>&#123;</span></span><br><span class=\"line\">    dictEntry[] table;        <span class=\"comment\">//存放一个数组的地址，数组中存放哈希节点dictEntry的地址</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span> size;      <span class=\"comment\">//哈希表table的大小，出始大小为4</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span>  sizemask; <span class=\"comment\">//用于将hash值映射到table位置的索引，大小为（size-1）</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span>  used;     <span class=\"comment\">//记录哈希表已有节点（键值对）的数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#哈希表节点结构定义</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntity</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *key;<span class=\"comment\">//键</span></span><br><span class=\"line\">    <span class=\"comment\">//值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//“我之所以要提醒你注意这里，其实是为了说明，这种实现方法是一种节省内存的开发小技巧，非常值得学习。因为当值为整数或双精度浮点数时，由于其本身就是 64 位，就可以不用指针指向了，而是可以直接存在键值对的结构体中，这样就避免了再用一个指针，从而节省了内存空间。”</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *val;<span class=\"comment\">//自定义类型</span></span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> u64;<span class=\"comment\">//无符号整形</span></span><br><span class=\"line\">        <span class=\"type\">int64_t</span> s64;<span class=\"comment\">//符合整形</span></span><br><span class=\"line\">        <span class=\"type\">double</span> d;<span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntity</span> *<span class=\"title\">next</span>;</span><span class=\"comment\">//发生哈希冲突时使用。指向下一个哈希表节点，形成链表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashTable渐进式扩容\"><a href=\"#HashTable渐进式扩容\" class=\"headerlink\" title=\"HashTable渐进式扩容\"></a>HashTable渐进式扩容</h3><p>渐进式扩容，顾名思义就是一点一点扩容容量。相比于一次性扩容大量空间，并进行大量的拷贝工作，渐进式扩容不易导致Redis在一段时间内由于进行扩容工作而无法提供其他服务，用户体验感更好。</p>\n<p>当dict满足扩容条件后，就会进行Rehash操作。Rehash操作大致分为三步：</p>\n<ul>\n<li><p>为<strong>ht[1]<strong>哈希表开辟一块空间，空间大小设定为</strong>第一个大于2 * ht[0]的2整数次幂</strong>。🌰：h[0] &#x3D; 500，那么在进行Rehash操作时开辟的空间为$2^{\\left\\lceil log_2(2*500) \\right\\rceil} &#x3D; 1024$</p>\n</li>\n<li><p>迁移ht[0]数据至ht[1]：在Rehash期间，每次对字典进行增删改查操作，程序会顺带迁移当前<code>rehashidx</code>所指向的数据，并递增下标值。如果当前<code>rehashidx</code>命中了一个空位置，则会先尝试继续往后查找若干位置，如果查询无果就直接返回</p>\n</li>\n<li><p>最终，ht[0]的数据将会全部迁移至ht[1]中。此时，需要交换ht[0]和ht[1]的指针，并将<code>rehash</code>设为-1，表示处于非Rehash状态</p>\n<ul>\n<li>为什么要交换两张哈希表的指针呢？因为ht[0]代表着正在使用的哈希表</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122114045.png\" alt=\"image-20241012211414978\" style=\"zoom:80%;\" />\n\n<p>⚠️：值得注意的是，在Rehash阶段，由于存在两张哈希表，此时进行的删除、查找、更新操作会在两个表上进行。比如查找元素时，如果ht[0]表没有找到，则会接着查询ht[1]表。但进行插入操作时，只会在ht[1]表上增添数据</p>\n<h3 id=\"扩（缩）容时机\"><a href=\"#扩（缩）容时机\" class=\"headerlink\" title=\"扩（缩）容时机\"></a>扩（缩）容时机</h3><p>HASHTABLE由一个变量——<strong>负载因子</strong>决定是否扩容（缩容）</p>\n<p><strong>负载因子的算法：<code>ht[0].used / ht[0].size</code></strong></p>\n<p><strong>扩容场景：</strong></p>\n<ul>\n<li>负载因子大于等于1并且此时服务器没有执行BGSAVE或BGREWRITEAOF这两个命令</li>\n<li>负载因子大于5</li>\n</ul>\n<p><strong>缩容场景：</strong></p>\n<ul>\n<li>负载因子小于0.1并且没有BGSAVE或BGWRITEAOF命令在执行</li>\n</ul>\n<h2 id=\"SkipList\"><a href=\"#SkipList\" class=\"headerlink\" title=\"SkipList\"></a>SkipList</h2><h2 id=\"跳表的结构\"><a href=\"#跳表的结构\" class=\"headerlink\" title=\"跳表的结构\"></a>跳表的结构</h2><p>跳表是Redis中ZSET的底层数据结构，跳表本质上就是由<strong>链表+多级索引</strong>组成的</p>\n<p>但Redis使用的跳表并非标准跳表，Redis中的跳表在标准跳表基础之上<strong>允许score值重复</strong>以及<strong>0层节点具有向后指针</strong>，如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141047754.png\" alt=\"image-20241014104743623\" style=\"zoom:67%;\" />\n\n<p>其中红色框中的属于同一个节点的不同层级，跳表中节点的数量体现在0层（最底层）节点的个数</p>\n<p>结合源码，分析节点的组成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// from Redis 7.0.8</span></span><br><span class=\"line\"><span class=\"comment\">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    sds ele;</span><br><span class=\"line\">    <span class=\"type\">double</span> score;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>ele</strong>：sds结构，一个被封装过的字符串，本质上是一个char数组，用于存储数据</li>\n<li><strong>score</strong>：双精度浮点数类型，表示该节点的分数，决定了跳表中节点的位置次序</li>\n<li><strong>backward</strong>：指向上一个节点的回退指针</li>\n<li><strong>level</strong>：是一个zskiplistLeve结构体数组，用于表示高层索引。zskiplistLeve结构体包含了两个字段，一个是<strong>forward</strong>，指向同层的下一个索引；另一个是<strong>span</strong>，记录了距离下一个索引（节点）的步长</li>\n</ul>\n<p>示意图：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141101384.png\" alt=\"image-20241014110129253\" style=\"zoom:67%;\" />\n\n<h3 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h3><ul>\n<li><p>Redis<strong>跳表中单个节点的层数</strong>由概率决定。每插入一个节点到0层，Redis决定该节点是否增加一层索引的<strong>概率为25%</strong></p>\n</li>\n<li><p>跳表将纯粹的有序单链表在插入、删除、更新操作从$O(n)$时间复杂度降低至$O(logN)$</p>\n</li>\n</ul>\n<h2 id=\"ZSet\"><a href=\"#ZSet\" class=\"headerlink\" title=\"ZSet\"></a>ZSet</h2><p>Zset也叫Sorted Set即有序集合，是按照元素的分数进行排序的集合。分数相同的情况下，按照元素的字典序进行排序</p>\n<p>ZSet常用于排序集合的场景，最典型的就是<strong>游戏排行榜</strong></p>\n<h3 id=\"编码方式-1\"><a href=\"#编码方式-1\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3><p>ZSet有两种底层编码方式，一种是ZIPLIST，另一种是SKIPLIST+HASHTABLE</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141759086.png\" alt=\"image-20241014175901004\" style=\"zoom:67%;\" />\n\n<p>如果满足下列条件，ZSet就用ZIPLIST编码方式：</p>\n<ul>\n<li>列表对象保存的所有字符串长度均小于64字节</li>\n<li>列表对象保存的元素个数少于128个</li>\n</ul>\n<p>ZIPLIST依旧保持着它的优点，在数据量较少时，十分节约内存空间。当ZSet采用ZIPLIST编码时，底层结构如下图：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141802693.png\" alt=\"image-20241014180256647\" style=\"zoom:67%;\" />\n\n<p>但凡上述的两个条件有一个不满足，ZSet就采用<strong>SKIPLIST+HASHTABLE</strong>的编码方式。其中，SKIPLIST是一个具有多级索引的有序链表，<strong>可以实现高效的查询、插入、删除操作</strong>。除此之外，Redis还利用HASHTABLE结构实现在$O(1)$时间复杂度下<strong>查询到ZSet中任一成员的<code>score</code>值</strong></p>\n","excerpt":"","more":"<h1 id=\"Redis对象\"><a href=\"#Redis对象\" class=\"headerlink\" title=\"Redis对象\"></a>Redis对象</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String就是字符串，是Redis中的一个最基本数据对象，最大存储数据<strong>512MB</strong></p>\n<h3 id=\"Set操作\"><a href=\"#Set操作\" class=\"headerlink\" title=\"Set操作\"></a>Set操作</h3><p>基本语法：**<code>set key value [expiration EX seconds | PX milliseconds] [NX|XX]</code>**</p>\n<p>Set操作用于在Redis中设置一个K-V对，其中几个扩展参数作用分别如下：</p>\n<ul>\n<li><strong>EX seconds</strong>：设置K-V对的过期时间为多少秒</li>\n<li><strong>PX milliseconds</strong>：设置K-V对的过期时间为多少毫秒</li>\n<li><strong>NX</strong>：只有当Key不存在时，命令才生效，相当于<code>setnx key value</code></li>\n<li><strong>XX</strong>：只有当Key存在时，命令才生效</li>\n</ul>\n<p>⚠️：对一个已经存在Key进行set操作会<strong>将原有值覆盖</strong>，可能会导致<strong>原有值丢失、擦除过期时间、丢失原有值类型</strong></p>\n<h3 id=\"三种编码方式\"><a href=\"#三种编码方式\" class=\"headerlink\" title=\"三种编码方式\"></a>三种编码方式</h3><p>String对象底层采用三种不同的编码方式以高效应对各种场景</p>\n<ul>\n<li><strong>INT编码</strong>：用于存储long范围内的<strong>整数</strong><ul>\n<li>⚠️：如果是浮点数，则不能使用INT编码。因为INT编码只能用于表示整数</li>\n</ul>\n</li>\n<li><strong>EMBSTR编码</strong>：如果字符串的大小小于阈值字节，则采用此方式</li>\n<li><strong>RAW编码</strong>：如果字符串的大小大于阈值字节，则采用此方式</li>\n</ul>\n<p>EMBSTR编码和RAW编码方式在底层实现中都是由redisObject和SDS两个结构组成，区别在于<strong>这两个结构在物理内存上是否连续（为一整体）</strong></p>\n<p>EMBSTR在内存中的表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004350.png\" alt=\"image-20241003100407308\"></p>\n<p>RAW在内存中的表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410031004128.png\" alt=\"image-20241003100440097\"></p>\n<h4 id=\"三种编码方式的转换关系\"><a href=\"#三种编码方式的转换关系\" class=\"headerlink\" title=\"三种编码方式的转换关系\"></a>三种编码方式的转换关系</h4><p>随着对Redis的操作，String对象的编码方式可能有如下变化：</p>\n<p>INT –&gt; RAW：当存储的内容不再是整数或大小超过long范围，则需要将INT编码转换为RAW编码</p>\n<p>EMBSTR –&gt; RAW：由于EMBSTR编码的String对象是<strong>只读</strong>的，所以对一个EMBSTR进行写操作时，就会将其编码方式改为RAW。这是因为修改数据就要重新分配存储空间，而EMBSTR中redisObject和SDS是连续的，不易分配空间。并且只要进行修改操作那么就能认为这个String是易变的、不稳定的，采用RAW编码方式能够减少频繁对EMBSTR内存分配的性能损耗</p>\n<h3 id=\"SDS结构\"><a href=\"#SDS结构\" class=\"headerlink\" title=\"SDS结构\"></a>SDS结构</h3><p>不管是EMBSTR还是RAW，都有一个SDS结构，SDS结构是为了解决C语言中字符串的尴尬处境</p>\n<ul>\n<li>计算字符串长度需要遍历，时间复杂度$$O(n)$$</li>\n<li>对字符串追加内容需要扩容操作</li>\n<li>二进制不安全<ul>\n<li>二进制安全是指公平对待每一个字符，不特殊处理任何字符</li>\n<li>C语言中字符串特殊处理<code>\\0</code>为字符串结尾</li>\n</ul>\n</li>\n</ul>\n<p>SDS结构具体由一下字段组成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> alloc;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> flags;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>len</strong>：表示字符串长度，<strong>可以快速返回字符串长度，并且不需要<code>\\0</code>作为结尾符号</strong></li>\n<li><strong>alloc</strong>：表示分配了多少内存空间，<strong>具有一定的预留空间，无需进行扩容操作</strong></li>\n<li><strong>flags</strong>：用于区分具体是什么类型的SDS<ul>\n<li>在Redis中SDS分为sdshdr8、sdshdr16、sdshdr32、sdshdr64</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>3.2版本之前，List对象有两种编码方式</p>\n<ul>\n<li>ZIPLIST</li>\n<li>LINKLIST</li>\n</ul>\n<p>当满足以下条件时，采用ZIPLIST编码方式</p>\n<ul>\n<li>列表对象中所有存储的字符串对象长度都小于64字节</li>\n<li>列表对象中存储的对象数量不超过512个（这是LIST的限制，而不是ZIPLIST的限制）</li>\n</ul>\n<p>🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051125337.png\" alt=\"image-20241005112548274\"></p>\n<p>ZIPLIST中数据都是紧密排列的，在数据量小的时候可以有效节约内存；而LINKLIST顾名思义，数据是以链表形式串联起来的，在数据量大的时候采用LINKLIST编码可以加快处理性能</p>\n<p>🌰：</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051126746.png\" alt=\"image-20241005112658713\"></p>\n<h3 id=\"QUICKLIST\"><a href=\"#QUICKLIST\" class=\"headerlink\" title=\"QUICKLIST\"></a>QUICKLIST</h3><p>ZIPLIST在数据较少时节约内存，LINKLIST是为了在数据较多时提高更新效率。但是ZIPLIST在数据稍多时插入数据会导致大量数据复制，占用内存空间；同样地，LINKLIST由于节点数量也异常多，也会占用不少内存</p>\n<p>基于上述问题，3.2版本就引入了QUICKLIST。QUICKLIST本质就是<strong>ZIPLIST和LINKLIST的结合体</strong></p>\n<p>QUICKLIST的实现思路是，将原本LINKLIST的<strong>单个节点存储单个数据</strong>的模式，更换成一个<strong>单个节点（ZIPLIST）存储多个数据</strong>的形式</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410051135173.png\" alt=\"image-20241005113525108\"></p>\n<p>当数据较少时，QUICKLIST节点只有一个，退化成ZIPLIST</p>\n<p>当数据较多时，则同时利用了ZIPLIST和LINKLIST的优势</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表作为List的底层数据结构，提供了紧凑型的数据存储方式，能节约内存，小数据量的时候遍历访问性能好（连续+局部性优势）</p>\n<h3 id=\"ZIPLIST整体结构\"><a href=\"#ZIPLIST整体结构\" class=\"headerlink\" title=\"ZIPLIST整体结构\"></a>ZIPLIST整体结构</h3><p>在Redis代码注释中，有对ZIPLIST清晰地描述：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The general layout of the ziplist is as follows:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>🌰：一个具有三个节点的ZIPLIST</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081615659.png\" alt=\"image-20241008161508590\"></p>\n<p><strong>zlbytes</strong>字段表示该ZIPLIST一共占用了多少字节（包含zlbytes字段的大小）</p>\n<p><strong>zltail</strong>字段表示最后一个<strong>数据节点（entry）</strong>距离ZIPLIST首部的偏移字节数，如果ZIPLIST为空（即木有entry），则指示<strong>zlend</strong>字段的偏移量</p>\n<blockquote>\n<p>很显然，会有如下等式：</p>\n<p>zlbytes &#x3D; zltial + 最后一个entry大小（可能为零） + zlend大小</p>\n</blockquote>\n<p><strong>zllen</strong>字段表示ZIPLIST结构中entry的个数，但由于该字段只占用2字节空间，所以最多只能表示65535个。当元素个数过多，只能通过<strong>遍历</strong>的方式获取元素个数</p>\n<p><strong>zlend</strong>字段是一个特殊节点，标识ZIPLIST结构的结束</p>\n<p><strong>entry</strong>字段表示一个数据节点，实际上也是一个结构体类型。该类型由三个字段构成，分别是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"entry结构\"><a href=\"#entry结构\" class=\"headerlink\" title=\"entry结构\"></a>entry结构</h3><p><strong><code>prevlen</code><strong>字段表示</strong>上一个数据节点（entry）的长度</strong>，如果长度<strong>小于254</strong>，那么**<code>prevlen</code><strong>字段占用1字节空间；如果长度</strong>大于等于254<strong>，那么该字段需要用5字节空间表示，并且</strong>第一个字节为11111110**，表示这是一个5字节的<code>prevlen</code>信息，剩下的4字节用来表示长度</p>\n<p>⚠️：为什么阈值是254而不是255？这是因为255被用来特殊表示<strong>zlend</strong>字段，标识ZIPLIST结构的结束</p>\n<p><strong><code>encoding</code><strong>字段是一个整形数据，其二进制编码由</strong>内容类型</strong>和<strong>内容数据的字节长度</strong>两部分组成</p>\n<h3 id=\"连锁更新\"><a href=\"#连锁更新\" class=\"headerlink\" title=\"连锁更新\"></a>连锁更新</h3><p>当向一个entry前面插入一个长度超过254的节点时，<code>prevlen</code>字段可能就会由1字节变成5字节，导致本entry长度增大。如果运气不是很好，将会导致下一个节点中的<code>prevlen</code>字段增加，以此类推，造成连锁反应，这就是连锁更新问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081855045.png\" alt=\"image-20241008185552935\"></p>\n<h4 id=\"LISTPACK优化\"><a href=\"#LISTPACK优化\" class=\"headerlink\" title=\"LISTPACK优化\"></a>LISTPACK优化</h4><p><code>prevlen</code>字段正是连锁更新的罪魁祸首，为了解决连锁更新问题，就不能再去记录上一个节点的长度，但又要保证能够实现倒序遍历（找到上一个节点的位置）</p>\n<p>Redis使用了一种巧妙的方法：删除<code>prevlen</code>字段，<strong>新增<code>element-tot-len</code>字段记录整个节点除它（element-tot-len字段）自身之外的长度</strong></p>\n<p>此时节点结构就变成了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;encoding-type&gt; &lt;element-data&gt; &lt;element-top-len&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>encoding-type是编码类型</li>\n<li>element-data是数据内容</li>\n<li>element-top-len所占的每个字节的第一个bit位用于标识是否结束，0则结束，1则继续</li>\n</ul>\n<p>🌰：<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410081903663.png\" alt=\"image-20241008190334625\"></p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>Redi中的set是一个不重复、无序的字符串集合</p>\n<blockquote>\n<p>如果Set底层使用INTSET编码方式，则集合是有序的</p>\n</blockquote>\n<h3 id=\"编码方式\"><a href=\"#编码方式\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3><p>Set底层有两种编码方式：<strong>INTSET、HASHTABLE</strong></p>\n<p>当Set中存储的都是整数并且元素个数少于512个时，则采用INTSET编码方式</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091541699.png\" alt=\"image-20241009154144626\"></p>\n<p>由上图可见，采用INTSET编码，元素排列比较紧凑，内存占用少，但查找时需要使用二分法，时间复杂度为$O(nlogn)$</p>\n<p>如果不满足INTSET编码条件，则需要使用HASHTABLE编码，HASHTABLE查询一个元素性能很高，时间复杂度为$O(1)$</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410091544018.png\" alt=\"image-20241009154437973\"></p>\n<p>简单地概括：</p>\n<ul>\n<li>INTSET编码适用于存储少量整数场景以节约内存空间</li>\n<li>HASHTABLE编码适用于快速定位某个元素的位置</li>\n</ul>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>&#x2F;&#x2F; to do</p>\n<p>panic(“implement me”)</p>\n<h2 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h2><blockquote>\n<p> HAHSTABLE是Redis中的一种底层数据结构</p>\n</blockquote>\n<p>通过HASHTABLE可以在$O(1)$时间复杂度内快速定位到Key对于的Value</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>总所周知，Redis是用C语言实现的。HASHTABLE的C实现涉及到三个结构体：<code>dict</code>、<code>dictht</code>、<code>dicEntry</code></p>\n<p>简单地说，<code>dict</code>封装了两个<code>dictht</code>结构，每一个<code>dictht</code>结构都有一个大小为<code>size</code>的<strong>bucket</strong>，bucket中存放着<code>dicEntry</code>链表。三个结构体之间的关系如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122043279.png\" alt=\"image-20241012204338184\" style=\"zoom:67%;\" />\n\n<p>可以看到dict结构中有两个dictht结构，也就是HASHTABLE结构。dicEntry是链表结构，通过拉链法解决Hash冲突</p>\n<p>接下来，结合源码j解释每一个结构体的字段含义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">    dictType *type; <span class=\"comment\">//直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *privdata; <span class=\"comment\">//私有数据，保存着dictType结构中函数的 参数</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>]; <span class=\"comment\">//两张哈希表</span></span><br><span class=\"line\">    <span class=\"type\">long</span> rehashidx; <span class=\"comment\">//rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一</span></span><br><span class=\"line\">    <span class=\"type\">int</span> itreators;  <span class=\"comment\">//正在迭代的迭代器数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#dict结构中ht[0]、ht[1]哈希表的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span>&#123;</span></span><br><span class=\"line\">    dictEntry[] table;        <span class=\"comment\">//存放一个数组的地址，数组中存放哈希节点dictEntry的地址</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span> size;      <span class=\"comment\">//哈希表table的大小，出始大小为4</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span>  sizemask; <span class=\"comment\">//用于将hash值映射到table位置的索引，大小为（size-1）</span></span><br><span class=\"line\">    unsingned <span class=\"type\">long</span>  used;     <span class=\"comment\">//记录哈希表已有节点（键值对）的数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#哈希表节点结构定义</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntity</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *key;<span class=\"comment\">//键</span></span><br><span class=\"line\">    <span class=\"comment\">//值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//“我之所以要提醒你注意这里，其实是为了说明，这种实现方法是一种节省内存的开发小技巧，非常值得学习。因为当值为整数或双精度浮点数时，由于其本身就是 64 位，就可以不用指针指向了，而是可以直接存在键值对的结构体中，这样就避免了再用一个指针，从而节省了内存空间。”</span></span><br><span class=\"line\">        <span class=\"type\">void</span> *val;<span class=\"comment\">//自定义类型</span></span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> u64;<span class=\"comment\">//无符号整形</span></span><br><span class=\"line\">        <span class=\"type\">int64_t</span> s64;<span class=\"comment\">//符合整形</span></span><br><span class=\"line\">        <span class=\"type\">double</span> d;<span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntity</span> *<span class=\"title\">next</span>;</span><span class=\"comment\">//发生哈希冲突时使用。指向下一个哈希表节点，形成链表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashTable渐进式扩容\"><a href=\"#HashTable渐进式扩容\" class=\"headerlink\" title=\"HashTable渐进式扩容\"></a>HashTable渐进式扩容</h3><p>渐进式扩容，顾名思义就是一点一点扩容容量。相比于一次性扩容大量空间，并进行大量的拷贝工作，渐进式扩容不易导致Redis在一段时间内由于进行扩容工作而无法提供其他服务，用户体验感更好。</p>\n<p>当dict满足扩容条件后，就会进行Rehash操作。Rehash操作大致分为三步：</p>\n<ul>\n<li><p>为<strong>ht[1]<strong>哈希表开辟一块空间，空间大小设定为</strong>第一个大于2 * ht[0]的2整数次幂</strong>。🌰：h[0] &#x3D; 500，那么在进行Rehash操作时开辟的空间为$2^{\\left\\lceil log_2(2*500) \\right\\rceil} &#x3D; 1024$</p>\n</li>\n<li><p>迁移ht[0]数据至ht[1]：在Rehash期间，每次对字典进行增删改查操作，程序会顺带迁移当前<code>rehashidx</code>所指向的数据，并递增下标值。如果当前<code>rehashidx</code>命中了一个空位置，则会先尝试继续往后查找若干位置，如果查询无果就直接返回</p>\n</li>\n<li><p>最终，ht[0]的数据将会全部迁移至ht[1]中。此时，需要交换ht[0]和ht[1]的指针，并将<code>rehash</code>设为-1，表示处于非Rehash状态</p>\n<ul>\n<li>为什么要交换两张哈希表的指针呢？因为ht[0]代表着正在使用的哈希表</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410122114045.png\" alt=\"image-20241012211414978\" style=\"zoom:80%;\" />\n\n<p>⚠️：值得注意的是，在Rehash阶段，由于存在两张哈希表，此时进行的删除、查找、更新操作会在两个表上进行。比如查找元素时，如果ht[0]表没有找到，则会接着查询ht[1]表。但进行插入操作时，只会在ht[1]表上增添数据</p>\n<h3 id=\"扩（缩）容时机\"><a href=\"#扩（缩）容时机\" class=\"headerlink\" title=\"扩（缩）容时机\"></a>扩（缩）容时机</h3><p>HASHTABLE由一个变量——<strong>负载因子</strong>决定是否扩容（缩容）</p>\n<p><strong>负载因子的算法：<code>ht[0].used / ht[0].size</code></strong></p>\n<p><strong>扩容场景：</strong></p>\n<ul>\n<li>负载因子大于等于1并且此时服务器没有执行BGSAVE或BGREWRITEAOF这两个命令</li>\n<li>负载因子大于5</li>\n</ul>\n<p><strong>缩容场景：</strong></p>\n<ul>\n<li>负载因子小于0.1并且没有BGSAVE或BGWRITEAOF命令在执行</li>\n</ul>\n<h2 id=\"SkipList\"><a href=\"#SkipList\" class=\"headerlink\" title=\"SkipList\"></a>SkipList</h2><h2 id=\"跳表的结构\"><a href=\"#跳表的结构\" class=\"headerlink\" title=\"跳表的结构\"></a>跳表的结构</h2><p>跳表是Redis中ZSET的底层数据结构，跳表本质上就是由<strong>链表+多级索引</strong>组成的</p>\n<p>但Redis使用的跳表并非标准跳表，Redis中的跳表在标准跳表基础之上<strong>允许score值重复</strong>以及<strong>0层节点具有向后指针</strong>，如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141047754.png\" alt=\"image-20241014104743623\" style=\"zoom:67%;\" />\n\n<p>其中红色框中的属于同一个节点的不同层级，跳表中节点的数量体现在0层（最底层）节点的个数</p>\n<p>结合源码，分析节点的组成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// from Redis 7.0.8</span></span><br><span class=\"line\"><span class=\"comment\">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    sds ele;</span><br><span class=\"line\">    <span class=\"type\">double</span> score;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>ele</strong>：sds结构，一个被封装过的字符串，本质上是一个char数组，用于存储数据</li>\n<li><strong>score</strong>：双精度浮点数类型，表示该节点的分数，决定了跳表中节点的位置次序</li>\n<li><strong>backward</strong>：指向上一个节点的回退指针</li>\n<li><strong>level</strong>：是一个zskiplistLeve结构体数组，用于表示高层索引。zskiplistLeve结构体包含了两个字段，一个是<strong>forward</strong>，指向同层的下一个索引；另一个是<strong>span</strong>，记录了距离下一个索引（节点）的步长</li>\n</ul>\n<p>示意图：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141101384.png\" alt=\"image-20241014110129253\" style=\"zoom:67%;\" />\n\n<h3 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h3><ul>\n<li><p>Redis<strong>跳表中单个节点的层数</strong>由概率决定。每插入一个节点到0层，Redis决定该节点是否增加一层索引的<strong>概率为25%</strong></p>\n</li>\n<li><p>跳表将纯粹的有序单链表在插入、删除、更新操作从$O(n)$时间复杂度降低至$O(logN)$</p>\n</li>\n</ul>\n<h2 id=\"ZSet\"><a href=\"#ZSet\" class=\"headerlink\" title=\"ZSet\"></a>ZSet</h2><p>Zset也叫Sorted Set即有序集合，是按照元素的分数进行排序的集合。分数相同的情况下，按照元素的字典序进行排序</p>\n<p>ZSet常用于排序集合的场景，最典型的就是<strong>游戏排行榜</strong></p>\n<h3 id=\"编码方式-1\"><a href=\"#编码方式-1\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3><p>ZSet有两种底层编码方式，一种是ZIPLIST，另一种是SKIPLIST+HASHTABLE</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141759086.png\" alt=\"image-20241014175901004\" style=\"zoom:67%;\" />\n\n<p>如果满足下列条件，ZSet就用ZIPLIST编码方式：</p>\n<ul>\n<li>列表对象保存的所有字符串长度均小于64字节</li>\n<li>列表对象保存的元素个数少于128个</li>\n</ul>\n<p>ZIPLIST依旧保持着它的优点，在数据量较少时，十分节约内存空间。当ZSet采用ZIPLIST编码时，底层结构如下图：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410141802693.png\" alt=\"image-20241014180256647\" style=\"zoom:67%;\" />\n\n<p>但凡上述的两个条件有一个不满足，ZSet就采用<strong>SKIPLIST+HASHTABLE</strong>的编码方式。其中，SKIPLIST是一个具有多级索引的有序链表，<strong>可以实现高效的查询、插入、删除操作</strong>。除此之外，Redis还利用HASHTABLE结构实现在$O(1)$时间复杂度下<strong>查询到ZSet中任一成员的<code>score</code>值</strong></p>\n"},{"title":"Redis运行原理","publish":true,"description":"记录Redis运行原理知识","_content":"\n\n\n# Redis运行原理\n\n## Redis在内存中是如何存储的？\n\n简单来说，Redis就是一个运行在内存中的k-v字典。说到k-v字典，很容易联想到Redis底层数据结构**dict(HASHTABLE)**，实际上从C代码中可以看出，Redis数据库就是在**dict**基础上封装了众多功能（~~装饰器模式万岁😆~~）\n\n```c\ntypedef struct redisDB {\n    dict *dict;\n    dict *expires;\n    dict *blocking_keys;\n    dict *ready_keys;\n    dict *watched_keys;\n    int id;\n    long long avg_ttl;\n    list *defrag_later;\n} redisDb;\n```\n\n核心结构**dict**值得重点关心：\n\n```c\ntypedef struct dict{\n    dictType *type; //直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据\n    void *privdata; //私有数据，保存着dictType结构中函数的 参数\n    dictht ht[2]; //两张哈希表\n    long rehashidx; //rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一\n    int itreators;  //正在迭代的迭代器数量\n}\n```\n\n当我们使用Redis存储键值对时，dict字段存储这字符串类型的key以及任意类型的value\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171559595.png\" alt=\"image-20241017155911540\" style=\"zoom:50%;\" />\n\n除了dict字段，expire字段也很重要。众所周知，Redis在存储k-v时可以为键值对设置过期时间，提高Redis对内存的使用效率。expire字典中就存储着具有过期时间的键值对信息，其中key就是键值对的键，而value就是对应的过期时间。具体如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171608652.png\" alt=\"image-20241017160835599\" style=\"zoom: 67%;\" />\n\n可以看到，在dict和expire其实是具有一些相同的key的，Redis为了节省内存开销，实际上并没有存储了两份一模一样的key，而是进行了内存复用操作。什么意思？简单地说，dict字典和expire字典都指向了同一块内存空间的key。🌰：dict中的`animal`执行内存`0xababababa`，expire中的`animal`也指向内存`0xababababa`\n\n## Redis是单线程还是多线程？\n\n先上结论，Redis作为一个能够高效处理数据请求的组件，**主模块使用单线程**；**辅助模块，例如异步操作、网络I/O则使用多线程**\n\n> 为什么Redis主模块不使用多线程？\n\n如果对底层存储有一定了解的话，那么对下面这张图一定不陌生。（[来源](https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409)）\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191118868.png\" alt=\"image-20241019111805677\" style=\"zoom:50%;\" />\n\n我们知道，多线程可以充分利用CPU多核的运算能力，但是对于主要工作内存上的Redis来说，CPU并不是主要的性能瓶颈。由上图我们也可以很容易猜到Redis性能**主要受限于网络IO**。\n\n另一方面，Redis的宗旨是“惜内存如金，简单高效”，引入多线程反而导致项目复杂、不易维护，同时也会带来一定的成本开销。具体有以下几个方面：\n\n- 引入多线程后，Redis为了支持事务的ACID就不得不额外添加一些复杂的操作，甚至需要将原有的数据结构改造成并发安全的\n- 上下文切换成本：CPU在进行线程调度时需要先保存当前线程的上下文数据，再切换到下一个线程\n- 多线程同步机制（加锁、解锁）会引入一定的CPU开销\n- 内存消耗：每一个线程都是占用一定的内存资源的，对于Redis来说，内存资源十分宝贵，能省则省\n\n## 为什么Redis单线程这么快？\n\n我们知道，Redis是单线程处理请求，但是Redis却能做到10w量级的QPS，关键点有以下几个：\n\n- Redis大部分操作都是在内存上完成的，内存操作本身就很快\n- Redis中各式各样的数据结构底层依据不同场景采用不同的编码实现方式，使得Redis在各种场景下都能保持高性能（[来源](https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409)）\n  - ![image-20241019152651588](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191526662.png)\n- Redis采用IO多路复用机制解决网络IO阻塞问题，避免Redis单线程在处理网络请求时频繁发生阻塞，提高了Redis网络吞吐量\n\n>  下面着重讲讲Redis的网络IO多路复用机制\n\n一般地，如果没有IO多路复用，那么Redis是如何处理请求的？\n\n🌰以一个GET请求为例：\n\n1. 客户端发送GET请求，Redis调用**accept**函数与其建立连接\n2. Redis调用**recv**函数从套接字中获取请求\n3. 解析客户端请求，获取参数\n4. Redis处理来自客户端的参数，本例中就是获取key所对应的value\n5. Redis通过**send**函数将结果返回给客户端\n\n![image-20241019154821888](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191548939.png)\n\n由于套接字采用默认阻塞模式，因此Redis在进行**accept和recv**时就有可能出现阻塞，比如accept建立链接时间过长、调用recv后，客户端迟迟没有发送数据，这对单线程的Redis来说是致命的。\n\n于是Redis采用IO多路复用机制解决阻塞问题。在Redis中，将套接字设置成**非阻塞**模式，并且基于系统函数封装了一个**reactor**模型。简单来说，每当有事件发生，reactor模型就通知不同的处理器去处理事件，这样就不会阻塞在某一个操作上，充分利用了CPU\n\n![image-20241019160842167](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191608206.png)\n\n**⚠️：这是仍是并发运行，而非并行**\n\n## 内存淘汰策略\n\n我们知道Redis将所有的数据保存在内存上，但是内存空间是有限的，随着时间的推移，有限的内存空间肯定是不能满足无限的数据。因此，Redis需要采用一些内存淘汰策略将“无用”的数据丢弃，以获得更多的空闲内存空间保存数据。\n\n在Redis中有如下几种内存淘汰策略：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410221850573.png\" alt=\"image-20241022185052519\" style=\"zoom: 50%;\" />\n\n现着重考虑**LRU和LFU**算法\n\n### LRU算法\n\nLRU(Least Recently Used)算法的一般实现就是维护一个按时间戳有序的（双向）链表，每次将链表末尾的节点淘汰，即删除最久未被访问的元素。\n\nRedis采用的是一种近似LRU算法，因为使用正统的LRU算法就意味着需要维护一个包含全局元素的链表，这对于Redis来说成本是巨大的，所以Redis选择一种近似的LRU算法作为内存淘汰策略。\n\nRedis使用的近似LRU算法会维护一个大小为16的淘汰池，下面根据淘汰池是否有空余位置进行分类讨论：\n\n- 当淘汰池未满时，每次从全局随机选取5个元素，放入池子中，然后淘汰池子中**空闲时间最大的元素**\n- 当淘汰池满了，每次从全局随机选取5个元素，但这5个元素只有空闲时间大于池中元素的最小空闲时间的，才会被放入池中。最后将淘汰池中空间时间最大的元素淘汰\n\n","source":"_posts/Redis/Redis运行原理.md","raw":"---\ntitle: Redis运行原理\npublish: true\ndescription: 记录Redis运行原理知识\ntag:\n- Redis\n---\n\n\n\n# Redis运行原理\n\n## Redis在内存中是如何存储的？\n\n简单来说，Redis就是一个运行在内存中的k-v字典。说到k-v字典，很容易联想到Redis底层数据结构**dict(HASHTABLE)**，实际上从C代码中可以看出，Redis数据库就是在**dict**基础上封装了众多功能（~~装饰器模式万岁😆~~）\n\n```c\ntypedef struct redisDB {\n    dict *dict;\n    dict *expires;\n    dict *blocking_keys;\n    dict *ready_keys;\n    dict *watched_keys;\n    int id;\n    long long avg_ttl;\n    list *defrag_later;\n} redisDb;\n```\n\n核心结构**dict**值得重点关心：\n\n```c\ntypedef struct dict{\n    dictType *type; //直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据\n    void *privdata; //私有数据，保存着dictType结构中函数的 参数\n    dictht ht[2]; //两张哈希表\n    long rehashidx; //rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一\n    int itreators;  //正在迭代的迭代器数量\n}\n```\n\n当我们使用Redis存储键值对时，dict字段存储这字符串类型的key以及任意类型的value\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171559595.png\" alt=\"image-20241017155911540\" style=\"zoom:50%;\" />\n\n除了dict字段，expire字段也很重要。众所周知，Redis在存储k-v时可以为键值对设置过期时间，提高Redis对内存的使用效率。expire字典中就存储着具有过期时间的键值对信息，其中key就是键值对的键，而value就是对应的过期时间。具体如下图所示：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171608652.png\" alt=\"image-20241017160835599\" style=\"zoom: 67%;\" />\n\n可以看到，在dict和expire其实是具有一些相同的key的，Redis为了节省内存开销，实际上并没有存储了两份一模一样的key，而是进行了内存复用操作。什么意思？简单地说，dict字典和expire字典都指向了同一块内存空间的key。🌰：dict中的`animal`执行内存`0xababababa`，expire中的`animal`也指向内存`0xababababa`\n\n## Redis是单线程还是多线程？\n\n先上结论，Redis作为一个能够高效处理数据请求的组件，**主模块使用单线程**；**辅助模块，例如异步操作、网络I/O则使用多线程**\n\n> 为什么Redis主模块不使用多线程？\n\n如果对底层存储有一定了解的话，那么对下面这张图一定不陌生。（[来源](https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409)）\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191118868.png\" alt=\"image-20241019111805677\" style=\"zoom:50%;\" />\n\n我们知道，多线程可以充分利用CPU多核的运算能力，但是对于主要工作内存上的Redis来说，CPU并不是主要的性能瓶颈。由上图我们也可以很容易猜到Redis性能**主要受限于网络IO**。\n\n另一方面，Redis的宗旨是“惜内存如金，简单高效”，引入多线程反而导致项目复杂、不易维护，同时也会带来一定的成本开销。具体有以下几个方面：\n\n- 引入多线程后，Redis为了支持事务的ACID就不得不额外添加一些复杂的操作，甚至需要将原有的数据结构改造成并发安全的\n- 上下文切换成本：CPU在进行线程调度时需要先保存当前线程的上下文数据，再切换到下一个线程\n- 多线程同步机制（加锁、解锁）会引入一定的CPU开销\n- 内存消耗：每一个线程都是占用一定的内存资源的，对于Redis来说，内存资源十分宝贵，能省则省\n\n## 为什么Redis单线程这么快？\n\n我们知道，Redis是单线程处理请求，但是Redis却能做到10w量级的QPS，关键点有以下几个：\n\n- Redis大部分操作都是在内存上完成的，内存操作本身就很快\n- Redis中各式各样的数据结构底层依据不同场景采用不同的编码实现方式，使得Redis在各种场景下都能保持高性能（[来源](https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409)）\n  - ![image-20241019152651588](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191526662.png)\n- Redis采用IO多路复用机制解决网络IO阻塞问题，避免Redis单线程在处理网络请求时频繁发生阻塞，提高了Redis网络吞吐量\n\n>  下面着重讲讲Redis的网络IO多路复用机制\n\n一般地，如果没有IO多路复用，那么Redis是如何处理请求的？\n\n🌰以一个GET请求为例：\n\n1. 客户端发送GET请求，Redis调用**accept**函数与其建立连接\n2. Redis调用**recv**函数从套接字中获取请求\n3. 解析客户端请求，获取参数\n4. Redis处理来自客户端的参数，本例中就是获取key所对应的value\n5. Redis通过**send**函数将结果返回给客户端\n\n![image-20241019154821888](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191548939.png)\n\n由于套接字采用默认阻塞模式，因此Redis在进行**accept和recv**时就有可能出现阻塞，比如accept建立链接时间过长、调用recv后，客户端迟迟没有发送数据，这对单线程的Redis来说是致命的。\n\n于是Redis采用IO多路复用机制解决阻塞问题。在Redis中，将套接字设置成**非阻塞**模式，并且基于系统函数封装了一个**reactor**模型。简单来说，每当有事件发生，reactor模型就通知不同的处理器去处理事件，这样就不会阻塞在某一个操作上，充分利用了CPU\n\n![image-20241019160842167](https://raw.githubusercontent.com/lyydsheep/pic/main/202410191608206.png)\n\n**⚠️：这是仍是并发运行，而非并行**\n\n## 内存淘汰策略\n\n我们知道Redis将所有的数据保存在内存上，但是内存空间是有限的，随着时间的推移，有限的内存空间肯定是不能满足无限的数据。因此，Redis需要采用一些内存淘汰策略将“无用”的数据丢弃，以获得更多的空闲内存空间保存数据。\n\n在Redis中有如下几种内存淘汰策略：\n\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410221850573.png\" alt=\"image-20241022185052519\" style=\"zoom: 50%;\" />\n\n现着重考虑**LRU和LFU**算法\n\n### LRU算法\n\nLRU(Least Recently Used)算法的一般实现就是维护一个按时间戳有序的（双向）链表，每次将链表末尾的节点淘汰，即删除最久未被访问的元素。\n\nRedis采用的是一种近似LRU算法，因为使用正统的LRU算法就意味着需要维护一个包含全局元素的链表，这对于Redis来说成本是巨大的，所以Redis选择一种近似的LRU算法作为内存淘汰策略。\n\nRedis使用的近似LRU算法会维护一个大小为16的淘汰池，下面根据淘汰池是否有空余位置进行分类讨论：\n\n- 当淘汰池未满时，每次从全局随机选取5个元素，放入池子中，然后淘汰池子中**空闲时间最大的元素**\n- 当淘汰池满了，每次从全局随机选取5个元素，但这5个元素只有空闲时间大于池中元素的最小空闲时间的，才会被放入池中。最后将淘汰池中空间时间最大的元素淘汰\n\n","slug":"Redis/Redis运行原理","published":1,"date":"2024-12-27T11:03:15.343Z","updated":"2024-12-27T11:03:15.343Z","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6o002sa5t29zbl1235","content":"<h1 id=\"Redis运行原理\"><a href=\"#Redis运行原理\" class=\"headerlink\" title=\"Redis运行原理\"></a>Redis运行原理</h1><h2 id=\"Redis在内存中是如何存储的？\"><a href=\"#Redis在内存中是如何存储的？\" class=\"headerlink\" title=\"Redis在内存中是如何存储的？\"></a>Redis在内存中是如何存储的？</h2><p>简单来说，Redis就是一个运行在内存中的k-v字典。说到k-v字典，很容易联想到Redis底层数据结构<strong>dict(HASHTABLE)<strong>，实际上从C代码中可以看出，Redis数据库就是在</strong>dict</strong>基础上封装了众多功能（<del>装饰器模式万岁😆</del>）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDB</span> &#123;</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    dict *blocking_keys;</span><br><span class=\"line\">    dict *ready_keys;</span><br><span class=\"line\">    dict *watched_keys;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> avg_ttl;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *defrag_later;</span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>核心结构<strong>dict</strong>值得重点关心：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">    dictType *type; <span class=\"comment\">//直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *privdata; <span class=\"comment\">//私有数据，保存着dictType结构中函数的 参数</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>]; <span class=\"comment\">//两张哈希表</span></span><br><span class=\"line\">    <span class=\"type\">long</span> rehashidx; <span class=\"comment\">//rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一</span></span><br><span class=\"line\">    <span class=\"type\">int</span> itreators;  <span class=\"comment\">//正在迭代的迭代器数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们使用Redis存储键值对时，dict字段存储这字符串类型的key以及任意类型的value</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171559595.png\" alt=\"image-20241017155911540\" style=\"zoom:50%;\" />\n\n<p>除了dict字段，expire字段也很重要。众所周知，Redis在存储k-v时可以为键值对设置过期时间，提高Redis对内存的使用效率。expire字典中就存储着具有过期时间的键值对信息，其中key就是键值对的键，而value就是对应的过期时间。具体如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171608652.png\" alt=\"image-20241017160835599\" style=\"zoom: 67%;\" />\n\n<p>可以看到，在dict和expire其实是具有一些相同的key的，Redis为了节省内存开销，实际上并没有存储了两份一模一样的key，而是进行了内存复用操作。什么意思？简单地说，dict字典和expire字典都指向了同一块内存空间的key。🌰：dict中的<code>animal</code>执行内存<code>0xababababa</code>，expire中的<code>animal</code>也指向内存<code>0xababababa</code></p>\n<h2 id=\"Redis是单线程还是多线程？\"><a href=\"#Redis是单线程还是多线程？\" class=\"headerlink\" title=\"Redis是单线程还是多线程？\"></a>Redis是单线程还是多线程？</h2><p>先上结论，Redis作为一个能够高效处理数据请求的组件，<strong>主模块使用单线程</strong>；<strong>辅助模块，例如异步操作、网络I&#x2F;O则使用多线程</strong></p>\n<blockquote>\n<p>为什么Redis主模块不使用多线程？</p>\n</blockquote>\n<p>如果对底层存储有一定了解的话，那么对下面这张图一定不陌生。（<a href=\"https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409\">来源</a>）</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191118868.png\" alt=\"image-20241019111805677\" style=\"zoom:50%;\" />\n\n<p>我们知道，多线程可以充分利用CPU多核的运算能力，但是对于主要工作内存上的Redis来说，CPU并不是主要的性能瓶颈。由上图我们也可以很容易猜到Redis性能<strong>主要受限于网络IO</strong>。</p>\n<p>另一方面，Redis的宗旨是“惜内存如金，简单高效”，引入多线程反而导致项目复杂、不易维护，同时也会带来一定的成本开销。具体有以下几个方面：</p>\n<ul>\n<li>引入多线程后，Redis为了支持事务的ACID就不得不额外添加一些复杂的操作，甚至需要将原有的数据结构改造成并发安全的</li>\n<li>上下文切换成本：CPU在进行线程调度时需要先保存当前线程的上下文数据，再切换到下一个线程</li>\n<li>多线程同步机制（加锁、解锁）会引入一定的CPU开销</li>\n<li>内存消耗：每一个线程都是占用一定的内存资源的，对于Redis来说，内存资源十分宝贵，能省则省</li>\n</ul>\n<h2 id=\"为什么Redis单线程这么快？\"><a href=\"#为什么Redis单线程这么快？\" class=\"headerlink\" title=\"为什么Redis单线程这么快？\"></a>为什么Redis单线程这么快？</h2><p>我们知道，Redis是单线程处理请求，但是Redis却能做到10w量级的QPS，关键点有以下几个：</p>\n<ul>\n<li>Redis大部分操作都是在内存上完成的，内存操作本身就很快</li>\n<li>Redis中各式各样的数据结构底层依据不同场景采用不同的编码实现方式，使得Redis在各种场景下都能保持高性能（<a href=\"https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409\">来源</a>）<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191526662.png\" alt=\"image-20241019152651588\"></li>\n</ul>\n</li>\n<li>Redis采用IO多路复用机制解决网络IO阻塞问题，避免Redis单线程在处理网络请求时频繁发生阻塞，提高了Redis网络吞吐量</li>\n</ul>\n<blockquote>\n<p> 下面着重讲讲Redis的网络IO多路复用机制</p>\n</blockquote>\n<p>一般地，如果没有IO多路复用，那么Redis是如何处理请求的？</p>\n<p>🌰以一个GET请求为例：</p>\n<ol>\n<li>客户端发送GET请求，Redis调用<strong>accept</strong>函数与其建立连接</li>\n<li>Redis调用<strong>recv</strong>函数从套接字中获取请求</li>\n<li>解析客户端请求，获取参数</li>\n<li>Redis处理来自客户端的参数，本例中就是获取key所对应的value</li>\n<li>Redis通过<strong>send</strong>函数将结果返回给客户端</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191548939.png\" alt=\"image-20241019154821888\"></p>\n<p>由于套接字采用默认阻塞模式，因此Redis在进行<strong>accept和recv</strong>时就有可能出现阻塞，比如accept建立链接时间过长、调用recv后，客户端迟迟没有发送数据，这对单线程的Redis来说是致命的。</p>\n<p>于是Redis采用IO多路复用机制解决阻塞问题。在Redis中，将套接字设置成<strong>非阻塞</strong>模式，并且基于系统函数封装了一个<strong>reactor</strong>模型。简单来说，每当有事件发生，reactor模型就通知不同的处理器去处理事件，这样就不会阻塞在某一个操作上，充分利用了CPU</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191608206.png\" alt=\"image-20241019160842167\"></p>\n<p><strong>⚠️：这是仍是并发运行，而非并行</strong></p>\n<h2 id=\"内存淘汰策略\"><a href=\"#内存淘汰策略\" class=\"headerlink\" title=\"内存淘汰策略\"></a>内存淘汰策略</h2><p>我们知道Redis将所有的数据保存在内存上，但是内存空间是有限的，随着时间的推移，有限的内存空间肯定是不能满足无限的数据。因此，Redis需要采用一些内存淘汰策略将“无用”的数据丢弃，以获得更多的空闲内存空间保存数据。</p>\n<p>在Redis中有如下几种内存淘汰策略：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410221850573.png\" alt=\"image-20241022185052519\" style=\"zoom: 50%;\" />\n\n<p>现着重考虑<strong>LRU和LFU</strong>算法</p>\n<h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><p>LRU(Least Recently Used)算法的一般实现就是维护一个按时间戳有序的（双向）链表，每次将链表末尾的节点淘汰，即删除最久未被访问的元素。</p>\n<p>Redis采用的是一种近似LRU算法，因为使用正统的LRU算法就意味着需要维护一个包含全局元素的链表，这对于Redis来说成本是巨大的，所以Redis选择一种近似的LRU算法作为内存淘汰策略。</p>\n<p>Redis使用的近似LRU算法会维护一个大小为16的淘汰池，下面根据淘汰池是否有空余位置进行分类讨论：</p>\n<ul>\n<li>当淘汰池未满时，每次从全局随机选取5个元素，放入池子中，然后淘汰池子中<strong>空闲时间最大的元素</strong></li>\n<li>当淘汰池满了，每次从全局随机选取5个元素，但这5个元素只有空闲时间大于池中元素的最小空闲时间的，才会被放入池中。最后将淘汰池中空间时间最大的元素淘汰</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Redis运行原理\"><a href=\"#Redis运行原理\" class=\"headerlink\" title=\"Redis运行原理\"></a>Redis运行原理</h1><h2 id=\"Redis在内存中是如何存储的？\"><a href=\"#Redis在内存中是如何存储的？\" class=\"headerlink\" title=\"Redis在内存中是如何存储的？\"></a>Redis在内存中是如何存储的？</h2><p>简单来说，Redis就是一个运行在内存中的k-v字典。说到k-v字典，很容易联想到Redis底层数据结构<strong>dict(HASHTABLE)<strong>，实际上从C代码中可以看出，Redis数据库就是在</strong>dict</strong>基础上封装了众多功能（<del>装饰器模式万岁😆</del>）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDB</span> &#123;</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    dict *blocking_keys;</span><br><span class=\"line\">    dict *ready_keys;</span><br><span class=\"line\">    dict *watched_keys;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> avg_ttl;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *defrag_later;</span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>核心结构<strong>dict</strong>值得重点关心：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">    dictType *type; <span class=\"comment\">//直线dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *privdata; <span class=\"comment\">//私有数据，保存着dictType结构中函数的 参数</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>]; <span class=\"comment\">//两张哈希表</span></span><br><span class=\"line\">    <span class=\"type\">long</span> rehashidx; <span class=\"comment\">//rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一</span></span><br><span class=\"line\">    <span class=\"type\">int</span> itreators;  <span class=\"comment\">//正在迭代的迭代器数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们使用Redis存储键值对时，dict字段存储这字符串类型的key以及任意类型的value</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171559595.png\" alt=\"image-20241017155911540\" style=\"zoom:50%;\" />\n\n<p>除了dict字段，expire字段也很重要。众所周知，Redis在存储k-v时可以为键值对设置过期时间，提高Redis对内存的使用效率。expire字典中就存储着具有过期时间的键值对信息，其中key就是键值对的键，而value就是对应的过期时间。具体如下图所示：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410171608652.png\" alt=\"image-20241017160835599\" style=\"zoom: 67%;\" />\n\n<p>可以看到，在dict和expire其实是具有一些相同的key的，Redis为了节省内存开销，实际上并没有存储了两份一模一样的key，而是进行了内存复用操作。什么意思？简单地说，dict字典和expire字典都指向了同一块内存空间的key。🌰：dict中的<code>animal</code>执行内存<code>0xababababa</code>，expire中的<code>animal</code>也指向内存<code>0xababababa</code></p>\n<h2 id=\"Redis是单线程还是多线程？\"><a href=\"#Redis是单线程还是多线程？\" class=\"headerlink\" title=\"Redis是单线程还是多线程？\"></a>Redis是单线程还是多线程？</h2><p>先上结论，Redis作为一个能够高效处理数据请求的组件，<strong>主模块使用单线程</strong>；<strong>辅助模块，例如异步操作、网络I&#x2F;O则使用多线程</strong></p>\n<blockquote>\n<p>为什么Redis主模块不使用多线程？</p>\n</blockquote>\n<p>如果对底层存储有一定了解的话，那么对下面这张图一定不陌生。（<a href=\"https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409\">来源</a>）</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191118868.png\" alt=\"image-20241019111805677\" style=\"zoom:50%;\" />\n\n<p>我们知道，多线程可以充分利用CPU多核的运算能力，但是对于主要工作内存上的Redis来说，CPU并不是主要的性能瓶颈。由上图我们也可以很容易猜到Redis性能<strong>主要受限于网络IO</strong>。</p>\n<p>另一方面，Redis的宗旨是“惜内存如金，简单高效”，引入多线程反而导致项目复杂、不易维护，同时也会带来一定的成本开销。具体有以下几个方面：</p>\n<ul>\n<li>引入多线程后，Redis为了支持事务的ACID就不得不额外添加一些复杂的操作，甚至需要将原有的数据结构改造成并发安全的</li>\n<li>上下文切换成本：CPU在进行线程调度时需要先保存当前线程的上下文数据，再切换到下一个线程</li>\n<li>多线程同步机制（加锁、解锁）会引入一定的CPU开销</li>\n<li>内存消耗：每一个线程都是占用一定的内存资源的，对于Redis来说，内存资源十分宝贵，能省则省</li>\n</ul>\n<h2 id=\"为什么Redis单线程这么快？\"><a href=\"#为什么Redis单线程这么快？\" class=\"headerlink\" title=\"为什么Redis单线程这么快？\"></a>为什么Redis单线程这么快？</h2><p>我们知道，Redis是单线程处理请求，但是Redis却能做到10w量级的QPS，关键点有以下几个：</p>\n<ul>\n<li>Redis大部分操作都是在内存上完成的，内存操作本身就很快</li>\n<li>Redis中各式各样的数据结构底层依据不同场景采用不同的编码实现方式，使得Redis在各种场景下都能保持高性能（<a href=\"https://www.toutiao.com/article/7204821418587144736/?wid=1729307852409\">来源</a>）<ul>\n<li><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191526662.png\" alt=\"image-20241019152651588\"></li>\n</ul>\n</li>\n<li>Redis采用IO多路复用机制解决网络IO阻塞问题，避免Redis单线程在处理网络请求时频繁发生阻塞，提高了Redis网络吞吐量</li>\n</ul>\n<blockquote>\n<p> 下面着重讲讲Redis的网络IO多路复用机制</p>\n</blockquote>\n<p>一般地，如果没有IO多路复用，那么Redis是如何处理请求的？</p>\n<p>🌰以一个GET请求为例：</p>\n<ol>\n<li>客户端发送GET请求，Redis调用<strong>accept</strong>函数与其建立连接</li>\n<li>Redis调用<strong>recv</strong>函数从套接字中获取请求</li>\n<li>解析客户端请求，获取参数</li>\n<li>Redis处理来自客户端的参数，本例中就是获取key所对应的value</li>\n<li>Redis通过<strong>send</strong>函数将结果返回给客户端</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191548939.png\" alt=\"image-20241019154821888\"></p>\n<p>由于套接字采用默认阻塞模式，因此Redis在进行<strong>accept和recv</strong>时就有可能出现阻塞，比如accept建立链接时间过长、调用recv后，客户端迟迟没有发送数据，这对单线程的Redis来说是致命的。</p>\n<p>于是Redis采用IO多路复用机制解决阻塞问题。在Redis中，将套接字设置成<strong>非阻塞</strong>模式，并且基于系统函数封装了一个<strong>reactor</strong>模型。简单来说，每当有事件发生，reactor模型就通知不同的处理器去处理事件，这样就不会阻塞在某一个操作上，充分利用了CPU</p>\n<p><img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410191608206.png\" alt=\"image-20241019160842167\"></p>\n<p><strong>⚠️：这是仍是并发运行，而非并行</strong></p>\n<h2 id=\"内存淘汰策略\"><a href=\"#内存淘汰策略\" class=\"headerlink\" title=\"内存淘汰策略\"></a>内存淘汰策略</h2><p>我们知道Redis将所有的数据保存在内存上，但是内存空间是有限的，随着时间的推移，有限的内存空间肯定是不能满足无限的数据。因此，Redis需要采用一些内存淘汰策略将“无用”的数据丢弃，以获得更多的空闲内存空间保存数据。</p>\n<p>在Redis中有如下几种内存淘汰策略：</p>\n<img src=\"https://raw.githubusercontent.com/lyydsheep/pic/main/202410221850573.png\" alt=\"image-20241022185052519\" style=\"zoom: 50%;\" />\n\n<p>现着重考虑<strong>LRU和LFU</strong>算法</p>\n<h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><p>LRU(Least Recently Used)算法的一般实现就是维护一个按时间戳有序的（双向）链表，每次将链表末尾的节点淘汰，即删除最久未被访问的元素。</p>\n<p>Redis采用的是一种近似LRU算法，因为使用正统的LRU算法就意味着需要维护一个包含全局元素的链表，这对于Redis来说成本是巨大的，所以Redis选择一种近似的LRU算法作为内存淘汰策略。</p>\n<p>Redis使用的近似LRU算法会维护一个大小为16的淘汰池，下面根据淘汰池是否有空余位置进行分类讨论：</p>\n<ul>\n<li>当淘汰池未满时，每次从全局随机选取5个元素，放入池子中，然后淘汰池子中<strong>空闲时间最大的元素</strong></li>\n<li>当淘汰池满了，每次从全局随机选取5个元素，但这5个元素只有空闲时间大于池中元素的最小空闲时间的，才会被放入池中。最后将淘汰池中空间时间最大的元素淘汰</li>\n</ul>\n"},{"_content":"## MySQL\n- 水平分表有哪些主流方式？分别有哪些优缺点以及使用场景？应对业务量扩增，哪种分表方式比较好？\n\t- 范围分片\n\t\t- 类型\n\t\t\t- 时间分片\n\t\t\t- 地域分片\n\t\t\t- 大小分片\n\t\t- 优点\n\t\t\t- 单表数据量可控\n\t\t\t- 水平扩展只需增加节点就行，不需要对其他分片数据进行迁移\n\t\t- 缺点\n\t\t\t- 某些分片可能存在连续的热点数据，导致数据倾斜，数据库压力分摊不均\n\t- hash分片\n\t\t- 优点\n\t\t\t- 数据分布比较均匀，不会出现大量大量请求落在一个数据库上\n\t\t- 缺点\n\t\t\t- 在集群的伸缩性上有一定的局限\n\t\t- 改进\n\t\t\t- 使用一致性哈希算法，避免大量地数据迁移\n\t- 查表分片\n\t\t- 优点\n\t\t\t- 灵活性高\n\t\t- 缺点\n\t\t\t- 对数据量有一定限制\n\t- 日志：数据量大、范围属性明显 ---> 范围分片\n\t- SaaS、玩家数据：数量不大、分片维度多、频繁调整分片策略 ---> 查表分片\n\t- 社交平台：数据量大、分布相对均匀 ---> hash分片\n\t\n- 有哪些情况会导致主从延迟？\n- 从库的重放可以并发执行吗？\n\n## Go\n- Go接口主要用于解决什么问题？interface底层原理？\n- GMP调度模型？为什么要有这个P？协程调度和线程调度的区别？\n\n\n## 计算机网络\n- tcp怎么保证可靠性？","source":"_posts/interview experience/其他.md","raw":"## MySQL\n- 水平分表有哪些主流方式？分别有哪些优缺点以及使用场景？应对业务量扩增，哪种分表方式比较好？\n\t- 范围分片\n\t\t- 类型\n\t\t\t- 时间分片\n\t\t\t- 地域分片\n\t\t\t- 大小分片\n\t\t- 优点\n\t\t\t- 单表数据量可控\n\t\t\t- 水平扩展只需增加节点就行，不需要对其他分片数据进行迁移\n\t\t- 缺点\n\t\t\t- 某些分片可能存在连续的热点数据，导致数据倾斜，数据库压力分摊不均\n\t- hash分片\n\t\t- 优点\n\t\t\t- 数据分布比较均匀，不会出现大量大量请求落在一个数据库上\n\t\t- 缺点\n\t\t\t- 在集群的伸缩性上有一定的局限\n\t\t- 改进\n\t\t\t- 使用一致性哈希算法，避免大量地数据迁移\n\t- 查表分片\n\t\t- 优点\n\t\t\t- 灵活性高\n\t\t- 缺点\n\t\t\t- 对数据量有一定限制\n\t- 日志：数据量大、范围属性明显 ---> 范围分片\n\t- SaaS、玩家数据：数量不大、分片维度多、频繁调整分片策略 ---> 查表分片\n\t- 社交平台：数据量大、分布相对均匀 ---> hash分片\n\t\n- 有哪些情况会导致主从延迟？\n- 从库的重放可以并发执行吗？\n\n## Go\n- Go接口主要用于解决什么问题？interface底层原理？\n- GMP调度模型？为什么要有这个P？协程调度和线程调度的区别？\n\n\n## 计算机网络\n- tcp怎么保证可靠性？","slug":"interview experience/其他","published":1,"date":"2025-01-16T12:23:34.969Z","updated":"2025-01-17T02:49:03.403Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6o002ua5t225vc42ay","content":"<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><ul>\n<li><p>水平分表有哪些主流方式？分别有哪些优缺点以及使用场景？应对业务量扩增，哪种分表方式比较好？</p>\n<ul>\n<li>范围分片<ul>\n<li>类型<ul>\n<li>时间分片</li>\n<li>地域分片</li>\n<li>大小分片</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>单表数据量可控</li>\n<li>水平扩展只需增加节点就行，不需要对其他分片数据进行迁移</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>某些分片可能存在连续的热点数据，导致数据倾斜，数据库压力分摊不均</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>hash分片<ul>\n<li>优点<ul>\n<li>数据分布比较均匀，不会出现大量大量请求落在一个数据库上</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在集群的伸缩性上有一定的局限</li>\n</ul>\n</li>\n<li>改进<ul>\n<li>使用一致性哈希算法，避免大量地数据迁移</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>查表分片<ul>\n<li>优点<ul>\n<li>灵活性高</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>对数据量有一定限制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>日志：数据量大、范围属性明显 —&gt; 范围分片</li>\n<li>SaaS、玩家数据：数量不大、分片维度多、频繁调整分片策略 —&gt; 查表分片</li>\n<li>社交平台：数据量大、分布相对均匀 —&gt; hash分片</li>\n</ul>\n</li>\n<li><p>有哪些情况会导致主从延迟？</p>\n</li>\n<li><p>从库的重放可以并发执行吗？</p>\n</li>\n</ul>\n<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><ul>\n<li>Go接口主要用于解决什么问题？interface底层原理？</li>\n<li>GMP调度模型？为什么要有这个P？协程调度和线程调度的区别？</li>\n</ul>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li>tcp怎么保证可靠性？</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><ul>\n<li><p>水平分表有哪些主流方式？分别有哪些优缺点以及使用场景？应对业务量扩增，哪种分表方式比较好？</p>\n<ul>\n<li>范围分片<ul>\n<li>类型<ul>\n<li>时间分片</li>\n<li>地域分片</li>\n<li>大小分片</li>\n</ul>\n</li>\n<li>优点<ul>\n<li>单表数据量可控</li>\n<li>水平扩展只需增加节点就行，不需要对其他分片数据进行迁移</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>某些分片可能存在连续的热点数据，导致数据倾斜，数据库压力分摊不均</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>hash分片<ul>\n<li>优点<ul>\n<li>数据分布比较均匀，不会出现大量大量请求落在一个数据库上</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>在集群的伸缩性上有一定的局限</li>\n</ul>\n</li>\n<li>改进<ul>\n<li>使用一致性哈希算法，避免大量地数据迁移</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>查表分片<ul>\n<li>优点<ul>\n<li>灵活性高</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>对数据量有一定限制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>日志：数据量大、范围属性明显 —&gt; 范围分片</li>\n<li>SaaS、玩家数据：数量不大、分片维度多、频繁调整分片策略 —&gt; 查表分片</li>\n<li>社交平台：数据量大、分布相对均匀 —&gt; hash分片</li>\n</ul>\n</li>\n<li><p>有哪些情况会导致主从延迟？</p>\n</li>\n<li><p>从库的重放可以并发执行吗？</p>\n</li>\n</ul>\n<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><ul>\n<li>Go接口主要用于解决什么问题？interface底层原理？</li>\n<li>GMP调度模型？为什么要有这个P？协程调度和线程调度的区别？</li>\n</ul>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li>tcp怎么保证可靠性？</li>\n</ul>\n"},{"_content":"## Go\n\n\n## 算法\n\n\n## Redis\n\n\n## MySQL\n\n\n## 操作系统\n\n\n## 计算机网络\n\n- 加入手机上登入了飞书，想在PC端进行扫码登录，过程是怎样的？\n-  服务端怎么知道扫码后，应该登入哪个账号？\n\t- [扫码登录流程](https://arcstack.top/md/interview/advance/advance/system-design/1-scan-code-login.html)\n\t- 飞书 --> 系统设计资料\n- 介绍一下WebSoket的原理\n\t- [WebSoket原理](https://juejin.cn/post/7086021621542027271)\n- 为什么HTTPS是安全的？\n\t- HTTPS通过TLS协议对数据进行加密，提供更高的安全性和数据保护\n- TLS握手过程中，服务端的证书是怎么验证的？\n\t- 客户端使用证书中的签名算法对证书进行哈希计算，获得签名\n\t- 客户端使用CA公钥对加密的签名解密，获取签名\n\t- 比较两个签名是否一致\n- URL长度有限制吗？限制是多少？为什么要有限制？\n\t- 有，不同的浏览器对URL长度的限制不同\n\t- 性能考虑：过长的URL在网络传输过程中会占用较多的网络带宽和服务器资源\n\t- 程序：与URL处理相关的内部缓冲区大小有限，过长的URL可能会造成缓冲区溢出，导致程序崩溃","source":"_posts/interview experience/字节跳动.md","raw":"## Go\n\n\n## 算法\n\n\n## Redis\n\n\n## MySQL\n\n\n## 操作系统\n\n\n## 计算机网络\n\n- 加入手机上登入了飞书，想在PC端进行扫码登录，过程是怎样的？\n-  服务端怎么知道扫码后，应该登入哪个账号？\n\t- [扫码登录流程](https://arcstack.top/md/interview/advance/advance/system-design/1-scan-code-login.html)\n\t- 飞书 --> 系统设计资料\n- 介绍一下WebSoket的原理\n\t- [WebSoket原理](https://juejin.cn/post/7086021621542027271)\n- 为什么HTTPS是安全的？\n\t- HTTPS通过TLS协议对数据进行加密，提供更高的安全性和数据保护\n- TLS握手过程中，服务端的证书是怎么验证的？\n\t- 客户端使用证书中的签名算法对证书进行哈希计算，获得签名\n\t- 客户端使用CA公钥对加密的签名解密，获取签名\n\t- 比较两个签名是否一致\n- URL长度有限制吗？限制是多少？为什么要有限制？\n\t- 有，不同的浏览器对URL长度的限制不同\n\t- 性能考虑：过长的URL在网络传输过程中会占用较多的网络带宽和服务器资源\n\t- 程序：与URL处理相关的内部缓冲区大小有限，过长的URL可能会造成缓冲区溢出，导致程序崩溃","slug":"interview experience/字节跳动","published":1,"date":"2025-01-12T01:25:51.005Z","updated":"2025-01-19T07:06:55.166Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6o0030a5t20qef5jb3","content":"<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li>加入手机上登入了飞书，想在PC端进行扫码登录，过程是怎样的？</li>\n<li>服务端怎么知道扫码后，应该登入哪个账号？<ul>\n<li><a href=\"https://arcstack.top/md/interview/advance/advance/system-design/1-scan-code-login.html\">扫码登录流程</a></li>\n<li>飞书 –&gt; 系统设计资料</li>\n</ul>\n</li>\n<li>介绍一下WebSoket的原理<ul>\n<li><a href=\"https://juejin.cn/post/7086021621542027271\">WebSoket原理</a></li>\n</ul>\n</li>\n<li>为什么HTTPS是安全的？<ul>\n<li>HTTPS通过TLS协议对数据进行加密，提供更高的安全性和数据保护</li>\n</ul>\n</li>\n<li>TLS握手过程中，服务端的证书是怎么验证的？<ul>\n<li>客户端使用证书中的签名算法对证书进行哈希计算，获得签名</li>\n<li>客户端使用CA公钥对加密的签名解密，获取签名</li>\n<li>比较两个签名是否一致</li>\n</ul>\n</li>\n<li>URL长度有限制吗？限制是多少？为什么要有限制？<ul>\n<li>有，不同的浏览器对URL长度的限制不同</li>\n<li>性能考虑：过长的URL在网络传输过程中会占用较多的网络带宽和服务器资源</li>\n<li>程序：与URL处理相关的内部缓冲区大小有限，过长的URL可能会造成缓冲区溢出，导致程序崩溃</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li>加入手机上登入了飞书，想在PC端进行扫码登录，过程是怎样的？</li>\n<li>服务端怎么知道扫码后，应该登入哪个账号？<ul>\n<li><a href=\"https://arcstack.top/md/interview/advance/advance/system-design/1-scan-code-login.html\">扫码登录流程</a></li>\n<li>飞书 –&gt; 系统设计资料</li>\n</ul>\n</li>\n<li>介绍一下WebSoket的原理<ul>\n<li><a href=\"https://juejin.cn/post/7086021621542027271\">WebSoket原理</a></li>\n</ul>\n</li>\n<li>为什么HTTPS是安全的？<ul>\n<li>HTTPS通过TLS协议对数据进行加密，提供更高的安全性和数据保护</li>\n</ul>\n</li>\n<li>TLS握手过程中，服务端的证书是怎么验证的？<ul>\n<li>客户端使用证书中的签名算法对证书进行哈希计算，获得签名</li>\n<li>客户端使用CA公钥对加密的签名解密，获取签名</li>\n<li>比较两个签名是否一致</li>\n</ul>\n</li>\n<li>URL长度有限制吗？限制是多少？为什么要有限制？<ul>\n<li>有，不同的浏览器对URL长度的限制不同</li>\n<li>性能考虑：过长的URL在网络传输过程中会占用较多的网络带宽和服务器资源</li>\n<li>程序：与URL处理相关的内部缓冲区大小有限，过长的URL可能会造成缓冲区溢出，导致程序崩溃</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"## Go\n\n\n## 算法\n\n\n## Redis\n- Redis基本数据类型\n\t- String、Set、ZSet、字典、List\n- 字符串底层的实现？\n\t- 字符串底层是一个String对象，有三种编码方式：INT、EMBSTR、RAW。如果是存储一个long的整数，那么使用INT型编码；如果是存字符串且字符串长度小于一定阈值，那么就用EMBSTR编码，否则就用RAW编码\n- ZSet的底层实现？\n\t- ZSet底层提供了两种编码方式：ziplist编码或者是skiplist + 字典\n\t- 当ZSet中的元素个数小于128并且，所有元素的长度小于64字节，那么就使用ziplist编码方式，否则采用skip list + 字典的编码方式\n- Redis持久化方式？\n\t- AOF或RDB\n- Redis内存满了怎么办？\n\t- 看是否开启了内存淘汰策略\n\t\t- 没有开启内存淘汰策略：如果此时内存满了，写入操作就会失败，但是不会淘汰已有的数据\n\t\t- 开启内存淘汰策略：按照规则进行淘汰\n\t\t\t- 分为两大类，一个是基于有过期时间的数据淘汰策略，另一个是针对全局数据的淘汰策略。这两种都支持LRU、LFU、Random算法，其中基于过期时间的还支持根据ttl大小淘汰\n- Redis缓存穿透是什么？如何解决？\n- 缓存击穿呢？\n- 使用Redis一个for循环，每次都去getRedis(key)，怎么去优化？\n\t- mget命令，批量读取\n\t- lua脚本\n- 分布式锁还有哪些实现方式？**（优化夜市，待学习）**\n- Redis是如何实现高可用的？\n- 了解一致性哈希吗？**（待学习）**\n\n\n## MySQL\n- 你知道哪些分库分表的设计吗？\n- 分布式事务的解决方式？（待学习）\n- 分库分表下的数据迁移？（分库分表的问题夜市）\n\t- 从库方案\n\t- 双写方案\n- 全局ID实现方式\n\t- 雪花\n\t- leaf\n\t- uuid\n\t- MySQL、Redis\n\n\n\n## 操作系统\n\n\n## 计算机网络\n","source":"_posts/interview experience/阿里巴巴.md","raw":"## Go\n\n\n## 算法\n\n\n## Redis\n- Redis基本数据类型\n\t- String、Set、ZSet、字典、List\n- 字符串底层的实现？\n\t- 字符串底层是一个String对象，有三种编码方式：INT、EMBSTR、RAW。如果是存储一个long的整数，那么使用INT型编码；如果是存字符串且字符串长度小于一定阈值，那么就用EMBSTR编码，否则就用RAW编码\n- ZSet的底层实现？\n\t- ZSet底层提供了两种编码方式：ziplist编码或者是skiplist + 字典\n\t- 当ZSet中的元素个数小于128并且，所有元素的长度小于64字节，那么就使用ziplist编码方式，否则采用skip list + 字典的编码方式\n- Redis持久化方式？\n\t- AOF或RDB\n- Redis内存满了怎么办？\n\t- 看是否开启了内存淘汰策略\n\t\t- 没有开启内存淘汰策略：如果此时内存满了，写入操作就会失败，但是不会淘汰已有的数据\n\t\t- 开启内存淘汰策略：按照规则进行淘汰\n\t\t\t- 分为两大类，一个是基于有过期时间的数据淘汰策略，另一个是针对全局数据的淘汰策略。这两种都支持LRU、LFU、Random算法，其中基于过期时间的还支持根据ttl大小淘汰\n- Redis缓存穿透是什么？如何解决？\n- 缓存击穿呢？\n- 使用Redis一个for循环，每次都去getRedis(key)，怎么去优化？\n\t- mget命令，批量读取\n\t- lua脚本\n- 分布式锁还有哪些实现方式？**（优化夜市，待学习）**\n- Redis是如何实现高可用的？\n- 了解一致性哈希吗？**（待学习）**\n\n\n## MySQL\n- 你知道哪些分库分表的设计吗？\n- 分布式事务的解决方式？（待学习）\n- 分库分表下的数据迁移？（分库分表的问题夜市）\n\t- 从库方案\n\t- 双写方案\n- 全局ID实现方式\n\t- 雪花\n\t- leaf\n\t- uuid\n\t- MySQL、Redis\n\n\n\n## 操作系统\n\n\n## 计算机网络\n","slug":"interview experience/阿里巴巴","published":1,"date":"2025-01-19T07:13:49.096Z","updated":"2025-01-20T14:29:55.728Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm6c7md6o0031a5t2a2m28sev","content":"<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><ul>\n<li>Redis基本数据类型<ul>\n<li>String、Set、ZSet、字典、List</li>\n</ul>\n</li>\n<li>字符串底层的实现？<ul>\n<li>字符串底层是一个String对象，有三种编码方式：INT、EMBSTR、RAW。如果是存储一个long的整数，那么使用INT型编码；如果是存字符串且字符串长度小于一定阈值，那么就用EMBSTR编码，否则就用RAW编码</li>\n</ul>\n</li>\n<li>ZSet的底层实现？<ul>\n<li>ZSet底层提供了两种编码方式：ziplist编码或者是skiplist + 字典</li>\n<li>当ZSet中的元素个数小于128并且，所有元素的长度小于64字节，那么就使用ziplist编码方式，否则采用skip list + 字典的编码方式</li>\n</ul>\n</li>\n<li>Redis持久化方式？<ul>\n<li>AOF或RDB</li>\n</ul>\n</li>\n<li>Redis内存满了怎么办？<ul>\n<li>看是否开启了内存淘汰策略<ul>\n<li>没有开启内存淘汰策略：如果此时内存满了，写入操作就会失败，但是不会淘汰已有的数据</li>\n<li>开启内存淘汰策略：按照规则进行淘汰<ul>\n<li>分为两大类，一个是基于有过期时间的数据淘汰策略，另一个是针对全局数据的淘汰策略。这两种都支持LRU、LFU、Random算法，其中基于过期时间的还支持根据ttl大小淘汰</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Redis缓存穿透是什么？如何解决？</li>\n<li>缓存击穿呢？</li>\n<li>使用Redis一个for循环，每次都去getRedis(key)，怎么去优化？<ul>\n<li>mget命令，批量读取</li>\n<li>lua脚本</li>\n</ul>\n</li>\n<li>分布式锁还有哪些实现方式？<strong>（优化夜市，待学习）</strong></li>\n<li>Redis是如何实现高可用的？</li>\n<li>了解一致性哈希吗？<strong>（待学习）</strong></li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><ul>\n<li>你知道哪些分库分表的设计吗？</li>\n<li>分布式事务的解决方式？（待学习）</li>\n<li>分库分表下的数据迁移？（分库分表的问题夜市）<ul>\n<li>从库方案</li>\n<li>双写方案</li>\n</ul>\n</li>\n<li>全局ID实现方式<ul>\n<li>雪花</li>\n<li>leaf</li>\n<li>uuid</li>\n<li>MySQL、Redis</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2>","excerpt":"","more":"<h2 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><ul>\n<li>Redis基本数据类型<ul>\n<li>String、Set、ZSet、字典、List</li>\n</ul>\n</li>\n<li>字符串底层的实现？<ul>\n<li>字符串底层是一个String对象，有三种编码方式：INT、EMBSTR、RAW。如果是存储一个long的整数，那么使用INT型编码；如果是存字符串且字符串长度小于一定阈值，那么就用EMBSTR编码，否则就用RAW编码</li>\n</ul>\n</li>\n<li>ZSet的底层实现？<ul>\n<li>ZSet底层提供了两种编码方式：ziplist编码或者是skiplist + 字典</li>\n<li>当ZSet中的元素个数小于128并且，所有元素的长度小于64字节，那么就使用ziplist编码方式，否则采用skip list + 字典的编码方式</li>\n</ul>\n</li>\n<li>Redis持久化方式？<ul>\n<li>AOF或RDB</li>\n</ul>\n</li>\n<li>Redis内存满了怎么办？<ul>\n<li>看是否开启了内存淘汰策略<ul>\n<li>没有开启内存淘汰策略：如果此时内存满了，写入操作就会失败，但是不会淘汰已有的数据</li>\n<li>开启内存淘汰策略：按照规则进行淘汰<ul>\n<li>分为两大类，一个是基于有过期时间的数据淘汰策略，另一个是针对全局数据的淘汰策略。这两种都支持LRU、LFU、Random算法，其中基于过期时间的还支持根据ttl大小淘汰</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Redis缓存穿透是什么？如何解决？</li>\n<li>缓存击穿呢？</li>\n<li>使用Redis一个for循环，每次都去getRedis(key)，怎么去优化？<ul>\n<li>mget命令，批量读取</li>\n<li>lua脚本</li>\n</ul>\n</li>\n<li>分布式锁还有哪些实现方式？<strong>（优化夜市，待学习）</strong></li>\n<li>Redis是如何实现高可用的？</li>\n<li>了解一致性哈希吗？<strong>（待学习）</strong></li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><ul>\n<li>你知道哪些分库分表的设计吗？</li>\n<li>分布式事务的解决方式？（待学习）</li>\n<li>分库分表下的数据迁移？（分库分表的问题夜市）<ul>\n<li>从库方案</li>\n<li>双写方案</li>\n</ul>\n</li>\n<li>全局ID实现方式<ul>\n<li>雪花</li>\n<li>leaf</li>\n<li>uuid</li>\n<li>MySQL、Redis</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cm6c7md6f0001a5t2d10u8ihd","tag_id":"cm6c7md6g0003a5t2a0lid5zs","_id":"cm6c7md6h0007a5t2cs6f4s0p"},{"post_id":"cm6c7md6h0008a5t29qz25cih","tag_id":"cm6c7md6h000aa5t237ofenzg","_id":"cm6c7md6i000fa5t2d4185rcx"},{"post_id":"cm6c7md6h0009a5t29ppedzne","tag_id":"cm6c7md6i000ea5t2g8qodjsu","_id":"cm6c7md6i000ka5t27aizflfe"},{"post_id":"cm6c7md6h000ca5t2a1jdepaq","tag_id":"cm6c7md6i000ia5t2gp803833","_id":"cm6c7md6i000oa5t2gzi0a2ob"},{"post_id":"cm6c7md6h000da5t2cs692rgb","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6j000sa5t2awmh6ukg"},{"post_id":"cm6c7md6i000pa5t2233r35uc","tag_id":"cm6c7md6i000ea5t2g8qodjsu","_id":"cm6c7md6j000ua5t2ahm47h6c"},{"post_id":"cm6c7md6i000ha5t27jvj6lzt","tag_id":"cm6c7md6i000qa5t2brz66nqm","_id":"cm6c7md6j000xa5t2h1845qkc"},{"post_id":"cm6c7md6i000ja5t21uba1ks8","tag_id":"cm6c7md6j000wa5t28sue4frg","_id":"cm6c7md6j0012a5t22g4obug8"},{"post_id":"cm6c7md6j0011a5t24hlzhtnu","tag_id":"cm6c7md6j0010a5t2d92h0p26","_id":"cm6c7md6j0015a5t26de956wy"},{"post_id":"cm6c7md6i000la5t21dfo2257","tag_id":"cm6c7md6j0010a5t2d92h0p26","_id":"cm6c7md6j0017a5t22cazg3vt"},{"post_id":"cm6c7md6l001aa5t26g27ffq2","tag_id":"cm6c7md6j0010a5t2d92h0p26","_id":"cm6c7md6l001ca5t2dbjudsd6"},{"post_id":"cm6c7md6l001ba5t2dt3q415q","tag_id":"cm6c7md6j0010a5t2d92h0p26","_id":"cm6c7md6l001fa5t2fgywhhma"},{"post_id":"cm6c7md6i000na5t297ug5by3","tag_id":"cm6c7md6j0014a5t24fbgga4g","_id":"cm6c7md6l001ha5t2g61w7pmi"},{"post_id":"cm6c7md6i000na5t297ug5by3","tag_id":"cm6c7md6k0019a5t21efeg4k3","_id":"cm6c7md6l001ka5t2dpez355x"},{"post_id":"cm6c7md6j000ta5t26mn0f4ae","tag_id":"cm6c7md6l001ea5t2277u3428","_id":"cm6c7md6l001ma5t29e164kdh"},{"post_id":"cm6c7md6j000va5t2aa62c9mc","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6m001qa5t2672mdf06"},{"post_id":"cm6c7md6j000va5t2aa62c9mc","tag_id":"cm6c7md6l001ja5t220v67t15","_id":"cm6c7md6m001sa5t2fuap88kn"},{"post_id":"cm6c7md6j000ya5t249oj8dxi","tag_id":"cm6c7md6l001ea5t2277u3428","_id":"cm6c7md6m001va5t2hf7u4hol"},{"post_id":"cm6c7md6m001ra5t24ban8agk","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6m001xa5t26lmzdf7r"},{"post_id":"cm6c7md6k0018a5t20hb54uqq","tag_id":"cm6c7md6l001ea5t2277u3428","_id":"cm6c7md6m0020a5t2djfkcalk"},{"post_id":"cm6c7md6m001wa5t217u41wql","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6m0022a5t21heq275s"},{"post_id":"cm6c7md6m001za5t2ex0zfbv6","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6m0024a5t27dw6bgz0"},{"post_id":"cm6c7md6m001za5t2ex0zfbv6","tag_id":"cm6c7md6l001ea5t2277u3428","_id":"cm6c7md6m0026a5t241ga16xy"},{"post_id":"cm6c7md6l001na5t2bas2f99k","tag_id":"cm6c7md6m001ya5t201275jna","_id":"cm6c7md6n0028a5t2edve7hnr"},{"post_id":"cm6c7md6m0021a5t2fa347a3p","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6n002aa5t2di98gk9x"},{"post_id":"cm6c7md6m0021a5t2fa347a3p","tag_id":"cm6c7md6l001ja5t220v67t15","_id":"cm6c7md6n002ca5t29oprdk3e"},{"post_id":"cm6c7md6m0025a5t2bpi200c0","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6n002fa5t2214s1wms"},{"post_id":"cm6c7md6m0025a5t2bpi200c0","tag_id":"cm6c7md6l001ja5t220v67t15","_id":"cm6c7md6n002ha5t24n5x4yre"},{"post_id":"cm6c7md6n0027a5t2ak4rf36m","tag_id":"cm6c7md6i000ma5t20b13drlx","_id":"cm6c7md6n002ja5t23fet4au5"},{"post_id":"cm6c7md6n0027a5t2ak4rf36m","tag_id":"cm6c7md6l001ja5t220v67t15","_id":"cm6c7md6n002la5t25qhk2c8u"},{"post_id":"cm6c7md6n002ga5t2h5t613uy","tag_id":"cm6c7md6n002da5t248qs9f2x","_id":"cm6c7md6n002na5t2dlli1mws"},{"post_id":"cm6c7md6n0029a5t23h4se78m","tag_id":"cm6c7md6n002da5t248qs9f2x","_id":"cm6c7md6n002pa5t29h8meprz"},{"post_id":"cm6c7md6n002ia5t22exeelcy","tag_id":"cm6c7md6n002da5t248qs9f2x","_id":"cm6c7md6o002ra5t2gru22fxx"},{"post_id":"cm6c7md6n002qa5t25va14by5","tag_id":"cm6c7md6o002ta5t25b6z2rf6","_id":"cm6c7md6o002xa5t2bbxearmx"},{"post_id":"cm6c7md6n002qa5t25va14by5","tag_id":"cm6c7md6o002va5t25pniajge","_id":"cm6c7md6o002ya5t2faxq9yep"},{"post_id":"cm6c7md6o002sa5t29zbl1235","tag_id":"cm6c7md6o002ta5t25b6z2rf6","_id":"cm6c7md6o002za5t2a8ky9swb"}],"Tag":[{"name":"Docker","_id":"cm6c7md6g0003a5t2a0lid5zs"},{"name":"Git","_id":"cm6c7md6h000aa5t237ofenzg"},{"name":"Golang","_id":"cm6c7md6i000ea5t2g8qodjsu"},{"name":"配置","_id":"cm6c7md6i000ia5t2gp803833"},{"name":"Go","_id":"cm6c7md6i000ma5t20b13drlx"},{"name":"优质文章","_id":"cm6c7md6i000qa5t2brz66nqm"},{"name":"设计模式","_id":"cm6c7md6j000wa5t28sue4frg"},{"name":"计算机网络","_id":"cm6c7md6j0010a5t2d92h0p26"},{"name":"开源工具","_id":"cm6c7md6j0014a5t24fbgga4g"},{"name":"资源","_id":"cm6c7md6k0019a5t21efeg4k3"},{"name":"项目","_id":"cm6c7md6l001ea5t2277u3428"},{"name":"学习","_id":"cm6c7md6l001ja5t220v67t15"},{"name":"excalidraw","_id":"cm6c7md6m001ya5t201275jna"},{"name":"MySQL","_id":"cm6c7md6n002da5t248qs9f2x"},{"name":"Redis","_id":"cm6c7md6o002ta5t25b6z2rf6"},{"name":"数据结构","_id":"cm6c7md6o002va5t25pniajge"}]}}