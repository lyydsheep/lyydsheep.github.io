---
date: 2025-11-09
title: defer
---
## defer
### defer 的历史
#### 三大优势
+ 就近原则

资源清理动作（`defer f.close()`)可以紧跟在资源获取动作之后（`os.Open()`)

+ 函数级作用域

defer 始终是在函数返回前执行，所以无论有多少个`if-else`嵌套，也无论有多少个`return`语句，都不会影响 defer 的执行

+ 动态与条件执行

`defer`执行并非静态，通过结合`if-else`语句可以实现动态条件执行，可以根据上下文来决定是否要设置`defer`语句，更富有灵活性

#### 双刃剑
由于`defer`关键字的动态性，即并非写多少个`defer`就要执行多少个`defer`，所以只能由 Go 运行时通过一个动态链表来维护`defer`调用栈。但这会带来极大的性能损耗。

#### 原罪（≤Go 1.12/1.13）
在旧版本中，一个`defer`的执行过程如下：

+ 创建`_defer`结构体：每次执行到`defer`语句时，会在堆上分配一个`_defer`结构体，这个结构体中包含了函数指针、指向下一个`_defer`结构体的指针
+ 执行`deferproc`运行时调用：这个函数会将`_defer`结构体挂在到当前goroutine 的的链表上，即`defer`链表
+ 执行`deferreturn`运行时调用：在函数返回之前，编译器会插入对`deferreturn`的执行，该函数会倒序遍历`defer`链表上的每一个`_defer`结构体，并执行对应的函数

在旧版的流程中需要：

+ 一次堆内存分配（影响 GC、加锁）
+ 两次运行时调用（频繁在用户代码和运行时代码之间切换）

所以旧版本的实现效率较低

#### 革命（Go 1.14）
新版本`defer`的核心思想是将非循环、简单的`defer`语句通过开发编码的方式进行调用，减少运行时函数调用以及频繁的内存拷贝。

一方面，在函数退出点直接生成代码：

新版本`defer`通过在栈上预留空间以及位掩码，替换了`deferproc`函数。在函数退出前，不再执行`deferreturn`函数，而是倒序遍历位掩码中的每一位，如果 bit 位为 1，那么就从栈上预留空间中取出函数指针和参数，发起函数调用。

另一方面，与 panic 流程深度整合：

在编译后的二进制文件中， 只要是使用了 open coded defer 机制的函数，都会有一份`funcdata`，它指明了三个信息

+ 该函数使用了 open coded defer
+ 位掩码在函数栈帧中的偏移量
+ 每个 `defer`的函数指针以及参数在函数栈帧中的偏移量

当发生 panic 时，`gopanic`函数就会扫描goroutine 栈，如果发现一个带有 open coded defer 的栈

#### 小结与共识
![image.png](https://raw.githubusercontent.com/lyydsheep/pic/main/20251109093809.png)